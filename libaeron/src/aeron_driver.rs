/* automatically generated by rust-bindgen 0.66.1 */

pub const AERON_NULL_VALUE: i32 = -1;
pub const AERON_CLIENT_ERROR_DRIVER_TIMEOUT: i32 = -1000;
pub const AERON_CLIENT_ERROR_CLIENT_TIMEOUT: i32 = -1001;
pub const AERON_CLIENT_ERROR_CONDUCTOR_SERVICE_TIMEOUT: i32 = -1002;
pub const AERON_CLIENT_ERROR_BUFFER_FULL: i32 = -1003;
pub const AERON_CLIENT_MAX_LOCAL_ADDRESS_STR_LEN: u32 = 64;
pub const AERON_DIR_ENV_VAR: &[u8; 10] = b"AERON_DIR\0";
pub const AERON_DRIVER_TIMEOUT_ENV_VAR: &[u8; 21] = b"AERON_DRIVER_TIMEOUT\0";
pub const AERON_CLIENT_RESOURCE_LINGER_DURATION_ENV_VAR: &[u8; 38] =
    b"AERON_CLIENT_RESOURCE_LINGER_DURATION\0";
pub const AERON_CLIENT_PRE_TOUCH_MAPPED_MEMORY_ENV_VAR: &[u8; 37] =
    b"AERON_CLIENT_PRE_TOUCH_MAPPED_MEMORY\0";
pub const AERON_AGENT_ON_START_FUNCTION_ENV_VAR: &[u8; 30] = b"AERON_AGENT_ON_START_FUNCTION\0";
pub const AERON_COUNTER_CACHE_LINE_LENGTH: u32 = 64;
pub const AERON_COUNTER_RECORD_UNUSED: u32 = 0;
pub const AERON_COUNTER_RECORD_ALLOCATED: u32 = 1;
pub const AERON_COUNTER_RECORD_RECLAIMED: i32 = -1;
pub const AERON_NULL_COUNTER_ID: i32 = -1;
pub const AERON_PUBLICATION_NOT_CONNECTED: i32 = -1;
pub const AERON_PUBLICATION_BACK_PRESSURED: i32 = -2;
pub const AERON_PUBLICATION_ADMIN_ACTION: i32 = -3;
pub const AERON_PUBLICATION_CLOSED: i32 = -4;
pub const AERON_PUBLICATION_MAX_POSITION_EXCEEDED: i32 = -5;
pub const AERON_PUBLICATION_ERROR: i32 = -6;
pub const AERON_COMPILER_GCC: u32 = 1;
pub const AERON_COMPILER_LLVM: u32 = 1;
pub const AERON_CPU_X64: u32 = 1;
pub const AERON_CACHE_LINE_LENGTH: u32 = 64;
pub const AERON_INIT_ONCE_VALUE: u32 = 0;
pub const AERON_MAX_PATH: u32 = 384;
pub const AERON_UDP_CHANNEL_RELIABLE_KEY: &[u8; 9] = b"reliable\0";
pub const AERON_UDP_CHANNEL_TTL_KEY: &[u8; 4] = b"ttl\0";
pub const AERON_UDP_CHANNEL_ENDPOINT_KEY: &[u8; 9] = b"endpoint\0";
pub const AERON_UDP_CHANNEL_INTERFACE_KEY: &[u8; 10] = b"interface\0";
pub const AERON_UDP_CHANNEL_CONTROL_KEY: &[u8; 8] = b"control\0";
pub const AERON_UDP_CHANNEL_CONTROL_MODE_KEY: &[u8; 13] = b"control-mode\0";
pub const AERON_UDP_CHANNEL_CONTROL_MODE_MANUAL_VALUE: &[u8; 7] = b"manual\0";
pub const AERON_UDP_CHANNEL_CONTROL_MODE_DYNAMIC_VALUE: &[u8; 8] = b"dynamic\0";
pub const AERON_URI_INITIAL_TERM_ID_KEY: &[u8; 13] = b"init-term-id\0";
pub const AERON_URI_TERM_ID_KEY: &[u8; 8] = b"term-id\0";
pub const AERON_URI_TERM_OFFSET_KEY: &[u8; 12] = b"term-offset\0";
pub const AERON_URI_TERM_LENGTH_KEY: &[u8; 12] = b"term-length\0";
pub const AERON_URI_LINGER_TIMEOUT_KEY: &[u8; 7] = b"linger\0";
pub const AERON_URI_MTU_LENGTH_KEY: &[u8; 4] = b"mtu\0";
pub const AERON_URI_SPARSE_TERM_KEY: &[u8; 7] = b"sparse\0";
pub const AERON_URI_EOS_KEY: &[u8; 4] = b"eos\0";
pub const AERON_URI_TETHER_KEY: &[u8; 7] = b"tether\0";
pub const AERON_URI_TAGS_KEY: &[u8; 5] = b"tags\0";
pub const AERON_URI_SESSION_ID_KEY: &[u8; 11] = b"session-id\0";
pub const AERON_URI_GROUP_KEY: &[u8; 6] = b"group\0";
pub const AERON_URI_REJOIN_KEY: &[u8; 7] = b"rejoin\0";
pub const AERON_URI_FC_KEY: &[u8; 3] = b"fc\0";
pub const AERON_URI_GTAG_KEY: &[u8; 5] = b"gtag\0";
pub const AERON_URI_CC_KEY: &[u8; 3] = b"cc\0";
pub const AERON_URI_SPIES_SIMULATE_CONNECTION_KEY: &[u8; 4] = b"ssc\0";
pub const AERON_URI_ATS_KEY: &[u8; 4] = b"ats\0";
pub const AERON_URI_SOCKET_SNDBUF_KEY: &[u8; 10] = b"so-sndbuf\0";
pub const AERON_URI_SOCKET_RCVBUF_KEY: &[u8; 10] = b"so-rcvbuf\0";
pub const AERON_URI_RECEIVER_WINDOW_KEY: &[u8; 8] = b"rcv-wnd\0";
pub const AERON_URI_MEDIA_RCV_TIMESTAMP_OFFSET_KEY: &[u8; 20] = b"media-rcv-ts-offset\0";
pub const AERON_URI_CHANNEL_RCV_TIMESTAMP_OFFSET_KEY: &[u8; 22] = b"channel-rcv-ts-offset\0";
pub const AERON_URI_CHANNEL_SND_TIMESTAMP_OFFSET_KEY: &[u8; 22] = b"channel-snd-ts-offset\0";
pub const AERON_URI_TIMESTAMP_OFFSET_RESERVED: &[u8; 9] = b"reserved\0";
pub const AERON_URI_INVALID_TAG: i32 = -1;
pub const AERON_MAX_HOSTNAME_LEN: u32 = 256;
pub const AERON_CHANNEL_STATUS_INDICATOR_NOT_ALLOCATED: i32 = -1;
pub const AERON_DIR_WARN_IF_EXISTS_ENV_VAR: &[u8; 25] = b"AERON_DIR_WARN_IF_EXISTS\0";
pub const AERON_THREADING_MODE_ENV_VAR: &[u8; 21] = b"AERON_THREADING_MODE\0";
pub const AERON_DIR_DELETE_ON_START_ENV_VAR: &[u8; 26] = b"AERON_DIR_DELETE_ON_START\0";
pub const AERON_DIR_DELETE_ON_SHUTDOWN_ENV_VAR: &[u8; 29] = b"AERON_DIR_DELETE_ON_SHUTDOWN\0";
pub const AERON_TO_CONDUCTOR_BUFFER_LENGTH_ENV_VAR: &[u8; 30] = b"AERON_CONDUCTOR_BUFFER_LENGTH\0";
pub const AERON_TO_CLIENTS_BUFFER_LENGTH_ENV_VAR: &[u8; 28] = b"AERON_CLIENTS_BUFFER_LENGTH\0";
pub const AERON_COUNTERS_VALUES_BUFFER_LENGTH_ENV_VAR: &[u8; 29] =
    b"AERON_COUNTERS_BUFFER_LENGTH\0";
pub const AERON_ERROR_BUFFER_LENGTH_ENV_VAR: &[u8; 26] = b"AERON_ERROR_BUFFER_LENGTH\0";
pub const AERON_CLIENT_LIVENESS_TIMEOUT_ENV_VAR: &[u8; 30] = b"AERON_CLIENT_LIVENESS_TIMEOUT\0";
pub const AERON_TERM_BUFFER_LENGTH_ENV_VAR: &[u8; 25] = b"AERON_TERM_BUFFER_LENGTH\0";
pub const AERON_IPC_TERM_BUFFER_LENGTH_ENV_VAR: &[u8; 29] = b"AERON_IPC_TERM_BUFFER_LENGTH\0";
pub const AERON_TERM_BUFFER_SPARSE_FILE_ENV_VAR: &[u8; 30] = b"AERON_TERM_BUFFER_SPARSE_FILE\0";
pub const AERON_PERFORM_STORAGE_CHECKS_ENV_VAR: &[u8; 29] = b"AERON_PERFORM_STORAGE_CHECKS\0";
pub const AERON_SPIES_SIMULATE_CONNECTION_ENV_VAR: &[u8; 32] = b"AERON_SPIES_SIMULATE_CONNECTION\0";
pub const AERON_FILE_PAGE_SIZE_ENV_VAR: &[u8; 21] = b"AERON_FILE_PAGE_SIZE\0";
pub const AERON_MTU_LENGTH_ENV_VAR: &[u8; 17] = b"AERON_MTU_LENGTH\0";
pub const AERON_IPC_MTU_LENGTH_ENV_VAR: &[u8; 21] = b"AERON_IPC_MTU_LENGTH\0";
pub const AERON_IPC_PUBLICATION_TERM_WINDOW_LENGTH_ENV_VAR: &[u8; 41] =
    b"AERON_IPC_PUBLICATION_TERM_WINDOW_LENGTH\0";
pub const AERON_PUBLICATION_TERM_WINDOW_LENGTH_ENV_VAR: &[u8; 37] =
    b"AERON_PUBLICATION_TERM_WINDOW_LENGTH\0";
pub const AERON_PUBLICATION_LINGER_TIMEOUT_ENV_VAR: &[u8; 33] =
    b"AERON_PUBLICATION_LINGER_TIMEOUT\0";
pub const AERON_SOCKET_SO_RCVBUF_ENV_VAR: &[u8; 23] = b"AERON_SOCKET_SO_RCVBUF\0";
pub const AERON_SOCKET_SO_SNDBUF_ENV_VAR: &[u8; 23] = b"AERON_SOCKET_SO_SNDBUF\0";
pub const AERON_SOCKET_MULTICAST_TTL_ENV_VAR: &[u8; 27] = b"AERON_SOCKET_MULTICAST_TTL\0";
pub const AERON_SEND_TO_STATUS_POLL_RATIO_ENV_VAR: &[u8; 32] = b"AERON_SEND_TO_STATUS_POLL_RATIO\0";
pub const AERON_RCV_STATUS_MESSAGE_TIMEOUT_ENV_VAR: &[u8; 33] =
    b"AERON_RCV_STATUS_MESSAGE_TIMEOUT\0";
pub const AERON_MULTICAST_MIN_FLOW_CONTROL_STRATEGY_NAME: &[u8; 14] = b"multicast_min\0";
pub const AERON_MULTICAST_MAX_FLOW_CONTROL_STRATEGY_NAME: &[u8; 14] = b"multicast_max\0";
pub const AERON_MULTICAST_TAGGED_FLOW_CONTROL_STRATEGY_NAME: &[u8; 17] = b"multicast_tagged\0";
pub const AERON_UNICAST_MAX_FLOW_CONTROL_STRATEGY_NAME: &[u8; 12] = b"unicast_max\0";
pub const AERON_MULTICAST_FLOWCONTROL_SUPPLIER_ENV_VAR: &[u8; 37] =
    b"AERON_MULTICAST_FLOWCONTROL_SUPPLIER\0";
pub const AERON_UNICAST_FLOWCONTROL_SUPPLIER_ENV_VAR: &[u8; 35] =
    b"AERON_UNICAST_FLOWCONTROL_SUPPLIER\0";
pub const AERON_IMAGE_LIVENESS_TIMEOUT_ENV_VAR: &[u8; 29] = b"AERON_IMAGE_LIVENESS_TIMEOUT\0";
pub const AERON_RCV_INITIAL_WINDOW_LENGTH_ENV_VAR: &[u8; 32] = b"AERON_RCV_INITIAL_WINDOW_LENGTH\0";
pub const AERON_CONGESTIONCONTROL_SUPPLIER_ENV_VAR: &[u8; 33] =
    b"AERON_CONGESTIONCONTROL_SUPPLIER\0";
pub const AERON_CUBICCONGESTIONCONTROL_MEASURERTT_ENV_VAR: &[u8; 40] =
    b"AERON_CUBICCONGESTIONCONTROL_MEASURERTT\0";
pub const AERON_CUBICCONGESTIONCONTROL_INITIALRTT_ENV_VAR: &[u8; 40] =
    b"AERON_CUBICCONGESTIONCONTROL_INITIALRTT\0";
pub const AERON_CUBICCONGESTIONCONTROL_TCPMODE_ENV_VAR: &[u8; 37] =
    b"AERON_CUBICCONGESTIONCONTROL_TCPMODE\0";
pub const AERON_LOSS_REPORT_BUFFER_LENGTH_ENV_VAR: &[u8; 32] = b"AERON_LOSS_REPORT_BUFFER_LENGTH\0";
pub const AERON_PUBLICATION_UNBLOCK_TIMEOUT_ENV_VAR: &[u8; 34] =
    b"AERON_PUBLICATION_UNBLOCK_TIMEOUT\0";
pub const AERON_PUBLICATION_CONNECTION_TIMEOUT_ENV_VAR: &[u8; 37] =
    b"AERON_PUBLICATION_CONNECTION_TIMEOUT\0";
pub const AERON_TIMER_INTERVAL_ENV_VAR: &[u8; 21] = b"AERON_TIMER_INTERVAL\0";
pub const AERON_SENDER_IDLE_STRATEGY_ENV_VAR: &[u8; 27] = b"AERON_SENDER_IDLE_STRATEGY\0";
pub const AERON_CONDUCTOR_IDLE_STRATEGY_ENV_VAR: &[u8; 30] = b"AERON_CONDUCTOR_IDLE_STRATEGY\0";
pub const AERON_RECEIVER_IDLE_STRATEGY_ENV_VAR: &[u8; 29] = b"AERON_RECEIVER_IDLE_STRATEGY\0";
pub const AERON_SHAREDNETWORK_IDLE_STRATEGY_ENV_VAR: &[u8; 34] =
    b"AERON_SHAREDNETWORK_IDLE_STRATEGY\0";
pub const AERON_SHARED_IDLE_STRATEGY_ENV_VAR: &[u8; 27] = b"AERON_SHARED_IDLE_STRATEGY\0";
pub const AERON_SENDER_IDLE_STRATEGY_INIT_ARGS_ENV_VAR: &[u8; 37] =
    b"AERON_SENDER_IDLE_STRATEGY_INIT_ARGS\0";
pub const AERON_CONDUCTOR_IDLE_STRATEGY_INIT_ARGS_ENV_VAR: &[u8; 40] =
    b"AERON_CONDUCTOR_IDLE_STRATEGY_INIT_ARGS\0";
pub const AERON_RECEIVER_IDLE_STRATEGY_INIT_ARGS_ENV_VAR: &[u8; 39] =
    b"AERON_RECEIVER_IDLE_STRATEGY_INIT_ARGS\0";
pub const AERON_SHAREDNETWORK_IDLE_STRATEGY_INIT_ARGS_ENV_VAR: &[u8; 44] =
    b"AERON_SHAREDNETWORK_IDLE_STRATEGY_INIT_ARGS\0";
pub const AERON_SHARED_IDLE_STRATEGY_ENV_INIT_ARGS_VAR: &[u8; 37] =
    b"AERON_SHARED_IDLE_STRATEGY_INIT_ARGS\0";
pub const AERON_COUNTERS_FREE_TO_REUSE_TIMEOUT_ENV_VAR: &[u8; 37] =
    b"AERON_COUNTERS_FREE_TO_REUSE_TIMEOUT\0";
pub const AERON_MIN_MULTICAST_FLOW_CONTROL_RECEIVER_TIMEOUT_ENV_VAR: &[u8; 50] =
    b"AERON_MIN_MULTICAST_FLOW_CONTROL_RECEIVER_TIMEOUT\0";
pub const AERON_FLOW_CONTROL_GROUP_TAG_ENV_VAR: &[u8; 29] = b"AERON_FLOW_CONTROL_GROUP_TAG\0";
pub const AERON_FLOW_CONTROL_GROUP_MIN_SIZE_ENV_VAR: &[u8; 34] =
    b"AERON_FLOW_CONTROL_GROUP_MIN_SIZE\0";
pub const AERON_RECEIVER_GROUP_TAG_ENV_VAR: &[u8; 25] = b"AERON_RECEIVER_GROUP_TAG\0";
pub const AERON_DRIVER_TERMINATION_VALIDATOR_ENV_VAR: &[u8; 35] =
    b"AERON_DRIVER_TERMINATION_VALIDATOR\0";
pub const AERON_PRINT_CONFIGURATION_ON_START_ENV_VAR: &[u8; 26] = b"AERON_PRINT_CONFIGURATION\0";
pub const AERON_RELIABLE_STREAM_ENV_VAR: &[u8; 22] = b"AERON_RELIABLE_STREAM\0";
pub const AERON_TETHER_SUBSCRIPTIONS_ENV_VAR: &[u8; 27] = b"AERON_TETHER_SUBSCRIPTIONS\0";
pub const AERON_UNTETHERED_WINDOW_LIMIT_TIMEOUT_ENV_VAR: &[u8; 38] =
    b"AERON_UNTETHERED_WINDOW_LIMIT_TIMEOUT\0";
pub const AERON_UNTETHERED_RESTING_TIMEOUT_ENV_VAR: &[u8; 33] =
    b"AERON_UNTETHERED_RESTING_TIMEOUT\0";
pub const AERON_NAK_MULTICAST_GROUP_SIZE_ENV_VAR: &[u8; 31] = b"AERON_NAK_MULTICAST_GROUP_SIZE\0";
pub const AERON_NAK_MULTICAST_MAX_BACKOFF_ENV_VAR: &[u8; 32] = b"AERON_NAK_MULTICAST_MAX_BACKOFF\0";
pub const AERON_NAK_UNICAST_DELAY_ENV_VAR: &[u8; 24] = b"AERON_NAK_UNICAST_DELAY\0";
pub const AERON_RETRANSMIT_UNICAST_DELAY_ENV_VAR: &[u8; 31] = b"AERON_RETRANSMIT_UNICAST_DELAY\0";
pub const AERON_RETRANSMIT_UNICAST_LINGER_ENV_VAR: &[u8; 32] = b"AERON_RETRANSMIT_UNICAST_LINGER\0";
pub const AERON_RECEIVER_GROUP_CONSIDERATION_ENV_VAR: &[u8; 35] =
    b"AERON_RECEIVER_GROUP_CONSIDERATION\0";
pub const AERON_REJOIN_STREAM_ENV_VAR: &[u8; 20] = b"AERON_REJOIN_STREAM\0";
pub const AERON_DRIVER_CONNECT_ENV_VAR: &[u8; 21] = b"AERON_DRIVER_CONNECT\0";
pub const AERON_IPC_CHANNEL: &[u8; 10] = b"aeron:ipc\0";
pub const AERON_SPY_PREFIX: &[u8; 11] = b"aeron-spy:\0";
pub const AERON_UDP_CHANNEL_TRANSPORT_BINDINGS_MEDIA_ENV_VAR: &[u8; 43] =
    b"AERON_UDP_CHANNEL_TRANSPORT_BINDINGS_MEDIA\0";
pub const AERON_CONDUCTOR_UDP_CHANNEL_TRANSPORT_BINDINGS_MEDIA_ENV_VAR: &[u8; 53] =
    b"AERON_CONDUCTOR_UDP_CHANNEL_TRANSPORT_BINDINGS_MEDIA\0";
pub const AERON_UDP_CHANNEL_OUTGOING_INTERCEPTORS_ENV_VAR: &[u8; 40] =
    b"AERON_UDP_CHANNEL_OUTGOING_INTERCEPTORS\0";
pub const AERON_UDP_CHANNEL_INCOMING_INTERCEPTORS_ENV_VAR: &[u8; 40] =
    b"AERON_UDP_CHANNEL_INCOMING_INTERCEPTORS\0";
pub const AERON_PUBLICATION_RESERVED_SESSION_ID_LOW_ENV_VAR: &[u8; 42] =
    b"AERON_PUBLICATION_RESERVED_SESSION_ID_LOW\0";
pub const AERON_PUBLICATION_RESERVED_SESSION_ID_HIGH_ENV_VAR: &[u8; 43] =
    b"AERON_PUBLICATION_RESERVED_SESSION_ID_HIGH\0";
pub const AERON_DRIVER_RESOLVER_NAME_ENV_VAR: &[u8; 27] = b"AERON_DRIVER_RESOLVER_NAME\0";
pub const AERON_DRIVER_RESOLVER_INTERFACE_ENV_VAR: &[u8; 32] = b"AERON_DRIVER_RESOLVER_INTERFACE\0";
pub const AERON_DRIVER_RESOLVER_BOOTSTRAP_NEIGHBOR_ENV_VAR: &[u8; 41] =
    b"AERON_DRIVER_RESOLVER_BOOTSTRAP_NEIGHBOR\0";
pub const AERON_NAME_RESOLVER_SUPPLIER_ENV_VAR: &[u8; 29] = b"AERON_NAME_RESOLVER_SUPPLIER\0";
pub const AERON_NAME_RESOLVER_SUPPLIER_DEFAULT: &[u8; 8] = b"default\0";
pub const AERON_NAME_RESOLVER_INIT_ARGS_ENV_VAR: &[u8; 30] = b"AERON_NAME_RESOLVER_INIT_ARGS\0";
pub const AERON_DRIVER_RERESOLUTION_CHECK_INTERVAL_ENV_VAR: &[u8; 41] =
    b"AERON_DRIVER_RERESOLUTION_CHECK_INTERVAL\0";
pub const AERON_DRIVER_CONDUCTOR_CYCLE_THRESHOLD_ENV_VAR: &[u8; 39] =
    b"AERON_DRIVER_CONDUCTOR_CYCLE_THRESHOLD\0";
pub const AERON_DRIVER_SENDER_CYCLE_THRESHOLD_ENV_VAR: &[u8; 36] =
    b"AERON_DRIVER_SENDER_CYCLE_THRESHOLD\0";
pub const AERON_DRIVER_RECEIVER_CYCLE_THRESHOLD_ENV_VAR: &[u8; 38] =
    b"AERON_DRIVER_RECEIVER_CYCLE_THRESHOLD\0";
pub const AERON_DRIVER_NAME_RESOLVER_THRESHOLD_ENV_VAR: &[u8; 37] =
    b"AERON_DRIVER_NAME_RESOLVER_THRESHOLD\0";
pub const AERON_RECEIVER_IO_VECTOR_CAPACITY_ENV_VAR: &[u8; 34] =
    b"AERON_RECEIVER_IO_VECTOR_CAPACITY\0";
pub const AERON_SENDER_IO_VECTOR_CAPACITY_ENV_VAR: &[u8; 32] = b"AERON_SENDER_IO_VECTOR_CAPACITY\0";
pub const AERON_NETWORK_PUBLICATION_MAX_MESSAGES_PER_SEND_ENV_VAR: &[u8; 48] =
    b"AERON_NETWORK_PUBLICATION_MAX_MESSAGES_PER_SEND\0";
pub const AERON_DRIVER_RESOURCE_FREE_LIMIT_ENV_VAR: &[u8; 33] =
    b"AERON_DRIVER_RESOURCE_FREE_LIMIT\0";
pub const AERON_CONDUCTOR_CPU_AFFINITY_ENV_VAR: &[u8; 29] = b"AERON_CONDUCTOR_CPU_AFFINITY\0";
pub const AERON_RECEIVER_CPU_AFFINITY_ENV_VAR: &[u8; 28] = b"AERON_RECEIVER_CPU_AFFINITY\0";
pub const AERON_SENDER_CPU_AFFINITY_ENV_VAR: &[u8; 26] = b"AERON_SENDER_CPU_AFFINITY\0";
pub const AERON_DRIVER_DYNAMIC_LIBRARIES_ENV_VAR: &[u8; 31] = b"AERON_DRIVER_DYNAMIC_LIBRARIES\0";
pub const AERON_UDP_CHANNEL_TRANSPORT_MAX_INTERCEPTORS: u32 = 2;
pub const AERON_RES_HEADER_ADDRESS_LENGTH_IP4: u32 = 4;
pub const AERON_RES_HEADER_ADDRESS_LENGTH_IP6: u32 = 16;
pub const AERON_FRAME_HEADER_VERSION: u32 = 0;
pub const AERON_HDR_TYPE_PAD: u32 = 0;
pub const AERON_HDR_TYPE_DATA: u32 = 1;
pub const AERON_HDR_TYPE_NAK: u32 = 2;
pub const AERON_HDR_TYPE_SM: u32 = 3;
pub const AERON_HDR_TYPE_ERR: u32 = 4;
pub const AERON_HDR_TYPE_SETUP: u32 = 5;
pub const AERON_HDR_TYPE_RTTM: u32 = 6;
pub const AERON_HDR_TYPE_RES: u32 = 7;
pub const AERON_HDR_TYPE_ATS_DATA: u32 = 8;
pub const AERON_HDR_TYPE_ATS_SETUP: u32 = 9;
pub const AERON_HDR_TYPE_ATS_SM: u32 = 10;
pub const AERON_HDR_TYPE_EXT: u32 = 65535;
pub const AERON_RES_HEADER_TYPE_NAME_TO_IP4_MD: u32 = 1;
pub const AERON_RES_HEADER_TYPE_NAME_TO_IP6_MD: u32 = 2;
pub const AERON_FRAME_MAX_MESSAGE_LENGTH: u32 = 16777216;
pub const AERON_OPT_HDR_ALIGNMENT: u32 = 4;
pub const AERON_LOGBUFFER_PARTITION_COUNT: u32 = 3;
pub const AERON_LOGBUFFER_TERM_MIN_LENGTH: u32 = 65536;
pub const AERON_LOGBUFFER_TERM_MAX_LENGTH: u32 = 1073741824;
pub const AERON_PAGE_MIN_SIZE: u32 = 4096;
pub const AERON_PAGE_MAX_SIZE: u32 = 1073741824;
pub const AERON_LOGBUFFER_DEFAULT_FRAME_HEADER_MAX_LENGTH: u32 = 128;
pub const AERON_MAX_UDP_PAYLOAD_LENGTH: u32 = 65504;
pub const AERON_LOGBUFFER_FRAME_ALIGNMENT: u32 = 32;
pub const AERON_PUBLICATIONS_DIR: &[u8; 13] = b"publications\0";
pub const AERON_IMAGES_DIR: &[u8; 7] = b"images\0";
pub const AERON_RB_PADDING_MSG_TYPE_ID: i32 = -1;
pub const AERON_BROADCAST_PADDING_MSG_TYPE_ID: i32 = -1;
pub const AERON_MAX_FLOW_CONTROL_STRATEGY_NAME: &[u8; 4] = b"max\0";
pub const AERON_MIN_FLOW_CONTROL_STRATEGY_NAME: &[u8; 4] = b"min\0";
pub const AERON_TAGGED_FLOW_CONTROL_STRATEGY_NAME: &[u8; 7] = b"tagged\0";
pub const AERON_MIN_FLOW_CONTROL_RECEIVERS_COUNTER_NAME: &[u8; 13] = b"fc-receivers\0";
pub const AERON_STATICWINDOWCONGESTIONCONTROL_CC_PARAM_VALUE: &[u8; 7] = b"static\0";
pub const AERON_CUBICCONGESTIONCONTROL_CC_PARAM_VALUE: &[u8; 6] = b"cubic\0";
pub const AERON_CUBICCONGESTIONCONTROL_RTT_INDICATOR_COUNTER_NAME: &[u8; 17] =
    b"rcv-cc-cubic-rtt\0";
pub const AERON_CUBICCONGESTIONCONTROL_WINDOW_INDICATOR_COUNTER_NAME: &[u8; 17] =
    b"rcv-cc-cubic-wnd\0";
pub const AERON_AGENT_STATE_UNUSED: u32 = 0;
pub const AERON_AGENT_STATE_INITED: u32 = 1;
pub const AERON_AGENT_STATE_STARTED: u32 = 2;
pub const AERON_AGENT_STATE_MANUAL: u32 = 3;
pub const AERON_AGENT_STATE_STOPPING: u32 = 4;
pub const AERON_AGENT_STATE_STOPPED: u32 = 5;
pub const AERON_IDLE_STRATEGY_BACKOFF_MAX_SPINS: u32 = 10;
pub const AERON_IDLE_STRATEGY_BACKOFF_MAX_YIELDS: u32 = 20;
pub const AERON_IDLE_STRATEGY_BACKOFF_MIN_PARK_PERIOD_NS: u32 = 1000;
pub const AERON_IDLE_STRATEGY_BACKOFF_MAX_PARK_PERIOD_NS: u32 = 1000000;
pub const AERON_COUNTER_CHANNEL_ENDPOINT_STATUS_INITIALIZING: u32 = 0;
pub const AERON_COUNTER_CHANNEL_ENDPOINT_STATUS_ERRORED: i32 = -1;
pub const AERON_COUNTER_CHANNEL_ENDPOINT_STATUS_NO_ID_ALLOCATED: i32 = -1;
pub const AERON_CNC_FILE: &[u8; 8] = b"cnc.dat\0";
pub const AERON_COMMAND_RB_CAPACITY: u32 = 131072;
pub const AERON_COMMAND_RB_RESERVE: u32 = 1024;
pub const AERON_COMMAND_DRAIN_LIMIT: u32 = 2;
pub const AERON_DRIVER_SENDER_IO_VECTOR_LENGTH_MAX: u32 = 16;
pub const AERON_NETWORK_PUBLICATION_MAX_MESSAGES_PER_SEND: u32 = 16;
pub const AERON_DRIVER_RECEIVER_IO_VECTOR_LENGTH_MAX: u32 = 16;
pub const AERON_DRIVER_RECEIVER_MAX_UDP_PACKET_LENGTH: u32 = 65536;
pub const AERON_COUNTERS_VALUES_BUFFER_LENGTH_DEFAULT: u32 = 1048576;
pub const AERON_COUNTERS_VALUES_BUFFER_LENGTH_MAX: u32 = 524288000;
pub const AERON_ERROR_BUFFER_LENGTH_DEFAULT: u32 = 1048576;
pub const AERON_COMMAND_ADD_PUBLICATION: u32 = 1;
pub const AERON_COMMAND_REMOVE_PUBLICATION: u32 = 2;
pub const AERON_COMMAND_ADD_EXCLUSIVE_PUBLICATION: u32 = 3;
pub const AERON_COMMAND_ADD_SUBSCRIPTION: u32 = 4;
pub const AERON_COMMAND_REMOVE_SUBSCRIPTION: u32 = 5;
pub const AERON_COMMAND_CLIENT_KEEPALIVE: u32 = 6;
pub const AERON_COMMAND_ADD_DESTINATION: u32 = 7;
pub const AERON_COMMAND_REMOVE_DESTINATION: u32 = 8;
pub const AERON_COMMAND_ADD_COUNTER: u32 = 9;
pub const AERON_COMMAND_REMOVE_COUNTER: u32 = 10;
pub const AERON_COMMAND_CLIENT_CLOSE: u32 = 11;
pub const AERON_COMMAND_ADD_RCV_DESTINATION: u32 = 12;
pub const AERON_COMMAND_REMOVE_RCV_DESTINATION: u32 = 13;
pub const AERON_COMMAND_TERMINATE_DRIVER: u32 = 14;
pub const AERON_RESPONSE_ON_ERROR: u32 = 3841;
pub const AERON_RESPONSE_ON_AVAILABLE_IMAGE: u32 = 3842;
pub const AERON_RESPONSE_ON_PUBLICATION_READY: u32 = 3843;
pub const AERON_RESPONSE_ON_OPERATION_SUCCESS: u32 = 3844;
pub const AERON_RESPONSE_ON_UNAVAILABLE_IMAGE: u32 = 3845;
pub const AERON_RESPONSE_ON_EXCLUSIVE_PUBLICATION_READY: u32 = 3846;
pub const AERON_RESPONSE_ON_SUBSCRIPTION_READY: u32 = 3847;
pub const AERON_RESPONSE_ON_COUNTER_READY: u32 = 3848;
pub const AERON_RESPONSE_ON_UNAVAILABLE_COUNTER: u32 = 3849;
pub const AERON_RESPONSE_ON_CLIENT_TIMEOUT: u32 = 3850;
pub const AERON_ERROR_CODE_UNKNOWN_CODE_VALUE: i32 = -1;
pub const AERON_ERROR_CODE_UNUSED: u32 = 0;
pub const AERON_ERROR_CODE_INVALID_CHANNEL: u32 = 1;
pub const AERON_ERROR_CODE_UNKNOWN_SUBSCRIPTION: u32 = 2;
pub const AERON_ERROR_CODE_UNKNOWN_PUBLICATION: u32 = 3;
pub const AERON_ERROR_CODE_CHANNEL_ENDPOINT_ERROR: u32 = 4;
pub const AERON_ERROR_CODE_UNKNOWN_COUNTER: u32 = 5;
pub const AERON_ERROR_CODE_UNKNOWN_COMMAND_TYPE_ID: u32 = 6;
pub const AERON_ERROR_CODE_MALFORMED_COMMAND: u32 = 7;
pub const AERON_ERROR_CODE_NOT_SUPPORTED: u32 = 8;
pub const AERON_ERROR_CODE_UNKNOWN_HOST: u32 = 9;
pub const AERON_ERROR_CODE_RESOURCE_TEMPORARILY_UNAVAILABLE: u32 = 10;
pub const AERON_ERROR_CODE_GENERIC_ERROR: u32 = 11;
pub const AERON_ERROR_CODE_STORAGE_SPACE: u32 = 12;
pub const AERON_FORMAT_NUMBER_TO_LOCALE_STR_LEN: u32 = 32;
pub const AERON_ERROR_MAX_TOTAL_LENGTH: u32 = 8192;
pub const AERON_MAP_DEFAULT_LOAD_FACTOR: f64 = 0.65;
pub const AERON_NETUTIL_FORMATTED_MAX_LENGTH: u32 = 54;
pub const AERON_RETRANSMIT_HANDLER_MAX_RETRANSMITS: u32 = 16;
pub const AERON_NETWORK_PUBLICATION_HEARTBEAT_TIMEOUT_NS: u32 = 100000000;
pub const AERON_NETWORK_PUBLICATION_SETUP_TIMEOUT_NS: u32 = 100000000;
pub const AERON_NAME_RESOLVER_CSV_TABLE: &[u8; 10] = b"csv_table\0";
pub const AERON_NAME_RESOLVER_DRIVER: &[u8; 7] = b"driver\0";
pub const AERON_NAME_RESOLVER_CSV_TABLE_ARGS_ENV_VAR: &[u8; 42] =
    b"AERON_NAME_RESOLVER_CSV_LOOKUP_TABLE_ARGS\0";
pub const AERON_UDP_CHANNEL_RESERVED_VALUE_OFFSET: i32 = -8;
pub const AERON_UDP_CHANNEL_TRANSPORT_MEDIA_RCV_TIMESTAMP_NONE: u32 = 0;
pub const AERON_UDP_CHANNEL_TRANSPORT_MEDIA_RCV_TIMESTAMP_HW: u32 = 1;
pub const AERON_UDP_CHANNEL_TRANSPORT_MEDIA_RCV_TIMESTAMP_SW: u32 = 2;
pub const AERON_UDP_CHANNEL_TRANSPORT_MEDIA_RCV_TIMESTAMP: u32 = 3;
pub const AERON_UDP_CHANNEL_TRANSPORT_CHANNEL_RCV_TIMESTAMP: u32 = 4;
pub const AERON_UDP_CHANNEL_TRANSPORT_CHANNEL_SND_TIMESTAMP: u32 = 8;
pub const AERON_UDP_DESTINATION_TRACKER_DESTINATION_TIMEOUT_NS: u64 = 5000000000;
pub const AERON_SEND_CHANNEL_ENDPOINT_DESTINATION_TIMEOUT_NS: u64 = 5000000000;
pub const AERON_RECEIVE_DESTINATION_TIMEOUT_NS: u64 = 5000000000;
pub const AERON_LOSS_DETECTOR_TIMER_INACTIVE: i32 = -1;
pub const AERON_LOSS_DETECTOR_NAK_UNICAST_DELAY_NS: u32 = 60000000;
pub const AERON_LOSS_DETECTOR_NAK_MULTICAST_GROUP_SIZE: f64 = 10.0;
pub const AERON_LOSS_DETECTOR_NAK_MULTICAST_MAX_BACKOFF_NS: f64 = 60000000.0;
pub const AERON_LOSS_REPORT_FILE: &[u8; 16] = b"loss-report.dat\0";
pub const AERON_LOSS_REPORTER_ENTRY_ALIGNMENT: u32 = 64;
pub const AERON_IMAGE_SM_EOS_MULTIPLE: u32 = 5;
pub const AERON_DRIVER_CONDUCTOR_LINGER_RESOURCE_TIMEOUT_NS: u64 = 5000000000;
pub const AERON_DRIVER_CONDUCTOR_CLOCK_UPDATE_INTERNAL_NS: u32 = 1000000;
pub const AERON_UDP_TRANSPORT_POLLER_ITERATION_THRESHOLD: u32 = 5;
pub const AERON_DRIVER_RECEIVER_PENDING_SETUP_TIMEOUT_NS: u32 = 1000000000;
pub const AERON_AGENT_RUNNER_CONDUCTOR: u32 = 0;
pub const AERON_AGENT_RUNNER_SENDER: u32 = 1;
pub const AERON_AGENT_RUNNER_RECEIVER: u32 = 2;
pub const AERON_AGENT_RUNNER_SHARED_NETWORK: u32 = 1;
pub const AERON_AGENT_RUNNER_SHARED: u32 = 0;
pub const AERON_AGENT_RUNNER_MAX: u32 = 3;
extern "C" {
    pub fn aeron_alloc_no_err(
        ptr: *mut *mut ::std::os::raw::c_void,
        size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_alloc(ptr: *mut *mut ::std::os::raw::c_void, size: usize)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_alloc_aligned(
        ptr: *mut *mut ::std::os::raw::c_void,
        offset: *mut usize,
        size: usize,
        alignment: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_reallocf(
        ptr: *mut *mut ::std::os::raw::c_void,
        size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_free(ptr: *mut ::std::os::raw::c_void);
}
pub type __time_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
#[test]
fn bindgen_test_layout_timespec() {
    const UNINIT: ::std::mem::MaybeUninit<timespec> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<timespec>(),
        16usize,
        concat!("Size of: ", stringify!(timespec))
    );
    assert_eq!(
        ::std::mem::align_of::<timespec>(),
        8usize,
        concat!("Alignment of ", stringify!(timespec))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_nsec) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_nsec)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_internal_list {
    pub __prev: *mut __pthread_internal_list,
    pub __next: *mut __pthread_internal_list,
}
#[test]
fn bindgen_test_layout___pthread_internal_list() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_internal_list> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_internal_list>(),
        16usize,
        concat!("Size of: ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_internal_list>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__prev) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__prev)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__next) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__next)
        )
    );
}
pub type __pthread_list_t = __pthread_internal_list;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_mutex_s {
    pub __lock: ::std::os::raw::c_int,
    pub __count: ::std::os::raw::c_uint,
    pub __owner: ::std::os::raw::c_int,
    pub __nusers: ::std::os::raw::c_uint,
    pub __kind: ::std::os::raw::c_int,
    pub __spins: ::std::os::raw::c_short,
    pub __elision: ::std::os::raw::c_short,
    pub __list: __pthread_list_t,
}
#[test]
fn bindgen_test_layout___pthread_mutex_s() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_mutex_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_mutex_s>(),
        40usize,
        concat!("Size of: ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_mutex_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__lock) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__lock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__count) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__owner) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__owner)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__nusers) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__nusers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__kind) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__kind)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__spins) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__spins)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__elision) as usize - ptr as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__elision)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__list) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__list)
        )
    );
}
pub type pthread_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutex_t {
    pub __data: __pthread_mutex_s,
    pub __size: [::std::os::raw::c_char; 40usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_mutex_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_mutex_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_mutex_t>(),
        40usize,
        concat!("Size of: ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutex_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aeron_context_stct {
    _unused: [u8; 0],
}
pub type aeron_context_t = aeron_context_stct;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aeron_stct {
    _unused: [u8; 0],
}
pub type aeron_t = aeron_stct;
#[doc = " Structure used to hold information for a try_claim function call."]
pub type aeron_buffer_claim_t = aeron_buffer_claim_stct;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aeron_publication_stct {
    _unused: [u8; 0],
}
pub type aeron_publication_t = aeron_publication_stct;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aeron_exclusive_publication_stct {
    _unused: [u8; 0],
}
pub type aeron_exclusive_publication_t = aeron_exclusive_publication_stct;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aeron_header_stct {
    _unused: [u8; 0],
}
pub type aeron_header_t = aeron_header_stct;
#[repr(C, packed(4))]
#[derive(Copy, Clone)]
pub struct aeron_header_values_frame_stct {
    pub frame_length: i32,
    pub version: i8,
    pub flags: u8,
    pub type_: i16,
    pub term_offset: i32,
    pub session_id: i32,
    pub stream_id: i32,
    pub term_id: i32,
    pub reserved_value: i64,
}
#[test]
fn bindgen_test_layout_aeron_header_values_frame_stct() {
    const UNINIT: ::std::mem::MaybeUninit<aeron_header_values_frame_stct> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_header_values_frame_stct>(),
        32usize,
        concat!("Size of: ", stringify!(aeron_header_values_frame_stct))
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_header_values_frame_stct>(),
        4usize,
        concat!("Alignment of ", stringify!(aeron_header_values_frame_stct))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).frame_length) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_header_values_frame_stct),
            "::",
            stringify!(frame_length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_header_values_frame_stct),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_header_values_frame_stct),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_header_values_frame_stct),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).term_offset) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_header_values_frame_stct),
            "::",
            stringify!(term_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).session_id) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_header_values_frame_stct),
            "::",
            stringify!(session_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stream_id) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_header_values_frame_stct),
            "::",
            stringify!(stream_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).term_id) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_header_values_frame_stct),
            "::",
            stringify!(term_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved_value) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_header_values_frame_stct),
            "::",
            stringify!(reserved_value)
        )
    );
}
pub type aeron_header_values_frame_t = aeron_header_values_frame_stct;
#[repr(C, packed(4))]
#[derive(Copy, Clone)]
pub struct aeron_header_values_stct {
    pub frame: aeron_header_values_frame_t,
    pub initial_term_id: i32,
    pub position_bits_to_shift: usize,
}
#[test]
fn bindgen_test_layout_aeron_header_values_stct() {
    const UNINIT: ::std::mem::MaybeUninit<aeron_header_values_stct> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_header_values_stct>(),
        44usize,
        concat!("Size of: ", stringify!(aeron_header_values_stct))
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_header_values_stct>(),
        4usize,
        concat!("Alignment of ", stringify!(aeron_header_values_stct))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).frame) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_header_values_stct),
            "::",
            stringify!(frame)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).initial_term_id) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_header_values_stct),
            "::",
            stringify!(initial_term_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).position_bits_to_shift) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_header_values_stct),
            "::",
            stringify!(position_bits_to_shift)
        )
    );
}
pub type aeron_header_values_t = aeron_header_values_stct;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aeron_subscription_stct {
    _unused: [u8; 0],
}
pub type aeron_subscription_t = aeron_subscription_stct;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aeron_image_stct {
    _unused: [u8; 0],
}
pub type aeron_image_t = aeron_image_stct;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aeron_counter_stct {
    _unused: [u8; 0],
}
pub type aeron_counter_t = aeron_counter_stct;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aeron_log_buffer_stct {
    _unused: [u8; 0],
}
pub type aeron_log_buffer_t = aeron_log_buffer_stct;
pub type aeron_counters_reader_t = aeron_counters_reader_stct;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aeron_client_registering_resource_stct {
    _unused: [u8; 0],
}
pub type aeron_async_add_publication_t = aeron_client_registering_resource_stct;
pub type aeron_async_add_exclusive_publication_t = aeron_client_registering_resource_stct;
pub type aeron_async_add_subscription_t = aeron_client_registering_resource_stct;
pub type aeron_async_add_counter_t = aeron_client_registering_resource_stct;
pub type aeron_async_destination_t = aeron_client_registering_resource_stct;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aeron_image_fragment_assembler_stct {
    _unused: [u8; 0],
}
pub type aeron_image_fragment_assembler_t = aeron_image_fragment_assembler_stct;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aeron_image_controlled_fragment_assembler_stct {
    _unused: [u8; 0],
}
pub type aeron_image_controlled_fragment_assembler_t =
    aeron_image_controlled_fragment_assembler_stct;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aeron_fragment_assembler_stct {
    _unused: [u8; 0],
}
pub type aeron_fragment_assembler_t = aeron_fragment_assembler_stct;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aeron_controlled_fragment_assembler_stct {
    _unused: [u8; 0],
}
pub type aeron_controlled_fragment_assembler_t = aeron_controlled_fragment_assembler_stct;
extern "C" {
    pub fn aeron_context_set_dir(
        context: *mut aeron_context_t,
        value: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_context_get_dir(context: *mut aeron_context_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn aeron_context_set_driver_timeout_ms(
        context: *mut aeron_context_t,
        value: u64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_context_get_driver_timeout_ms(context: *mut aeron_context_t) -> u64;
}
extern "C" {
    pub fn aeron_context_set_keepalive_interval_ns(
        context: *mut aeron_context_t,
        value: u64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_context_get_keepalive_interval_ns(context: *mut aeron_context_t) -> u64;
}
extern "C" {
    pub fn aeron_context_set_resource_linger_duration_ns(
        context: *mut aeron_context_t,
        value: u64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_context_get_resource_linger_duration_ns(context: *mut aeron_context_t) -> u64;
}
extern "C" {
    pub fn aeron_context_set_pre_touch_mapped_memory(
        context: *mut aeron_context_t,
        value: bool,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_context_get_pre_touch_mapped_memory(context: *mut aeron_context_t) -> bool;
}
#[doc = " The error handler to be called when an error occurs."]
pub type aeron_error_handler_t = ::std::option::Option<
    unsafe extern "C" fn(
        clientd: *mut ::std::os::raw::c_void,
        errcode: ::std::os::raw::c_int,
        message: *const ::std::os::raw::c_char,
    ),
>;
#[doc = " Generalised notification callback."]
pub type aeron_notification_t =
    ::std::option::Option<unsafe extern "C" fn(clientd: *mut ::std::os::raw::c_void)>;
extern "C" {
    pub fn aeron_context_set_error_handler(
        context: *mut aeron_context_t,
        handler: aeron_error_handler_t,
        clientd: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_context_get_error_handler(context: *mut aeron_context_t) -> aeron_error_handler_t;
}
extern "C" {
    pub fn aeron_context_get_error_handler_clientd(
        context: *mut aeron_context_t,
    ) -> *mut ::std::os::raw::c_void;
}
#[doc = " Function called by aeron_client_t to deliver notification that the media driver has added an aeron_publication_t\n or aeron_exclusive_publication_t successfully.\n\n Implementations should do the minimum work for passing off state to another thread for later processing.\n\n @param clientd to be returned in the call\n @param async associated with the original add publication call\n @param channel of the publication\n @param stream_id within the channel of the publication\n @param session_id of the publication\n @param correlation_id used by the publication"]
pub type aeron_on_new_publication_t = ::std::option::Option<
    unsafe extern "C" fn(
        clientd: *mut ::std::os::raw::c_void,
        async_: *mut aeron_async_add_publication_t,
        channel: *const ::std::os::raw::c_char,
        stream_id: i32,
        session_id: i32,
        correlation_id: i64,
    ),
>;
extern "C" {
    pub fn aeron_context_set_on_new_publication(
        context: *mut aeron_context_t,
        handler: aeron_on_new_publication_t,
        clientd: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_context_get_on_new_publication(
        context: *mut aeron_context_t,
    ) -> aeron_on_new_publication_t;
}
extern "C" {
    pub fn aeron_context_get_on_new_publication_clientd(
        context: *mut aeron_context_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn aeron_context_set_on_new_exclusive_publication(
        context: *mut aeron_context_t,
        handler: aeron_on_new_publication_t,
        clientd: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_context_get_on_new_exclusive_publication(
        context: *mut aeron_context_t,
    ) -> aeron_on_new_publication_t;
}
extern "C" {
    pub fn aeron_context_get_on_new_exclusive_publication_clientd(
        context: *mut aeron_context_t,
    ) -> *mut ::std::os::raw::c_void;
}
#[doc = " Function called by aeron_client_t to deliver notification that the media driver has added an aeron_subscription_t\n successfully.\n\n Implementations should do the minimum work for handing off state to another thread for later processing.\n\n @param clientd to be returned in the call\n @param async associated with the original aeron_add_async_subscription call\n @param channel of the subscription\n @param stream_id within the channel of the subscription\n @param session_id of the subscription\n @param correlation_id used by the subscription"]
pub type aeron_on_new_subscription_t = ::std::option::Option<
    unsafe extern "C" fn(
        clientd: *mut ::std::os::raw::c_void,
        async_: *mut aeron_async_add_subscription_t,
        channel: *const ::std::os::raw::c_char,
        stream_id: i32,
        correlation_id: i64,
    ),
>;
extern "C" {
    pub fn aeron_context_set_on_new_subscription(
        context: *mut aeron_context_t,
        handler: aeron_on_new_subscription_t,
        clientd: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_context_get_on_new_subscription(
        context: *mut aeron_context_t,
    ) -> aeron_on_new_subscription_t;
}
extern "C" {
    pub fn aeron_context_get_on_new_subscription_clientd(
        context: *mut aeron_context_t,
    ) -> *mut ::std::os::raw::c_void;
}
#[doc = " Function called by aeron_client_t to deliver notifications that an aeron_image_t was added.\n\n @param clientd to be returned in the call.\n @param subscription that image is part of.\n @param image that has become available."]
pub type aeron_on_available_image_t = ::std::option::Option<
    unsafe extern "C" fn(
        clientd: *mut ::std::os::raw::c_void,
        subscription: *mut aeron_subscription_t,
        image: *mut aeron_image_t,
    ),
>;
#[doc = " Function called by aeron_client_t to deliver notifications that an aeron_image_t has been removed from use and\n should not be used any longer.\n\n @param clientd to be returned in the call.\n @param subscription that image is part of.\n @param image that has become unavailable."]
pub type aeron_on_unavailable_image_t = ::std::option::Option<
    unsafe extern "C" fn(
        clientd: *mut ::std::os::raw::c_void,
        subscription: *mut aeron_subscription_t,
        image: *mut aeron_image_t,
    ),
>;
#[doc = " Function called by aeron_client_t to deliver notifications that a counter has been added to the driver.\n\n @param clientd to be returned in the call.\n @param counters_reader that holds the counter.\n @param registration_id of the counter.\n @param counter_id of the counter."]
pub type aeron_on_available_counter_t = ::std::option::Option<
    unsafe extern "C" fn(
        clientd: *mut ::std::os::raw::c_void,
        counters_reader: *mut aeron_counters_reader_t,
        registration_id: i64,
        counter_id: i32,
    ),
>;
extern "C" {
    pub fn aeron_context_set_on_available_counter(
        context: *mut aeron_context_t,
        handler: aeron_on_available_counter_t,
        clientd: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_context_get_on_available_counter(
        context: *mut aeron_context_t,
    ) -> aeron_on_available_counter_t;
}
extern "C" {
    pub fn aeron_context_get_on_available_counter_clientd(
        context: *mut aeron_context_t,
    ) -> *mut ::std::os::raw::c_void;
}
#[doc = " Function called by aeron_client_t to deliver notifications that a counter has been removed from the driver.\n\n @param clientd to be returned in the call.\n @param counters_reader that holds the counter.\n @param registration_id of the counter.\n @param counter_id of the counter."]
pub type aeron_on_unavailable_counter_t = ::std::option::Option<
    unsafe extern "C" fn(
        clientd: *mut ::std::os::raw::c_void,
        counters_reader: *mut aeron_counters_reader_t,
        registration_id: i64,
        counter_id: i32,
    ),
>;
extern "C" {
    pub fn aeron_context_set_on_unavailable_counter(
        context: *mut aeron_context_t,
        handler: aeron_on_unavailable_counter_t,
        clientd: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_context_get_on_unavailable_counter(
        context: *mut aeron_context_t,
    ) -> aeron_on_unavailable_counter_t;
}
extern "C" {
    pub fn aeron_context_get_on_unavailable_counter_clientd(
        context: *mut aeron_context_t,
    ) -> *mut ::std::os::raw::c_void;
}
#[doc = " Function called by aeron_client_t to deliver notifications that the client is closing.\n\n @param clientd to be returned in the call."]
pub type aeron_on_close_client_t =
    ::std::option::Option<unsafe extern "C" fn(clientd: *mut ::std::os::raw::c_void)>;
extern "C" {
    pub fn aeron_context_set_on_close_client(
        context: *mut aeron_context_t,
        handler: aeron_on_close_client_t,
        clientd: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_context_get_on_close_client(
        context: *mut aeron_context_t,
    ) -> aeron_on_close_client_t;
}
extern "C" {
    pub fn aeron_context_get_on_close_client_clientd(
        context: *mut aeron_context_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Whether to use an invoker to control the conductor agent or spawn a thread."]
    pub fn aeron_context_set_use_conductor_agent_invoker(
        context: *mut aeron_context_t,
        value: bool,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_context_get_use_conductor_agent_invoker(context: *mut aeron_context_t) -> bool;
}
pub type aeron_agent_on_start_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        state: *mut ::std::os::raw::c_void,
        role_name: *const ::std::os::raw::c_char,
    ),
>;
extern "C" {
    pub fn aeron_context_set_agent_on_start_function(
        context: *mut aeron_context_t,
        value: aeron_agent_on_start_func_t,
        state: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_context_get_agent_on_start_function(
        context: *mut aeron_context_t,
    ) -> aeron_agent_on_start_func_t;
}
extern "C" {
    pub fn aeron_context_get_agent_on_start_state(
        context: *mut aeron_context_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Create a aeron_context_t struct and initialize with default values.\n\n @param context to create and initialize\n @return 0 for success and -1 for error."]
    pub fn aeron_context_init(context: *mut *mut aeron_context_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Close and delete aeron_context_t struct.\n\n @param context to close and delete\n @return 0 for success and -1 for error."]
    pub fn aeron_context_close(context: *mut aeron_context_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Create a aeron_t client struct and initialize from the aeron_context_t struct.\n\n The given aeron_context_t struct will be used exclusively by the client. Do not reuse between clients.\n\n @param aeron  client to create and initialize.\n @param context to use for initialization.\n @return 0 for success and -1 for error."]
    pub fn aeron_init(
        client: *mut *mut aeron_t,
        context: *mut aeron_context_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Start an aeron_t. This may spawn a thread for the Client Conductor.\n\n @param client to start.\n @return 0 for success and -1 for error."]
    pub fn aeron_start(client: *mut aeron_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Call the Conductor main do_work duty cycle once.\n\n Client must have been created with use conductor invoker set to true.\n\n @param client to call do_work duty cycle on.\n @return 0 for success and -1 for error."]
    pub fn aeron_main_do_work(client: *mut aeron_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Call the Conductor Idle Strategy.\n\n @param client to idle.\n @param work_count to pass to idle strategy."]
    pub fn aeron_main_idle_strategy(client: *mut aeron_t, work_count: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Close and delete aeron_t struct.\n\n @param client to close and delete\n @return 0 for success and -1 for error."]
    pub fn aeron_close(client: *mut aeron_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Determines if the client has been closed, e.g. via a driver timeout. Don't call this method after calling\n aeron_close as that will have already freed the associated memory.\n\n @param client to check if closed.\n @return true if it has been closed, false otherwise."]
    pub fn aeron_is_closed(client: *mut aeron_t) -> bool;
}
extern "C" {
    #[doc = " Call stream_out to print the counter labels and values.\n\n @param client to get the counters from.\n @param stream_out to call for each label and value."]
    pub fn aeron_print_counters(
        client: *mut aeron_t,
        stream_out: ::std::option::Option<
            unsafe extern "C" fn(arg1: *const ::std::os::raw::c_char),
        >,
    );
}
extern "C" {
    #[doc = " Return the aeron_context_t that is in use by the given client.\n\n @param client to return the aeron_context_t for.\n @return the aeron_context_t for the given client or NULL for an error."]
    pub fn aeron_context(client: *mut aeron_t) -> *mut aeron_context_t;
}
extern "C" {
    #[doc = " Return the client id in use by the client.\n\n @param client to return the client id for.\n @return id value or -1 for an error."]
    pub fn aeron_client_id(client: *mut aeron_t) -> i64;
}
extern "C" {
    #[doc = " Return a unique correlation id from the driver.\n\n @param client to use to get the id.\n @return unique correlation id or -1 for an error."]
    pub fn aeron_next_correlation_id(client: *mut aeron_t) -> i64;
}
extern "C" {
    #[doc = " Asynchronously add a publication using the given client and return an object to use to determine when the\n publication is available.\n\n @param async object to use for polling completion.\n @param client to add the publication to.\n @param uri for the channel of the publication.\n @param stream_id for the publication.\n @return 0 for success or -1 for an error."]
    pub fn aeron_async_add_publication(
        async_: *mut *mut aeron_async_add_publication_t,
        client: *mut aeron_t,
        uri: *const ::std::os::raw::c_char,
        stream_id: i32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Poll the completion of the aeron_async_add_publication call.\n\n @param publication to set if completed successfully.\n @param async to check for completion.\n @return 0 for not complete (try again), 1 for completed successfully, or -1 for an error."]
    pub fn aeron_async_add_publication_poll(
        publication: *mut *mut aeron_publication_t,
        async_: *mut aeron_async_add_publication_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Asynchronously add an exclusive publication using the given client and return an object to use to determine when the\n publication is available.\n\n @param async object to use for polling completion.\n @param client to add the publication to.\n @param uri for the channel of the publication.\n @param stream_id for the publication.\n @return 0 for success or -1 for an error."]
    pub fn aeron_async_add_exclusive_publication(
        async_: *mut *mut aeron_async_add_exclusive_publication_t,
        client: *mut aeron_t,
        uri: *const ::std::os::raw::c_char,
        stream_id: i32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Poll the completion of the aeron_async_add_exclusive_publication call.\n\n @param publication to set if completed successfully.\n @param async to check for completion.\n @return 0 for not complete (try again), 1 for completed successfully, or -1 for an error."]
    pub fn aeron_async_add_exclusive_publication_poll(
        publication: *mut *mut aeron_exclusive_publication_t,
        async_: *mut aeron_async_add_exclusive_publication_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Asynchronously add a subscription using the given client and return an object to use to determine when the\n subscription is available.\n\n @param async object to use for polling completion.\n @param client to add the subscription to.\n @param uri for the channel of the subscription.\n @param stream_id for the subscription.\n @param on_available_image_handler to be called when images become available on the subscription.\n @param on_available_image_clientd to be passed when images become available on the subscription.\n @param on_unavailable_image_handler to be called when images go unavailable on the subscription.\n @param on_available_image_clientd to be called when images go unavailable on the subscription.\n @return 0 for success or -1 for an error."]
    pub fn aeron_async_add_subscription(
        async_: *mut *mut aeron_async_add_subscription_t,
        client: *mut aeron_t,
        uri: *const ::std::os::raw::c_char,
        stream_id: i32,
        on_available_image_handler: aeron_on_available_image_t,
        on_available_image_clientd: *mut ::std::os::raw::c_void,
        on_unavailable_image_handler: aeron_on_unavailable_image_t,
        on_unavailable_image_clientd: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Poll the completion of the aeron_async_add_subscription call.\n\n @param subscription to set if completed successfully.\n @param async to check for completion.\n @return 0 for not complete (try again), 1 for completed successfully, or -1 for an error."]
    pub fn aeron_async_add_subscription_poll(
        subscription: *mut *mut aeron_subscription_t,
        async_: *mut aeron_async_add_subscription_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return a reference to the counters reader of the given client.\n\n The aeron_counters_reader_t is maintained by the client. And should not be freed.\n\n @param client that contains the counters reader.\n @return aeron_counters_reader_t or NULL for error."]
    pub fn aeron_counters_reader(client: *mut aeron_t) -> *mut aeron_counters_reader_t;
}
extern "C" {
    #[doc = " Asynchronously add a counter using the given client and return an object to use to determine when the\n counter is available.\n\n @param async object to use for polling completion.\n @param client to add the counter to.\n @param type_id for the counter.\n @param key_buffer for the counter.\n @param key_buffer_length for the counter.\n @param label_buffer for the counter.\n @param label_buffer_length for the counter.\n @return 0 for success or -1 for an error."]
    pub fn aeron_async_add_counter(
        async_: *mut *mut aeron_async_add_counter_t,
        client: *mut aeron_t,
        type_id: i32,
        key_buffer: *const u8,
        key_buffer_length: usize,
        label_buffer: *const ::std::os::raw::c_char,
        label_buffer_length: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Poll the completion of the aeron_async_add_counter call.\n\n @param counter to set if completed successfully.\n @param async to check for completion.\n @return 0 for not complete (try again), 1 for completed successfully, or -1 for an error."]
    pub fn aeron_async_add_counter_poll(
        counter: *mut *mut aeron_counter_t,
        async_: *mut aeron_async_add_counter_t,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aeron_on_available_counter_pair_stct {
    pub handler: aeron_on_available_counter_t,
    pub clientd: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_aeron_on_available_counter_pair_stct() {
    const UNINIT: ::std::mem::MaybeUninit<aeron_on_available_counter_pair_stct> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_on_available_counter_pair_stct>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(aeron_on_available_counter_pair_stct)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_on_available_counter_pair_stct>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(aeron_on_available_counter_pair_stct)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).handler) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_on_available_counter_pair_stct),
            "::",
            stringify!(handler)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).clientd) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_on_available_counter_pair_stct),
            "::",
            stringify!(clientd)
        )
    );
}
pub type aeron_on_available_counter_pair_t = aeron_on_available_counter_pair_stct;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aeron_on_unavailable_counter_pair_stct {
    pub handler: aeron_on_unavailable_counter_t,
    pub clientd: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_aeron_on_unavailable_counter_pair_stct() {
    const UNINIT: ::std::mem::MaybeUninit<aeron_on_unavailable_counter_pair_stct> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_on_unavailable_counter_pair_stct>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(aeron_on_unavailable_counter_pair_stct)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_on_unavailable_counter_pair_stct>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(aeron_on_unavailable_counter_pair_stct)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).handler) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_on_unavailable_counter_pair_stct),
            "::",
            stringify!(handler)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).clientd) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_on_unavailable_counter_pair_stct),
            "::",
            stringify!(clientd)
        )
    );
}
pub type aeron_on_unavailable_counter_pair_t = aeron_on_unavailable_counter_pair_stct;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aeron_on_close_client_pair_stct {
    pub handler: aeron_on_close_client_t,
    pub clientd: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_aeron_on_close_client_pair_stct() {
    const UNINIT: ::std::mem::MaybeUninit<aeron_on_close_client_pair_stct> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_on_close_client_pair_stct>(),
        16usize,
        concat!("Size of: ", stringify!(aeron_on_close_client_pair_stct))
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_on_close_client_pair_stct>(),
        8usize,
        concat!("Alignment of ", stringify!(aeron_on_close_client_pair_stct))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).handler) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_on_close_client_pair_stct),
            "::",
            stringify!(handler)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).clientd) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_on_close_client_pair_stct),
            "::",
            stringify!(clientd)
        )
    );
}
pub type aeron_on_close_client_pair_t = aeron_on_close_client_pair_stct;
extern "C" {
    #[doc = " Add a handler to be called when a new counter becomes available.\n\n NOTE: This function blocks until the handler is added by the client conductor thread.\n\n @param client for the counter\n @param pair holding the handler to call and a clientd to pass when called.\n @return 0 for success and -1 for error"]
    pub fn aeron_add_available_counter_handler(
        client: *mut aeron_t,
        pair: *mut aeron_on_available_counter_pair_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Remove a previously added handler to be called when a new counter becomes available.\n\n NOTE: This function blocks until the handler is removed by the client conductor thread.\n\n @param client for the counter\n @param pair holding the handler to call and a clientd to pass when called.\n @return 0 for success and -1 for error"]
    pub fn aeron_remove_available_counter_handler(
        client: *mut aeron_t,
        pair: *mut aeron_on_available_counter_pair_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Add a handler to be called when a new counter becomes unavailable or goes away.\n\n NOTE: This function blocks until the handler is added by the client conductor thread.\n\n @param client for the counter\n @param pair holding the handler to call and a clientd to pass when called.\n @return 0 for success and -1 for error"]
    pub fn aeron_add_unavailable_counter_handler(
        client: *mut aeron_t,
        pair: *mut aeron_on_unavailable_counter_pair_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Remove a previously added handler to be called when a new counter becomes unavailable or goes away.\n\n NOTE: This function blocks until the handler is removed by the client conductor thread.\n\n @param client for the counter\n @param pair holding the handler to call and a clientd to pass when called.\n @return 0 for success and -1 for error"]
    pub fn aeron_remove_unavailable_counter_handler(
        client: *mut aeron_t,
        pair: *mut aeron_on_unavailable_counter_pair_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Add a handler to be called when client is closed.\n\n NOTE: This function blocks until the handler is added by the client conductor thread.\n\n @param client for the counter\n @param pair holding the handler to call and a clientd to pass when called.\n @return 0 for success and -1 for error"]
    pub fn aeron_add_close_handler(
        client: *mut aeron_t,
        pair: *mut aeron_on_close_client_pair_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Remove a previously added handler to be called when client is closed.\n\n NOTE: This function blocks until the handler is removed by the client conductor thread.\n\n @param client for the counter\n @param pair holding the handler to call and a clientd to pass when called.\n @return 0 for success and -1 for error"]
    pub fn aeron_remove_close_handler(
        client: *mut aeron_t,
        pair: *mut aeron_on_close_client_pair_t,
    ) -> ::std::os::raw::c_int;
}
#[repr(C, packed(4))]
#[derive(Copy, Clone)]
pub struct aeron_counter_value_descriptor_stct {
    pub counter_value: i64,
    pub registration_id: i64,
    pub owner_id: i64,
    pub pad1: [u8; 104usize],
}
#[test]
fn bindgen_test_layout_aeron_counter_value_descriptor_stct() {
    const UNINIT: ::std::mem::MaybeUninit<aeron_counter_value_descriptor_stct> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_counter_value_descriptor_stct>(),
        128usize,
        concat!("Size of: ", stringify!(aeron_counter_value_descriptor_stct))
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_counter_value_descriptor_stct>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(aeron_counter_value_descriptor_stct)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).counter_value) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_counter_value_descriptor_stct),
            "::",
            stringify!(counter_value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).registration_id) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_counter_value_descriptor_stct),
            "::",
            stringify!(registration_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).owner_id) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_counter_value_descriptor_stct),
            "::",
            stringify!(owner_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad1) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_counter_value_descriptor_stct),
            "::",
            stringify!(pad1)
        )
    );
}
pub type aeron_counter_value_descriptor_t = aeron_counter_value_descriptor_stct;
#[repr(C, packed(4))]
#[derive(Copy, Clone)]
pub struct aeron_counter_metadata_descriptor_stct {
    pub state: i32,
    pub type_id: i32,
    pub free_for_reuse_deadline_ms: i64,
    pub key: [u8; 112usize],
    pub label_length: i32,
    pub label: [u8; 380usize],
}
#[test]
fn bindgen_test_layout_aeron_counter_metadata_descriptor_stct() {
    const UNINIT: ::std::mem::MaybeUninit<aeron_counter_metadata_descriptor_stct> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_counter_metadata_descriptor_stct>(),
        512usize,
        concat!(
            "Size of: ",
            stringify!(aeron_counter_metadata_descriptor_stct)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_counter_metadata_descriptor_stct>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(aeron_counter_metadata_descriptor_stct)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_counter_metadata_descriptor_stct),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_id) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_counter_metadata_descriptor_stct),
            "::",
            stringify!(type_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).free_for_reuse_deadline_ms) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_counter_metadata_descriptor_stct),
            "::",
            stringify!(free_for_reuse_deadline_ms)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).key) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_counter_metadata_descriptor_stct),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).label_length) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_counter_metadata_descriptor_stct),
            "::",
            stringify!(label_length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).label) as usize - ptr as usize },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_counter_metadata_descriptor_stct),
            "::",
            stringify!(label)
        )
    );
}
pub type aeron_counter_metadata_descriptor_t = aeron_counter_metadata_descriptor_stct;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aeron_counters_reader_buffers_stct {
    pub values: *mut u8,
    pub metadata: *mut u8,
    pub values_length: usize,
    pub metadata_length: usize,
}
#[test]
fn bindgen_test_layout_aeron_counters_reader_buffers_stct() {
    const UNINIT: ::std::mem::MaybeUninit<aeron_counters_reader_buffers_stct> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_counters_reader_buffers_stct>(),
        32usize,
        concat!("Size of: ", stringify!(aeron_counters_reader_buffers_stct))
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_counters_reader_buffers_stct>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(aeron_counters_reader_buffers_stct)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).values) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_counters_reader_buffers_stct),
            "::",
            stringify!(values)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).metadata) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_counters_reader_buffers_stct),
            "::",
            stringify!(metadata)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).values_length) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_counters_reader_buffers_stct),
            "::",
            stringify!(values_length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).metadata_length) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_counters_reader_buffers_stct),
            "::",
            stringify!(metadata_length)
        )
    );
}
pub type aeron_counters_reader_buffers_t = aeron_counters_reader_buffers_stct;
extern "C" {
    #[doc = " Get buffer pointers and lengths for the counters reader.\n\n @param reader reader containing the buffers.\n @param buffers output structure to return the buffers.\n @return -1 on failure, 0 on success."]
    pub fn aeron_counters_reader_get_buffers(
        reader: *mut aeron_counters_reader_t,
        buffers: *mut aeron_counters_reader_buffers_t,
    ) -> ::std::os::raw::c_int;
}
#[doc = " Function called by aeron_counters_reader_foreach_counter for each counter in the aeron_counters_reader_t.\n\n @param value of the counter.\n @param id of the counter.\n @param label for the counter.\n @param label_length for the counter.\n @param clientd to be returned in the call"]
pub type aeron_counters_reader_foreach_counter_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        value: i64,
        id: i32,
        type_id: i32,
        key: *const u8,
        key_length: usize,
        label: *const ::std::os::raw::c_char,
        label_length: usize,
        clientd: *mut ::std::os::raw::c_void,
    ),
>;
extern "C" {
    #[doc = " Iterate over the counters in the counters_reader and call the given function for each counter.\n\n @param counters_reader to iterate over.\n @param func to call for each counter.\n @param clientd to pass for each call to func."]
    pub fn aeron_counters_reader_foreach_counter(
        counters_reader: *mut aeron_counters_reader_t,
        func: aeron_counters_reader_foreach_counter_func_t,
        clientd: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Get the current max counter id.\n\n @param reader to query\n @return -1 on failure, max counter id on success."]
    pub fn aeron_counters_reader_max_counter_id(reader: *mut aeron_counters_reader_t) -> i32;
}
extern "C" {
    #[doc = " Get the address for a counter.\n\n @param counters_reader that contains the counter\n @param counter_id to find\n @return address of the counter value"]
    pub fn aeron_counters_reader_addr(
        counters_reader: *mut aeron_counters_reader_t,
        counter_id: i32,
    ) -> *mut i64;
}
extern "C" {
    #[doc = " Get the registration id assigned to a counter.\n\n @param counters_reader representing the this pointer.\n @param counter_id      for which the registration id requested.\n @param registration_id pointer for value to be set on success.\n @return -1 on failure, 0 on success."]
    pub fn aeron_counters_reader_counter_registration_id(
        counters_reader: *mut aeron_counters_reader_t,
        counter_id: i32,
        registration_id: *mut i64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the owner id assigned to a counter which will typically be the client id.\n\n @param counters_reader representing the this pointer.\n @param counter_id      for which the registration id requested.\n @param owner_id        pointer for value to be set on success.\n @return -1 on failure, 0 on success."]
    pub fn aeron_counters_reader_counter_owner_id(
        counters_reader: *mut aeron_counters_reader_t,
        counter_id: i32,
        owner_id: *mut i64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the state for a counter.\n\n @param counters_reader that contains the counter\n @param counter_id to find\n @param state out pointer for the current state to be stored in.\n @return -1 on failure, 0 on success."]
    pub fn aeron_counters_reader_counter_state(
        counters_reader: *mut aeron_counters_reader_t,
        counter_id: i32,
        state: *mut i32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the type id for a counter.\n\n @param counters_reader that contains the counter\n @param counter_id to find\n @param type id out pointer for the current state to be stored in.\n @return -1 on failure, 0 on success."]
    pub fn aeron_counters_reader_counter_type_id(
        counters_reader: *mut aeron_counters_reader_t,
        counter_id: i32,
        type_id: *mut i32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the label for a counter.\n\n @param counters_reader that contains the counter\n @param counter_id to find\n @param buffer to store the counter in.\n @param buffer_length length of the output buffer\n @return -1 on failure, number of characters copied to buffer on success."]
    pub fn aeron_counters_reader_counter_label(
        counters_reader: *mut aeron_counters_reader_t,
        counter_id: i32,
        buffer: *mut ::std::os::raw::c_char,
        buffer_length: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the free for reuse deadline (ms) for a counter.\n\n @param counters_reader that contains the counter.\n @param counter_id to find.\n @param deadline_ms output value to store the deadline.\n @return -1 on failure, 0 on success."]
    pub fn aeron_counters_reader_free_for_reuse_deadline_ms(
        counters_reader: *mut aeron_counters_reader_t,
        counter_id: i32,
        deadline_ms: *mut i64,
    ) -> ::std::os::raw::c_int;
}
#[doc = " Function called when filling in the reserved value field of a message.\n\n @param clientd passed to the offer function.\n @param buffer of the entire frame, including Aeron data header.\n @param frame_length of the entire frame."]
pub type aeron_reserved_value_supplier_t = ::std::option::Option<
    unsafe extern "C" fn(
        clientd: *mut ::std::os::raw::c_void,
        buffer: *mut u8,
        frame_length: usize,
    ) -> i64,
>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aeron_iovec_stct {
    pub iov_base: *mut u8,
    pub iov_len: usize,
}
#[test]
fn bindgen_test_layout_aeron_iovec_stct() {
    const UNINIT: ::std::mem::MaybeUninit<aeron_iovec_stct> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_iovec_stct>(),
        16usize,
        concat!("Size of: ", stringify!(aeron_iovec_stct))
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_iovec_stct>(),
        8usize,
        concat!("Alignment of ", stringify!(aeron_iovec_stct))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).iov_base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_iovec_stct),
            "::",
            stringify!(iov_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).iov_len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_iovec_stct),
            "::",
            stringify!(iov_len)
        )
    );
}
pub type aeron_iovec_t = aeron_iovec_stct;
#[doc = " Structure used to hold information for a try_claim function call."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aeron_buffer_claim_stct {
    pub frame_header: *mut u8,
    pub data: *mut u8,
    pub length: usize,
}
#[test]
fn bindgen_test_layout_aeron_buffer_claim_stct() {
    const UNINIT: ::std::mem::MaybeUninit<aeron_buffer_claim_stct> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_buffer_claim_stct>(),
        24usize,
        concat!("Size of: ", stringify!(aeron_buffer_claim_stct))
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_buffer_claim_stct>(),
        8usize,
        concat!("Alignment of ", stringify!(aeron_buffer_claim_stct))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).frame_header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_buffer_claim_stct),
            "::",
            stringify!(frame_header)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_buffer_claim_stct),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_buffer_claim_stct),
            "::",
            stringify!(length)
        )
    );
}
extern "C" {
    #[doc = " Commit the given buffer_claim as a complete message available for consumption.\n\n @param buffer_claim to commit.\n @return 0 for success or -1 for error."]
    pub fn aeron_buffer_claim_commit(
        buffer_claim: *mut aeron_buffer_claim_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Abort the given buffer_claim and assign its position as padding.\n\n @param buffer_claim to abort.\n @return 0 for success or -1 for error."]
    pub fn aeron_buffer_claim_abort(
        buffer_claim: *mut aeron_buffer_claim_t,
    ) -> ::std::os::raw::c_int;
}
#[doc = " Configuration for a publication that does not change during it's lifetime."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aeron_publication_constants_stct {
    #[doc = " Media address for delivery to the channel.\n\n This returns a pointer only valid for the lifetime of the publication."]
    pub channel: *const ::std::os::raw::c_char,
    #[doc = " The registration used to register this Publication with the media driver by the first publisher."]
    pub original_registration_id: i64,
    #[doc = " Get the registration id used to register this Publication with the media driver.\n\n If this value is different from the original_registration_id then a previous active registration exists."]
    pub registration_id: i64,
    #[doc = " The maximum possible position this stream can reach due to its term buffer length.\n\n Maximum possible position is term-length times 2^31 in bytes."]
    pub max_possible_position: i64,
    #[doc = " Number of bits to right shift a position to get a term count for how far the stream has progressed."]
    pub position_bits_to_shift: usize,
    #[doc = " Get the length in bytes for each term partition in the log buffer."]
    pub term_buffer_length: usize,
    #[doc = " Maximum message length supported in bytes. Messages may be made of multiple fragments if greater than\n MTU length."]
    pub max_message_length: usize,
    #[doc = " Maximum length of a message payload that fits within a message fragment.\n\n This is he MTU length minus the message fragment header length."]
    pub max_payload_length: usize,
    #[doc = " Stream id of the publication."]
    pub stream_id: i32,
    #[doc = " Session id of the publication."]
    pub session_id: i32,
    #[doc = " The initial term id assigned when this publication was created. This can be used to determine how many\n terms have passed since creation."]
    pub initial_term_id: i32,
    #[doc = " Counter id for the publication limit."]
    pub publication_limit_counter_id: i32,
    #[doc = " Counter id for the channel status indicator"]
    pub channel_status_indicator_id: i32,
}
#[test]
fn bindgen_test_layout_aeron_publication_constants_stct() {
    const UNINIT: ::std::mem::MaybeUninit<aeron_publication_constants_stct> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_publication_constants_stct>(),
        88usize,
        concat!("Size of: ", stringify!(aeron_publication_constants_stct))
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_publication_constants_stct>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(aeron_publication_constants_stct)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).channel) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_publication_constants_stct),
            "::",
            stringify!(channel)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).original_registration_id) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_publication_constants_stct),
            "::",
            stringify!(original_registration_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).registration_id) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_publication_constants_stct),
            "::",
            stringify!(registration_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_possible_position) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_publication_constants_stct),
            "::",
            stringify!(max_possible_position)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).position_bits_to_shift) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_publication_constants_stct),
            "::",
            stringify!(position_bits_to_shift)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).term_buffer_length) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_publication_constants_stct),
            "::",
            stringify!(term_buffer_length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_message_length) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_publication_constants_stct),
            "::",
            stringify!(max_message_length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_payload_length) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_publication_constants_stct),
            "::",
            stringify!(max_payload_length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stream_id) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_publication_constants_stct),
            "::",
            stringify!(stream_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).session_id) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_publication_constants_stct),
            "::",
            stringify!(session_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).initial_term_id) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_publication_constants_stct),
            "::",
            stringify!(initial_term_id)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).publication_limit_counter_id) as usize - ptr as usize
        },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_publication_constants_stct),
            "::",
            stringify!(publication_limit_counter_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).channel_status_indicator_id) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_publication_constants_stct),
            "::",
            stringify!(channel_status_indicator_id)
        )
    );
}
#[doc = " Configuration for a publication that does not change during it's lifetime."]
pub type aeron_publication_constants_t = aeron_publication_constants_stct;
extern "C" {
    #[doc = " Non-blocking publish of a buffer containing a message.\n\n @param publication to publish on.\n @param buffer to publish.\n @param length of the buffer.\n @param reserved_value_supplier to use for setting the reserved value field or NULL.\n @param clientd to pass to the reserved_value_supplier.\n @return the new stream position otherwise a negative error value."]
    pub fn aeron_publication_offer(
        publication: *mut aeron_publication_t,
        buffer: *const u8,
        length: usize,
        reserved_value_supplier: aeron_reserved_value_supplier_t,
        clientd: *mut ::std::os::raw::c_void,
    ) -> i64;
}
extern "C" {
    #[doc = " Non-blocking publish by gathering buffer vectors into a message.\n\n @param publication to publish on.\n @param iov array for the vectors\n @param iovcnt of the number of vectors\n @param reserved_value_supplier to use for setting the reserved value field or NULL.\n @param clientd to pass to the reserved_value_supplier.\n @return the new stream position otherwise a negative error value."]
    pub fn aeron_publication_offerv(
        publication: *mut aeron_publication_t,
        iov: *mut aeron_iovec_t,
        iovcnt: usize,
        reserved_value_supplier: aeron_reserved_value_supplier_t,
        clientd: *mut ::std::os::raw::c_void,
    ) -> i64;
}
extern "C" {
    #[doc = " Try to claim a range in the publication log into which a message can be written with zero copy semantics.\n Once the message has been written then aeron_buffer_claim_commit should be called thus making it available.\n A claim length cannot be greater than max payload length.\n <p>\n <b>Note:</b> This method can only be used for message lengths less than MTU length minus header.\n If the claim is held for more than the aeron.publication.unblock.timeout system property then the driver will\n assume the publication thread is dead and will unblock the claim thus allowing other threads to make progress\n and other claims to be sent to reach end-of-stream (EOS).\n\n @code\n aeron_buffer_claim_t buffer_claim;\n\n if (aeron_publication_try_claim(publication, length, &buffer_claim) > 0L)\n {\n     // work with buffer_claim->data directly.\n     aeron_buffer_claim_commit(&buffer_claim);\n }\n @endcode\n\n @param publication to publish to.\n @param length of the message.\n @param buffer_claim to be populated if the claim succeeds.\n @return the new stream position otherwise a negative error value."]
    pub fn aeron_publication_try_claim(
        publication: *mut aeron_publication_t,
        length: usize,
        buffer_claim: *mut aeron_buffer_claim_t,
    ) -> i64;
}
extern "C" {
    #[doc = " Get the status of the media channel for this publication.\n <p>\n The status will be ERRORED (-1) if a socket exception occurs on setup and ACTIVE (1) if all is well.\n\n @param publication to check status of.\n @return 1 for ACTIVE, -1 for ERRORED"]
    pub fn aeron_publication_channel_status(publication: *mut aeron_publication_t) -> i64;
}
extern "C" {
    #[doc = " Has the publication closed?\n\n @param publication to check\n @return true if this publication is closed."]
    pub fn aeron_publication_is_closed(publication: *mut aeron_publication_t) -> bool;
}
extern "C" {
    #[doc = " Has the publication seen an active Subscriber recently?\n\n @param publication to check.\n @return true if this publication has recently seen an active subscriber otherwise false."]
    pub fn aeron_publication_is_connected(publication: *mut aeron_publication_t) -> bool;
}
extern "C" {
    #[doc = " Fill in a structure with the constants in use by a publication.\n\n @param publication to get the constants for.\n @param constants structure to fill in with the constants\n @return 0 for success and -1 for error."]
    pub fn aeron_publication_constants(
        publication: *mut aeron_publication_t,
        constants: *mut aeron_publication_constants_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the current position to which the publication has advanced for this stream.\n\n @param publication to query.\n @return the current position to which the publication has advanced for this stream or a negative error value."]
    pub fn aeron_publication_position(publication: *mut aeron_publication_t) -> i64;
}
extern "C" {
    #[doc = " Get the position limit beyond which this publication will be back pressured.\n\n This should only be used as a guide to determine when back pressure is likely to be applied.\n\n @param publication to query.\n @return the position limit beyond which this publication will be back pressured or a negative error value."]
    pub fn aeron_publication_position_limit(publication: *mut aeron_publication_t) -> i64;
}
extern "C" {
    #[doc = " Add a destination manually to a multi-destination-cast publication.\n\n @param async object to use for polling completion.\n @param publication to add destination to.\n @param uri for the destination to add.\n @return 0 for success and -1 for error."]
    pub fn aeron_publication_async_add_destination(
        async_: *mut *mut aeron_async_destination_t,
        client: *mut aeron_t,
        publication: *mut aeron_publication_t,
        uri: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Remove a destination manually from a multi-destination-cast publication.\n\n @param async object to use for polling completion.\n @param publication to remove destination from.\n @param uri for the destination to remove.\n @return 0 for success and -1 for error."]
    pub fn aeron_publication_async_remove_destination(
        async_: *mut *mut aeron_async_destination_t,
        client: *mut aeron_t,
        publication: *mut aeron_publication_t,
        uri: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Poll the completion of the add/remove of a destination to/from a publication.\n\n @param async to check for completion.\n @return 0 for not complete (try again), 1 for completed successfully, or -1 for an error."]
    pub fn aeron_publication_async_destination_poll(
        async_: *mut aeron_async_destination_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Add a destination manually to a multi-destination-cast exclusive publication.\n\n @param async object to use for polling completion.\n @param publication to add destination to.\n @param uri for the destination to add.\n @return 0 for success and -1 for error."]
    pub fn aeron_exclusive_publication_async_add_destination(
        async_: *mut *mut aeron_async_destination_t,
        client: *mut aeron_t,
        publication: *mut aeron_exclusive_publication_t,
        uri: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Remove a destination manually from a multi-destination-cast exclusive publication.\n\n @param async object to use for polling completion.\n @param publication to remove destination from.\n @param uri for the destination to remove.\n @return 0 for success and -1 for error."]
    pub fn aeron_exclusive_publication_async_remove_destination(
        async_: *mut *mut aeron_async_destination_t,
        client: *mut aeron_t,
        publication: *mut aeron_exclusive_publication_t,
        uri: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Poll the completion of the add/remove of a destination to/from an exclusive publication.\n\n @param async to check for completion.\n @return 0 for not complete (try again), 1 for completed successfully, or -1 for an error."]
    pub fn aeron_exclusive_publication_async_destination_poll(
        async_: *mut aeron_async_destination_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Asynchronously close the publication. Will callback on the on_complete notification when the subscription is closed.\n The callback is optional, use NULL for the on_complete callback if not required.\n\n @param publication to close\n @param on_close_complete optional callback to execute once the subscription has been closed and freed. This may\n happen on a separate thread, so the caller should ensure that clientd has the appropriate lifetime.\n @param on_close_complete_clientd parameter to pass to the on_complete callback.\n @return 0 for success or -1 for error."]
    pub fn aeron_publication_close(
        publication: *mut aeron_publication_t,
        on_close_complete: aeron_notification_t,
        on_close_complete_clientd: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the publication's channel\n\n @param publication this\n @return channel uri string"]
    pub fn aeron_publication_channel(
        publication: *mut aeron_publication_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Get the publication's stream id\n\n @param publication this\n @return stream id"]
    pub fn aeron_publication_stream_id(publication: *mut aeron_publication_t) -> i32;
}
extern "C" {
    #[doc = " Get the publication's session id\n @param publication this\n @return session id"]
    pub fn aeron_publication_session_id(publication: *mut aeron_publication_t) -> i32;
}
extern "C" {
    #[doc = " Get all of the local socket addresses for this publication. Typically only one representing the control address.\n\n @param subscription to query\n @param address_vec to hold the received addresses\n @param address_vec_len available length of the vector to hold the addresses\n @return number of addresses found or -1 if there is an error.\n @see aeron_subscription_local_sockaddrs"]
    pub fn aeron_publication_local_sockaddrs(
        publication: *mut aeron_publication_t,
        address_vec: *mut aeron_iovec_t,
        address_vec_len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Non-blocking publish of a buffer containing a message.\n\n @param publication to publish on.\n @param buffer to publish.\n @param length of the buffer.\n @param reserved_value_supplier to use for setting the reserved value field or NULL.\n @param clientd to pass to the reserved_value_supplier.\n @return the new stream position otherwise a negative error value."]
    pub fn aeron_exclusive_publication_offer(
        publication: *mut aeron_exclusive_publication_t,
        buffer: *const u8,
        length: usize,
        reserved_value_supplier: aeron_reserved_value_supplier_t,
        clientd: *mut ::std::os::raw::c_void,
    ) -> i64;
}
extern "C" {
    #[doc = " Non-blocking publish by gathering buffer vectors into a message.\n\n @param publication to publish on.\n @param iov array for the vectors\n @param iovcnt of the number of vectors\n @param reserved_value_supplier to use for setting the reserved value field or NULL.\n @param clientd to pass to the reserved_value_supplier.\n @return the new stream position otherwise a negative error value."]
    pub fn aeron_exclusive_publication_offerv(
        publication: *mut aeron_exclusive_publication_t,
        iov: *mut aeron_iovec_t,
        iovcnt: usize,
        reserved_value_supplier: aeron_reserved_value_supplier_t,
        clientd: *mut ::std::os::raw::c_void,
    ) -> i64;
}
extern "C" {
    #[doc = " Try to claim a range in the publication log into which a message can be written with zero copy semantics.\n Once the message has been written then aeron_buffer_claim_commit should be called thus making it available.\n A claim length cannot be greater than max payload length.\n <p>\n <b>Note:</b> This method can only be used for message lengths less than MTU length minus header.\n\n @code\n aeron_buffer_claim_t buffer_claim;\n\n if (aeron_exclusive_publication_try_claim(publication, length, &buffer_claim) > 0L)\n {\n     // work with buffer_claim->data directly.\n     aeron_buffer_claim_commit(&buffer_claim);\n }\n @endcode\n\n @param publication to publish to.\n @param length of the message.\n @param buffer_claim to be populated if the claim succeeds.\n @return the new stream position otherwise a negative error value."]
    pub fn aeron_exclusive_publication_try_claim(
        publication: *mut aeron_exclusive_publication_t,
        length: usize,
        buffer_claim: *mut aeron_buffer_claim_t,
    ) -> i64;
}
extern "C" {
    #[doc = " Append a padding record log of a given length to make up the log to a position.\n\n @param length of the range to claim, in bytes.\n @return the new stream position otherwise a negative error value."]
    pub fn aeron_exclusive_publication_append_padding(
        publication: *mut aeron_exclusive_publication_t,
        length: usize,
    ) -> i64;
}
extern "C" {
    #[doc = " Offer a block of pre-formatted message fragments directly into the current term.\n\n @param buffer containing the pre-formatted block of message fragments.\n @param offset offset in the buffer at which the first fragment begins.\n @param length in bytes of the encoded block.\n @return the new stream position otherwise a negative error value."]
    pub fn aeron_exclusive_publication_offer_block(
        publication: *mut aeron_exclusive_publication_t,
        buffer: *const u8,
        length: usize,
    ) -> i64;
}
extern "C" {
    #[doc = " Get the status of the media channel for this publication.\n <p>\n The status will be ERRORED (-1) if a socket exception occurs on setup and ACTIVE (1) if all is well.\n\n @param publication to check status of.\n @return 1 for ACTIVE, -1 for ERRORED"]
    pub fn aeron_exclusive_publication_channel_status(
        publication: *mut aeron_exclusive_publication_t,
    ) -> i64;
}
extern "C" {
    #[doc = " Fill in a structure with the constants in use by a publication.\n\n @param publication to get the constants for.\n @param constants structure to fill in with the constants\n @return 0 for success and -1 for error."]
    pub fn aeron_exclusive_publication_constants(
        publication: *mut aeron_exclusive_publication_t,
        constants: *mut aeron_publication_constants_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the current position to which the publication has advanced for this stream.\n\n @param publication to query.\n @return the current position to which the publication has advanced for this stream or a negative error value."]
    pub fn aeron_exclusive_publication_position(
        publication: *mut aeron_exclusive_publication_t,
    ) -> i64;
}
extern "C" {
    #[doc = " Get the position limit beyond which this publication will be back pressured.\n\n This should only be used as a guide to determine when back pressure is likely to be applied.\n\n @param publication to query.\n @return the position limit beyond which this publication will be back pressured or a negative error value."]
    pub fn aeron_exclusive_publication_position_limit(
        publication: *mut aeron_exclusive_publication_t,
    ) -> i64;
}
extern "C" {
    #[doc = " Asynchronously close the publication.\n\n @param publication to close\n @return 0 for success or -1 for error."]
    pub fn aeron_exclusive_publication_close(
        publication: *mut aeron_exclusive_publication_t,
        on_close_complete: aeron_notification_t,
        on_close_complete_clientd: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Has the exclusive publication closed?\n\n @param publication to check\n @return true if this publication is closed."]
    pub fn aeron_exclusive_publication_is_closed(
        publication: *mut aeron_exclusive_publication_t,
    ) -> bool;
}
extern "C" {
    #[doc = " Has the exclusive publication seen an active Subscriber recently?\n\n @param publication to check.\n @return true if this publication has recently seen an active subscriber otherwise false."]
    pub fn aeron_exclusive_publication_is_connected(
        publication: *mut aeron_exclusive_publication_t,
    ) -> bool;
}
extern "C" {
    #[doc = " Get all of the local socket addresses for this exclusive publication. Typically only one representing the control\n address.\n\n @see aeron_subscription_local_sockaddrs\n @param subscription to query\n @param address_vec to hold the received addresses\n @param address_vec_len available length of the vector to hold the addresses\n @return number of addresses found or -1 if there is an error."]
    pub fn aeron_exclusive_publication_local_sockaddrs(
        publication: *mut aeron_exclusive_publication_t,
        address_vec: *mut aeron_iovec_t,
        address_vec_len: usize,
    ) -> ::std::os::raw::c_int;
}
#[doc = " Callback for handling fragments of data being read from a log.\n\n The frame will either contain a whole message or a fragment of a message to be reassembled. Messages are fragmented\n if greater than the frame for MTU in length.\n\n @param clientd passed to the poll function.\n @param buffer containing the data.\n @param length of the data in bytes.\n @param header representing the meta data for the data."]
pub type aeron_fragment_handler_t = ::std::option::Option<
    unsafe extern "C" fn(
        clientd: *mut ::std::os::raw::c_void,
        buffer: *const u8,
        length: usize,
        header: *mut aeron_header_t,
    ),
>;
#[doc = " Abort the current polling operation and do not advance the position for this fragment."]
pub const aeron_controlled_fragment_handler_action_en_AERON_ACTION_ABORT:
    aeron_controlled_fragment_handler_action_en = 1;
#[doc = " Break from the current polling operation and commit the position as of the end of the current fragment\n being handled."]
pub const aeron_controlled_fragment_handler_action_en_AERON_ACTION_BREAK:
    aeron_controlled_fragment_handler_action_en = 2;
#[doc = " Continue processing but commit the position as of the end of the current fragment so that\n flow control is applied to this point."]
pub const aeron_controlled_fragment_handler_action_en_AERON_ACTION_COMMIT:
    aeron_controlled_fragment_handler_action_en = 3;
#[doc = " Continue processing until fragment limit or no fragments with position commit at end of poll as in\n aeron_fragment_handler_t."]
pub const aeron_controlled_fragment_handler_action_en_AERON_ACTION_CONTINUE:
    aeron_controlled_fragment_handler_action_en = 4;
pub type aeron_controlled_fragment_handler_action_en = ::std::os::raw::c_uint;
pub use self::aeron_controlled_fragment_handler_action_en as aeron_controlled_fragment_handler_action_t;
#[doc = " Callback for handling fragments of data being read from a log.\n\n Handler for reading data that is coming from a log buffer. The frame will either contain a whole message\n or a fragment of a message to be reassembled. Messages are fragmented if greater than the frame for MTU in length.\n\n @param clientd passed to the controlled poll function.\n @param buffer containing the data.\n @param length of the data in bytes.\n @param header representing the meta data for the data.\n @return The action to be taken with regard to the stream position after the callback."]
pub type aeron_controlled_fragment_handler_t = ::std::option::Option<
    unsafe extern "C" fn(
        clientd: *mut ::std::os::raw::c_void,
        buffer: *const u8,
        length: usize,
        header: *mut aeron_header_t,
    ) -> aeron_controlled_fragment_handler_action_t,
>;
#[doc = " Callback for handling a block of messages being read from a log.\n\n @param clientd passed to the block poll function.\n @param buffer containing the block of message fragments.\n @param offset at which the block begins, including any frame headers.\n @param length of the block in bytes, including any frame headers that is aligned.\n @param session_id of the stream containing this block of message fragments.\n @param term_id of the stream containing this block of message fragments."]
pub type aeron_block_handler_t = ::std::option::Option<
    unsafe extern "C" fn(
        clientd: *mut ::std::os::raw::c_void,
        buffer: *const u8,
        length: usize,
        session_id: i32,
        term_id: i32,
    ),
>;
extern "C" {
    #[doc = " Get all of the field values from the header. This will do a memcpy into the supplied header_values_t pointer.\n\n @param header to read values from.\n @param values to copy values to, must not be null.\n @return 0 on success, -1 on failure."]
    pub fn aeron_header_values(
        header: *mut aeron_header_t,
        values: *mut aeron_header_values_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the current position to which the Image has advanced on reading this message.\n\n @param header the current header message\n @return the current position to which the Image has advanced on reading this message."]
    pub fn aeron_header_position(header: *mut aeron_header_t) -> i64;
}
extern "C" {
    #[doc = " Get the number of times to left shift the term count to multiply by term length.\n\n @return number of times to left shift the term count to multiply by term length."]
    pub fn aeron_header_position_bits_to_shift(header: *mut aeron_header_t) -> usize;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aeron_subscription_constants_stct {
    #[doc = " Media address for delivery to the channel.\n\n This returns a pointer only valid for the lifetime of the subscription."]
    pub channel: *const ::std::os::raw::c_char,
    #[doc = " Callback used to indicate when an Image becomes available under this Subscription."]
    pub on_available_image: aeron_on_available_image_t,
    #[doc = " Callback used to indicate when an Image goes unavailable under this Subscription."]
    pub on_unavailable_image: aeron_on_unavailable_image_t,
    #[doc = " Return the registration id used to register this Subscription with the media driver."]
    pub registration_id: i64,
    #[doc = " Stream identity for scoping within the channel media address."]
    pub stream_id: i32,
    #[doc = " Counter id for the channel status indicator"]
    pub channel_status_indicator_id: i32,
}
#[test]
fn bindgen_test_layout_aeron_subscription_constants_stct() {
    const UNINIT: ::std::mem::MaybeUninit<aeron_subscription_constants_stct> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_subscription_constants_stct>(),
        40usize,
        concat!("Size of: ", stringify!(aeron_subscription_constants_stct))
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_subscription_constants_stct>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(aeron_subscription_constants_stct)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).channel) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_subscription_constants_stct),
            "::",
            stringify!(channel)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).on_available_image) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_subscription_constants_stct),
            "::",
            stringify!(on_available_image)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).on_unavailable_image) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_subscription_constants_stct),
            "::",
            stringify!(on_unavailable_image)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).registration_id) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_subscription_constants_stct),
            "::",
            stringify!(registration_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stream_id) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_subscription_constants_stct),
            "::",
            stringify!(stream_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).channel_status_indicator_id) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_subscription_constants_stct),
            "::",
            stringify!(channel_status_indicator_id)
        )
    );
}
pub type aeron_subscription_constants_t = aeron_subscription_constants_stct;
extern "C" {
    #[doc = " Poll the images under the subscription for available message fragments.\n <p>\n Each fragment read will be a whole message if it is under MTU length. If larger than MTU then it will come\n as a series of fragments ordered within a session.\n <p>\n To assemble messages that span multiple fragments then use aeron_fragment_assembler_t.\n\n @param subscription to poll.\n @param handler for handling each message fragment as it is read.\n @param fragment_limit number of message fragments to limit when polling across multiple images.\n @return the number of fragments received or -1 for error."]
    pub fn aeron_subscription_poll(
        subscription: *mut aeron_subscription_t,
        handler: aeron_fragment_handler_t,
        clientd: *mut ::std::os::raw::c_void,
        fragment_limit: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Poll in a controlled manner the images under the subscription for available message fragments.\n Control is applied to fragments in the stream. If more fragments can be read on another stream\n they will even if BREAK or ABORT is returned from the fragment handler.\n <p>\n Each fragment read will be a whole message if it is under MTU length. If larger than MTU then it will come\n as a series of fragments ordered within a session.\n <p>\n To assemble messages that span multiple fragments then use aeron_controlled_fragment_assembler_t.\n\n @param subscription to poll.\n @param handler for handling each message fragment as it is read.\n @param fragment_limit number of message fragments to limit when polling across multiple images.\n @return the number of fragments received or -1 for error."]
    pub fn aeron_subscription_controlled_poll(
        subscription: *mut aeron_subscription_t,
        handler: aeron_controlled_fragment_handler_t,
        clientd: *mut ::std::os::raw::c_void,
        fragment_limit: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Poll the images under the subscription for available message fragments in blocks.\n <p>\n This method is useful for operations like bulk archiving and messaging indexing.\n\n @param subscription to poll.\n @param handler to receive a block of fragments from each image.\n @param block_length_limit for each image polled.\n @return the number of bytes consumed or -1 for error."]
    pub fn aeron_subscription_block_poll(
        subscription: *mut aeron_subscription_t,
        handler: aeron_block_handler_t,
        clientd: *mut ::std::os::raw::c_void,
        block_length_limit: usize,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    #[doc = " Is this subscription connected by having at least one open publication image.\n\n @param subscription to check.\n @return true if this subscription connected by having at least one open publication image."]
    pub fn aeron_subscription_is_connected(subscription: *mut aeron_subscription_t) -> bool;
}
extern "C" {
    #[doc = " Fill in a structure with the constants in use by a subscription.\n\n @param subscription to get the constants for.\n @param constants structure to fill in with the constants\n @return 0 for success and -1 for error."]
    pub fn aeron_subscription_constants(
        subscription: *mut aeron_subscription_t,
        constants: *mut aeron_subscription_constants_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Count of images associated to this subscription.\n\n @param subscription to count images for.\n @return count of count associated to this subscription or -1 for error."]
    pub fn aeron_subscription_image_count(
        subscription: *mut aeron_subscription_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return the image associated with the given session_id under the given subscription.\n\n Note: the returned image is considered retained by the application and thus must be released via\n aeron_image_release when finished or if the image becomes unavailable.\n\n @param subscription to search.\n @param session_id associated with the image.\n @return image associated with the given session_id or NULL if no image exists."]
    pub fn aeron_subscription_image_by_session_id(
        subscription: *mut aeron_subscription_t,
        session_id: i32,
    ) -> *mut aeron_image_t;
}
extern "C" {
    #[doc = " Return the image at the given index.\n\n Note: the returned image is considered retained by the application and thus must be released via\n aeron_image_release when finished or if the image becomes unavailable.\n\n @param subscription to search.\n @param index for the image.\n @return image at the given index or NULL if no image exists."]
    pub fn aeron_subscription_image_at_index(
        subscription: *mut aeron_subscription_t,
        index: usize,
    ) -> *mut aeron_image_t;
}
extern "C" {
    #[doc = " Iterate over the images for this subscription calling the given function.\n\n @param subscription to iterate over.\n @param handler to be called for each image."]
    pub fn aeron_subscription_for_each_image(
        subscription: *mut aeron_subscription_t,
        handler: ::std::option::Option<
            unsafe extern "C" fn(image: *mut aeron_image_t, clientd: *mut ::std::os::raw::c_void),
        >,
        clientd: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Retain the given image for access in the application.\n\n Note: A retain call must have a corresponding release call.\n Note: Subscriptions are not threadsafe and should not be shared between subscribers.\n\n @param subscription that image is part of.\n @param image to retain\n @return 0 for success and -1 for error."]
    pub fn aeron_subscription_image_retain(
        subscription: *mut aeron_subscription_t,
        image: *mut aeron_image_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Release the given image and relinquish desire to use the image directly.\n\n Note: Subscriptions are not threadsafe and should not be shared between subscribers.\n\n @param subscription that image is part of.\n @param image to release\n @return 0 for success and -1 for error."]
    pub fn aeron_subscription_image_release(
        subscription: *mut aeron_subscription_t,
        image: *mut aeron_image_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Is the subscription closed.\n\n @param subscription to be checked.\n @return true if it has been closed otherwise false."]
    pub fn aeron_subscription_is_closed(subscription: *mut aeron_subscription_t) -> bool;
}
extern "C" {
    #[doc = " Get the status of the media channel for this subscription.\n <p>\n The status will be ERRORED (-1) if a socket exception occurs on setup and ACTIVE (1) if all is well.\n\n @param subscription to check status of.\n @return 1 for ACTIVE, -1 for ERRORED"]
    pub fn aeron_subscription_channel_status(subscription: *mut aeron_subscription_t) -> i64;
}
extern "C" {
    #[doc = " Add a destination manually to a multi-destination-subscription.\n\n @param async object to use for polling completion.\n @param subscription to add destination to.\n @param uri for the destination to add.\n @return 0 for success and -1 for error."]
    pub fn aeron_subscription_async_add_destination(
        async_: *mut *mut aeron_async_destination_t,
        client: *mut aeron_t,
        subscription: *mut aeron_subscription_t,
        uri: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Remove a destination manually from a multi-destination-subscription.\n\n @param async object to use for polling completion.\n @param subscription to remove destination from.\n @param uri for the destination to remove.\n @return 0 for success and -1 for error."]
    pub fn aeron_subscription_async_remove_destination(
        async_: *mut *mut aeron_async_destination_t,
        client: *mut aeron_t,
        subscription: *mut aeron_subscription_t,
        uri: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Poll the completion of add/remove of a destination to/from a subscription.\n\n @param async to check for completion.\n @return 0 for not complete (try again), 1 for completed successfully, or -1 for an error."]
    pub fn aeron_subscription_async_destination_poll(
        async_: *mut aeron_async_destination_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Asynchronously close the subscription. Will callback on the on_complete notification when the subscription is\n closed. The callback is optional, use NULL for the on_complete callback if not required.\n\n @param subscription to close\n @param on_close_complete optional callback to execute once the subscription has been closed and freed. This may\n happen on a separate thread, so the caller should ensure that clientd has the appropriate lifetime.\n @param on_close_complete_clientd parameter to pass to the on_complete callback.\n @return 0 for success or -1 for error."]
    pub fn aeron_subscription_close(
        subscription: *mut aeron_subscription_t,
        on_close_complete: aeron_notification_t,
        on_close_complete_clientd: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get all of the local socket addresses for this subscription. Multiple addresses can occur if this is a\n multi-destination subscription. Addresses will a string representation in numeric form. IPv6 addresses will be\n surrounded by '[' and ']' so that the ':' that separate the parts are distinguishable from the port delimiter.\n E.g. [fe80::7552:c06e:6bf4:4160]:12345. As of writing the maximum length for a formatted address is 54 bytes\n including the NULL terminator. AERON_CLIENT_MAX_LOCAL_ADDRESS_STR_LEN is defined to provide enough space to fit the\n returned string. Returned strings will be NULL terminated. If the buffer to hold the address can not hold enough\n of the message it will be truncated and the last character will be null.\n\n If the address_vec_len is less the total number of addresses available then the first addresses found up to that\n length will be placed into the address_vec. However the function will return the total number of addresses available\n so if if that is larger than the input array then the client code may wish to re-query with a larger array to get\n them all.\n\n @param subscription to query\n @param address_vec to hold the received addresses\n @param address_vec_len available length of the vector to hold the addresses\n @return number of addresses found or -1 if there is an error."]
    pub fn aeron_subscription_local_sockaddrs(
        subscription: *mut aeron_subscription_t,
        address_vec: *mut aeron_iovec_t,
        address_vec_len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Retrieves the first local socket address for this subscription. If this is not MDS then it will be the one\n representing endpoint for this subscription.\n\n @see aeron_subscription_local_sockaddrs\n @param subscription to query\n @param address for the received address\n @param address_len available length for the copied address.\n @return -1 on error, 0 if address not found, 1 if address is found."]
    pub fn aeron_subscription_resolved_endpoint(
        subscription: *mut aeron_subscription_t,
        address: *const ::std::os::raw::c_char,
        address_len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Retrieves the channel URI for this subscription with any wildcard ports filled in. If the channel is not UDP or\n does not have a wildcard port (`0`), then it will return the original URI.\n\n @param subscription to query\n @param uri buffer to hold the resolved uri\n @param uri_len length of the buffer\n @return -1 on failure or the number of bytes written to the buffer (excluding the NULL terminator). Writing is done\n on a per key basis, so if the buffer was truncated before writing completed, it will only include the byte count up\n to the key that overflowed. However, the invariant that if the number returned >= uri_len, then output will have been\n truncated."]
    pub fn aeron_subscription_try_resolve_channel_endpoint_port(
        subscription: *mut aeron_subscription_t,
        uri: *mut ::std::os::raw::c_char,
        uri_len: usize,
    ) -> ::std::os::raw::c_int;
}
#[doc = " Configuration for an image that does not change during it's lifetime."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aeron_image_constants_stct {
    #[doc = " The subscription to which this image belongs."]
    pub subscription: *mut aeron_subscription_t,
    #[doc = " The source identity of the sending publisher as an abstract concept appropriate for the media."]
    pub source_identity: *const ::std::os::raw::c_char,
    #[doc = " The correlationId for identification of the image with the media driver."]
    pub correlation_id: i64,
    #[doc = " Get the position the subscriber joined this stream at."]
    pub join_position: i64,
    #[doc = " Number of bits to right shift a position to get a term count for how far the stream has progressed."]
    pub position_bits_to_shift: usize,
    #[doc = " Get the length in bytes for each term partition in the log buffer."]
    pub term_buffer_length: usize,
    #[doc = " The length in bytes of the MTU (Maximum Transmission Unit) the Sender used for the datagram."]
    pub mtu_length: usize,
    #[doc = " The sessionId for the steam of messages. Sessions are unique within a subscription and unique across\n all publications from a source identity."]
    pub session_id: i32,
    #[doc = " The initial term at which the stream started for this session."]
    pub initial_term_id: i32,
    #[doc = " Counter id that refers to the subscriber position for this image."]
    pub subscriber_position_id: i32,
}
#[test]
fn bindgen_test_layout_aeron_image_constants_stct() {
    const UNINIT: ::std::mem::MaybeUninit<aeron_image_constants_stct> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_image_constants_stct>(),
        72usize,
        concat!("Size of: ", stringify!(aeron_image_constants_stct))
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_image_constants_stct>(),
        8usize,
        concat!("Alignment of ", stringify!(aeron_image_constants_stct))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).subscription) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_image_constants_stct),
            "::",
            stringify!(subscription)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).source_identity) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_image_constants_stct),
            "::",
            stringify!(source_identity)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).correlation_id) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_image_constants_stct),
            "::",
            stringify!(correlation_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).join_position) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_image_constants_stct),
            "::",
            stringify!(join_position)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).position_bits_to_shift) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_image_constants_stct),
            "::",
            stringify!(position_bits_to_shift)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).term_buffer_length) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_image_constants_stct),
            "::",
            stringify!(term_buffer_length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mtu_length) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_image_constants_stct),
            "::",
            stringify!(mtu_length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).session_id) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_image_constants_stct),
            "::",
            stringify!(session_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).initial_term_id) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_image_constants_stct),
            "::",
            stringify!(initial_term_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).subscriber_position_id) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_image_constants_stct),
            "::",
            stringify!(subscriber_position_id)
        )
    );
}
#[doc = " Configuration for an image that does not change during it's lifetime."]
pub type aeron_image_constants_t = aeron_image_constants_stct;
extern "C" {
    #[doc = " Fill in a structure with the constants in use by a image.\n\n @param image to get the constants for.\n @param constants structure to fill in with the constants\n @return 0 for success and -1 for error."]
    pub fn aeron_image_constants(
        image: *mut aeron_image_t,
        constants: *mut aeron_image_constants_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " The position this image has been consumed to by the subscriber.\n\n @param image to query position of.\n @return the position this image has been consumed to by the subscriber."]
    pub fn aeron_image_position(image: *mut aeron_image_t) -> i64;
}
extern "C" {
    #[doc = " Set the subscriber position for this image to indicate where it has been consumed to.\n\n @param image to set the position of.\n @param new_position for the consumption point."]
    pub fn aeron_image_set_position(
        image: *mut aeron_image_t,
        position: i64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Is the current consumed position at the end of the stream?\n\n @param image to check.\n @return true if at the end of the stream or false if not."]
    pub fn aeron_image_is_end_of_stream(image: *mut aeron_image_t) -> bool;
}
extern "C" {
    #[doc = " Count of observed active transports within the image liveness timeout.\n\n If the image is closed, then this is 0. This may also be 0 if no actual datagrams have arrived. IPC\n Images also will be 0.\n\n @param image to check.\n @return count of active transports - 0 if Image is closed, no datagrams yet, or IPC. Or -1 for error."]
    pub fn aeron_image_active_transport_count(image: *mut aeron_image_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Poll for new messages in a stream. If new messages are found beyond the last consumed position then they\n will be delivered to the handler up to a limited number of fragments as specified.\n <p>\n Use a fragment assembler to assemble messages which span multiple fragments.\n\n @param image to poll.\n @param handler to which message fragments are delivered.\n @param clientd to pass to the handler.\n @param fragment_limit for the number of fragments to be consumed during one polling operation.\n @return the number of fragments that have been consumed or -1 for error."]
    pub fn aeron_image_poll(
        image: *mut aeron_image_t,
        handler: aeron_fragment_handler_t,
        clientd: *mut ::std::os::raw::c_void,
        fragment_limit: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Poll for new messages in a stream. If new messages are found beyond the last consumed position then they\n will be delivered to the handler up to a limited number of fragments as specified.\n <p>\n Use a controlled fragment assembler to assemble messages which span multiple fragments.\n\n @param image to poll.\n @param handler to which message fragments are delivered.\n @param clientd to pass to the handler.\n @param fragment_limit for the number of fragments to be consumed during one polling operation.\n @return the number of fragments that have been consumed or -1 for error."]
    pub fn aeron_image_controlled_poll(
        image: *mut aeron_image_t,
        handler: aeron_controlled_fragment_handler_t,
        clientd: *mut ::std::os::raw::c_void,
        fragment_limit: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Poll for new messages in a stream. If new messages are found beyond the last consumed position then they\n will be delivered to the handler up to a limited number of fragments as specified or the maximum position specified.\n <p>\n Use a fragment assembler to assemble messages which span multiple fragments.\n\n @param image to poll.\n @param handler to which message fragments are delivered.\n @param clientd to pass to the handler.\n @param limit_position to consume messages up to.\n @param fragment_limit for the number of fragments to be consumed during one polling operation.\n @return the number of fragments that have been consumed or -1 for error."]
    pub fn aeron_image_bounded_poll(
        image: *mut aeron_image_t,
        handler: aeron_fragment_handler_t,
        clientd: *mut ::std::os::raw::c_void,
        limit_position: i64,
        fragment_limit: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Poll for new messages in a stream. If new messages are found beyond the last consumed position then they\n will be delivered to the handler up to a limited number of fragments as specified or the maximum position specified.\n <p>\n Use a controlled fragment assembler to assemble messages which span multiple fragments.\n\n @param image to poll.\n @param handler to which message fragments are delivered.\n @param clientd to pass to the handler.\n @param limit_position to consume messages up to.\n @param fragment_limit for the number of fragments to be consumed during one polling operation.\n @return the number of fragments that have been consumed or -1 for error."]
    pub fn aeron_image_bounded_controlled_poll(
        image: *mut aeron_image_t,
        handler: aeron_controlled_fragment_handler_t,
        clientd: *mut ::std::os::raw::c_void,
        limit_position: i64,
        fragment_limit: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Peek for new messages in a stream by scanning forward from an initial position. If new messages are found then\n they will be delivered to the handler up to a limited position.\n <p>\n Use a controlled fragment assembler to assemble messages which span multiple fragments. Scans must also\n start at the beginning of a message so that the assembler is reset.\n\n @param image to peek.\n @param initial_position from which to peek forward.\n @param handler to which message fragments are delivered.\n @param clientd to pass to the handler.\n @param limit_position up to which can be scanned.\n @return the resulting position after the scan terminates which is a complete message or -1 for error."]
    pub fn aeron_image_controlled_peek(
        image: *mut aeron_image_t,
        initial_position: i64,
        handler: aeron_controlled_fragment_handler_t,
        clientd: *mut ::std::os::raw::c_void,
        limit_position: i64,
    ) -> i64;
}
extern "C" {
    #[doc = " Poll for new messages in a stream. If new messages are found beyond the last consumed position then they\n will be delivered to the handler up to a limited number of bytes.\n <p>\n A scan will terminate if a padding frame is encountered. If first frame in a scan is padding then a block\n for the padding is notified. If the padding comes after the first frame in a scan then the scan terminates\n at the offset the padding frame begins. Padding frames are delivered singularly in a block.\n <p>\n Padding frames may be for a greater range than the limit offset but only the header needs to be valid so\n relevant length of the frame is data header length.\n\n @param image to poll.\n @param handler to which block is delivered.\n @param clientd to pass to the handler.\n @param block_length_limit up to which a block may be in length.\n @return the number of bytes that have been consumed or -1 for error."]
    pub fn aeron_image_block_poll(
        image: *mut aeron_image_t,
        handler: aeron_block_handler_t,
        clientd: *mut ::std::os::raw::c_void,
        block_length_limit: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_image_is_closed(image: *mut aeron_image_t) -> bool;
}
extern "C" {
    #[doc = " Create an image fragment assembler for use with a single image.\n\n @param assembler to be set when created successfully.\n @param delegate to call on completed.\n @param delegate_clientd to pass to delegate handler.\n @return 0 for success and -1 for error."]
    pub fn aeron_image_fragment_assembler_create(
        assembler: *mut *mut aeron_image_fragment_assembler_t,
        delegate: aeron_fragment_handler_t,
        delegate_clientd: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Delete an image fragment assembler.\n\n @param assembler to delete.\n @return 0 for success or -1 for error."]
    pub fn aeron_image_fragment_assembler_delete(
        assembler: *mut aeron_image_fragment_assembler_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Handler function to be passed for handling fragment assembly.\n\n @param clientd passed in the poll call (must be a aeron_image_fragment_assembler_t)\n @param buffer containing the data.\n @param length of the data in bytes.\n @param header representing the meta data for the data."]
    pub fn aeron_image_fragment_assembler_handler(
        clientd: *mut ::std::os::raw::c_void,
        buffer: *const u8,
        length: usize,
        header: *mut aeron_header_t,
    );
}
extern "C" {
    #[doc = " Create an image controlled fragment assembler for use with a single image.\n\n @param assembler to be set when created successfully.\n @param delegate to call on completed\n @param delegate_clientd to pass to delegate handler.\n @return 0 for success and -1 for error."]
    pub fn aeron_image_controlled_fragment_assembler_create(
        assembler: *mut *mut aeron_image_controlled_fragment_assembler_t,
        delegate: aeron_controlled_fragment_handler_t,
        delegate_clientd: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Delete an image controlled fragment assembler.\n\n @param assembler to delete.\n @return 0 for success or -1 for error."]
    pub fn aeron_image_controlled_fragment_assembler_delete(
        assembler: *mut aeron_image_controlled_fragment_assembler_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Handler function to be passed for handling fragment assembly.\n\n @param clientd passed in the poll call (must be a aeron_image_controlled_fragment_assembler_t)\n @param buffer containing the data.\n @param length of the data in bytes.\n @param header representing the meta data for the data.\n @return The action to be taken with regard to the stream position after the callback."]
    pub fn aeron_controlled_image_fragment_assembler_handler(
        clientd: *mut ::std::os::raw::c_void,
        buffer: *const u8,
        length: usize,
        header: *mut aeron_header_t,
    ) -> aeron_controlled_fragment_handler_action_t;
}
extern "C" {
    #[doc = " Create a fragment assembler for use with a subscription.\n\n @param assembler to be set when created successfully.\n @param delegate to call on completed\n @param delegate_clientd to pass to delegate handler.\n @return 0 for success and -1 for error."]
    pub fn aeron_fragment_assembler_create(
        assembler: *mut *mut aeron_fragment_assembler_t,
        delegate: aeron_fragment_handler_t,
        delegate_clientd: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Delete a fragment assembler.\n\n @param assembler to delete.\n @return 0 for success or -1 for error."]
    pub fn aeron_fragment_assembler_delete(
        assembler: *mut aeron_fragment_assembler_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Handler function to be passed for handling fragment assembly.\n\n @param clientd passed in the poll call (must be a aeron_fragment_assembler_t)\n @param buffer containing the data.\n @param length of the data in bytes.\n @param header representing the meta data for the data."]
    pub fn aeron_fragment_assembler_handler(
        clientd: *mut ::std::os::raw::c_void,
        buffer: *const u8,
        length: usize,
        header: *mut aeron_header_t,
    );
}
extern "C" {
    #[doc = " Create a controlled fragment assembler for use with a subscription.\n\n @param assembler to be set when created successfully.\n @param delegate to call on completed\n @param delegate_clientd to pass to delegate handler.\n @return 0 for success and -1 for error."]
    pub fn aeron_controlled_fragment_assembler_create(
        assembler: *mut *mut aeron_controlled_fragment_assembler_t,
        delegate: aeron_controlled_fragment_handler_t,
        delegate_clientd: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Delete a controlled fragment assembler.\n\n @param assembler to delete.\n @return 0 for success or -1 for error."]
    pub fn aeron_controlled_fragment_assembler_delete(
        assembler: *mut aeron_controlled_fragment_assembler_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Handler function to be passed for handling fragment assembly.\n\n @param clientd passed in the poll call (must be a aeron_controlled_fragment_assembler_t)\n @param buffer containing the data.\n @param length of the data in bytes.\n @param header representing the meta data for the data.\n @return The action to be taken with regard to the stream position after the callback."]
    pub fn aeron_controlled_fragment_assembler_handler(
        clientd: *mut ::std::os::raw::c_void,
        buffer: *const u8,
        length: usize,
        header: *mut aeron_header_t,
    ) -> aeron_controlled_fragment_handler_action_t;
}
extern "C" {
    #[doc = " Return a pointer to the counter value.\n\n @param counter to pointer to.\n @return pointer to the counter value."]
    pub fn aeron_counter_addr(counter: *mut aeron_counter_t) -> *mut i64;
}
#[doc = " Configuration for a counter that does not change during it's lifetime."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aeron_counter_constants_stct {
    #[doc = " Return the registration id used to register this counter with the media driver."]
    pub registration_id: i64,
    #[doc = " Identity for the counter within the counters reader and counters manager."]
    pub counter_id: i32,
}
#[test]
fn bindgen_test_layout_aeron_counter_constants_stct() {
    const UNINIT: ::std::mem::MaybeUninit<aeron_counter_constants_stct> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_counter_constants_stct>(),
        16usize,
        concat!("Size of: ", stringify!(aeron_counter_constants_stct))
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_counter_constants_stct>(),
        8usize,
        concat!("Alignment of ", stringify!(aeron_counter_constants_stct))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).registration_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_counter_constants_stct),
            "::",
            stringify!(registration_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).counter_id) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_counter_constants_stct),
            "::",
            stringify!(counter_id)
        )
    );
}
#[doc = " Configuration for a counter that does not change during it's lifetime."]
pub type aeron_counter_constants_t = aeron_counter_constants_stct;
extern "C" {
    #[doc = " Fill in a structure with the constants in use by a counter.\n\n @param counter to get the constants for.\n @param constants structure to fill in with the constants.\n @return 0 for success and -1 for error."]
    pub fn aeron_counter_constants(
        counter: *mut aeron_counter_t,
        constants: *mut aeron_counter_constants_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Asynchronously close the counter.\n\n @param counter to close.\n @return 0 for success or -1 for error."]
    pub fn aeron_counter_close(
        counter: *mut aeron_counter_t,
        on_close_complete: aeron_notification_t,
        on_close_complete_clientd: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Check if the counter is closed\n @param counter to check\n @return true if closed, false otherwise."]
    pub fn aeron_counter_is_closed(counter: *mut aeron_counter_t) -> bool;
}
extern "C" {
    #[doc = " Return full version and build string.\n\n @return full version and build string."]
    pub fn aeron_version_full() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Return major version number.\n\n @return major version number."]
    pub fn aeron_version_major() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return minor version number.\n\n @return minor version number."]
    pub fn aeron_version_minor() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return patch version number.\n\n @return patch version number."]
    pub fn aeron_version_patch() -> ::std::os::raw::c_int;
}
#[doc = " Clock function used by aeron."]
pub type aeron_clock_func_t = ::std::option::Option<unsafe extern "C" fn() -> i64>;
extern "C" {
    #[doc = " Return time in nanoseconds for machine. Is not wall clock time.\n\n @return nanoseconds since epoch for machine."]
    pub fn aeron_nano_clock() -> i64;
}
extern "C" {
    #[doc = " Return time in milliseconds since epoch. Is wall clock time.\n\n @return milliseconds since epoch."]
    pub fn aeron_epoch_clock() -> i64;
}
#[doc = " Function to return logging information."]
pub type aeron_log_func_t =
    ::std::option::Option<unsafe extern "C" fn(arg1: *const ::std::os::raw::c_char)>;
extern "C" {
    #[doc = " Determine if an aeron driver is using a given aeron directory.\n\n @param dirname  for aeron directory\n @param timeout_ms  to use to determine activity for aeron directory\n @param log_func to call during activity check to log diagnostic information.\n @return true for active driver or false for no active driver."]
    pub fn aeron_is_driver_active(
        dirname: *const ::std::os::raw::c_char,
        timeout_ms: i64,
        log_func: aeron_log_func_t,
    ) -> bool;
}
extern "C" {
    #[doc = " Load properties from a string containing name=value pairs and set appropriate environment variables for the\n process so that subsequent calls to aeron_driver_context_init will use those values.\n\n @param buffer containing properties and values.\n @return 0 for success and -1 for error."]
    pub fn aeron_properties_buffer_load(
        buffer: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Load properties file and set appropriate environment variables for the process so that subsequent\n calls to aeron_driver_context_init will use those values.\n\n @param filename to load.\n @return 0 for success and -1 for error."]
    pub fn aeron_properties_file_load(
        filename: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Load properties from HTTP URL and set environment variables for the process so that subsequent\n calls to aeron_driver_context_init will use those values.\n\n @param url to attempt to retrieve and load.\n @return 0 for success and -1 for error."]
    pub fn aeron_properties_http_load(url: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Load properties based on URL or filename. If string contains file or http URL, it will attempt\n to load properties from a file or http as indicated. If not a URL, then it will try to load the string\n as a filename.\n\n @param url_or_filename to load properties from.\n @return 0 for success and -1 for error."]
    pub fn aeron_properties_load(
        url_or_filename: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return current aeron error code (errno) for calling thread.\n\n @return aeron error code for calling thread."]
    pub fn aeron_errcode() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return the current aeron error message for calling thread.\n\n @return aeron error message for calling thread."]
    pub fn aeron_errmsg() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Get the default path used by the Aeron media driver.\n\n @param path buffer to store the path.\n @param path_length space available in the buffer\n @return -1 if there is an issue or the number of bytes written to path excluding the terminator `\\0`. If this\n is equal to or greater than the path_length then the path has been truncated."]
    pub fn aeron_default_path(
        path: *mut ::std::os::raw::c_char,
        path_length: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Gets the registration id for addition of the counter. Note that using this after a call to poll the succeeds or\n errors is undefined behaviour. As the async_add_counter_t may have been freed.\n\n @param add_counter used to check for completion.\n @return registration id for the counter."]
    pub fn aeron_async_add_counter_get_registration_id(
        add_counter: *mut aeron_async_add_counter_t,
    ) -> i64;
}
extern "C" {
    #[doc = " Gets the registration id for addition of the publication. Note that using this after a call to poll the succeeds or\n errors is undefined behaviour. As the async_add_publication_t may have been freed.\n\n @param add_publication used to check for completion.\n @return registration id for the publication."]
    pub fn aeron_async_add_publication_get_registration_id(
        add_publication: *mut aeron_async_add_publication_t,
    ) -> i64;
}
extern "C" {
    #[doc = " Gets the registration id for addition of the exclusive_publication. Note that using this after a call to poll the\n succeeds or errors is undefined behaviour. As the async_add_exclusive_publication_t may have been freed.\n\n @param add_exclusive_publication used to check for completion.\n @return registration id for the exclusive_publication."]
    pub fn aeron_async_add_exclusive_exclusive_publication_get_registration_id(
        add_exclusive_publication: *mut aeron_async_add_exclusive_publication_t,
    ) -> i64;
}
extern "C" {
    #[doc = " Gets the registration id for addition of the subscription. Note that using this after a call to poll the succeeds or\n errors is undefined behaviour. As the async_add_subscription_t may have been freed.\n\n @param add_subscription used to check for completion.\n @return registration id for the subscription."]
    pub fn aeron_async_add_subscription_get_registration_id(
        add_subscription: *mut aeron_async_add_subscription_t,
    ) -> i64;
}
extern "C" {
    #[doc = " Gets the registration_id for the destination command supplied. Note that this is the correlation_id used for\n the specified destination command, not the registration_id for the original parent resource (publication,\n subscription).\n\n @param async_destination tracking the current destination command.\n @return correlation_id sent to driver."]
    pub fn aeron_async_destination_get_registration_id(
        async_destination: *mut aeron_async_destination_t,
    ) -> i64;
}
extern "C" {
    #[doc = " Request the media driver terminates operation and closes all resources.\n\n @param directory    in which the media driver is running.\n @param token_buffer containing the authentication token confirming the client is allowed to terminate the driver.\n @param token_length of the token in the buffer.\n @return"]
    pub fn aeron_context_request_driver_termination(
        directory: *const ::std::os::raw::c_char,
        token_buffer: *const u8,
        token_length: usize,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aeron_cnc_stct {
    _unused: [u8; 0],
}
pub type aeron_cnc_t = aeron_cnc_stct;
#[repr(C, packed(4))]
#[derive(Copy, Clone)]
pub struct aeron_cnc_constants_stct {
    pub cnc_version: i32,
    pub to_driver_buffer_length: i32,
    pub to_clients_buffer_length: i32,
    pub counter_metadata_buffer_length: i32,
    pub counter_values_buffer_length: i32,
    pub error_log_buffer_length: i32,
    pub client_liveness_timeout: i64,
    pub start_timestamp: i64,
    pub pid: i64,
}
#[test]
fn bindgen_test_layout_aeron_cnc_constants_stct() {
    const UNINIT: ::std::mem::MaybeUninit<aeron_cnc_constants_stct> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_cnc_constants_stct>(),
        48usize,
        concat!("Size of: ", stringify!(aeron_cnc_constants_stct))
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_cnc_constants_stct>(),
        4usize,
        concat!("Alignment of ", stringify!(aeron_cnc_constants_stct))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cnc_version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_cnc_constants_stct),
            "::",
            stringify!(cnc_version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).to_driver_buffer_length) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_cnc_constants_stct),
            "::",
            stringify!(to_driver_buffer_length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).to_clients_buffer_length) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_cnc_constants_stct),
            "::",
            stringify!(to_clients_buffer_length)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).counter_metadata_buffer_length) as usize - ptr as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_cnc_constants_stct),
            "::",
            stringify!(counter_metadata_buffer_length)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).counter_values_buffer_length) as usize - ptr as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_cnc_constants_stct),
            "::",
            stringify!(counter_values_buffer_length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).error_log_buffer_length) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_cnc_constants_stct),
            "::",
            stringify!(error_log_buffer_length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).client_liveness_timeout) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_cnc_constants_stct),
            "::",
            stringify!(client_liveness_timeout)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).start_timestamp) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_cnc_constants_stct),
            "::",
            stringify!(start_timestamp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pid) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_cnc_constants_stct),
            "::",
            stringify!(pid)
        )
    );
}
pub type aeron_cnc_constants_t = aeron_cnc_constants_stct;
extern "C" {
    #[doc = " Initialise an aeron_cnc, which gives user level access to the command and control file used to communicate\n with the media driver. Will wait until the media driver has loaded and the cnc file is created, up to timeout_ms.\n Use a value of 0 for a non-blocking initialisation.\n\n @param aeron_cnc to hold the loaded aeron_cnc\n @param base_path media driver's base path\n @param timeout_ms Number of milliseconds to wait before timing out.\n @return 0 on success, -1 on failure."]
    pub fn aeron_cnc_init(
        aeron_cnc: *mut *mut aeron_cnc_t,
        base_path: *const ::std::os::raw::c_char,
        timeout_ms: i64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Fetch the sets of constant values associated with this command and control file.\n\n @param aeron_cnc to query\n @param constants user supplied structure to hold return values.\n @return 0 on success, -1 on failure."]
    pub fn aeron_cnc_constants(
        aeron_cnc: *mut aeron_cnc_t,
        constants: *mut aeron_cnc_constants_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the current file name of the cnc file.\n\n @param aeron_cnc to query\n @return name of the cnc file"]
    pub fn aeron_cnc_filename(aeron_cnc: *mut aeron_cnc_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Gets the timestamp of the last heartbeat sent to the media driver from any client.\n\n @param aeron_cnc to query\n @return last heartbeat timestamp in ms."]
    pub fn aeron_cnc_to_driver_heartbeat(aeron_cnc: *mut aeron_cnc_t) -> i64;
}
pub type aeron_error_log_reader_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        observation_count: i32,
        first_observation_timestamp: i64,
        last_observation_timestamp: i64,
        error: *const ::std::os::raw::c_char,
        error_length: usize,
        clientd: *mut ::std::os::raw::c_void,
    ),
>;
extern "C" {
    #[doc = " Reads the current error log for this driver.\n\n @param aeron_cnc to query\n @param callback called for every distinct error observation\n @param clientd client data to be passed to the callback\n @param since_timestamp only return errors after this timestamp (0 returns all)\n @return the number of distinct errors seen"]
    pub fn aeron_cnc_error_log_read(
        aeron_cnc: *mut aeron_cnc_t,
        callback: aeron_error_log_reader_func_t,
        clientd: *mut ::std::os::raw::c_void,
        since_timestamp: i64,
    ) -> usize;
}
extern "C" {
    #[doc = " Gets a counters reader for this command and control file. This does not need to be closed manually, resources\n are tied to the instance of aeron_cnc.\n\n @param aeron_cnc to query\n @return pointer to a counters reader."]
    pub fn aeron_cnc_counters_reader(aeron_cnc: *mut aeron_cnc_t) -> *mut aeron_counters_reader_t;
}
pub type aeron_loss_reporter_read_entry_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        clientd: *mut ::std::os::raw::c_void,
        observation_count: i64,
        total_bytes_lost: i64,
        first_observation_timestamp: i64,
        last_observation_timestamp: i64,
        session_id: i32,
        stream_id: i32,
        channel: *const ::std::os::raw::c_char,
        channel_length: i32,
        source: *const ::std::os::raw::c_char,
        source_length: i32,
    ),
>;
extern "C" {
    #[doc = " Read all of the data loss observations from the report in the same media driver instances as the cnc file.\n\n @param aeron_cnc to query\n @param entry_func callback for each observation found\n @param clientd client data to be passed to the callback.\n @return -1 on failure, number of observations on success (could be 0)."]
    pub fn aeron_cnc_loss_reporter_read(
        aeron_cnc: *mut aeron_cnc_t,
        entry_func: aeron_loss_reporter_read_entry_func_t,
        clientd: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Closes the instance of the aeron cnc and frees its resources.\n\n @param aeron_cnc to close"]
    pub fn aeron_cnc_close(aeron_cnc: *mut aeron_cnc_t);
}
extern "C" {
    pub fn aeron_randomised_int32() -> i32;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aeron_clock_cache_stct {
    pub pre_pad: [u8; 56usize],
    pub cached_epoch_time: i64,
    pub cached_nano_time: i64,
    pub post_pad: [u8; 56usize],
}
#[test]
fn bindgen_test_layout_aeron_clock_cache_stct() {
    const UNINIT: ::std::mem::MaybeUninit<aeron_clock_cache_stct> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_clock_cache_stct>(),
        128usize,
        concat!("Size of: ", stringify!(aeron_clock_cache_stct))
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_clock_cache_stct>(),
        8usize,
        concat!("Alignment of ", stringify!(aeron_clock_cache_stct))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pre_pad) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_clock_cache_stct),
            "::",
            stringify!(pre_pad)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cached_epoch_time) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_clock_cache_stct),
            "::",
            stringify!(cached_epoch_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cached_nano_time) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_clock_cache_stct),
            "::",
            stringify!(cached_nano_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).post_pad) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_clock_cache_stct),
            "::",
            stringify!(post_pad)
        )
    );
}
pub type aeron_clock_cache_t = aeron_clock_cache_stct;
extern "C" {
    #[doc = " Update the cached clock with the current epoch and nano time values.\n\n @param cached_clock 'this'\n @param epoch_time current ms since epoch.\n @param nano_time current ns time."]
    pub fn aeron_clock_update_cached_time(
        cached_clock: *mut aeron_clock_cache_t,
        epoch_time: i64,
        nano_time: i64,
    );
}
extern "C" {
    #[doc = " Update the cached clock with the current epoch time value.\n\n @param cached_clock 'this'\n @param epoch_time current ms since epoch."]
    pub fn aeron_clock_update_cached_epoch_time(
        cached_clock: *mut aeron_clock_cache_t,
        epoch_time: i64,
    );
}
extern "C" {
    #[doc = " Update the cached clock with the current nano time value.\n\n @param cached_clock 'this'\n @param nano_time current ns time."]
    pub fn aeron_clock_update_cached_nano_time(
        cached_clock: *mut aeron_clock_cache_t,
        nano_time: i64,
    );
}
extern "C" {
    #[doc = " Retrieves the cached epoch time from supplied cached clock.\n\n @param cached_clock 'this'\n @return The current cached value for the epoch time."]
    pub fn aeron_clock_cached_epoch_time(cached_clock: *mut aeron_clock_cache_t) -> i64;
}
extern "C" {
    #[doc = " Retrieves the cached nano time from supplied cached clock.\n\n @param cached_clock 'this'\n @return The current cached value for the nano time."]
    pub fn aeron_clock_cached_nano_time(cached_clock: *mut aeron_clock_cache_t) -> i64;
}
extern "C" {
    #[doc = " Allocate a cached clock.\n\n @param cached_clock Pointer to the pointer to be initialised with the new cached clock\n @return -1 if allocation fails, e.g. out of memory."]
    pub fn aeron_clock_cache_alloc(
        cached_clock: *mut *mut aeron_clock_cache_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the realtime from the system in timespec format\n\n @param time value to fill with the current time\n @return 0 on success, -1 on failure."]
    pub fn aeron_clock_gettime_realtime(time: *mut timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_thread_set_name(role_name: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn aeron_nano_sleep(nanoseconds: u64);
}
extern "C" {
    pub fn aeron_micro_sleep(microseconds: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn aeron_thread_set_affinity(
        role_name: *const ::std::os::raw::c_char,
        cpu_affinity_no: u8,
    ) -> ::std::os::raw::c_int;
}
pub type aeron_mutex_t = pthread_mutex_t;
pub type aeron_thread_t = pthread_t;
#[repr(C, packed(4))]
#[derive(Copy, Clone)]
pub struct aeron_error_log_entry_stct {
    pub length: i32,
    pub observation_count: i32,
    pub last_observation_timestamp: i64,
    pub first_observation_timestamp: i64,
}
#[test]
fn bindgen_test_layout_aeron_error_log_entry_stct() {
    const UNINIT: ::std::mem::MaybeUninit<aeron_error_log_entry_stct> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_error_log_entry_stct>(),
        24usize,
        concat!("Size of: ", stringify!(aeron_error_log_entry_stct))
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_error_log_entry_stct>(),
        4usize,
        concat!("Alignment of ", stringify!(aeron_error_log_entry_stct))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_error_log_entry_stct),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).observation_count) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_error_log_entry_stct),
            "::",
            stringify!(observation_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).last_observation_timestamp) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_error_log_entry_stct),
            "::",
            stringify!(last_observation_timestamp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).first_observation_timestamp) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_error_log_entry_stct),
            "::",
            stringify!(first_observation_timestamp)
        )
    );
}
pub type aeron_error_log_entry_t = aeron_error_log_entry_stct;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aeron_distinct_observation_stct {
    pub description: *const ::std::os::raw::c_char,
    pub error_code: ::std::os::raw::c_int,
    pub offset: usize,
    pub description_length: usize,
}
#[test]
fn bindgen_test_layout_aeron_distinct_observation_stct() {
    const UNINIT: ::std::mem::MaybeUninit<aeron_distinct_observation_stct> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_distinct_observation_stct>(),
        32usize,
        concat!("Size of: ", stringify!(aeron_distinct_observation_stct))
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_distinct_observation_stct>(),
        8usize,
        concat!("Alignment of ", stringify!(aeron_distinct_observation_stct))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).description) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_distinct_observation_stct),
            "::",
            stringify!(description)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).error_code) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_distinct_observation_stct),
            "::",
            stringify!(error_code)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).offset) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_distinct_observation_stct),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).description_length) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_distinct_observation_stct),
            "::",
            stringify!(description_length)
        )
    );
}
pub type aeron_distinct_observation_t = aeron_distinct_observation_stct;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aeron_distinct_error_log_observation_list_stct {
    pub num_observations: u64,
    pub observations: *mut aeron_distinct_observation_t,
}
#[test]
fn bindgen_test_layout_aeron_distinct_error_log_observation_list_stct() {
    const UNINIT: ::std::mem::MaybeUninit<aeron_distinct_error_log_observation_list_stct> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_distinct_error_log_observation_list_stct>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(aeron_distinct_error_log_observation_list_stct)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_distinct_error_log_observation_list_stct>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(aeron_distinct_error_log_observation_list_stct)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num_observations) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_distinct_error_log_observation_list_stct),
            "::",
            stringify!(num_observations)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).observations) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_distinct_error_log_observation_list_stct),
            "::",
            stringify!(observations)
        )
    );
}
pub type aeron_distinct_error_log_observation_list_t =
    aeron_distinct_error_log_observation_list_stct;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aeron_distinct_error_log_stct {
    pub buffer: *mut u8,
    pub observation_list: *mut aeron_distinct_error_log_observation_list_t,
    pub buffer_capacity: usize,
    pub next_offset: usize,
    pub clock: aeron_clock_func_t,
    pub mutex: aeron_mutex_t,
}
#[test]
fn bindgen_test_layout_aeron_distinct_error_log_stct() {
    const UNINIT: ::std::mem::MaybeUninit<aeron_distinct_error_log_stct> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_distinct_error_log_stct>(),
        80usize,
        concat!("Size of: ", stringify!(aeron_distinct_error_log_stct))
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_distinct_error_log_stct>(),
        8usize,
        concat!("Alignment of ", stringify!(aeron_distinct_error_log_stct))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buffer) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_distinct_error_log_stct),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).observation_list) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_distinct_error_log_stct),
            "::",
            stringify!(observation_list)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buffer_capacity) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_distinct_error_log_stct),
            "::",
            stringify!(buffer_capacity)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next_offset) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_distinct_error_log_stct),
            "::",
            stringify!(next_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).clock) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_distinct_error_log_stct),
            "::",
            stringify!(clock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mutex) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_distinct_error_log_stct),
            "::",
            stringify!(mutex)
        )
    );
}
pub type aeron_distinct_error_log_t = aeron_distinct_error_log_stct;
extern "C" {
    pub fn aeron_distinct_error_log_init(
        log: *mut aeron_distinct_error_log_t,
        buffer: *mut u8,
        buffer_size: usize,
        clock: aeron_clock_func_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_distinct_error_log_close(log: *mut aeron_distinct_error_log_t);
}
extern "C" {
    pub fn aeron_distinct_error_log_record(
        log: *mut aeron_distinct_error_log_t,
        error_code: ::std::os::raw::c_int,
        description: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_error_log_exists(buffer: *const u8, buffer_size: usize) -> bool;
}
extern "C" {
    pub fn aeron_error_log_read(
        buffer: *const u8,
        buffer_size: usize,
        reader: aeron_error_log_reader_func_t,
        clientd: *mut ::std::os::raw::c_void,
        since_timestamp: i64,
    ) -> usize;
}
extern "C" {
    pub fn aeron_distinct_error_log_num_observations(log: *mut aeron_distinct_error_log_t)
        -> usize;
}
pub type aeron_idle_strategy_func_t = ::std::option::Option<
    unsafe extern "C" fn(state: *mut ::std::os::raw::c_void, work_count: ::std::os::raw::c_int),
>;
pub type aeron_idle_strategy_init_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        state: *mut *mut ::std::os::raw::c_void,
        env_var: *const ::std::os::raw::c_char,
        init_args: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn aeron_semantic_version_compose(major: u8, minor: u8, patch: u8) -> i32;
}
extern "C" {
    pub fn aeron_semantic_version_major(version: i32) -> u8;
}
extern "C" {
    pub fn aeron_semantic_version_minor(version: i32) -> u8;
}
extern "C" {
    pub fn aeron_semantic_version_patch(version: i32) -> u8;
}
pub type aeron_fptr_t = ::std::option::Option<unsafe extern "C" fn()>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aeron_uri_param_stct {
    pub key: *const ::std::os::raw::c_char,
    pub value: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_aeron_uri_param_stct() {
    const UNINIT: ::std::mem::MaybeUninit<aeron_uri_param_stct> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_uri_param_stct>(),
        16usize,
        concat!("Size of: ", stringify!(aeron_uri_param_stct))
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_uri_param_stct>(),
        8usize,
        concat!("Alignment of ", stringify!(aeron_uri_param_stct))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).key) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_uri_param_stct),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_uri_param_stct),
            "::",
            stringify!(value)
        )
    );
}
pub type aeron_uri_param_t = aeron_uri_param_stct;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aeron_uri_params_stct {
    pub length: usize,
    pub array: *mut aeron_uri_param_t,
}
#[test]
fn bindgen_test_layout_aeron_uri_params_stct() {
    const UNINIT: ::std::mem::MaybeUninit<aeron_uri_params_stct> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_uri_params_stct>(),
        16usize,
        concat!("Size of: ", stringify!(aeron_uri_params_stct))
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_uri_params_stct>(),
        8usize,
        concat!("Alignment of ", stringify!(aeron_uri_params_stct))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_uri_params_stct),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).array) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_uri_params_stct),
            "::",
            stringify!(array)
        )
    );
}
pub type aeron_uri_params_t = aeron_uri_params_stct;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aeron_udp_channel_params_stct {
    pub endpoint: *const ::std::os::raw::c_char,
    pub bind_interface: *const ::std::os::raw::c_char,
    pub control: *const ::std::os::raw::c_char,
    pub control_mode: *const ::std::os::raw::c_char,
    pub channel_tag: *const ::std::os::raw::c_char,
    pub entity_tag: *const ::std::os::raw::c_char,
    pub ttl: *const ::std::os::raw::c_char,
    pub additional_params: aeron_uri_params_t,
}
#[test]
fn bindgen_test_layout_aeron_udp_channel_params_stct() {
    const UNINIT: ::std::mem::MaybeUninit<aeron_udp_channel_params_stct> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_udp_channel_params_stct>(),
        72usize,
        concat!("Size of: ", stringify!(aeron_udp_channel_params_stct))
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_udp_channel_params_stct>(),
        8usize,
        concat!("Alignment of ", stringify!(aeron_udp_channel_params_stct))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).endpoint) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_udp_channel_params_stct),
            "::",
            stringify!(endpoint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bind_interface) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_udp_channel_params_stct),
            "::",
            stringify!(bind_interface)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).control) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_udp_channel_params_stct),
            "::",
            stringify!(control)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).control_mode) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_udp_channel_params_stct),
            "::",
            stringify!(control_mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).channel_tag) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_udp_channel_params_stct),
            "::",
            stringify!(channel_tag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).entity_tag) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_udp_channel_params_stct),
            "::",
            stringify!(entity_tag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ttl) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_udp_channel_params_stct),
            "::",
            stringify!(ttl)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).additional_params) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_udp_channel_params_stct),
            "::",
            stringify!(additional_params)
        )
    );
}
pub type aeron_udp_channel_params_t = aeron_udp_channel_params_stct;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aeron_ipc_channel_params_stct {
    pub channel_tag: *const ::std::os::raw::c_char,
    pub entity_tag: *const ::std::os::raw::c_char,
    pub additional_params: aeron_uri_params_t,
}
#[test]
fn bindgen_test_layout_aeron_ipc_channel_params_stct() {
    const UNINIT: ::std::mem::MaybeUninit<aeron_ipc_channel_params_stct> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_ipc_channel_params_stct>(),
        32usize,
        concat!("Size of: ", stringify!(aeron_ipc_channel_params_stct))
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_ipc_channel_params_stct>(),
        8usize,
        concat!("Alignment of ", stringify!(aeron_ipc_channel_params_stct))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).channel_tag) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_ipc_channel_params_stct),
            "::",
            stringify!(channel_tag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).entity_tag) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_ipc_channel_params_stct),
            "::",
            stringify!(entity_tag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).additional_params) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_ipc_channel_params_stct),
            "::",
            stringify!(additional_params)
        )
    );
}
pub type aeron_ipc_channel_params_t = aeron_ipc_channel_params_stct;
pub mod aeron_uri_type_enum {
    pub type Type = ::std::os::raw::c_uint;
    pub const AERON_URI_UDP: Type = 0;
    pub const AERON_URI_IPC: Type = 1;
    pub const AERON_URI_UNKNOWN: Type = 2;
}
pub use self::aeron_uri_type_enum::Type as aeron_uri_type_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aeron_uri_stct {
    pub mutable_uri: [::std::os::raw::c_char; 384usize],
    pub type_: aeron_uri_type_t,
    pub params: aeron_uri_stct__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union aeron_uri_stct__bindgen_ty_1 {
    pub udp: aeron_udp_channel_params_t,
    pub ipc: aeron_ipc_channel_params_t,
}
#[test]
fn bindgen_test_layout_aeron_uri_stct__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<aeron_uri_stct__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_uri_stct__bindgen_ty_1>(),
        72usize,
        concat!("Size of: ", stringify!(aeron_uri_stct__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_uri_stct__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(aeron_uri_stct__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).udp) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_uri_stct__bindgen_ty_1),
            "::",
            stringify!(udp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ipc) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_uri_stct__bindgen_ty_1),
            "::",
            stringify!(ipc)
        )
    );
}
#[test]
fn bindgen_test_layout_aeron_uri_stct() {
    const UNINIT: ::std::mem::MaybeUninit<aeron_uri_stct> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_uri_stct>(),
        464usize,
        concat!("Size of: ", stringify!(aeron_uri_stct))
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_uri_stct>(),
        8usize,
        concat!("Alignment of ", stringify!(aeron_uri_stct))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mutable_uri) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_uri_stct),
            "::",
            stringify!(mutable_uri)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        384usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_uri_stct),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).params) as usize - ptr as usize },
        392usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_uri_stct),
            "::",
            stringify!(params)
        )
    );
}
pub type aeron_uri_t = aeron_uri_stct;
pub const aeron_uri_ats_status_en_AERON_URI_ATS_STATUS_DEFAULT: aeron_uri_ats_status_en = 0;
pub const aeron_uri_ats_status_en_AERON_URI_ATS_STATUS_ENABLED: aeron_uri_ats_status_en = 1;
pub const aeron_uri_ats_status_en_AERON_URI_ATS_STATUS_DISABLED: aeron_uri_ats_status_en = 2;
pub type aeron_uri_ats_status_en = ::std::os::raw::c_uint;
pub use self::aeron_uri_ats_status_en as aeron_uri_ats_status_t;
pub type aeron_uri_parse_callback_t = ::std::option::Option<
    unsafe extern "C" fn(
        clientd: *mut ::std::os::raw::c_void,
        key: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn aeron_uri_parse_params(
        uri: *mut ::std::os::raw::c_char,
        param_func: aeron_uri_parse_callback_t,
        clientd: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_udp_uri_parse(
        uri: *mut ::std::os::raw::c_char,
        params: *mut aeron_udp_channel_params_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_ipc_uri_parse(
        uri: *mut ::std::os::raw::c_char,
        params: *mut aeron_ipc_channel_params_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_uri_parse(
        uri_length: usize,
        uri: *const ::std::os::raw::c_char,
        params: *mut aeron_uri_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_uri_close(params: *mut aeron_uri_t);
}
extern "C" {
    pub fn aeron_uri_multicast_ttl(uri: *mut aeron_uri_t) -> u8;
}
extern "C" {
    pub fn aeron_uri_find_param_value(
        uri_params: *const aeron_uri_params_t,
        key: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn aeron_uri_get_int32(
        uri_params: *mut aeron_uri_params_t,
        key: *const ::std::os::raw::c_char,
        retval: *mut i32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_uri_get_int64(
        uri_params: *mut aeron_uri_params_t,
        key: *const ::std::os::raw::c_char,
        retval: *mut i64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_uri_get_bool(
        uri_params: *mut aeron_uri_params_t,
        key: *const ::std::os::raw::c_char,
        retval: *mut bool,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_uri_get_ats(
        uri_params: *mut aeron_uri_params_t,
        uri_ats_status: *mut aeron_uri_ats_status_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_uri_sprint(
        uri: *mut aeron_uri_t,
        buffer: *mut ::std::os::raw::c_char,
        buffer_len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_uri_get_socket_buf_lengths(
        uri_params: *mut aeron_uri_params_t,
        socket_sndbuf_length: *mut usize,
        socket_rcvbuf_length: *mut usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_uri_get_receiver_window_length(
        uri_params: *mut aeron_uri_params_t,
        receiver_window_length: *mut usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_uri_parse_tag(tag_str: *const ::std::os::raw::c_char) -> i64;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aeron_driver_managed_resource_stct {
    pub registration_id: i64,
    pub time_of_last_state_change_ns: i64,
    pub clientd: *mut ::std::os::raw::c_void,
    pub decref: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    pub incref: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
}
#[test]
fn bindgen_test_layout_aeron_driver_managed_resource_stct() {
    const UNINIT: ::std::mem::MaybeUninit<aeron_driver_managed_resource_stct> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_driver_managed_resource_stct>(),
        40usize,
        concat!("Size of: ", stringify!(aeron_driver_managed_resource_stct))
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_driver_managed_resource_stct>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(aeron_driver_managed_resource_stct)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).registration_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_managed_resource_stct),
            "::",
            stringify!(registration_id)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).time_of_last_state_change_ns) as usize - ptr as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_managed_resource_stct),
            "::",
            stringify!(time_of_last_state_change_ns)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).clientd) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_managed_resource_stct),
            "::",
            stringify!(clientd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).decref) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_managed_resource_stct),
            "::",
            stringify!(decref)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).incref) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_managed_resource_stct),
            "::",
            stringify!(incref)
        )
    );
}
pub type aeron_driver_managed_resource_t = aeron_driver_managed_resource_stct;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aeron_position_stct {
    pub counter_id: i32,
    pub value_addr: *mut i64,
}
#[test]
fn bindgen_test_layout_aeron_position_stct() {
    const UNINIT: ::std::mem::MaybeUninit<aeron_position_stct> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_position_stct>(),
        16usize,
        concat!("Size of: ", stringify!(aeron_position_stct))
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_position_stct>(),
        8usize,
        concat!("Alignment of ", stringify!(aeron_position_stct))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).counter_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_position_stct),
            "::",
            stringify!(counter_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value_addr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_position_stct),
            "::",
            stringify!(value_addr)
        )
    );
}
pub type aeron_position_t = aeron_position_stct;
pub type aeron_atomic_counter_t = aeron_position_stct;
pub mod aeron_subscription_tether_state_enum {
    pub type Type = ::std::os::raw::c_uint;
    pub const AERON_SUBSCRIPTION_TETHER_ACTIVE: Type = 0;
    pub const AERON_SUBSCRIPTION_TETHER_LINGER: Type = 1;
    pub const AERON_SUBSCRIPTION_TETHER_RESTING: Type = 2;
}
pub use self::aeron_subscription_tether_state_enum::Type as aeron_subscription_tether_state_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aeron_tetherable_position_stct {
    pub is_tether: bool,
    pub state: aeron_subscription_tether_state_t,
    pub counter_id: i32,
    pub value_addr: *mut i64,
    pub subscription_registration_id: i64,
    pub time_of_last_update_ns: i64,
}
#[test]
fn bindgen_test_layout_aeron_tetherable_position_stct() {
    const UNINIT: ::std::mem::MaybeUninit<aeron_tetherable_position_stct> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_tetherable_position_stct>(),
        40usize,
        concat!("Size of: ", stringify!(aeron_tetherable_position_stct))
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_tetherable_position_stct>(),
        8usize,
        concat!("Alignment of ", stringify!(aeron_tetherable_position_stct))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).is_tether) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_tetherable_position_stct),
            "::",
            stringify!(is_tether)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_tetherable_position_stct),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).counter_id) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_tetherable_position_stct),
            "::",
            stringify!(counter_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value_addr) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_tetherable_position_stct),
            "::",
            stringify!(value_addr)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).subscription_registration_id) as usize - ptr as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_tetherable_position_stct),
            "::",
            stringify!(subscription_registration_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).time_of_last_update_ns) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_tetherable_position_stct),
            "::",
            stringify!(time_of_last_update_ns)
        )
    );
}
pub type aeron_tetherable_position_t = aeron_tetherable_position_stct;
pub type aeron_untethered_subscription_state_change_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        tetherable_position: *mut aeron_tetherable_position_t,
        now_ns: i64,
        new_state: aeron_subscription_tether_state_t,
        stream_id: i32,
        session_id: i32,
    ),
>;
extern "C" {
    pub fn aeron_untethered_subscription_state_change(
        tetherable_position: *mut aeron_tetherable_position_t,
        now_ns: i64,
        new_state: aeron_subscription_tether_state_t,
        stream_id: i32,
        session_id: i32,
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aeron_subscribable_stct {
    pub correlation_id: i64,
    pub length: usize,
    pub capacity: usize,
    pub array: *mut aeron_tetherable_position_t,
    pub add_position_hook_func: ::std::option::Option<
        unsafe extern "C" fn(clientd: *mut ::std::os::raw::c_void, value_addr: *mut i64),
    >,
    pub remove_position_hook_func: ::std::option::Option<
        unsafe extern "C" fn(clientd: *mut ::std::os::raw::c_void, value_addr: *mut i64),
    >,
    pub clientd: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_aeron_subscribable_stct() {
    const UNINIT: ::std::mem::MaybeUninit<aeron_subscribable_stct> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_subscribable_stct>(),
        56usize,
        concat!("Size of: ", stringify!(aeron_subscribable_stct))
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_subscribable_stct>(),
        8usize,
        concat!("Alignment of ", stringify!(aeron_subscribable_stct))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).correlation_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_subscribable_stct),
            "::",
            stringify!(correlation_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_subscribable_stct),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).capacity) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_subscribable_stct),
            "::",
            stringify!(capacity)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).array) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_subscribable_stct),
            "::",
            stringify!(array)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).add_position_hook_func) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_subscribable_stct),
            "::",
            stringify!(add_position_hook_func)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).remove_position_hook_func) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_subscribable_stct),
            "::",
            stringify!(remove_position_hook_func)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).clientd) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_subscribable_stct),
            "::",
            stringify!(clientd)
        )
    );
}
pub type aeron_subscribable_t = aeron_subscribable_stct;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aeron_command_base_stct {
    pub func: ::std::option::Option<
        unsafe extern "C" fn(
            clientd: *mut ::std::os::raw::c_void,
            command: *mut ::std::os::raw::c_void,
        ),
    >,
    pub item: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_aeron_command_base_stct() {
    const UNINIT: ::std::mem::MaybeUninit<aeron_command_base_stct> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_command_base_stct>(),
        16usize,
        concat!("Size of: ", stringify!(aeron_command_base_stct))
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_command_base_stct>(),
        8usize,
        concat!("Alignment of ", stringify!(aeron_command_base_stct))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).func) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_command_base_stct),
            "::",
            stringify!(func)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).item) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_command_base_stct),
            "::",
            stringify!(item)
        )
    );
}
pub type aeron_command_base_t = aeron_command_base_stct;
pub type aeron_feedback_delay_generator_state_t = aeron_feedback_delay_generator_state_stct;
pub type aeron_feedback_delay_generator_func_t = ::std::option::Option<
    unsafe extern "C" fn(state: *mut aeron_feedback_delay_generator_state_t) -> i64,
>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aeron_feedback_delay_generator_state_stct {
    pub static_delay: aeron_feedback_delay_generator_state_stct_static_delay_stct,
    pub optimal_delay: aeron_feedback_delay_generator_state_stct_optimal_delay_stct,
    pub should_immediate_feedback: bool,
    pub delay_generator: aeron_feedback_delay_generator_func_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aeron_feedback_delay_generator_state_stct_static_delay_stct {
    pub delay_ns: i64,
}
#[test]
fn bindgen_test_layout_aeron_feedback_delay_generator_state_stct_static_delay_stct() {
    const UNINIT: ::std::mem::MaybeUninit<
        aeron_feedback_delay_generator_state_stct_static_delay_stct,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_feedback_delay_generator_state_stct_static_delay_stct>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(aeron_feedback_delay_generator_state_stct_static_delay_stct)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_feedback_delay_generator_state_stct_static_delay_stct>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(aeron_feedback_delay_generator_state_stct_static_delay_stct)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).delay_ns) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_feedback_delay_generator_state_stct_static_delay_stct),
            "::",
            stringify!(delay_ns)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aeron_feedback_delay_generator_state_stct_optimal_delay_stct {
    pub rand_max: f64,
    pub base_x: f64,
    pub constant_t: f64,
    pub factor_t: f64,
}
#[test]
fn bindgen_test_layout_aeron_feedback_delay_generator_state_stct_optimal_delay_stct() {
    const UNINIT: ::std::mem::MaybeUninit<
        aeron_feedback_delay_generator_state_stct_optimal_delay_stct,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_feedback_delay_generator_state_stct_optimal_delay_stct>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(aeron_feedback_delay_generator_state_stct_optimal_delay_stct)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_feedback_delay_generator_state_stct_optimal_delay_stct>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(aeron_feedback_delay_generator_state_stct_optimal_delay_stct)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rand_max) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_feedback_delay_generator_state_stct_optimal_delay_stct),
            "::",
            stringify!(rand_max)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).base_x) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_feedback_delay_generator_state_stct_optimal_delay_stct),
            "::",
            stringify!(base_x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).constant_t) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_feedback_delay_generator_state_stct_optimal_delay_stct),
            "::",
            stringify!(constant_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).factor_t) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_feedback_delay_generator_state_stct_optimal_delay_stct),
            "::",
            stringify!(factor_t)
        )
    );
}
#[test]
fn bindgen_test_layout_aeron_feedback_delay_generator_state_stct() {
    const UNINIT: ::std::mem::MaybeUninit<aeron_feedback_delay_generator_state_stct> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_feedback_delay_generator_state_stct>(),
        56usize,
        concat!(
            "Size of: ",
            stringify!(aeron_feedback_delay_generator_state_stct)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_feedback_delay_generator_state_stct>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(aeron_feedback_delay_generator_state_stct)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).static_delay) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_feedback_delay_generator_state_stct),
            "::",
            stringify!(static_delay)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).optimal_delay) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_feedback_delay_generator_state_stct),
            "::",
            stringify!(optimal_delay)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).should_immediate_feedback) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_feedback_delay_generator_state_stct),
            "::",
            stringify!(should_immediate_feedback)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).delay_generator) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_feedback_delay_generator_state_stct),
            "::",
            stringify!(delay_generator)
        )
    );
}
extern "C" {
    pub fn aeron_driver_subscribable_remove_position(
        subscribable: *mut aeron_subscribable_t,
        counter_id: i32,
    );
}
pub type aeron_on_remove_publication_cleanup_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        session_id: i32,
        stream_id: i32,
        channel_length: usize,
        channel: *const ::std::os::raw::c_char,
    ),
>;
pub type aeron_on_remove_subscription_cleanup_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        id: i64,
        stream_id: i32,
        channel_length: usize,
        channel: *const ::std::os::raw::c_char,
    ),
>;
pub type aeron_on_remove_image_cleanup_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        id: i64,
        session_id: i32,
        stream_id: i32,
        channel_length: usize,
        channel: *const ::std::os::raw::c_char,
    ),
>;
pub type aeron_on_endpoint_change_func_t =
    ::std::option::Option<unsafe extern "C" fn(channel: *const ::std::os::raw::c_void)>;
pub type aeron_driver_context_t = aeron_driver_context_stct;
pub type aeron_driver_t = aeron_driver_stct;
extern "C" {
    pub fn aeron_driver_context_set_dir(
        context: *mut aeron_driver_context_t,
        value: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_driver_context_get_dir(
        context: *mut aeron_driver_context_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn aeron_driver_context_set_dir_warn_if_exists(
        context: *mut aeron_driver_context_t,
        value: bool,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_driver_context_get_dir_warn_if_exists(
        context: *mut aeron_driver_context_t,
    ) -> bool;
}
pub mod aeron_threading_mode_enum {
    pub type Type = ::std::os::raw::c_uint;
    pub const AERON_THREADING_MODE_DEDICATED: Type = 0;
    pub const AERON_THREADING_MODE_SHARED_NETWORK: Type = 1;
    pub const AERON_THREADING_MODE_SHARED: Type = 2;
    pub const AERON_THREADING_MODE_INVOKER: Type = 3;
}
pub use self::aeron_threading_mode_enum::Type as aeron_threading_mode_t;
extern "C" {
    pub fn aeron_driver_context_set_threading_mode(
        context: *mut aeron_driver_context_t,
        mode: aeron_threading_mode_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_driver_context_get_threading_mode(
        context: *mut aeron_driver_context_t,
    ) -> aeron_threading_mode_t;
}
extern "C" {
    pub fn aeron_driver_context_set_dir_delete_on_start(
        context: *mut aeron_driver_context_t,
        value: bool,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_driver_context_get_dir_delete_on_start(
        context: *mut aeron_driver_context_t,
    ) -> bool;
}
extern "C" {
    pub fn aeron_driver_context_set_dir_delete_on_shutdown(
        context: *mut aeron_driver_context_t,
        value: bool,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_driver_context_get_dir_delete_on_shutdown(
        context: *mut aeron_driver_context_t,
    ) -> bool;
}
extern "C" {
    pub fn aeron_driver_context_set_to_conductor_buffer_length(
        context: *mut aeron_driver_context_t,
        length: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_driver_context_get_to_conductor_buffer_length(
        context: *mut aeron_driver_context_t,
    ) -> usize;
}
extern "C" {
    pub fn aeron_driver_context_set_to_clients_buffer_length(
        context: *mut aeron_driver_context_t,
        length: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_driver_context_get_to_clients_buffer_length(
        context: *mut aeron_driver_context_t,
    ) -> usize;
}
extern "C" {
    pub fn aeron_driver_context_set_counters_buffer_length(
        context: *mut aeron_driver_context_t,
        length: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_driver_context_get_counters_buffer_length(
        context: *mut aeron_driver_context_t,
    ) -> usize;
}
extern "C" {
    pub fn aeron_driver_context_set_error_buffer_length(
        context: *mut aeron_driver_context_t,
        length: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_driver_context_get_error_buffer_length(
        context: *mut aeron_driver_context_t,
    ) -> usize;
}
extern "C" {
    pub fn aeron_driver_context_set_client_liveness_timeout_ns(
        context: *mut aeron_driver_context_t,
        value: u64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_driver_context_get_client_liveness_timeout_ns(
        context: *mut aeron_driver_context_t,
    ) -> u64;
}
extern "C" {
    pub fn aeron_driver_context_set_term_buffer_length(
        context: *mut aeron_driver_context_t,
        value: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_driver_context_get_term_buffer_length(
        context: *mut aeron_driver_context_t,
    ) -> usize;
}
extern "C" {
    pub fn aeron_driver_context_set_ipc_term_buffer_length(
        context: *mut aeron_driver_context_t,
        value: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_driver_context_get_ipc_term_buffer_length(
        context: *mut aeron_driver_context_t,
    ) -> usize;
}
extern "C" {
    pub fn aeron_driver_context_set_term_buffer_sparse_file(
        context: *mut aeron_driver_context_t,
        value: bool,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_driver_context_get_term_buffer_sparse_file(
        context: *mut aeron_driver_context_t,
    ) -> bool;
}
extern "C" {
    pub fn aeron_driver_context_set_perform_storage_checks(
        context: *mut aeron_driver_context_t,
        value: bool,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_driver_context_get_perform_storage_checks(
        context: *mut aeron_driver_context_t,
    ) -> bool;
}
extern "C" {
    pub fn aeron_driver_context_set_spies_simulate_connection(
        context: *mut aeron_driver_context_t,
        value: bool,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_driver_context_get_spies_simulate_connection(
        context: *mut aeron_driver_context_t,
    ) -> bool;
}
extern "C" {
    pub fn aeron_driver_context_set_file_page_size(
        context: *mut aeron_driver_context_t,
        value: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_driver_context_get_file_page_size(context: *mut aeron_driver_context_t) -> usize;
}
extern "C" {
    pub fn aeron_driver_context_set_mtu_length(
        context: *mut aeron_driver_context_t,
        value: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_driver_context_get_mtu_length(context: *mut aeron_driver_context_t) -> usize;
}
extern "C" {
    pub fn aeron_driver_context_set_ipc_mtu_length(
        context: *mut aeron_driver_context_t,
        value: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_driver_context_get_ipc_mtu_length(context: *mut aeron_driver_context_t) -> usize;
}
extern "C" {
    pub fn aeron_driver_context_set_ipc_publication_term_window_length(
        context: *mut aeron_driver_context_t,
        value: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_driver_context_get_ipc_publication_term_window_length(
        context: *mut aeron_driver_context_t,
    ) -> usize;
}
extern "C" {
    pub fn aeron_driver_context_set_publication_term_window_length(
        context: *mut aeron_driver_context_t,
        value: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_driver_context_get_publication_term_window_length(
        context: *mut aeron_driver_context_t,
    ) -> usize;
}
extern "C" {
    pub fn aeron_driver_context_set_publication_linger_timeout_ns(
        context: *mut aeron_driver_context_t,
        value: u64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_driver_context_get_publication_linger_timeout_ns(
        context: *mut aeron_driver_context_t,
    ) -> u64;
}
extern "C" {
    pub fn aeron_driver_context_set_socket_so_rcvbuf(
        context: *mut aeron_driver_context_t,
        value: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_driver_context_get_socket_so_rcvbuf(context: *mut aeron_driver_context_t)
        -> usize;
}
extern "C" {
    pub fn aeron_driver_context_set_socket_so_sndbuf(
        context: *mut aeron_driver_context_t,
        value: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_driver_context_get_socket_so_sndbuf(context: *mut aeron_driver_context_t)
        -> usize;
}
extern "C" {
    pub fn aeron_driver_context_set_socket_multicast_ttl(
        context: *mut aeron_driver_context_t,
        value: u8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_driver_context_get_socket_multicast_ttl(
        context: *mut aeron_driver_context_t,
    ) -> u8;
}
extern "C" {
    pub fn aeron_driver_context_set_send_to_status_poll_ratio(
        context: *mut aeron_driver_context_t,
        value: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_driver_context_get_send_to_status_poll_ratio(
        context: *mut aeron_driver_context_t,
    ) -> usize;
}
extern "C" {
    pub fn aeron_driver_context_set_rcv_status_message_timeout_ns(
        context: *mut aeron_driver_context_t,
        value: u64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_driver_context_get_rcv_status_message_timeout_ns(
        context: *mut aeron_driver_context_t,
    ) -> u64;
}
pub type aeron_flow_control_strategy_t = aeron_flow_control_strategy_stct;
pub type aeron_counters_manager_t = aeron_counters_manager_stct;
pub type aeron_udp_channel_t = aeron_udp_channel_stct;
pub type aeron_flow_control_strategy_supplier_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        strategy: *mut *mut aeron_flow_control_strategy_t,
        context: *mut aeron_driver_context_t,
        counters_manager: *mut aeron_counters_manager_t,
        channel: *const aeron_udp_channel_t,
        stream_id: i32,
        session_id: i32,
        registration_id: i64,
        initial_term_id: i32,
        term_length: usize,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    #[doc = " Return a flow control strategy supplier function pointer associated with the given name. This only will find\n strategies built into the driver and will not try to dynamically load nor find any in the current executable.\n\n @param name of the strategy\n @return function pointer to supplier associated with the name"]
    pub fn aeron_flow_control_strategy_supplier_by_name(
        name: *const ::std::os::raw::c_char,
    ) -> aeron_flow_control_strategy_supplier_func_t;
}
extern "C" {
    pub fn aeron_driver_context_set_multicast_flowcontrol_supplier(
        context: *mut aeron_driver_context_t,
        value: aeron_flow_control_strategy_supplier_func_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_driver_context_get_multicast_flowcontrol_supplier(
        context: *mut aeron_driver_context_t,
    ) -> aeron_flow_control_strategy_supplier_func_t;
}
extern "C" {
    pub fn aeron_driver_context_set_unicast_flowcontrol_supplier(
        context: *mut aeron_driver_context_t,
        value: aeron_flow_control_strategy_supplier_func_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_driver_context_get_unicast_flowcontrol_supplier(
        context: *mut aeron_driver_context_t,
    ) -> aeron_flow_control_strategy_supplier_func_t;
}
extern "C" {
    pub fn aeron_driver_context_set_image_liveness_timeout_ns(
        context: *mut aeron_driver_context_t,
        value: u64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_driver_context_get_image_liveness_timeout_ns(
        context: *mut aeron_driver_context_t,
    ) -> u64;
}
extern "C" {
    pub fn aeron_driver_context_set_rcv_initial_window_length(
        context: *mut aeron_driver_context_t,
        value: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_driver_context_get_rcv_initial_window_length(
        context: *mut aeron_driver_context_t,
    ) -> usize;
}
pub type aeron_congestion_control_strategy_t = aeron_congestion_control_strategy_stct;
pub type aeron_congestion_control_strategy_supplier_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        strategy: *mut *mut aeron_congestion_control_strategy_t,
        channel: *mut aeron_udp_channel_t,
        stream_id: i32,
        session_id: i32,
        registration_id: i64,
        term_length: i32,
        sender_mtu_length: i32,
        control_address: *mut sockaddr_storage,
        src_address: *mut sockaddr_storage,
        context: *mut aeron_driver_context_t,
        counters_manager: *mut aeron_counters_manager_t,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn aeron_driver_context_set_congestioncontrol_supplier(
        context: *mut aeron_driver_context_t,
        value: aeron_congestion_control_strategy_supplier_func_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_driver_context_get_congestioncontrol_supplier(
        context: *mut aeron_driver_context_t,
    ) -> aeron_congestion_control_strategy_supplier_func_t;
}
extern "C" {
    pub fn aeron_driver_context_set_loss_report_buffer_length(
        context: *mut aeron_driver_context_t,
        value: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_driver_context_get_loss_report_buffer_length(
        context: *mut aeron_driver_context_t,
    ) -> usize;
}
extern "C" {
    pub fn aeron_driver_context_set_publication_unblock_timeout_ns(
        context: *mut aeron_driver_context_t,
        value: u64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_driver_context_get_publication_unblock_timeout_ns(
        context: *mut aeron_driver_context_t,
    ) -> u64;
}
extern "C" {
    pub fn aeron_driver_context_set_publication_connection_timeout_ns(
        context: *mut aeron_driver_context_t,
        value: u64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_driver_context_get_publication_connection_timeout_ns(
        context: *mut aeron_driver_context_t,
    ) -> u64;
}
extern "C" {
    pub fn aeron_driver_context_set_timer_interval_ns(
        context: *mut aeron_driver_context_t,
        value: u64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_driver_context_get_timer_interval_ns(context: *mut aeron_driver_context_t) -> u64;
}
extern "C" {
    pub fn aeron_driver_context_set_sender_idle_strategy(
        context: *mut aeron_driver_context_t,
        value: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_driver_context_get_sender_idle_strategy(
        context: *mut aeron_driver_context_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn aeron_driver_context_set_conductor_idle_strategy(
        context: *mut aeron_driver_context_t,
        value: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_driver_context_get_conductor_idle_strategy(
        context: *mut aeron_driver_context_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn aeron_driver_context_set_receiver_idle_strategy(
        context: *mut aeron_driver_context_t,
        value: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_driver_context_get_receiver_idle_strategy(
        context: *mut aeron_driver_context_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn aeron_driver_context_set_sharednetwork_idle_strategy(
        context: *mut aeron_driver_context_t,
        value: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_driver_context_get_sharednetwork_idle_strategy(
        context: *mut aeron_driver_context_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn aeron_driver_context_set_shared_idle_strategy(
        context: *mut aeron_driver_context_t,
        value: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_driver_context_get_shared_idle_strategy(
        context: *mut aeron_driver_context_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn aeron_driver_context_set_sender_idle_strategy_init_args(
        context: *mut aeron_driver_context_t,
        value: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_driver_context_get_sender_idle_strategy_init_args(
        context: *mut aeron_driver_context_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn aeron_driver_context_set_conductor_idle_strategy_init_args(
        context: *mut aeron_driver_context_t,
        value: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_driver_context_get_conductor_idle_strategy_init_args(
        context: *mut aeron_driver_context_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn aeron_driver_context_set_receiver_idle_strategy_init_args(
        context: *mut aeron_driver_context_t,
        value: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_driver_context_get_receiver_idle_strategy_init_args(
        context: *mut aeron_driver_context_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn aeron_driver_context_set_sharednetwork_idle_strategy_init_args(
        context: *mut aeron_driver_context_t,
        value: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_driver_context_get_sharednetwork_idle_strategy_init_args(
        context: *mut aeron_driver_context_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn aeron_driver_context_set_shared_idle_strategy_init_args(
        context: *mut aeron_driver_context_t,
        value: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_driver_context_get_shared_idle_strategy_init_args(
        context: *mut aeron_driver_context_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn aeron_driver_context_set_agent_on_start_function(
        context: *mut aeron_driver_context_t,
        value: aeron_agent_on_start_func_t,
        state: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_driver_context_get_agent_on_start_function(
        context: *mut aeron_driver_context_t,
    ) -> aeron_agent_on_start_func_t;
}
extern "C" {
    pub fn aeron_driver_context_get_agent_on_start_state(
        context: *mut aeron_driver_context_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn aeron_driver_context_set_counters_free_to_reuse_timeout_ns(
        context: *mut aeron_driver_context_t,
        value: u64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_driver_context_get_counters_free_to_reuse_timeout_ns(
        context: *mut aeron_driver_context_t,
    ) -> u64;
}
extern "C" {
    pub fn aeron_driver_context_set_flow_control_receiver_timeout_ns(
        context: *mut aeron_driver_context_t,
        value: u64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_driver_context_get_flow_control_receiver_timeout_ns(
        context: *mut aeron_driver_context_t,
    ) -> u64;
}
extern "C" {
    pub fn aeron_driver_context_set_flow_control_group_tag(
        context: *mut aeron_driver_context_t,
        value: i64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_driver_context_get_flow_control_group_tag(
        context: *mut aeron_driver_context_t,
    ) -> i64;
}
extern "C" {
    pub fn aeron_driver_context_set_flow_control_group_min_size(
        context: *mut aeron_driver_context_t,
        value: i32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_driver_context_get_flow_control_group_min_size(
        context: *mut aeron_driver_context_t,
    ) -> i32;
}
extern "C" {
    pub fn aeron_driver_context_set_receiver_group_tag(
        context: *mut aeron_driver_context_t,
        is_present: bool,
        value: i64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_driver_context_get_receiver_group_tag_is_present(
        context: *mut aeron_driver_context_t,
    ) -> bool;
}
extern "C" {
    pub fn aeron_driver_context_get_receiver_group_tag_value(
        context: *mut aeron_driver_context_t,
    ) -> i64;
}
pub type aeron_driver_termination_validator_func_t = ::std::option::Option<
    unsafe extern "C" fn(state: *mut ::std::os::raw::c_void, buffer: *mut u8, length: i32) -> bool,
>;
extern "C" {
    pub fn aeron_driver_context_set_driver_termination_validator(
        context: *mut aeron_driver_context_t,
        value: aeron_driver_termination_validator_func_t,
        state: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_driver_context_get_driver_termination_validator(
        context: *mut aeron_driver_context_t,
    ) -> aeron_driver_termination_validator_func_t;
}
extern "C" {
    pub fn aeron_driver_context_get_driver_termination_validator_state(
        context: *mut aeron_driver_context_t,
    ) -> *mut ::std::os::raw::c_void;
}
pub type aeron_driver_termination_hook_func_t =
    ::std::option::Option<unsafe extern "C" fn(clientd: *mut ::std::os::raw::c_void)>;
extern "C" {
    pub fn aeron_driver_context_set_driver_termination_hook(
        context: *mut aeron_driver_context_t,
        value: aeron_driver_termination_hook_func_t,
        state: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_driver_context_get_driver_termination_hook(
        context: *mut aeron_driver_context_t,
    ) -> aeron_driver_termination_hook_func_t;
}
extern "C" {
    pub fn aeron_driver_context_get_driver_termination_hook_state(
        context: *mut aeron_driver_context_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn aeron_driver_context_set_print_configuration(
        context: *mut aeron_driver_context_t,
        value: bool,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_driver_context_get_print_configuration(
        context: *mut aeron_driver_context_t,
    ) -> bool;
}
extern "C" {
    pub fn aeron_driver_context_set_reliable_stream(
        context: *mut aeron_driver_context_t,
        value: bool,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_driver_context_get_reliable_stream(context: *mut aeron_driver_context_t) -> bool;
}
extern "C" {
    pub fn aeron_driver_context_set_tether_subscriptions(
        context: *mut aeron_driver_context_t,
        value: bool,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_driver_context_get_tether_subscriptions(
        context: *mut aeron_driver_context_t,
    ) -> bool;
}
extern "C" {
    pub fn aeron_driver_context_set_untethered_window_limit_timeout_ns(
        context: *mut aeron_driver_context_t,
        value: u64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_driver_context_get_untethered_window_limit_timeout_ns(
        context: *mut aeron_driver_context_t,
    ) -> u64;
}
extern "C" {
    pub fn aeron_driver_context_set_untethered_resting_timeout_ns(
        context: *mut aeron_driver_context_t,
        value: u64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_driver_context_get_untethered_resting_timeout_ns(
        context: *mut aeron_driver_context_t,
    ) -> u64;
}
extern "C" {
    pub fn aeron_driver_context_set_driver_timeout_ms(
        context: *mut aeron_driver_context_t,
        value: u64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_driver_context_get_driver_timeout_ms(context: *mut aeron_driver_context_t) -> u64;
}
extern "C" {
    pub fn aeron_driver_context_set_nak_multicast_group_size(
        context: *mut aeron_driver_context_t,
        value: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_driver_context_get_nak_multicast_group_size(
        context: *mut aeron_driver_context_t,
    ) -> usize;
}
extern "C" {
    pub fn aeron_driver_context_set_nak_multicast_max_backoff_ns(
        context: *mut aeron_driver_context_t,
        value: u64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_driver_context_get_nak_multicast_max_backoff_ns(
        context: *mut aeron_driver_context_t,
    ) -> u64;
}
extern "C" {
    pub fn aeron_driver_context_set_nak_unicast_delay_ns(
        context: *mut aeron_driver_context_t,
        value: u64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_driver_context_get_nak_unicast_delay_ns(
        context: *mut aeron_driver_context_t,
    ) -> u64;
}
extern "C" {
    pub fn aeron_driver_context_set_retransmit_unicast_delay_ns(
        context: *mut aeron_driver_context_t,
        value: u64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_driver_context_get_retransmit_unicast_delay_ns(
        context: *mut aeron_driver_context_t,
    ) -> u64;
}
extern "C" {
    pub fn aeron_driver_context_set_retransmit_unicast_linger_ns(
        context: *mut aeron_driver_context_t,
        value: u64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_driver_context_get_retransmit_unicast_linger_ns(
        context: *mut aeron_driver_context_t,
    ) -> u64;
}
pub mod aeron_inferable_boolean_enum {
    pub type Type = ::std::os::raw::c_uint;
    pub const AERON_FORCE_FALSE: Type = 0;
    pub const AERON_FORCE_TRUE: Type = 1;
    pub const AERON_INFER: Type = 2;
}
pub use self::aeron_inferable_boolean_enum::Type as aeron_inferable_boolean_t;
extern "C" {
    pub fn aeron_driver_context_set_receiver_group_consideration(
        context: *mut aeron_driver_context_t,
        value: aeron_inferable_boolean_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_driver_context_get_receiver_group_consideration(
        context: *mut aeron_driver_context_t,
    ) -> aeron_inferable_boolean_t;
}
extern "C" {
    pub fn aeron_driver_context_set_rejoin_stream(
        context: *mut aeron_driver_context_t,
        value: bool,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_driver_context_get_rejoin_stream(context: *mut aeron_driver_context_t) -> bool;
}
extern "C" {
    pub fn aeron_driver_context_set_connect_enabled(
        context: *mut aeron_driver_context_t,
        value: bool,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_driver_context_get_connect_enabled(
        context: *mut aeron_driver_context_t,
    ) -> ::std::os::raw::c_int;
}
pub type aeron_udp_channel_transport_bindings_t = aeron_udp_channel_transport_bindings_stct;
extern "C" {
    pub fn aeron_driver_context_set_udp_channel_transport_bindings(
        context: *mut aeron_driver_context_t,
        value: *mut aeron_udp_channel_transport_bindings_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_driver_context_get_udp_channel_transport_bindings(
        context: *mut aeron_driver_context_t,
    ) -> *mut aeron_udp_channel_transport_bindings_t;
}
pub type aeron_udp_channel_interceptor_bindings_t = aeron_udp_channel_interceptor_bindings_stct;
extern "C" {
    pub fn aeron_driver_context_set_udp_channel_outgoing_interceptors(
        context: *mut aeron_driver_context_t,
        value: *mut aeron_udp_channel_interceptor_bindings_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_driver_context_get_udp_channel_outgoing_interceptors(
        context: *mut aeron_driver_context_t,
    ) -> *mut aeron_udp_channel_interceptor_bindings_t;
}
extern "C" {
    pub fn aeron_driver_context_set_udp_channel_incoming_interceptors(
        context: *mut aeron_driver_context_t,
        value: *mut aeron_udp_channel_interceptor_bindings_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_driver_context_get_udp_channel_incoming_interceptors(
        context: *mut aeron_driver_context_t,
    ) -> *mut aeron_udp_channel_interceptor_bindings_t;
}
extern "C" {
    pub fn aeron_driver_context_set_publication_reserved_session_id_low(
        context: *mut aeron_driver_context_t,
        value: i32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_driver_context_get_publication_reserved_session_id_low(
        context: *mut aeron_driver_context_t,
    ) -> i32;
}
extern "C" {
    pub fn aeron_driver_context_set_publication_reserved_session_id_high(
        context: *mut aeron_driver_context_t,
        value: i32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_driver_context_get_publication_reserved_session_id_high(
        context: *mut aeron_driver_context_t,
    ) -> i32;
}
pub type aeron_name_resolver_t = aeron_name_resolver_stct;
pub type aeron_name_resolver_supplier_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        resolver: *mut aeron_name_resolver_t,
        args: *const ::std::os::raw::c_char,
        context: *mut aeron_driver_context_t,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn aeron_driver_context_set_resolver_name(
        context: *mut aeron_driver_context_t,
        value: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_driver_context_get_resolver_name(
        context: *mut aeron_driver_context_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn aeron_driver_context_set_resolver_interface(
        context: *mut aeron_driver_context_t,
        value: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_driver_context_get_resolver_interface(
        context: *mut aeron_driver_context_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn aeron_driver_context_set_resolver_bootstrap_neighbor(
        context: *mut aeron_driver_context_t,
        value: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_driver_context_get_resolver_bootstrap_neighbor(
        context: *mut aeron_driver_context_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn aeron_driver_context_set_name_resolver_supplier(
        context: *mut aeron_driver_context_t,
        value: aeron_name_resolver_supplier_func_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_driver_context_get_name_resolver_supplier(
        context: *mut aeron_driver_context_t,
    ) -> aeron_name_resolver_supplier_func_t;
}
extern "C" {
    pub fn aeron_driver_context_set_name_resolver_init_args(
        context: *mut aeron_driver_context_t,
        value: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_driver_context_get_name_resolver_init_args(
        context: *mut aeron_driver_context_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn aeron_driver_context_set_re_resolution_check_interval_ns(
        context: *mut aeron_driver_context_t,
        value: u64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_driver_context_get_re_resolution_check_interval_ns(
        context: *mut aeron_driver_context_t,
    ) -> u64;
}
pub type aeron_duty_cycle_tracker_t = aeron_duty_cycle_tracker_stct;
extern "C" {
    pub fn aeron_driver_context_set_conductor_duty_cycle_tracker(
        context: *mut aeron_driver_context_t,
        value: *mut aeron_duty_cycle_tracker_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_driver_context_get_conductor_duty_cycle_tracker(
        context: *mut aeron_driver_context_t,
    ) -> *mut aeron_duty_cycle_tracker_t;
}
extern "C" {
    pub fn aeron_driver_context_set_sender_duty_cycle_tracker(
        context: *mut aeron_driver_context_t,
        value: *mut aeron_duty_cycle_tracker_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_driver_context_get_sender_duty_cycle_tracker(
        context: *mut aeron_driver_context_t,
    ) -> *mut aeron_duty_cycle_tracker_t;
}
extern "C" {
    pub fn aeron_driver_context_set_receiver_duty_cycle_tracker(
        context: *mut aeron_driver_context_t,
        value: *mut aeron_duty_cycle_tracker_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_driver_context_get_receiver_duty_cycle_tracker(
        context: *mut aeron_driver_context_t,
    ) -> *mut aeron_duty_cycle_tracker_t;
}
extern "C" {
    pub fn aeron_driver_context_set_name_resolver_time_tracker(
        context: *mut aeron_driver_context_t,
        value: *mut aeron_duty_cycle_tracker_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_driver_context_get_name_resolver_time_tracker(
        context: *mut aeron_driver_context_t,
    ) -> *mut aeron_duty_cycle_tracker_t;
}
extern "C" {
    pub fn aeron_driver_context_set_conductor_cycle_threshold_ns(
        context: *mut aeron_driver_context_t,
        value: u64,
    ) -> i64;
}
extern "C" {
    pub fn aeron_driver_context_get_conductor_cycle_threshold_ns(
        context: *mut aeron_driver_context_t,
    ) -> i64;
}
extern "C" {
    pub fn aeron_driver_context_set_sender_cycle_threshold_ns(
        context: *mut aeron_driver_context_t,
        value: u64,
    ) -> i64;
}
extern "C" {
    pub fn aeron_driver_context_get_sender_cycle_threshold_ns(
        context: *mut aeron_driver_context_t,
    ) -> i64;
}
extern "C" {
    pub fn aeron_driver_context_set_receiver_cycle_threshold_ns(
        context: *mut aeron_driver_context_t,
        value: u64,
    ) -> i64;
}
extern "C" {
    pub fn aeron_driver_context_get_receiver_cycle_threshold_ns(
        context: *mut aeron_driver_context_t,
    ) -> i64;
}
extern "C" {
    pub fn aeron_driver_context_set_name_resolver_threshold_ns(
        context: *mut aeron_driver_context_t,
        value: u64,
    ) -> i64;
}
extern "C" {
    pub fn aeron_driver_context_get_name_resolver_threshold_ns(
        context: *mut aeron_driver_context_t,
    ) -> i64;
}
extern "C" {
    pub fn aeron_driver_context_set_receiver_io_vector_capacity(
        context: *mut aeron_driver_context_t,
        value: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_driver_context_get_receiver_io_vector_capacity(
        context: *mut aeron_driver_context_t,
    ) -> u32;
}
extern "C" {
    pub fn aeron_driver_context_set_sender_io_vector_capacity(
        context: *mut aeron_driver_context_t,
        value: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_driver_context_get_sender_io_vector_capacity(
        context: *mut aeron_driver_context_t,
    ) -> u32;
}
extern "C" {
    pub fn aeron_driver_context_set_network_publication_max_messages_per_send(
        context: *mut aeron_driver_context_t,
        value: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_driver_context_get_network_publication_max_messages_per_send(
        context: *mut aeron_driver_context_t,
    ) -> u32;
}
extern "C" {
    pub fn aeron_driver_context_set_resource_free_limit(
        context: *mut aeron_driver_context_t,
        value: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_driver_context_get_resource_free_limit(
        context: *mut aeron_driver_context_t,
    ) -> u32;
}
extern "C" {
    #[doc = " Create a aeron_driver_context_t struct and initialize with default values.\n\n @param context to create and initialize\n @return 0 for success and -1 for error."]
    pub fn aeron_driver_context_init(
        context: *mut *mut aeron_driver_context_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Close and delete aeron_driver_context_t struct.\n\n @param context to close and delete\n @return 0 for success and -1 for error."]
    pub fn aeron_driver_context_close(
        context: *mut aeron_driver_context_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Create a aeron_driver_t struct and initialize from the aeron_driver_context_t struct.\n\n The given aeron_driver_context_t struct will be used exclusively by the driver. Do not reuse between drivers.\n\n @param driver  to create and initialize.\n @param context to use for initialization.\n @return 0 for success and -1 for error."]
    pub fn aeron_driver_init(
        driver: *mut *mut aeron_driver_t,
        context: *mut aeron_driver_context_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Start an aeron_driver_t given the threading mode. This may spawn threads for the Sender, Receiver, and Conductor\n depending on threading mode used.\n\n @param driver to start.\n @param manual_main_loop to be called by the caller for the Conductor do_work cycle.\n @return 0 for success and -1 for error."]
    pub fn aeron_driver_start(
        driver: *mut aeron_driver_t,
        manual_main_loop: bool,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Call the Conductor (or Shared) main do_work duty cycle once.\n\n Driver must have been created with manual_main_loop set to true.\n\n @param driver to call do_work duty cycle on.\n @return 0 for success and -1 for error."]
    pub fn aeron_driver_main_do_work(driver: *mut aeron_driver_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Call the Conductor (or Shared) Idle Strategy.\n\n @param driver to idle.\n @param work_count to pass to idle strategy."]
    pub fn aeron_driver_main_idle_strategy(
        driver: *mut aeron_driver_t,
        work_count: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Close and delete aeron_driver_t struct.\n\n @param driver to close and delete\n @return 0 for success and -1 for error."]
    pub fn aeron_driver_close(driver: *mut aeron_driver_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Delete the given aeron directory.\n\n @param dirname to delete.\n @return 0 for success and -1 for error."]
    pub fn aeron_delete_directory(dirname: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Affinity setting function that complies with the aeron_agent_on_start_func_t structure that can\n be used as an agent start function.  The state should be the aeron_driver_context_t* and the function\n will match the values \"conductor\", \"sender\", \"receiver\" and use the respective configuration options from\n the aeron_driver_context_t.\n\n @param state client information passed to function, should be the aeron_driver_context_t*.\n @param role_name name of the role specified on the agent."]
    pub fn aeron_set_thread_affinity_on_start(
        state: *mut ::std::os::raw::c_void,
        role_name: *const ::std::os::raw::c_char,
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aeron_driver_uri_publication_params_stct {
    pub has_position: bool,
    pub is_sparse: bool,
    pub signal_eos: bool,
    pub spies_simulate_connection: bool,
    pub has_mtu_length: bool,
    pub mtu_length: usize,
    pub has_term_length: bool,
    pub term_length: usize,
    pub term_offset: usize,
    pub initial_term_id: i32,
    pub term_id: i32,
    pub linger_timeout_ns: u64,
    pub has_session_id: bool,
    pub session_id: i32,
    pub entity_tag: i64,
}
#[test]
fn bindgen_test_layout_aeron_driver_uri_publication_params_stct() {
    const UNINIT: ::std::mem::MaybeUninit<aeron_driver_uri_publication_params_stct> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_driver_uri_publication_params_stct>(),
        72usize,
        concat!(
            "Size of: ",
            stringify!(aeron_driver_uri_publication_params_stct)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_driver_uri_publication_params_stct>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(aeron_driver_uri_publication_params_stct)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_position) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_uri_publication_params_stct),
            "::",
            stringify!(has_position)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).is_sparse) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_uri_publication_params_stct),
            "::",
            stringify!(is_sparse)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).signal_eos) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_uri_publication_params_stct),
            "::",
            stringify!(signal_eos)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).spies_simulate_connection) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_uri_publication_params_stct),
            "::",
            stringify!(spies_simulate_connection)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_mtu_length) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_uri_publication_params_stct),
            "::",
            stringify!(has_mtu_length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mtu_length) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_uri_publication_params_stct),
            "::",
            stringify!(mtu_length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_term_length) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_uri_publication_params_stct),
            "::",
            stringify!(has_term_length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).term_length) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_uri_publication_params_stct),
            "::",
            stringify!(term_length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).term_offset) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_uri_publication_params_stct),
            "::",
            stringify!(term_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).initial_term_id) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_uri_publication_params_stct),
            "::",
            stringify!(initial_term_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).term_id) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_uri_publication_params_stct),
            "::",
            stringify!(term_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).linger_timeout_ns) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_uri_publication_params_stct),
            "::",
            stringify!(linger_timeout_ns)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_session_id) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_uri_publication_params_stct),
            "::",
            stringify!(has_session_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).session_id) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_uri_publication_params_stct),
            "::",
            stringify!(session_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).entity_tag) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_uri_publication_params_stct),
            "::",
            stringify!(entity_tag)
        )
    );
}
pub type aeron_driver_uri_publication_params_t = aeron_driver_uri_publication_params_stct;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aeron_driver_uri_subscription_params_stct {
    pub is_reliable: bool,
    pub is_sparse: bool,
    pub is_tether: bool,
    pub is_rejoin: bool,
    pub group: aeron_inferable_boolean_t,
    pub has_session_id: bool,
    pub session_id: i32,
    pub initial_window_length: usize,
}
#[test]
fn bindgen_test_layout_aeron_driver_uri_subscription_params_stct() {
    const UNINIT: ::std::mem::MaybeUninit<aeron_driver_uri_subscription_params_stct> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_driver_uri_subscription_params_stct>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(aeron_driver_uri_subscription_params_stct)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_driver_uri_subscription_params_stct>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(aeron_driver_uri_subscription_params_stct)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).is_reliable) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_uri_subscription_params_stct),
            "::",
            stringify!(is_reliable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).is_sparse) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_uri_subscription_params_stct),
            "::",
            stringify!(is_sparse)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).is_tether) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_uri_subscription_params_stct),
            "::",
            stringify!(is_tether)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).is_rejoin) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_uri_subscription_params_stct),
            "::",
            stringify!(is_rejoin)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).group) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_uri_subscription_params_stct),
            "::",
            stringify!(group)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_session_id) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_uri_subscription_params_stct),
            "::",
            stringify!(has_session_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).session_id) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_uri_subscription_params_stct),
            "::",
            stringify!(session_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).initial_window_length) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_uri_subscription_params_stct),
            "::",
            stringify!(initial_window_length)
        )
    );
}
pub type aeron_driver_uri_subscription_params_t = aeron_driver_uri_subscription_params_stct;
pub type aeron_driver_conductor_t = aeron_driver_conductor_stct;
extern "C" {
    pub fn aeron_diver_uri_publication_params(
        uri: *mut aeron_uri_t,
        params: *mut aeron_driver_uri_publication_params_t,
        conductor: *mut aeron_driver_conductor_t,
        is_exclusive: bool,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_driver_uri_subscription_params(
        uri: *mut aeron_uri_t,
        params: *mut aeron_driver_uri_subscription_params_t,
        conductor: *mut aeron_driver_conductor_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_publication_params_validate_mtu_for_sndbuf(
        params: *mut aeron_driver_uri_publication_params_t,
        endpoint_socket_sndbuf: usize,
        channel_socket_sndbuf: usize,
        context_socket_sndbuf: usize,
        os_default_socket_sndbuf: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_subscription_params_validate_initial_window_for_rcvbuf(
        params: *mut aeron_driver_uri_subscription_params_t,
        endpoint_socket_rcvbuf: usize,
        os_default_socket_rcvbuf: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_driver_uri_get_timestamp_offset(
        uri: *mut aeron_uri_t,
        key: *const ::std::os::raw::c_char,
        offset: *mut i32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_driver_uri_get_offset_info(offset: i32) -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct iovec {
    pub iov_base: *mut ::std::os::raw::c_void,
    pub iov_len: usize,
}
#[test]
fn bindgen_test_layout_iovec() {
    const UNINIT: ::std::mem::MaybeUninit<iovec> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<iovec>(),
        16usize,
        concat!("Size of: ", stringify!(iovec))
    );
    assert_eq!(
        ::std::mem::align_of::<iovec>(),
        8usize,
        concat!("Alignment of ", stringify!(iovec))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).iov_base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(iovec),
            "::",
            stringify!(iov_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).iov_len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(iovec),
            "::",
            stringify!(iov_len)
        )
    );
}
pub type socklen_t = __socklen_t;
pub type sa_family_t = ::std::os::raw::c_ushort;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sockaddr {
    pub sa_family: sa_family_t,
    pub sa_data: [::std::os::raw::c_char; 14usize],
}
#[test]
fn bindgen_test_layout_sockaddr() {
    const UNINIT: ::std::mem::MaybeUninit<sockaddr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sockaddr>(),
        16usize,
        concat!("Size of: ", stringify!(sockaddr))
    );
    assert_eq!(
        ::std::mem::align_of::<sockaddr>(),
        2usize,
        concat!("Alignment of ", stringify!(sockaddr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sa_family) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr),
            "::",
            stringify!(sa_family)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sa_data) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr),
            "::",
            stringify!(sa_data)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sockaddr_storage {
    pub ss_family: sa_family_t,
    pub __ss_padding: [::std::os::raw::c_char; 118usize],
    pub __ss_align: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_sockaddr_storage() {
    const UNINIT: ::std::mem::MaybeUninit<sockaddr_storage> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sockaddr_storage>(),
        128usize,
        concat!("Size of: ", stringify!(sockaddr_storage))
    );
    assert_eq!(
        ::std::mem::align_of::<sockaddr_storage>(),
        8usize,
        concat!("Alignment of ", stringify!(sockaddr_storage))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ss_family) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_storage),
            "::",
            stringify!(ss_family)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ss_padding) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_storage),
            "::",
            stringify!(__ss_padding)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ss_align) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_storage),
            "::",
            stringify!(__ss_align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct msghdr {
    pub msg_name: *mut ::std::os::raw::c_void,
    pub msg_namelen: socklen_t,
    pub msg_iov: *mut iovec,
    pub msg_iovlen: usize,
    pub msg_control: *mut ::std::os::raw::c_void,
    pub msg_controllen: usize,
    pub msg_flags: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_msghdr() {
    const UNINIT: ::std::mem::MaybeUninit<msghdr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<msghdr>(),
        56usize,
        concat!("Size of: ", stringify!(msghdr))
    );
    assert_eq!(
        ::std::mem::align_of::<msghdr>(),
        8usize,
        concat!("Alignment of ", stringify!(msghdr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msg_name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(msg_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msg_namelen) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(msg_namelen)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msg_iov) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(msg_iov)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msg_iovlen) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(msg_iovlen)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msg_control) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(msg_control)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msg_controllen) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(msg_controllen)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msg_flags) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(msg_flags)
        )
    );
}
pub type in_addr_t = u32;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct in_addr {
    pub s_addr: in_addr_t,
}
#[test]
fn bindgen_test_layout_in_addr() {
    const UNINIT: ::std::mem::MaybeUninit<in_addr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<in_addr>(),
        4usize,
        concat!("Size of: ", stringify!(in_addr))
    );
    assert_eq!(
        ::std::mem::align_of::<in_addr>(),
        4usize,
        concat!("Alignment of ", stringify!(in_addr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).s_addr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in_addr),
            "::",
            stringify!(s_addr)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct in6_addr {
    pub __in6_u: in6_addr__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union in6_addr__bindgen_ty_1 {
    pub __u6_addr8: [u8; 16usize],
    pub __u6_addr16: [u16; 8usize],
    pub __u6_addr32: [u32; 4usize],
}
#[test]
fn bindgen_test_layout_in6_addr__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<in6_addr__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<in6_addr__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(in6_addr__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<in6_addr__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(in6_addr__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__u6_addr8) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in6_addr__bindgen_ty_1),
            "::",
            stringify!(__u6_addr8)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__u6_addr16) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in6_addr__bindgen_ty_1),
            "::",
            stringify!(__u6_addr16)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__u6_addr32) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in6_addr__bindgen_ty_1),
            "::",
            stringify!(__u6_addr32)
        )
    );
}
#[test]
fn bindgen_test_layout_in6_addr() {
    const UNINIT: ::std::mem::MaybeUninit<in6_addr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<in6_addr>(),
        16usize,
        concat!("Size of: ", stringify!(in6_addr))
    );
    assert_eq!(
        ::std::mem::align_of::<in6_addr>(),
        4usize,
        concat!("Alignment of ", stringify!(in6_addr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__in6_u) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in6_addr),
            "::",
            stringify!(__in6_u)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct addrinfo {
    pub ai_flags: ::std::os::raw::c_int,
    pub ai_family: ::std::os::raw::c_int,
    pub ai_socktype: ::std::os::raw::c_int,
    pub ai_protocol: ::std::os::raw::c_int,
    pub ai_addrlen: socklen_t,
    pub ai_addr: *mut sockaddr,
    pub ai_canonname: *mut ::std::os::raw::c_char,
    pub ai_next: *mut addrinfo,
}
#[test]
fn bindgen_test_layout_addrinfo() {
    const UNINIT: ::std::mem::MaybeUninit<addrinfo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<addrinfo>(),
        48usize,
        concat!("Size of: ", stringify!(addrinfo))
    );
    assert_eq!(
        ::std::mem::align_of::<addrinfo>(),
        8usize,
        concat!("Alignment of ", stringify!(addrinfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ai_flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(addrinfo),
            "::",
            stringify!(ai_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ai_family) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(addrinfo),
            "::",
            stringify!(ai_family)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ai_socktype) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(addrinfo),
            "::",
            stringify!(ai_socktype)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ai_protocol) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(addrinfo),
            "::",
            stringify!(ai_protocol)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ai_addrlen) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(addrinfo),
            "::",
            stringify!(ai_addrlen)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ai_addr) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(addrinfo),
            "::",
            stringify!(ai_addr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ai_canonname) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(addrinfo),
            "::",
            stringify!(ai_canonname)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ai_next) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(addrinfo),
            "::",
            stringify!(ai_next)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ifaddrs {
    pub ifa_next: *mut ifaddrs,
    pub ifa_name: *mut ::std::os::raw::c_char,
    pub ifa_flags: ::std::os::raw::c_uint,
    pub ifa_addr: *mut sockaddr,
    pub ifa_netmask: *mut sockaddr,
    pub ifa_ifu: ifaddrs__bindgen_ty_1,
    pub ifa_data: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ifaddrs__bindgen_ty_1 {
    pub ifu_broadaddr: *mut sockaddr,
    pub ifu_dstaddr: *mut sockaddr,
}
#[test]
fn bindgen_test_layout_ifaddrs__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<ifaddrs__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ifaddrs__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(ifaddrs__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<ifaddrs__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(ifaddrs__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ifu_broadaddr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ifaddrs__bindgen_ty_1),
            "::",
            stringify!(ifu_broadaddr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ifu_dstaddr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ifaddrs__bindgen_ty_1),
            "::",
            stringify!(ifu_dstaddr)
        )
    );
}
#[test]
fn bindgen_test_layout_ifaddrs() {
    const UNINIT: ::std::mem::MaybeUninit<ifaddrs> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ifaddrs>(),
        56usize,
        concat!("Size of: ", stringify!(ifaddrs))
    );
    assert_eq!(
        ::std::mem::align_of::<ifaddrs>(),
        8usize,
        concat!("Alignment of ", stringify!(ifaddrs))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ifa_next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ifaddrs),
            "::",
            stringify!(ifa_next)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ifa_name) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ifaddrs),
            "::",
            stringify!(ifa_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ifa_flags) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ifaddrs),
            "::",
            stringify!(ifa_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ifa_addr) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ifaddrs),
            "::",
            stringify!(ifa_addr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ifa_netmask) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ifaddrs),
            "::",
            stringify!(ifa_netmask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ifa_ifu) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ifaddrs),
            "::",
            stringify!(ifa_ifu)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ifa_data) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ifaddrs),
            "::",
            stringify!(ifa_data)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pollfd {
    pub fd: ::std::os::raw::c_int,
    pub events: ::std::os::raw::c_short,
    pub revents: ::std::os::raw::c_short,
}
#[test]
fn bindgen_test_layout_pollfd() {
    const UNINIT: ::std::mem::MaybeUninit<pollfd> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pollfd>(),
        8usize,
        concat!("Size of: ", stringify!(pollfd))
    );
    assert_eq!(
        ::std::mem::align_of::<pollfd>(),
        4usize,
        concat!("Alignment of ", stringify!(pollfd))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fd) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pollfd),
            "::",
            stringify!(fd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).events) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(pollfd),
            "::",
            stringify!(events)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).revents) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(pollfd),
            "::",
            stringify!(revents)
        )
    );
}
pub type aeron_socket_t = ::std::os::raw::c_int;
extern "C" {
    pub fn aeron_set_socket_non_blocking(fd: aeron_socket_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_socket(
        domain: ::std::os::raw::c_int,
        type_: ::std::os::raw::c_int,
        protocol: ::std::os::raw::c_int,
    ) -> aeron_socket_t;
}
extern "C" {
    pub fn aeron_close_socket(socket: aeron_socket_t);
}
extern "C" {
    pub fn aeron_connect(
        fd: aeron_socket_t,
        address: *mut sockaddr,
        address_length: socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_bind(
        fd: aeron_socket_t,
        address: *mut sockaddr,
        address_length: socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_net_init() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_getsockopt(
        fd: aeron_socket_t,
        level: ::std::os::raw::c_int,
        optname: ::std::os::raw::c_int,
        optval: *mut ::std::os::raw::c_void,
        optlen: *mut socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_setsockopt(
        fd: aeron_socket_t,
        level: ::std::os::raw::c_int,
        optname: ::std::os::raw::c_int,
        optval: *const ::std::os::raw::c_void,
        optlen: socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_getifaddrs(ifap: *mut *mut ifaddrs) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_freeifaddrs(ifa: *mut ifaddrs);
}
extern "C" {
    pub fn aeron_sendmsg(
        fd: aeron_socket_t,
        msghdr: *mut msghdr,
        flags: ::std::os::raw::c_int,
    ) -> isize;
}
extern "C" {
    pub fn aeron_send(
        fd: aeron_socket_t,
        buf: *const ::std::os::raw::c_void,
        len: usize,
        flags: ::std::os::raw::c_int,
    ) -> isize;
}
extern "C" {
    pub fn aeron_recvmsg(
        fd: aeron_socket_t,
        msghdr: *mut msghdr,
        flags: ::std::os::raw::c_int,
    ) -> isize;
}
extern "C" {
    pub fn aeron_poll(
        fds: *mut pollfd,
        nfds: ::std::os::raw::c_ulong,
        timeout: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
pub const aeron_udp_channel_transport_affinity_en_AERON_UDP_CHANNEL_TRANSPORT_AFFINITY_SENDER:
    aeron_udp_channel_transport_affinity_en = 0;
pub const aeron_udp_channel_transport_affinity_en_AERON_UDP_CHANNEL_TRANSPORT_AFFINITY_RECEIVER:
    aeron_udp_channel_transport_affinity_en = 1;
pub const aeron_udp_channel_transport_affinity_en_AERON_UDP_CHANNEL_TRANSPORT_AFFINITY_CONDUCTOR:
    aeron_udp_channel_transport_affinity_en = 2;
pub type aeron_udp_channel_transport_affinity_en = ::std::os::raw::c_uint;
pub use self::aeron_udp_channel_transport_affinity_en as aeron_udp_channel_transport_affinity_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mmsghdr {
    _unused: [u8; 0],
}
pub type aeron_udp_channel_transport_t = aeron_udp_channel_transport_stct;
pub type aeron_network_publication_t = aeron_network_publication_stct;
pub type aeron_publication_image_t = aeron_publication_image_stct;
pub type aeron_udp_transport_poller_t = aeron_udp_transport_poller_stct;
pub type aeron_udp_channel_data_paths_t = aeron_udp_channel_data_paths_stct;
pub type aeron_data_packet_dispatcher_t = aeron_data_packet_dispatcher_stct;
pub type aeron_udp_channel_transport_init_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        transport: *mut aeron_udp_channel_transport_t,
        bind_addr: *mut sockaddr_storage,
        multicast_if_addr: *mut sockaddr_storage,
        connect_addr: *mut sockaddr_storage,
        multicast_if_index: ::std::os::raw::c_uint,
        ttl: u8,
        socket_rcvbuf: usize,
        socket_sndbuf: usize,
        is_media_timestamping: bool,
        context: *mut aeron_driver_context_t,
        affinity: aeron_udp_channel_transport_affinity_t,
    ) -> ::std::os::raw::c_int,
>;
pub type aeron_udp_channel_transport_reconnect_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        transport: *mut aeron_udp_channel_transport_t,
        connect_addr: *mut sockaddr_storage,
    ) -> ::std::os::raw::c_int,
>;
pub type aeron_udp_channel_transport_close_func_t = ::std::option::Option<
    unsafe extern "C" fn(transport: *mut aeron_udp_channel_transport_t) -> ::std::os::raw::c_int,
>;
pub type aeron_udp_transport_recv_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        data_paths: *mut aeron_udp_channel_data_paths_t,
        transport: *mut aeron_udp_channel_transport_t,
        receiver_clientd: *mut ::std::os::raw::c_void,
        endpoint_clientd: *mut ::std::os::raw::c_void,
        destination_clientd: *mut ::std::os::raw::c_void,
        buffer: *mut u8,
        length: usize,
        addr: *mut sockaddr_storage,
        media_timestamp: *mut timespec,
    ),
>;
pub type aeron_udp_channel_transport_recvmmsg_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        transport: *mut aeron_udp_channel_transport_t,
        msgvec: *mut mmsghdr,
        vlen: usize,
        bytes_rcved: *mut i64,
        recv_func: aeron_udp_transport_recv_func_t,
        clientd: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
pub type aeron_udp_channel_transport_send_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        data_paths: *mut aeron_udp_channel_data_paths_t,
        transport: *mut aeron_udp_channel_transport_t,
        address: *mut sockaddr_storage,
        iov: *mut iovec,
        iov_length: usize,
        bytes_sent: *mut i64,
    ) -> ::std::os::raw::c_int,
>;
pub type aeron_udp_channel_transport_get_so_rcvbuf_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        transport: *mut aeron_udp_channel_transport_t,
        so_rcvbuf: *mut usize,
    ) -> ::std::os::raw::c_int,
>;
pub type aeron_udp_channel_transport_bind_addr_and_port_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        transport: *mut aeron_udp_channel_transport_t,
        buffer: *mut ::std::os::raw::c_char,
        length: usize,
    ) -> ::std::os::raw::c_int,
>;
pub type aeron_udp_transport_poller_init_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        poller: *mut aeron_udp_transport_poller_t,
        context: *mut aeron_driver_context_t,
        affinity: aeron_udp_channel_transport_affinity_t,
    ) -> ::std::os::raw::c_int,
>;
pub type aeron_udp_transport_poller_close_func_t = ::std::option::Option<
    unsafe extern "C" fn(poller: *mut aeron_udp_transport_poller_t) -> ::std::os::raw::c_int,
>;
pub type aeron_udp_transport_poller_add_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        poller: *mut aeron_udp_transport_poller_t,
        transport: *mut aeron_udp_channel_transport_t,
    ) -> ::std::os::raw::c_int,
>;
pub type aeron_udp_transport_poller_remove_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        poller: *mut aeron_udp_transport_poller_t,
        transport: *mut aeron_udp_channel_transport_t,
    ) -> ::std::os::raw::c_int,
>;
pub type aeron_udp_transport_poller_poll_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        poller: *mut aeron_udp_transport_poller_t,
        msgvec: *mut mmsghdr,
        vlen: usize,
        bytes_rcved: *mut i64,
        recv_func: aeron_udp_transport_recv_func_t,
        recvmmsg_func: aeron_udp_channel_transport_recvmmsg_func_t,
        clientd: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aeron_udp_channel_transport_bindings_stct {
    pub init_func: aeron_udp_channel_transport_init_func_t,
    pub reconnect_func: aeron_udp_channel_transport_reconnect_func_t,
    pub close_func: aeron_udp_channel_transport_close_func_t,
    pub recvmmsg_func: aeron_udp_channel_transport_recvmmsg_func_t,
    pub send_func: aeron_udp_channel_transport_send_func_t,
    pub get_so_rcvbuf_func: aeron_udp_channel_transport_get_so_rcvbuf_func_t,
    pub bind_addr_and_port_func: aeron_udp_channel_transport_bind_addr_and_port_func_t,
    pub poller_init_func: aeron_udp_transport_poller_init_func_t,
    pub poller_close_func: aeron_udp_transport_poller_close_func_t,
    pub poller_add_func: aeron_udp_transport_poller_add_func_t,
    pub poller_remove_func: aeron_udp_transport_poller_remove_func_t,
    pub poller_poll_func: aeron_udp_transport_poller_poll_func_t,
    pub meta_info: aeron_udp_channel_transport_bindings_stct_meta_info_fields,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aeron_udp_channel_transport_bindings_stct_meta_info_fields {
    pub name: *const ::std::os::raw::c_char,
    pub type_: *const ::std::os::raw::c_char,
    pub source_symbol: *const ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_aeron_udp_channel_transport_bindings_stct_meta_info_fields() {
    const UNINIT: ::std::mem::MaybeUninit<
        aeron_udp_channel_transport_bindings_stct_meta_info_fields,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_udp_channel_transport_bindings_stct_meta_info_fields>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(aeron_udp_channel_transport_bindings_stct_meta_info_fields)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_udp_channel_transport_bindings_stct_meta_info_fields>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(aeron_udp_channel_transport_bindings_stct_meta_info_fields)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_udp_channel_transport_bindings_stct_meta_info_fields),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_udp_channel_transport_bindings_stct_meta_info_fields),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).source_symbol) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_udp_channel_transport_bindings_stct_meta_info_fields),
            "::",
            stringify!(source_symbol)
        )
    );
}
#[test]
fn bindgen_test_layout_aeron_udp_channel_transport_bindings_stct() {
    const UNINIT: ::std::mem::MaybeUninit<aeron_udp_channel_transport_bindings_stct> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_udp_channel_transport_bindings_stct>(),
        120usize,
        concat!(
            "Size of: ",
            stringify!(aeron_udp_channel_transport_bindings_stct)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_udp_channel_transport_bindings_stct>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(aeron_udp_channel_transport_bindings_stct)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).init_func) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_udp_channel_transport_bindings_stct),
            "::",
            stringify!(init_func)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reconnect_func) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_udp_channel_transport_bindings_stct),
            "::",
            stringify!(reconnect_func)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).close_func) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_udp_channel_transport_bindings_stct),
            "::",
            stringify!(close_func)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).recvmmsg_func) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_udp_channel_transport_bindings_stct),
            "::",
            stringify!(recvmmsg_func)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).send_func) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_udp_channel_transport_bindings_stct),
            "::",
            stringify!(send_func)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_so_rcvbuf_func) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_udp_channel_transport_bindings_stct),
            "::",
            stringify!(get_so_rcvbuf_func)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bind_addr_and_port_func) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_udp_channel_transport_bindings_stct),
            "::",
            stringify!(bind_addr_and_port_func)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).poller_init_func) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_udp_channel_transport_bindings_stct),
            "::",
            stringify!(poller_init_func)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).poller_close_func) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_udp_channel_transport_bindings_stct),
            "::",
            stringify!(poller_close_func)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).poller_add_func) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_udp_channel_transport_bindings_stct),
            "::",
            stringify!(poller_add_func)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).poller_remove_func) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_udp_channel_transport_bindings_stct),
            "::",
            stringify!(poller_remove_func)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).poller_poll_func) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_udp_channel_transport_bindings_stct),
            "::",
            stringify!(poller_poll_func)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).meta_info) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_udp_channel_transport_bindings_stct),
            "::",
            stringify!(meta_info)
        )
    );
}
extern "C" {
    pub fn aeron_udp_channel_transport_bindings_load_media(
        bindings_name: *const ::std::os::raw::c_char,
    ) -> *mut aeron_udp_channel_transport_bindings_t;
}
pub type aeron_udp_channel_interceptor_bindings_load_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        delegate_bindings: *mut aeron_udp_channel_interceptor_bindings_t,
    ) -> *mut aeron_udp_channel_interceptor_bindings_t,
>;
extern "C" {
    pub fn aeron_udp_channel_interceptor_bindings_load(
        existing_interceptor_bindings: *mut aeron_udp_channel_interceptor_bindings_t,
        interceptors: *const ::std::os::raw::c_char,
    ) -> *mut aeron_udp_channel_interceptor_bindings_t;
}
pub type aeron_udp_channel_outgoing_interceptor_t = aeron_udp_channel_outgoing_interceptor_stct;
pub type aeron_udp_channel_incoming_interceptor_t = aeron_udp_channel_incoming_interceptor_stct;
pub const aeron_udp_channel_interceptor_notification_type_en_AERON_UDP_CHANNEL_INTERCEPTOR_ADD_NOTIFICATION : aeron_udp_channel_interceptor_notification_type_en = 0 ;
pub const aeron_udp_channel_interceptor_notification_type_en_AERON_UDP_CHANNEL_INTERCEPTOR_REMOVE_NOTIFICATION : aeron_udp_channel_interceptor_notification_type_en = 1 ;
pub type aeron_udp_channel_interceptor_notification_type_en = ::std::os::raw::c_uint;
pub use self::aeron_udp_channel_interceptor_notification_type_en as aeron_udp_channel_interceptor_notification_type_t;
pub type aeron_udp_channel_interceptor_outgoing_send_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        interceptor_state: *mut ::std::os::raw::c_void,
        delegate: *mut aeron_udp_channel_outgoing_interceptor_t,
        transport: *mut aeron_udp_channel_transport_t,
        address: *mut sockaddr_storage,
        iov: *mut iovec,
        iov_length: usize,
        bytes_sent: *mut i64,
    ) -> ::std::os::raw::c_int,
>;
pub type aeron_udp_channel_interceptor_incoming_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        interceptor_state: *mut ::std::os::raw::c_void,
        delegate: *mut aeron_udp_channel_incoming_interceptor_t,
        transport: *mut aeron_udp_channel_transport_t,
        receiver_clientd: *mut ::std::os::raw::c_void,
        endpoint_clientd: *mut ::std::os::raw::c_void,
        destination_clientd: *mut ::std::os::raw::c_void,
        buffer: *mut u8,
        length: usize,
        addr: *mut sockaddr_storage,
        media_timestamp: *mut timespec,
    ),
>;
pub type aeron_udp_channel_interceptor_init_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        interceptor_state: *mut *mut ::std::os::raw::c_void,
        context: *mut aeron_driver_context_t,
        affinity: aeron_udp_channel_transport_affinity_t,
    ) -> ::std::os::raw::c_int,
>;
pub type aeron_udp_channel_interceptor_close_func_t = ::std::option::Option<
    unsafe extern "C" fn(interceptor_state: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
>;
pub type aeron_udp_channel_interceptor_transport_notification_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        interceptor_state: *mut ::std::os::raw::c_void,
        transport: *mut aeron_udp_channel_transport_t,
        udp_channel: *const aeron_udp_channel_t,
        data_packet_dispatcher: *mut aeron_data_packet_dispatcher_t,
        type_: aeron_udp_channel_interceptor_notification_type_t,
    ) -> ::std::os::raw::c_int,
>;
pub type aeron_udp_channel_interceptor_publication_notification_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        interceptor_state: *mut ::std::os::raw::c_void,
        transport: *mut aeron_udp_channel_transport_t,
        publication: *mut aeron_network_publication_t,
        type_: aeron_udp_channel_interceptor_notification_type_t,
    ) -> ::std::os::raw::c_int,
>;
pub type aeron_udp_channel_interceptor_image_notification_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        interceptor_state: *mut ::std::os::raw::c_void,
        transport: *mut aeron_udp_channel_transport_t,
        image: *mut aeron_publication_image_t,
        type_: aeron_udp_channel_interceptor_notification_type_t,
    ) -> ::std::os::raw::c_int,
>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aeron_udp_channel_interceptor_bindings_stct {
    pub outgoing_init_func: aeron_udp_channel_interceptor_init_func_t,
    pub incoming_init_func: aeron_udp_channel_interceptor_init_func_t,
    pub outgoing_send_func: aeron_udp_channel_interceptor_outgoing_send_func_t,
    pub incoming_func: aeron_udp_channel_interceptor_incoming_func_t,
    pub outgoing_close_func: aeron_udp_channel_interceptor_close_func_t,
    pub incoming_close_func: aeron_udp_channel_interceptor_close_func_t,
    pub outgoing_transport_notification_func:
        aeron_udp_channel_interceptor_transport_notification_func_t,
    pub incoming_transport_notification_func:
        aeron_udp_channel_interceptor_transport_notification_func_t,
    pub outgoing_publication_notification_func:
        aeron_udp_channel_interceptor_publication_notification_func_t,
    pub incoming_publication_notification_func:
        aeron_udp_channel_interceptor_publication_notification_func_t,
    pub outgoing_image_notification_func: aeron_udp_channel_interceptor_image_notification_func_t,
    pub incoming_image_notification_func: aeron_udp_channel_interceptor_image_notification_func_t,
    pub meta_info: aeron_udp_channel_interceptor_bindings_stct_interceptor_meta_info_fields,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aeron_udp_channel_interceptor_bindings_stct_interceptor_meta_info_fields {
    pub name: *const ::std::os::raw::c_char,
    pub type_: *const ::std::os::raw::c_char,
    pub next_interceptor_bindings: *const aeron_udp_channel_interceptor_bindings_t,
    pub source_symbol: ::std::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout_aeron_udp_channel_interceptor_bindings_stct_interceptor_meta_info_fields() {
    const UNINIT: ::std::mem::MaybeUninit<
        aeron_udp_channel_interceptor_bindings_stct_interceptor_meta_info_fields,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<
            aeron_udp_channel_interceptor_bindings_stct_interceptor_meta_info_fields,
        >(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(aeron_udp_channel_interceptor_bindings_stct_interceptor_meta_info_fields)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<
            aeron_udp_channel_interceptor_bindings_stct_interceptor_meta_info_fields,
        >(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(aeron_udp_channel_interceptor_bindings_stct_interceptor_meta_info_fields)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_udp_channel_interceptor_bindings_stct_interceptor_meta_info_fields),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_udp_channel_interceptor_bindings_stct_interceptor_meta_info_fields),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next_interceptor_bindings) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_udp_channel_interceptor_bindings_stct_interceptor_meta_info_fields),
            "::",
            stringify!(next_interceptor_bindings)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).source_symbol) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_udp_channel_interceptor_bindings_stct_interceptor_meta_info_fields),
            "::",
            stringify!(source_symbol)
        )
    );
}
#[test]
fn bindgen_test_layout_aeron_udp_channel_interceptor_bindings_stct() {
    const UNINIT: ::std::mem::MaybeUninit<aeron_udp_channel_interceptor_bindings_stct> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_udp_channel_interceptor_bindings_stct>(),
        128usize,
        concat!(
            "Size of: ",
            stringify!(aeron_udp_channel_interceptor_bindings_stct)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_udp_channel_interceptor_bindings_stct>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(aeron_udp_channel_interceptor_bindings_stct)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).outgoing_init_func) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_udp_channel_interceptor_bindings_stct),
            "::",
            stringify!(outgoing_init_func)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).incoming_init_func) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_udp_channel_interceptor_bindings_stct),
            "::",
            stringify!(incoming_init_func)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).outgoing_send_func) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_udp_channel_interceptor_bindings_stct),
            "::",
            stringify!(outgoing_send_func)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).incoming_func) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_udp_channel_interceptor_bindings_stct),
            "::",
            stringify!(incoming_func)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).outgoing_close_func) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_udp_channel_interceptor_bindings_stct),
            "::",
            stringify!(outgoing_close_func)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).incoming_close_func) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_udp_channel_interceptor_bindings_stct),
            "::",
            stringify!(incoming_close_func)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).outgoing_transport_notification_func) as usize
                - ptr as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_udp_channel_interceptor_bindings_stct),
            "::",
            stringify!(outgoing_transport_notification_func)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).incoming_transport_notification_func) as usize
                - ptr as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_udp_channel_interceptor_bindings_stct),
            "::",
            stringify!(incoming_transport_notification_func)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).outgoing_publication_notification_func) as usize
                - ptr as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_udp_channel_interceptor_bindings_stct),
            "::",
            stringify!(outgoing_publication_notification_func)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).incoming_publication_notification_func) as usize
                - ptr as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_udp_channel_interceptor_bindings_stct),
            "::",
            stringify!(incoming_publication_notification_func)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).outgoing_image_notification_func) as usize - ptr as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_udp_channel_interceptor_bindings_stct),
            "::",
            stringify!(outgoing_image_notification_func)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).incoming_image_notification_func) as usize - ptr as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_udp_channel_interceptor_bindings_stct),
            "::",
            stringify!(incoming_image_notification_func)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).meta_info) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_udp_channel_interceptor_bindings_stct),
            "::",
            stringify!(meta_info)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aeron_udp_channel_outgoing_interceptor_stct {
    pub interceptor_state: *mut ::std::os::raw::c_void,
    pub outgoing_send_func: aeron_udp_channel_interceptor_outgoing_send_func_t,
    pub close_func: aeron_udp_channel_interceptor_close_func_t,
    pub outgoing_transport_notification_func:
        aeron_udp_channel_interceptor_transport_notification_func_t,
    pub outgoing_publication_notification_func:
        aeron_udp_channel_interceptor_publication_notification_func_t,
    pub outgoing_image_notification_func: aeron_udp_channel_interceptor_image_notification_func_t,
    pub next_interceptor: *mut aeron_udp_channel_outgoing_interceptor_t,
}
#[test]
fn bindgen_test_layout_aeron_udp_channel_outgoing_interceptor_stct() {
    const UNINIT: ::std::mem::MaybeUninit<aeron_udp_channel_outgoing_interceptor_stct> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_udp_channel_outgoing_interceptor_stct>(),
        56usize,
        concat!(
            "Size of: ",
            stringify!(aeron_udp_channel_outgoing_interceptor_stct)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_udp_channel_outgoing_interceptor_stct>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(aeron_udp_channel_outgoing_interceptor_stct)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).interceptor_state) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_udp_channel_outgoing_interceptor_stct),
            "::",
            stringify!(interceptor_state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).outgoing_send_func) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_udp_channel_outgoing_interceptor_stct),
            "::",
            stringify!(outgoing_send_func)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).close_func) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_udp_channel_outgoing_interceptor_stct),
            "::",
            stringify!(close_func)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).outgoing_transport_notification_func) as usize
                - ptr as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_udp_channel_outgoing_interceptor_stct),
            "::",
            stringify!(outgoing_transport_notification_func)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).outgoing_publication_notification_func) as usize
                - ptr as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_udp_channel_outgoing_interceptor_stct),
            "::",
            stringify!(outgoing_publication_notification_func)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).outgoing_image_notification_func) as usize - ptr as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_udp_channel_outgoing_interceptor_stct),
            "::",
            stringify!(outgoing_image_notification_func)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next_interceptor) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_udp_channel_outgoing_interceptor_stct),
            "::",
            stringify!(next_interceptor)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aeron_udp_channel_incoming_interceptor_stct {
    pub interceptor_state: *mut ::std::os::raw::c_void,
    pub incoming_func: aeron_udp_channel_interceptor_incoming_func_t,
    pub close_func: aeron_udp_channel_interceptor_close_func_t,
    pub incoming_transport_notification_func:
        aeron_udp_channel_interceptor_transport_notification_func_t,
    pub incoming_publication_notification_func:
        aeron_udp_channel_interceptor_publication_notification_func_t,
    pub incoming_image_notification_func: aeron_udp_channel_interceptor_image_notification_func_t,
    pub next_interceptor: *mut aeron_udp_channel_incoming_interceptor_t,
}
#[test]
fn bindgen_test_layout_aeron_udp_channel_incoming_interceptor_stct() {
    const UNINIT: ::std::mem::MaybeUninit<aeron_udp_channel_incoming_interceptor_stct> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_udp_channel_incoming_interceptor_stct>(),
        56usize,
        concat!(
            "Size of: ",
            stringify!(aeron_udp_channel_incoming_interceptor_stct)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_udp_channel_incoming_interceptor_stct>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(aeron_udp_channel_incoming_interceptor_stct)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).interceptor_state) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_udp_channel_incoming_interceptor_stct),
            "::",
            stringify!(interceptor_state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).incoming_func) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_udp_channel_incoming_interceptor_stct),
            "::",
            stringify!(incoming_func)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).close_func) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_udp_channel_incoming_interceptor_stct),
            "::",
            stringify!(close_func)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).incoming_transport_notification_func) as usize
                - ptr as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_udp_channel_incoming_interceptor_stct),
            "::",
            stringify!(incoming_transport_notification_func)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).incoming_publication_notification_func) as usize
                - ptr as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_udp_channel_incoming_interceptor_stct),
            "::",
            stringify!(incoming_publication_notification_func)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).incoming_image_notification_func) as usize - ptr as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_udp_channel_incoming_interceptor_stct),
            "::",
            stringify!(incoming_image_notification_func)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next_interceptor) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_udp_channel_incoming_interceptor_stct),
            "::",
            stringify!(next_interceptor)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aeron_udp_channel_data_paths_stct {
    pub outgoing_interceptors: *mut aeron_udp_channel_outgoing_interceptor_t,
    pub incoming_interceptors: *mut aeron_udp_channel_incoming_interceptor_t,
    pub send_func: aeron_udp_channel_transport_send_func_t,
    pub recv_func: aeron_udp_transport_recv_func_t,
}
#[test]
fn bindgen_test_layout_aeron_udp_channel_data_paths_stct() {
    const UNINIT: ::std::mem::MaybeUninit<aeron_udp_channel_data_paths_stct> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_udp_channel_data_paths_stct>(),
        32usize,
        concat!("Size of: ", stringify!(aeron_udp_channel_data_paths_stct))
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_udp_channel_data_paths_stct>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(aeron_udp_channel_data_paths_stct)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).outgoing_interceptors) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_udp_channel_data_paths_stct),
            "::",
            stringify!(outgoing_interceptors)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).incoming_interceptors) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_udp_channel_data_paths_stct),
            "::",
            stringify!(incoming_interceptors)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).send_func) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_udp_channel_data_paths_stct),
            "::",
            stringify!(send_func)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).recv_func) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_udp_channel_data_paths_stct),
            "::",
            stringify!(recv_func)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aeron_udp_channel_transport_recv_func_holder_stct {
    pub func: aeron_udp_transport_recv_func_t,
}
#[test]
fn bindgen_test_layout_aeron_udp_channel_transport_recv_func_holder_stct() {
    const UNINIT: ::std::mem::MaybeUninit<aeron_udp_channel_transport_recv_func_holder_stct> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_udp_channel_transport_recv_func_holder_stct>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(aeron_udp_channel_transport_recv_func_holder_stct)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_udp_channel_transport_recv_func_holder_stct>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(aeron_udp_channel_transport_recv_func_holder_stct)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).func) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_udp_channel_transport_recv_func_holder_stct),
            "::",
            stringify!(func)
        )
    );
}
pub type aeron_udp_channel_transport_recv_func_holder_t =
    aeron_udp_channel_transport_recv_func_holder_stct;
extern "C" {
    pub fn aeron_udp_channel_transport_recv_func_holder_close(
        holder: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_udp_channel_incoming_interceptor_recv_func(
        data_paths: *mut aeron_udp_channel_data_paths_t,
        transport: *mut aeron_udp_channel_transport_t,
        receiver_clientd: *mut ::std::os::raw::c_void,
        endpoint_clientd: *mut ::std::os::raw::c_void,
        destination_clientd: *mut ::std::os::raw::c_void,
        buffer: *mut u8,
        length: usize,
        addr: *mut sockaddr_storage,
        media_timestamp: *mut timespec,
    );
}
extern "C" {
    pub fn aeron_udp_channel_data_paths_init(
        data_paths: *mut aeron_udp_channel_data_paths_t,
        outgoing_interceptor_bindings: *mut aeron_udp_channel_interceptor_bindings_t,
        incoming_interceptor_bindings: *mut aeron_udp_channel_interceptor_bindings_t,
        media_bindings: *mut aeron_udp_channel_transport_bindings_t,
        recv_func: aeron_udp_transport_recv_func_t,
        context: *mut aeron_driver_context_t,
        affinity: aeron_udp_channel_transport_affinity_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_udp_channel_data_paths_delete(
        data_paths: *mut aeron_udp_channel_data_paths_t,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aeron_frame_header_stct {
    pub frame_length: i32,
    pub version: i8,
    pub flags: u8,
    pub type_: i16,
}
#[test]
fn bindgen_test_layout_aeron_frame_header_stct() {
    const UNINIT: ::std::mem::MaybeUninit<aeron_frame_header_stct> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_frame_header_stct>(),
        8usize,
        concat!("Size of: ", stringify!(aeron_frame_header_stct))
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_frame_header_stct>(),
        4usize,
        concat!("Alignment of ", stringify!(aeron_frame_header_stct))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).frame_length) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_frame_header_stct),
            "::",
            stringify!(frame_length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_frame_header_stct),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_frame_header_stct),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_frame_header_stct),
            "::",
            stringify!(type_)
        )
    );
}
pub type aeron_frame_header_t = aeron_frame_header_stct;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aeron_setup_header_stct {
    pub frame_header: aeron_frame_header_t,
    pub term_offset: i32,
    pub session_id: i32,
    pub stream_id: i32,
    pub initial_term_id: i32,
    pub active_term_id: i32,
    pub term_length: i32,
    pub mtu: i32,
    pub ttl: i32,
}
#[test]
fn bindgen_test_layout_aeron_setup_header_stct() {
    const UNINIT: ::std::mem::MaybeUninit<aeron_setup_header_stct> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_setup_header_stct>(),
        40usize,
        concat!("Size of: ", stringify!(aeron_setup_header_stct))
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_setup_header_stct>(),
        4usize,
        concat!("Alignment of ", stringify!(aeron_setup_header_stct))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).frame_header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_setup_header_stct),
            "::",
            stringify!(frame_header)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).term_offset) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_setup_header_stct),
            "::",
            stringify!(term_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).session_id) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_setup_header_stct),
            "::",
            stringify!(session_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stream_id) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_setup_header_stct),
            "::",
            stringify!(stream_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).initial_term_id) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_setup_header_stct),
            "::",
            stringify!(initial_term_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).active_term_id) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_setup_header_stct),
            "::",
            stringify!(active_term_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).term_length) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_setup_header_stct),
            "::",
            stringify!(term_length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mtu) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_setup_header_stct),
            "::",
            stringify!(mtu)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ttl) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_setup_header_stct),
            "::",
            stringify!(ttl)
        )
    );
}
pub type aeron_setup_header_t = aeron_setup_header_stct;
#[repr(C, packed(4))]
#[derive(Copy, Clone)]
pub struct aeron_data_header_stct {
    pub frame_header: aeron_frame_header_t,
    pub term_offset: i32,
    pub session_id: i32,
    pub stream_id: i32,
    pub term_id: i32,
    pub reserved_value: i64,
}
#[test]
fn bindgen_test_layout_aeron_data_header_stct() {
    const UNINIT: ::std::mem::MaybeUninit<aeron_data_header_stct> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_data_header_stct>(),
        32usize,
        concat!("Size of: ", stringify!(aeron_data_header_stct))
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_data_header_stct>(),
        4usize,
        concat!("Alignment of ", stringify!(aeron_data_header_stct))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).frame_header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_data_header_stct),
            "::",
            stringify!(frame_header)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).term_offset) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_data_header_stct),
            "::",
            stringify!(term_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).session_id) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_data_header_stct),
            "::",
            stringify!(session_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stream_id) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_data_header_stct),
            "::",
            stringify!(stream_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).term_id) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_data_header_stct),
            "::",
            stringify!(term_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved_value) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_data_header_stct),
            "::",
            stringify!(reserved_value)
        )
    );
}
pub type aeron_data_header_t = aeron_data_header_stct;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aeron_nak_header_stct {
    pub frame_header: aeron_frame_header_t,
    pub session_id: i32,
    pub stream_id: i32,
    pub term_id: i32,
    pub term_offset: i32,
    pub length: i32,
}
#[test]
fn bindgen_test_layout_aeron_nak_header_stct() {
    const UNINIT: ::std::mem::MaybeUninit<aeron_nak_header_stct> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_nak_header_stct>(),
        28usize,
        concat!("Size of: ", stringify!(aeron_nak_header_stct))
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_nak_header_stct>(),
        4usize,
        concat!("Alignment of ", stringify!(aeron_nak_header_stct))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).frame_header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_nak_header_stct),
            "::",
            stringify!(frame_header)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).session_id) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_nak_header_stct),
            "::",
            stringify!(session_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stream_id) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_nak_header_stct),
            "::",
            stringify!(stream_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).term_id) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_nak_header_stct),
            "::",
            stringify!(term_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).term_offset) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_nak_header_stct),
            "::",
            stringify!(term_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_nak_header_stct),
            "::",
            stringify!(length)
        )
    );
}
pub type aeron_nak_header_t = aeron_nak_header_stct;
#[repr(C, packed(4))]
#[derive(Copy, Clone)]
pub struct aeron_status_message_header_stct {
    pub frame_header: aeron_frame_header_t,
    pub session_id: i32,
    pub stream_id: i32,
    pub consumption_term_id: i32,
    pub consumption_term_offset: i32,
    pub receiver_window: i32,
    pub receiver_id: i64,
}
#[test]
fn bindgen_test_layout_aeron_status_message_header_stct() {
    const UNINIT: ::std::mem::MaybeUninit<aeron_status_message_header_stct> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_status_message_header_stct>(),
        36usize,
        concat!("Size of: ", stringify!(aeron_status_message_header_stct))
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_status_message_header_stct>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(aeron_status_message_header_stct)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).frame_header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_status_message_header_stct),
            "::",
            stringify!(frame_header)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).session_id) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_status_message_header_stct),
            "::",
            stringify!(session_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stream_id) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_status_message_header_stct),
            "::",
            stringify!(stream_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).consumption_term_id) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_status_message_header_stct),
            "::",
            stringify!(consumption_term_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).consumption_term_offset) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_status_message_header_stct),
            "::",
            stringify!(consumption_term_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).receiver_window) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_status_message_header_stct),
            "::",
            stringify!(receiver_window)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).receiver_id) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_status_message_header_stct),
            "::",
            stringify!(receiver_id)
        )
    );
}
pub type aeron_status_message_header_t = aeron_status_message_header_stct;
#[repr(C, packed(4))]
#[derive(Copy, Clone)]
pub struct aeron_status_message_optional_header_stct {
    pub group_tag: i64,
}
#[test]
fn bindgen_test_layout_aeron_status_message_optional_header_stct() {
    const UNINIT: ::std::mem::MaybeUninit<aeron_status_message_optional_header_stct> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_status_message_optional_header_stct>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(aeron_status_message_optional_header_stct)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_status_message_optional_header_stct>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(aeron_status_message_optional_header_stct)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).group_tag) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_status_message_optional_header_stct),
            "::",
            stringify!(group_tag)
        )
    );
}
pub type aeron_status_message_optional_header_t = aeron_status_message_optional_header_stct;
#[repr(C, packed(4))]
#[derive(Copy, Clone)]
pub struct aeron_rttm_header_stct {
    pub frame_header: aeron_frame_header_t,
    pub session_id: i32,
    pub stream_id: i32,
    pub echo_timestamp: i64,
    pub reception_delta: i64,
    pub receiver_id: i64,
}
#[test]
fn bindgen_test_layout_aeron_rttm_header_stct() {
    const UNINIT: ::std::mem::MaybeUninit<aeron_rttm_header_stct> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_rttm_header_stct>(),
        40usize,
        concat!("Size of: ", stringify!(aeron_rttm_header_stct))
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_rttm_header_stct>(),
        4usize,
        concat!("Alignment of ", stringify!(aeron_rttm_header_stct))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).frame_header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_rttm_header_stct),
            "::",
            stringify!(frame_header)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).session_id) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_rttm_header_stct),
            "::",
            stringify!(session_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stream_id) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_rttm_header_stct),
            "::",
            stringify!(stream_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).echo_timestamp) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_rttm_header_stct),
            "::",
            stringify!(echo_timestamp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reception_delta) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_rttm_header_stct),
            "::",
            stringify!(reception_delta)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).receiver_id) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_rttm_header_stct),
            "::",
            stringify!(receiver_id)
        )
    );
}
pub type aeron_rttm_header_t = aeron_rttm_header_stct;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct aeron_resolution_header_stct {
    pub res_type: i8,
    pub res_flags: u8,
    pub udp_port: u16,
    pub age_in_ms: i32,
}
#[test]
fn bindgen_test_layout_aeron_resolution_header_stct() {
    const UNINIT: ::std::mem::MaybeUninit<aeron_resolution_header_stct> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_resolution_header_stct>(),
        8usize,
        concat!("Size of: ", stringify!(aeron_resolution_header_stct))
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_resolution_header_stct>(),
        1usize,
        concat!("Alignment of ", stringify!(aeron_resolution_header_stct))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).res_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_resolution_header_stct),
            "::",
            stringify!(res_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).res_flags) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_resolution_header_stct),
            "::",
            stringify!(res_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).udp_port) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_resolution_header_stct),
            "::",
            stringify!(udp_port)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).age_in_ms) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_resolution_header_stct),
            "::",
            stringify!(age_in_ms)
        )
    );
}
pub type aeron_resolution_header_t = aeron_resolution_header_stct;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct aeron_resolution_header_ipv4_stct {
    pub resolution_header: aeron_resolution_header_t,
    pub addr: [u8; 4usize],
    pub name_length: i16,
}
#[test]
fn bindgen_test_layout_aeron_resolution_header_ipv4_stct() {
    const UNINIT: ::std::mem::MaybeUninit<aeron_resolution_header_ipv4_stct> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_resolution_header_ipv4_stct>(),
        14usize,
        concat!("Size of: ", stringify!(aeron_resolution_header_ipv4_stct))
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_resolution_header_ipv4_stct>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(aeron_resolution_header_ipv4_stct)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).resolution_header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_resolution_header_ipv4_stct),
            "::",
            stringify!(resolution_header)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).addr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_resolution_header_ipv4_stct),
            "::",
            stringify!(addr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name_length) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_resolution_header_ipv4_stct),
            "::",
            stringify!(name_length)
        )
    );
}
pub type aeron_resolution_header_ipv4_t = aeron_resolution_header_ipv4_stct;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct aeron_resolution_header_ipv6_stct {
    pub resolution_header: aeron_resolution_header_t,
    pub addr: [u8; 16usize],
    pub name_length: i16,
}
#[test]
fn bindgen_test_layout_aeron_resolution_header_ipv6_stct() {
    const UNINIT: ::std::mem::MaybeUninit<aeron_resolution_header_ipv6_stct> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_resolution_header_ipv6_stct>(),
        26usize,
        concat!("Size of: ", stringify!(aeron_resolution_header_ipv6_stct))
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_resolution_header_ipv6_stct>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(aeron_resolution_header_ipv6_stct)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).resolution_header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_resolution_header_ipv6_stct),
            "::",
            stringify!(resolution_header)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).addr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_resolution_header_ipv6_stct),
            "::",
            stringify!(addr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name_length) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_resolution_header_ipv6_stct),
            "::",
            stringify!(name_length)
        )
    );
}
pub type aeron_resolution_header_ipv6_t = aeron_resolution_header_ipv6_stct;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct aeron_option_hdeader_stct {
    pub option_length: u16,
    pub type_: u16,
}
#[test]
fn bindgen_test_layout_aeron_option_hdeader_stct() {
    const UNINIT: ::std::mem::MaybeUninit<aeron_option_hdeader_stct> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_option_hdeader_stct>(),
        4usize,
        concat!("Size of: ", stringify!(aeron_option_hdeader_stct))
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_option_hdeader_stct>(),
        1usize,
        concat!("Alignment of ", stringify!(aeron_option_hdeader_stct))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).option_length) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_option_hdeader_stct),
            "::",
            stringify!(option_length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_option_hdeader_stct),
            "::",
            stringify!(type_)
        )
    );
}
pub type aeron_option_header_t = aeron_option_hdeader_stct;
extern "C" {
    pub fn aeron_udp_protocol_group_tag(
        sm: *mut aeron_status_message_header_t,
        group_tag: *mut i64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_res_header_entry_length_ipv4(header: *mut aeron_resolution_header_ipv4_t)
        -> usize;
}
extern "C" {
    pub fn aeron_res_header_entry_length_ipv6(header: *mut aeron_resolution_header_ipv6_t)
        -> usize;
}
extern "C" {
    pub fn aeron_res_header_entry_length(
        res: *mut ::std::os::raw::c_void,
        remaining: usize,
    ) -> ::std::os::raw::c_int;
}
#[repr(C, packed(4))]
#[derive(Copy, Clone)]
pub struct aeron_logbuffer_metadata_stct {
    pub term_tail_counters: [i64; 3usize],
    pub active_term_count: i32,
    pub pad1: [u8; 100usize],
    pub end_of_stream_position: i64,
    pub is_connected: i32,
    pub active_transport_count: i32,
    pub pad2: [u8; 112usize],
    pub correlation_id: i64,
    pub initial_term_id: i32,
    pub default_frame_header_length: i32,
    pub mtu_length: i32,
    pub term_length: i32,
    pub page_size: i32,
    pub pad3: [u8; 36usize],
}
#[test]
fn bindgen_test_layout_aeron_logbuffer_metadata_stct() {
    const UNINIT: ::std::mem::MaybeUninit<aeron_logbuffer_metadata_stct> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_logbuffer_metadata_stct>(),
        320usize,
        concat!("Size of: ", stringify!(aeron_logbuffer_metadata_stct))
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_logbuffer_metadata_stct>(),
        4usize,
        concat!("Alignment of ", stringify!(aeron_logbuffer_metadata_stct))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).term_tail_counters) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_logbuffer_metadata_stct),
            "::",
            stringify!(term_tail_counters)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).active_term_count) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_logbuffer_metadata_stct),
            "::",
            stringify!(active_term_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad1) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_logbuffer_metadata_stct),
            "::",
            stringify!(pad1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).end_of_stream_position) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_logbuffer_metadata_stct),
            "::",
            stringify!(end_of_stream_position)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).is_connected) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_logbuffer_metadata_stct),
            "::",
            stringify!(is_connected)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).active_transport_count) as usize - ptr as usize },
        140usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_logbuffer_metadata_stct),
            "::",
            stringify!(active_transport_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad2) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_logbuffer_metadata_stct),
            "::",
            stringify!(pad2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).correlation_id) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_logbuffer_metadata_stct),
            "::",
            stringify!(correlation_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).initial_term_id) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_logbuffer_metadata_stct),
            "::",
            stringify!(initial_term_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).default_frame_header_length) as usize - ptr as usize },
        268usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_logbuffer_metadata_stct),
            "::",
            stringify!(default_frame_header_length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mtu_length) as usize - ptr as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_logbuffer_metadata_stct),
            "::",
            stringify!(mtu_length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).term_length) as usize - ptr as usize },
        276usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_logbuffer_metadata_stct),
            "::",
            stringify!(term_length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).page_size) as usize - ptr as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_logbuffer_metadata_stct),
            "::",
            stringify!(page_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad3) as usize - ptr as usize },
        284usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_logbuffer_metadata_stct),
            "::",
            stringify!(pad3)
        )
    );
}
pub type aeron_logbuffer_metadata_t = aeron_logbuffer_metadata_stct;
extern "C" {
    pub fn aeron_logbuffer_check_term_length(term_length: u64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_logbuffer_check_page_size(page_size: u64) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aeron_mapped_file_stct {
    pub addr: *mut ::std::os::raw::c_void,
    pub length: usize,
}
#[test]
fn bindgen_test_layout_aeron_mapped_file_stct() {
    const UNINIT: ::std::mem::MaybeUninit<aeron_mapped_file_stct> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_mapped_file_stct>(),
        16usize,
        concat!("Size of: ", stringify!(aeron_mapped_file_stct))
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_mapped_file_stct>(),
        8usize,
        concat!("Alignment of ", stringify!(aeron_mapped_file_stct))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).addr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_mapped_file_stct),
            "::",
            stringify!(addr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_mapped_file_stct),
            "::",
            stringify!(length)
        )
    );
}
pub type aeron_mapped_file_t = aeron_mapped_file_stct;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aeron_mapped_buffer_stct {
    pub addr: *mut u8,
    pub length: usize,
}
#[test]
fn bindgen_test_layout_aeron_mapped_buffer_stct() {
    const UNINIT: ::std::mem::MaybeUninit<aeron_mapped_buffer_stct> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_mapped_buffer_stct>(),
        16usize,
        concat!("Size of: ", stringify!(aeron_mapped_buffer_stct))
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_mapped_buffer_stct>(),
        8usize,
        concat!("Alignment of ", stringify!(aeron_mapped_buffer_stct))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).addr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_mapped_buffer_stct),
            "::",
            stringify!(addr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_mapped_buffer_stct),
            "::",
            stringify!(length)
        )
    );
}
pub type aeron_mapped_buffer_t = aeron_mapped_buffer_stct;
extern "C" {
    pub fn aeron_is_directory(path: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_map_new_file(
        mapped_file: *mut aeron_mapped_file_t,
        path: *const ::std::os::raw::c_char,
        fill_with_zeroes: bool,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_map_existing_file(
        mapped_file: *mut aeron_mapped_file_t,
        path: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_unmap(mapped_file: *mut aeron_mapped_file_t) -> ::std::os::raw::c_int;
}
pub type aeron_usable_fs_space_func_t =
    ::std::option::Option<unsafe extern "C" fn(path: *const ::std::os::raw::c_char) -> u64>;
extern "C" {
    pub fn aeron_file_length(path: *const ::std::os::raw::c_char) -> i64;
}
extern "C" {
    pub fn aeron_usable_fs_space(path: *const ::std::os::raw::c_char) -> u64;
}
extern "C" {
    pub fn aeron_usable_fs_space_disabled(path: *const ::std::os::raw::c_char) -> u64;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aeron_mapped_raw_log_stct {
    pub term_buffers: [aeron_mapped_buffer_t; 3usize],
    pub log_meta_data: aeron_mapped_buffer_t,
    pub mapped_file: aeron_mapped_file_t,
    pub term_length: usize,
}
#[test]
fn bindgen_test_layout_aeron_mapped_raw_log_stct() {
    const UNINIT: ::std::mem::MaybeUninit<aeron_mapped_raw_log_stct> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_mapped_raw_log_stct>(),
        88usize,
        concat!("Size of: ", stringify!(aeron_mapped_raw_log_stct))
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_mapped_raw_log_stct>(),
        8usize,
        concat!("Alignment of ", stringify!(aeron_mapped_raw_log_stct))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).term_buffers) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_mapped_raw_log_stct),
            "::",
            stringify!(term_buffers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).log_meta_data) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_mapped_raw_log_stct),
            "::",
            stringify!(log_meta_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mapped_file) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_mapped_raw_log_stct),
            "::",
            stringify!(mapped_file)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).term_length) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_mapped_raw_log_stct),
            "::",
            stringify!(term_length)
        )
    );
}
pub type aeron_mapped_raw_log_t = aeron_mapped_raw_log_stct;
extern "C" {
    pub fn aeron_ipc_publication_location(
        dst: *mut ::std::os::raw::c_char,
        length: usize,
        aeron_dir: *const ::std::os::raw::c_char,
        correlation_id: i64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_network_publication_location(
        dst: *mut ::std::os::raw::c_char,
        length: usize,
        aeron_dir: *const ::std::os::raw::c_char,
        correlation_id: i64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_publication_image_location(
        dst: *mut ::std::os::raw::c_char,
        length: usize,
        aeron_dir: *const ::std::os::raw::c_char,
        correlation_id: i64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_temp_filename(filename: *mut ::std::os::raw::c_char, length: usize) -> usize;
}
pub type aeron_raw_log_map_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut aeron_mapped_raw_log_t,
        arg2: *const ::std::os::raw::c_char,
        arg3: bool,
        arg4: u64,
        arg5: u64,
    ) -> ::std::os::raw::c_int,
>;
pub type aeron_raw_log_close_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut aeron_mapped_raw_log_t,
        filename: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int,
>;
pub type aeron_raw_log_free_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut aeron_mapped_raw_log_t,
        filename: *const ::std::os::raw::c_char,
    ) -> bool,
>;
extern "C" {
    pub fn aeron_raw_log_map(
        mapped_raw_log: *mut aeron_mapped_raw_log_t,
        path: *const ::std::os::raw::c_char,
        use_sparse_files: bool,
        term_length: u64,
        page_size: u64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_raw_log_map_existing(
        mapped_raw_log: *mut aeron_mapped_raw_log_t,
        path: *const ::std::os::raw::c_char,
        pre_touch: bool,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_raw_log_close(
        mapped_raw_log: *mut aeron_mapped_raw_log_t,
        filename: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_raw_log_free(
        mapped_raw_log: *mut aeron_mapped_raw_log_t,
        filename: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn aeron_file_resolve(
        parent: *const ::std::os::raw::c_char,
        child: *const ::std::os::raw::c_char,
        buffer: *mut ::std::os::raw::c_char,
        buffer_len: usize,
    ) -> ::std::os::raw::c_int;
}
pub const aeron_queue_offer_result_stct_AERON_OFFER_SUCCESS: aeron_queue_offer_result_stct = 0;
pub const aeron_queue_offer_result_stct_AERON_OFFER_ERROR: aeron_queue_offer_result_stct = -2;
pub const aeron_queue_offer_result_stct_AERON_OFFER_FULL: aeron_queue_offer_result_stct = -1;
pub type aeron_queue_offer_result_stct = ::std::os::raw::c_int;
pub use self::aeron_queue_offer_result_stct as aeron_queue_offer_result_t;
pub type aeron_queue_drain_func_t = ::std::option::Option<
    unsafe extern "C" fn(clientd: *mut ::std::os::raw::c_void, item: *mut ::std::os::raw::c_void),
>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aeron_spsc_concurrent_array_queue_stct {
    pub padding: [i8; 56usize],
    pub producer: aeron_spsc_concurrent_array_queue_stct__bindgen_ty_1,
    pub consumer: aeron_spsc_concurrent_array_queue_stct__bindgen_ty_2,
    pub capacity: usize,
    pub mask: usize,
    pub buffer: *mut *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aeron_spsc_concurrent_array_queue_stct__bindgen_ty_1 {
    pub tail: u64,
    pub head_cache: u64,
    pub padding: [i8; 48usize],
}
#[test]
fn bindgen_test_layout_aeron_spsc_concurrent_array_queue_stct__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<aeron_spsc_concurrent_array_queue_stct__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_spsc_concurrent_array_queue_stct__bindgen_ty_1>(),
        64usize,
        concat!(
            "Size of: ",
            stringify!(aeron_spsc_concurrent_array_queue_stct__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_spsc_concurrent_array_queue_stct__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(aeron_spsc_concurrent_array_queue_stct__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tail) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_spsc_concurrent_array_queue_stct__bindgen_ty_1),
            "::",
            stringify!(tail)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).head_cache) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_spsc_concurrent_array_queue_stct__bindgen_ty_1),
            "::",
            stringify!(head_cache)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).padding) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_spsc_concurrent_array_queue_stct__bindgen_ty_1),
            "::",
            stringify!(padding)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aeron_spsc_concurrent_array_queue_stct__bindgen_ty_2 {
    pub head: u64,
    pub padding: [i8; 56usize],
}
#[test]
fn bindgen_test_layout_aeron_spsc_concurrent_array_queue_stct__bindgen_ty_2() {
    const UNINIT: ::std::mem::MaybeUninit<aeron_spsc_concurrent_array_queue_stct__bindgen_ty_2> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_spsc_concurrent_array_queue_stct__bindgen_ty_2>(),
        64usize,
        concat!(
            "Size of: ",
            stringify!(aeron_spsc_concurrent_array_queue_stct__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_spsc_concurrent_array_queue_stct__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(aeron_spsc_concurrent_array_queue_stct__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).head) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_spsc_concurrent_array_queue_stct__bindgen_ty_2),
            "::",
            stringify!(head)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).padding) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_spsc_concurrent_array_queue_stct__bindgen_ty_2),
            "::",
            stringify!(padding)
        )
    );
}
#[test]
fn bindgen_test_layout_aeron_spsc_concurrent_array_queue_stct() {
    const UNINIT: ::std::mem::MaybeUninit<aeron_spsc_concurrent_array_queue_stct> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_spsc_concurrent_array_queue_stct>(),
        208usize,
        concat!(
            "Size of: ",
            stringify!(aeron_spsc_concurrent_array_queue_stct)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_spsc_concurrent_array_queue_stct>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(aeron_spsc_concurrent_array_queue_stct)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).padding) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_spsc_concurrent_array_queue_stct),
            "::",
            stringify!(padding)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).producer) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_spsc_concurrent_array_queue_stct),
            "::",
            stringify!(producer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).consumer) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_spsc_concurrent_array_queue_stct),
            "::",
            stringify!(consumer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).capacity) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_spsc_concurrent_array_queue_stct),
            "::",
            stringify!(capacity)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mask) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_spsc_concurrent_array_queue_stct),
            "::",
            stringify!(mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buffer) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_spsc_concurrent_array_queue_stct),
            "::",
            stringify!(buffer)
        )
    );
}
pub type aeron_spsc_concurrent_array_queue_t = aeron_spsc_concurrent_array_queue_stct;
extern "C" {
    pub fn aeron_spsc_concurrent_array_queue_init(
        queue: *mut aeron_spsc_concurrent_array_queue_t,
        length: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_spsc_concurrent_array_queue_close(
        queue: *mut aeron_spsc_concurrent_array_queue_t,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aeron_mpsc_concurrent_array_queue_stct {
    pub padding: [i8; 56usize],
    pub producer: aeron_mpsc_concurrent_array_queue_stct__bindgen_ty_1,
    pub consumer: aeron_mpsc_concurrent_array_queue_stct__bindgen_ty_2,
    pub capacity: usize,
    pub mask: usize,
    pub buffer: *mut *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aeron_mpsc_concurrent_array_queue_stct__bindgen_ty_1 {
    pub tail: u64,
    pub head_cache: u64,
    pub shared_head_cache: u64,
    pub padding: [i8; 40usize],
}
#[test]
fn bindgen_test_layout_aeron_mpsc_concurrent_array_queue_stct__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<aeron_mpsc_concurrent_array_queue_stct__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_mpsc_concurrent_array_queue_stct__bindgen_ty_1>(),
        64usize,
        concat!(
            "Size of: ",
            stringify!(aeron_mpsc_concurrent_array_queue_stct__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_mpsc_concurrent_array_queue_stct__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(aeron_mpsc_concurrent_array_queue_stct__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tail) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_mpsc_concurrent_array_queue_stct__bindgen_ty_1),
            "::",
            stringify!(tail)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).head_cache) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_mpsc_concurrent_array_queue_stct__bindgen_ty_1),
            "::",
            stringify!(head_cache)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).shared_head_cache) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_mpsc_concurrent_array_queue_stct__bindgen_ty_1),
            "::",
            stringify!(shared_head_cache)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).padding) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_mpsc_concurrent_array_queue_stct__bindgen_ty_1),
            "::",
            stringify!(padding)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aeron_mpsc_concurrent_array_queue_stct__bindgen_ty_2 {
    pub head: u64,
    pub padding: [i8; 56usize],
}
#[test]
fn bindgen_test_layout_aeron_mpsc_concurrent_array_queue_stct__bindgen_ty_2() {
    const UNINIT: ::std::mem::MaybeUninit<aeron_mpsc_concurrent_array_queue_stct__bindgen_ty_2> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_mpsc_concurrent_array_queue_stct__bindgen_ty_2>(),
        64usize,
        concat!(
            "Size of: ",
            stringify!(aeron_mpsc_concurrent_array_queue_stct__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_mpsc_concurrent_array_queue_stct__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(aeron_mpsc_concurrent_array_queue_stct__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).head) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_mpsc_concurrent_array_queue_stct__bindgen_ty_2),
            "::",
            stringify!(head)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).padding) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_mpsc_concurrent_array_queue_stct__bindgen_ty_2),
            "::",
            stringify!(padding)
        )
    );
}
#[test]
fn bindgen_test_layout_aeron_mpsc_concurrent_array_queue_stct() {
    const UNINIT: ::std::mem::MaybeUninit<aeron_mpsc_concurrent_array_queue_stct> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_mpsc_concurrent_array_queue_stct>(),
        208usize,
        concat!(
            "Size of: ",
            stringify!(aeron_mpsc_concurrent_array_queue_stct)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_mpsc_concurrent_array_queue_stct>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(aeron_mpsc_concurrent_array_queue_stct)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).padding) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_mpsc_concurrent_array_queue_stct),
            "::",
            stringify!(padding)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).producer) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_mpsc_concurrent_array_queue_stct),
            "::",
            stringify!(producer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).consumer) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_mpsc_concurrent_array_queue_stct),
            "::",
            stringify!(consumer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).capacity) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_mpsc_concurrent_array_queue_stct),
            "::",
            stringify!(capacity)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mask) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_mpsc_concurrent_array_queue_stct),
            "::",
            stringify!(mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buffer) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_mpsc_concurrent_array_queue_stct),
            "::",
            stringify!(buffer)
        )
    );
}
pub type aeron_mpsc_concurrent_array_queue_t = aeron_mpsc_concurrent_array_queue_stct;
extern "C" {
    pub fn aeron_mpsc_concurrent_array_queue_init(
        queue: *mut aeron_mpsc_concurrent_array_queue_t,
        length: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_mpsc_concurrent_array_queue_close(
        queue: *mut aeron_mpsc_concurrent_array_queue_t,
    ) -> ::std::os::raw::c_int;
}
#[repr(C, packed(4))]
#[derive(Copy, Clone)]
pub struct aeron_rb_descriptor_stct {
    pub begin_pad: [u8; 128usize],
    pub tail_position: i64,
    pub tail_pad: [u8; 120usize],
    pub head_cache_position: i64,
    pub head_cache_pad: [u8; 120usize],
    pub head_position: i64,
    pub head_pad: [u8; 120usize],
    pub correlation_counter: i64,
    pub correlation_counter_pad: [u8; 120usize],
    pub consumer_heartbeat: i64,
    pub consumer_heartbeat_pad: [u8; 120usize],
}
#[test]
fn bindgen_test_layout_aeron_rb_descriptor_stct() {
    const UNINIT: ::std::mem::MaybeUninit<aeron_rb_descriptor_stct> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_rb_descriptor_stct>(),
        768usize,
        concat!("Size of: ", stringify!(aeron_rb_descriptor_stct))
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_rb_descriptor_stct>(),
        4usize,
        concat!("Alignment of ", stringify!(aeron_rb_descriptor_stct))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).begin_pad) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_rb_descriptor_stct),
            "::",
            stringify!(begin_pad)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tail_position) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_rb_descriptor_stct),
            "::",
            stringify!(tail_position)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tail_pad) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_rb_descriptor_stct),
            "::",
            stringify!(tail_pad)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).head_cache_position) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_rb_descriptor_stct),
            "::",
            stringify!(head_cache_position)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).head_cache_pad) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_rb_descriptor_stct),
            "::",
            stringify!(head_cache_pad)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).head_position) as usize - ptr as usize },
        384usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_rb_descriptor_stct),
            "::",
            stringify!(head_position)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).head_pad) as usize - ptr as usize },
        392usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_rb_descriptor_stct),
            "::",
            stringify!(head_pad)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).correlation_counter) as usize - ptr as usize },
        512usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_rb_descriptor_stct),
            "::",
            stringify!(correlation_counter)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).correlation_counter_pad) as usize - ptr as usize },
        520usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_rb_descriptor_stct),
            "::",
            stringify!(correlation_counter_pad)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).consumer_heartbeat) as usize - ptr as usize },
        640usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_rb_descriptor_stct),
            "::",
            stringify!(consumer_heartbeat)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).consumer_heartbeat_pad) as usize - ptr as usize },
        648usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_rb_descriptor_stct),
            "::",
            stringify!(consumer_heartbeat_pad)
        )
    );
}
pub type aeron_rb_descriptor_t = aeron_rb_descriptor_stct;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aeron_rb_record_descriptor_stct {
    pub length: i32,
    pub msg_type_id: i32,
}
#[test]
fn bindgen_test_layout_aeron_rb_record_descriptor_stct() {
    const UNINIT: ::std::mem::MaybeUninit<aeron_rb_record_descriptor_stct> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_rb_record_descriptor_stct>(),
        8usize,
        concat!("Size of: ", stringify!(aeron_rb_record_descriptor_stct))
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_rb_record_descriptor_stct>(),
        4usize,
        concat!("Alignment of ", stringify!(aeron_rb_record_descriptor_stct))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_rb_record_descriptor_stct),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msg_type_id) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_rb_record_descriptor_stct),
            "::",
            stringify!(msg_type_id)
        )
    );
}
pub type aeron_rb_record_descriptor_t = aeron_rb_record_descriptor_stct;
pub const aeron_rb_write_result_stct_AERON_RB_SUCCESS: aeron_rb_write_result_stct = 0;
pub const aeron_rb_write_result_stct_AERON_RB_ERROR: aeron_rb_write_result_stct = -2;
pub const aeron_rb_write_result_stct_AERON_RB_FULL: aeron_rb_write_result_stct = -1;
pub type aeron_rb_write_result_stct = ::std::os::raw::c_int;
pub use self::aeron_rb_write_result_stct as aeron_rb_write_result_t;
pub type aeron_rb_handler_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: i32,
        arg2: *const ::std::os::raw::c_void,
        arg3: usize,
        arg4: *mut ::std::os::raw::c_void,
    ),
>;
pub const aeron_rb_read_action_stct_AERON_RB_ABORT: aeron_rb_read_action_stct = 0;
pub const aeron_rb_read_action_stct_AERON_RB_BREAK: aeron_rb_read_action_stct = 1;
pub const aeron_rb_read_action_stct_AERON_RB_COMMIT: aeron_rb_read_action_stct = 2;
pub const aeron_rb_read_action_stct_AERON_RB_CONTINUE: aeron_rb_read_action_stct = 3;
pub type aeron_rb_read_action_stct = ::std::os::raw::c_uint;
pub use self::aeron_rb_read_action_stct as aeron_rb_read_action_t;
pub type aeron_rb_controlled_handler_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: i32,
        arg2: *const ::std::os::raw::c_void,
        arg3: usize,
        arg4: *mut ::std::os::raw::c_void,
    ) -> aeron_rb_read_action_t,
>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aeron_mpsc_rb_stct {
    pub buffer: *mut u8,
    pub descriptor: *mut aeron_rb_descriptor_t,
    pub capacity: usize,
    pub max_message_length: usize,
}
#[test]
fn bindgen_test_layout_aeron_mpsc_rb_stct() {
    const UNINIT: ::std::mem::MaybeUninit<aeron_mpsc_rb_stct> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_mpsc_rb_stct>(),
        32usize,
        concat!("Size of: ", stringify!(aeron_mpsc_rb_stct))
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_mpsc_rb_stct>(),
        8usize,
        concat!("Alignment of ", stringify!(aeron_mpsc_rb_stct))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buffer) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_mpsc_rb_stct),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).descriptor) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_mpsc_rb_stct),
            "::",
            stringify!(descriptor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).capacity) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_mpsc_rb_stct),
            "::",
            stringify!(capacity)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_message_length) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_mpsc_rb_stct),
            "::",
            stringify!(max_message_length)
        )
    );
}
pub type aeron_mpsc_rb_t = aeron_mpsc_rb_stct;
extern "C" {
    pub fn aeron_mpsc_rb_init(
        ring_buffer: *mut aeron_mpsc_rb_t,
        buffer: *mut ::std::os::raw::c_void,
        length: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_mpsc_rb_write(
        ring_buffer: *mut aeron_mpsc_rb_t,
        msg_type_id: i32,
        msg: *const ::std::os::raw::c_void,
        length: usize,
    ) -> aeron_rb_write_result_t;
}
extern "C" {
    pub fn aeron_mpsc_rb_try_claim(
        ring_buffer: *mut aeron_mpsc_rb_t,
        msg_type_id: i32,
        length: usize,
    ) -> i32;
}
extern "C" {
    pub fn aeron_mpsc_rb_commit(
        ring_buffer: *mut aeron_mpsc_rb_t,
        offset: i32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_mpsc_rb_abort(
        ring_buffer: *mut aeron_mpsc_rb_t,
        offset: i32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_mpsc_rb_read(
        ring_buffer: *mut aeron_mpsc_rb_t,
        handler: aeron_rb_handler_t,
        clientd: *mut ::std::os::raw::c_void,
        message_count_limit: usize,
    ) -> usize;
}
extern "C" {
    pub fn aeron_mpsc_rb_controlled_read(
        ring_buffer: *mut aeron_mpsc_rb_t,
        handler: aeron_rb_controlled_handler_t,
        clientd: *mut ::std::os::raw::c_void,
        message_count_limit: usize,
    ) -> usize;
}
extern "C" {
    pub fn aeron_mpsc_rb_next_correlation_id(ring_buffer: *mut aeron_mpsc_rb_t) -> i64;
}
extern "C" {
    pub fn aeron_mpsc_rb_consumer_heartbeat_time(ring_buffer: *mut aeron_mpsc_rb_t, now_ms: i64);
}
extern "C" {
    pub fn aeron_mpsc_rb_consumer_heartbeat_time_value(ring_buffer: *mut aeron_mpsc_rb_t) -> i64;
}
extern "C" {
    pub fn aeron_mpsc_rb_unblock(ring_buffer: *mut aeron_mpsc_rb_t) -> bool;
}
#[repr(C, packed(4))]
#[derive(Copy, Clone)]
pub struct aeron_broadcast_descriptor_stct {
    pub tail_intent_counter: i64,
    pub tail_counter: i64,
    pub latest_counter: i64,
    pub pad: [u8; 104usize],
}
#[test]
fn bindgen_test_layout_aeron_broadcast_descriptor_stct() {
    const UNINIT: ::std::mem::MaybeUninit<aeron_broadcast_descriptor_stct> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_broadcast_descriptor_stct>(),
        128usize,
        concat!("Size of: ", stringify!(aeron_broadcast_descriptor_stct))
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_broadcast_descriptor_stct>(),
        4usize,
        concat!("Alignment of ", stringify!(aeron_broadcast_descriptor_stct))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tail_intent_counter) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_broadcast_descriptor_stct),
            "::",
            stringify!(tail_intent_counter)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tail_counter) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_broadcast_descriptor_stct),
            "::",
            stringify!(tail_counter)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).latest_counter) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_broadcast_descriptor_stct),
            "::",
            stringify!(latest_counter)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_broadcast_descriptor_stct),
            "::",
            stringify!(pad)
        )
    );
}
pub type aeron_broadcast_descriptor_t = aeron_broadcast_descriptor_stct;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aeron_broadcast_record_descriptor_stct {
    pub length: i32,
    pub msg_type_id: i32,
}
#[test]
fn bindgen_test_layout_aeron_broadcast_record_descriptor_stct() {
    const UNINIT: ::std::mem::MaybeUninit<aeron_broadcast_record_descriptor_stct> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_broadcast_record_descriptor_stct>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(aeron_broadcast_record_descriptor_stct)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_broadcast_record_descriptor_stct>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(aeron_broadcast_record_descriptor_stct)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_broadcast_record_descriptor_stct),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msg_type_id) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_broadcast_record_descriptor_stct),
            "::",
            stringify!(msg_type_id)
        )
    );
}
pub type aeron_broadcast_record_descriptor_t = aeron_broadcast_record_descriptor_stct;
pub type aeron_flow_control_strategy_on_idle_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        state: *mut ::std::os::raw::c_void,
        now_ns: i64,
        snd_lmt: i64,
        snd_pos: i64,
        is_end_of_stream: bool,
    ) -> i64,
>;
pub type aeron_flow_control_strategy_on_sm_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        state: *mut ::std::os::raw::c_void,
        sm: *const u8,
        length: usize,
        recv_addr: *mut sockaddr_storage,
        snd_lmt: i64,
        initial_term_id: i32,
        position_bits_to_shift: usize,
        now_ns: i64,
    ) -> i64,
>;
pub type aeron_flow_control_strategy_on_setup_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        state: *mut ::std::os::raw::c_void,
        setup: *const u8,
        length: usize,
        now_ns: i64,
        snd_lmt: i64,
        position_bits_to_shift: usize,
        snd_pos: i64,
    ) -> i64,
>;
pub type aeron_flow_control_strategy_fini_func_t = ::std::option::Option<
    unsafe extern "C" fn(strategy: *mut aeron_flow_control_strategy_t) -> ::std::os::raw::c_int,
>;
pub type aeron_flow_control_strategy_has_required_receivers_func_t = ::std::option::Option<
    unsafe extern "C" fn(strategy: *mut aeron_flow_control_strategy_t) -> bool,
>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aeron_flow_control_strategy_stct {
    pub on_status_message: aeron_flow_control_strategy_on_sm_func_t,
    pub on_idle: aeron_flow_control_strategy_on_idle_func_t,
    pub on_setup: aeron_flow_control_strategy_on_setup_func_t,
    pub fini: aeron_flow_control_strategy_fini_func_t,
    pub has_required_receivers: aeron_flow_control_strategy_has_required_receivers_func_t,
    pub state: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_aeron_flow_control_strategy_stct() {
    const UNINIT: ::std::mem::MaybeUninit<aeron_flow_control_strategy_stct> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_flow_control_strategy_stct>(),
        48usize,
        concat!("Size of: ", stringify!(aeron_flow_control_strategy_stct))
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_flow_control_strategy_stct>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(aeron_flow_control_strategy_stct)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).on_status_message) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_flow_control_strategy_stct),
            "::",
            stringify!(on_status_message)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).on_idle) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_flow_control_strategy_stct),
            "::",
            stringify!(on_idle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).on_setup) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_flow_control_strategy_stct),
            "::",
            stringify!(on_setup)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fini) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_flow_control_strategy_stct),
            "::",
            stringify!(fini)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_required_receivers) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_flow_control_strategy_stct),
            "::",
            stringify!(has_required_receivers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_flow_control_strategy_stct),
            "::",
            stringify!(state)
        )
    );
}
extern "C" {
    pub fn aeron_flow_control_strategy_has_required_receivers_default(
        strategy: *mut aeron_flow_control_strategy_t,
    ) -> bool;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aeron_flow_control_tagged_options_stct {
    pub strategy_name_length: usize,
    pub strategy_name: *const ::std::os::raw::c_char,
    pub group_tag: aeron_flow_control_tagged_options_stct__bindgen_ty_1,
    pub timeout_ns: aeron_flow_control_tagged_options_stct__bindgen_ty_2,
    pub group_min_size: aeron_flow_control_tagged_options_stct__bindgen_ty_3,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aeron_flow_control_tagged_options_stct__bindgen_ty_1 {
    pub is_present: bool,
    pub value: i64,
}
#[test]
fn bindgen_test_layout_aeron_flow_control_tagged_options_stct__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<aeron_flow_control_tagged_options_stct__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_flow_control_tagged_options_stct__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(aeron_flow_control_tagged_options_stct__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_flow_control_tagged_options_stct__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(aeron_flow_control_tagged_options_stct__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).is_present) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_flow_control_tagged_options_stct__bindgen_ty_1),
            "::",
            stringify!(is_present)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_flow_control_tagged_options_stct__bindgen_ty_1),
            "::",
            stringify!(value)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aeron_flow_control_tagged_options_stct__bindgen_ty_2 {
    pub is_present: bool,
    pub value: u64,
}
#[test]
fn bindgen_test_layout_aeron_flow_control_tagged_options_stct__bindgen_ty_2() {
    const UNINIT: ::std::mem::MaybeUninit<aeron_flow_control_tagged_options_stct__bindgen_ty_2> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_flow_control_tagged_options_stct__bindgen_ty_2>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(aeron_flow_control_tagged_options_stct__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_flow_control_tagged_options_stct__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(aeron_flow_control_tagged_options_stct__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).is_present) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_flow_control_tagged_options_stct__bindgen_ty_2),
            "::",
            stringify!(is_present)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_flow_control_tagged_options_stct__bindgen_ty_2),
            "::",
            stringify!(value)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aeron_flow_control_tagged_options_stct__bindgen_ty_3 {
    pub is_present: bool,
    pub value: i32,
}
#[test]
fn bindgen_test_layout_aeron_flow_control_tagged_options_stct__bindgen_ty_3() {
    const UNINIT: ::std::mem::MaybeUninit<aeron_flow_control_tagged_options_stct__bindgen_ty_3> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_flow_control_tagged_options_stct__bindgen_ty_3>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(aeron_flow_control_tagged_options_stct__bindgen_ty_3)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_flow_control_tagged_options_stct__bindgen_ty_3>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(aeron_flow_control_tagged_options_stct__bindgen_ty_3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).is_present) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_flow_control_tagged_options_stct__bindgen_ty_3),
            "::",
            stringify!(is_present)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_flow_control_tagged_options_stct__bindgen_ty_3),
            "::",
            stringify!(value)
        )
    );
}
#[test]
fn bindgen_test_layout_aeron_flow_control_tagged_options_stct() {
    const UNINIT: ::std::mem::MaybeUninit<aeron_flow_control_tagged_options_stct> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_flow_control_tagged_options_stct>(),
        56usize,
        concat!(
            "Size of: ",
            stringify!(aeron_flow_control_tagged_options_stct)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_flow_control_tagged_options_stct>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(aeron_flow_control_tagged_options_stct)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).strategy_name_length) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_flow_control_tagged_options_stct),
            "::",
            stringify!(strategy_name_length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).strategy_name) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_flow_control_tagged_options_stct),
            "::",
            stringify!(strategy_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).group_tag) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_flow_control_tagged_options_stct),
            "::",
            stringify!(group_tag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timeout_ns) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_flow_control_tagged_options_stct),
            "::",
            stringify!(timeout_ns)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).group_min_size) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_flow_control_tagged_options_stct),
            "::",
            stringify!(group_min_size)
        )
    );
}
pub type aeron_flow_control_tagged_options_t = aeron_flow_control_tagged_options_stct;
extern "C" {
    pub fn aeron_flow_control_strategy_supplier_load(
        strategy_name: *const ::std::os::raw::c_char,
    ) -> aeron_flow_control_strategy_supplier_func_t;
}
extern "C" {
    pub fn aeron_max_multicast_flow_control_strategy_supplier(
        strategy: *mut *mut aeron_flow_control_strategy_t,
        context: *mut aeron_driver_context_t,
        counters_manager: *mut aeron_counters_manager_t,
        channel: *const aeron_udp_channel_t,
        stream_id: i32,
        session_id: i32,
        registration_id: i64,
        initial_term_id: i32,
        term_length: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_unicast_flow_control_strategy_supplier(
        strategy: *mut *mut aeron_flow_control_strategy_t,
        context: *mut aeron_driver_context_t,
        counters_manager: *mut aeron_counters_manager_t,
        channel: *const aeron_udp_channel_t,
        stream_id: i32,
        session_id: i32,
        registration_id: i64,
        initial_term_id: i32,
        term_length: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_min_flow_control_strategy_supplier(
        strategy: *mut *mut aeron_flow_control_strategy_t,
        context: *mut aeron_driver_context_t,
        counters_manager: *mut aeron_counters_manager_t,
        channel: *const aeron_udp_channel_t,
        stream_id: i32,
        session_id: i32,
        registration_id: i64,
        initial_term_id: i32,
        term_buffer_capacity: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_tagged_flow_control_strategy_supplier(
        strategy: *mut *mut aeron_flow_control_strategy_t,
        context: *mut aeron_driver_context_t,
        counters_manager: *mut aeron_counters_manager_t,
        channel: *const aeron_udp_channel_t,
        stream_id: i32,
        session_id: i32,
        registration_id: i64,
        initial_term_id: i32,
        term_buffer_capacity: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_tagged_flow_control_strategy_to_string(
        strategy: *mut aeron_flow_control_strategy_t,
        buffer: *mut ::std::os::raw::c_char,
        buffer_len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_default_multicast_flow_control_strategy_supplier(
        strategy: *mut *mut aeron_flow_control_strategy_t,
        context: *mut aeron_driver_context_t,
        counters_manager: *mut aeron_counters_manager_t,
        channel: *const aeron_udp_channel_t,
        stream_id: i32,
        session_id: i32,
        registration_id: i64,
        initial_term_id: i32,
        term_length: usize,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aeron_flow_control_strategy_supplier_func_table_entry_stct {
    pub name: *const ::std::os::raw::c_char,
    pub supplier_func: aeron_flow_control_strategy_supplier_func_t,
}
#[test]
fn bindgen_test_layout_aeron_flow_control_strategy_supplier_func_table_entry_stct() {
    const UNINIT: ::std::mem::MaybeUninit<
        aeron_flow_control_strategy_supplier_func_table_entry_stct,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_flow_control_strategy_supplier_func_table_entry_stct>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(aeron_flow_control_strategy_supplier_func_table_entry_stct)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_flow_control_strategy_supplier_func_table_entry_stct>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(aeron_flow_control_strategy_supplier_func_table_entry_stct)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_flow_control_strategy_supplier_func_table_entry_stct),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).supplier_func) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_flow_control_strategy_supplier_func_table_entry_stct),
            "::",
            stringify!(supplier_func)
        )
    );
}
pub type aeron_flow_control_strategy_supplier_func_table_entry_t =
    aeron_flow_control_strategy_supplier_func_table_entry_stct;
extern "C" {
    pub fn aeron_flow_control_parse_tagged_options(
        options_length: usize,
        options: *const ::std::os::raw::c_char,
        flow_control_options: *mut aeron_flow_control_tagged_options_t,
    ) -> ::std::os::raw::c_int;
}
pub type aeron_congestion_control_strategy_should_measure_rtt_func_t = ::std::option::Option<
    unsafe extern "C" fn(state: *mut ::std::os::raw::c_void, now_ns: i64) -> bool,
>;
pub type aeron_congestion_control_strategy_on_rttm_sent_func_t =
    ::std::option::Option<unsafe extern "C" fn(state: *mut ::std::os::raw::c_void, now_ns: i64)>;
pub type aeron_congestion_control_strategy_on_rttm_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        state: *mut ::std::os::raw::c_void,
        now_ns: i64,
        rtt_ns: i64,
        source_address: *mut sockaddr_storage,
    ),
>;
pub type aeron_congestion_control_strategy_on_track_rebuild_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        state: *mut ::std::os::raw::c_void,
        should_force_sm: *mut bool,
        now_ns: i64,
        new_consumption_position: i64,
        last_sm_position: i64,
        hwm_position: i64,
        starting_rebuild_position: i64,
        ending_rebuild_position: i64,
        loss_occurred: bool,
    ) -> i32,
>;
pub type aeron_congestion_control_strategy_initial_window_length_func_t =
    ::std::option::Option<unsafe extern "C" fn(state: *mut ::std::os::raw::c_void) -> i32>;
pub type aeron_congestion_control_strategy_max_window_length_func_t =
    ::std::option::Option<unsafe extern "C" fn(state: *mut ::std::os::raw::c_void) -> i32>;
pub type aeron_congestion_control_strategy_fini_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        strategy: *mut aeron_congestion_control_strategy_t,
    ) -> ::std::os::raw::c_int,
>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aeron_congestion_control_strategy_stct {
    pub should_measure_rtt: aeron_congestion_control_strategy_should_measure_rtt_func_t,
    pub on_rttm_sent: aeron_congestion_control_strategy_on_rttm_sent_func_t,
    pub on_rttm: aeron_congestion_control_strategy_on_rttm_func_t,
    pub on_track_rebuild: aeron_congestion_control_strategy_on_track_rebuild_func_t,
    pub initial_window_length: aeron_congestion_control_strategy_initial_window_length_func_t,
    pub max_window_length: aeron_congestion_control_strategy_max_window_length_func_t,
    pub fini: aeron_congestion_control_strategy_fini_func_t,
    pub state: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_aeron_congestion_control_strategy_stct() {
    const UNINIT: ::std::mem::MaybeUninit<aeron_congestion_control_strategy_stct> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_congestion_control_strategy_stct>(),
        64usize,
        concat!(
            "Size of: ",
            stringify!(aeron_congestion_control_strategy_stct)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_congestion_control_strategy_stct>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(aeron_congestion_control_strategy_stct)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).should_measure_rtt) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_congestion_control_strategy_stct),
            "::",
            stringify!(should_measure_rtt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).on_rttm_sent) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_congestion_control_strategy_stct),
            "::",
            stringify!(on_rttm_sent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).on_rttm) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_congestion_control_strategy_stct),
            "::",
            stringify!(on_rttm)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).on_track_rebuild) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_congestion_control_strategy_stct),
            "::",
            stringify!(on_track_rebuild)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).initial_window_length) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_congestion_control_strategy_stct),
            "::",
            stringify!(initial_window_length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_window_length) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_congestion_control_strategy_stct),
            "::",
            stringify!(max_window_length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fini) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_congestion_control_strategy_stct),
            "::",
            stringify!(fini)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_congestion_control_strategy_stct),
            "::",
            stringify!(state)
        )
    );
}
extern "C" {
    pub fn aeron_congestion_control_strategy_supplier_load(
        strategy_name: *const ::std::os::raw::c_char,
    ) -> aeron_congestion_control_strategy_supplier_func_t;
}
extern "C" {
    pub fn aeron_congestion_control_default_strategy_supplier(
        strategy: *mut *mut aeron_congestion_control_strategy_t,
        channel: *mut aeron_udp_channel_t,
        stream_id: i32,
        session_id: i32,
        registration_id: i64,
        term_length: i32,
        sender_mtu_length: i32,
        control_address: *mut sockaddr_storage,
        src_address: *mut sockaddr_storage,
        context: *mut aeron_driver_context_t,
        counters_manager: *mut aeron_counters_manager_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_static_window_congestion_control_strategy_supplier(
        strategy: *mut *mut aeron_congestion_control_strategy_t,
        channel: *mut aeron_udp_channel_t,
        stream_id: i32,
        session_id: i32,
        registration_id: i64,
        term_length: i32,
        sender_mtu_length: i32,
        control_address: *mut sockaddr_storage,
        src_address: *mut sockaddr_storage,
        context: *mut aeron_driver_context_t,
        counters_manager: *mut aeron_counters_manager_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_cubic_congestion_control_strategy_supplier(
        strategy: *mut *mut aeron_congestion_control_strategy_t,
        channel: *mut aeron_udp_channel_t,
        stream_id: i32,
        session_id: i32,
        registration_id: i64,
        term_length: i32,
        sender_mtu_length: i32,
        control_address: *mut sockaddr_storage,
        src_address: *mut sockaddr_storage,
        context: *mut aeron_driver_context_t,
        counters_manager: *mut aeron_counters_manager_t,
    ) -> ::std::os::raw::c_int;
}
pub type aeron_agent_do_work_func_t = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
>;
pub type aeron_agent_on_close_func_t =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aeron_idle_strategy_stct {
    pub idle: aeron_idle_strategy_func_t,
    pub init: aeron_idle_strategy_init_func_t,
}
#[test]
fn bindgen_test_layout_aeron_idle_strategy_stct() {
    const UNINIT: ::std::mem::MaybeUninit<aeron_idle_strategy_stct> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_idle_strategy_stct>(),
        16usize,
        concat!("Size of: ", stringify!(aeron_idle_strategy_stct))
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_idle_strategy_stct>(),
        8usize,
        concat!("Alignment of ", stringify!(aeron_idle_strategy_stct))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).idle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_idle_strategy_stct),
            "::",
            stringify!(idle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).init) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_idle_strategy_stct),
            "::",
            stringify!(init)
        )
    );
}
pub type aeron_idle_strategy_t = aeron_idle_strategy_stct;
extern "C" {
    pub fn aeron_idle_strategy_sleeping_idle(
        state: *mut ::std::os::raw::c_void,
        work_count: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn aeron_idle_strategy_yielding_idle(
        state: *mut ::std::os::raw::c_void,
        work_count: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn aeron_idle_strategy_busy_spinning_idle(
        state: *mut ::std::os::raw::c_void,
        work_count: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn aeron_idle_strategy_noop_idle(
        state: *mut ::std::os::raw::c_void,
        work_count: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn aeron_idle_strategy_backoff_idle(
        state: *mut ::std::os::raw::c_void,
        work_count: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn aeron_idle_strategy_backoff_state_init(
        state: *mut *mut ::std::os::raw::c_void,
        max_spins: u64,
        max_yields: u64,
        min_park_period_ns: u64,
        max_park_period_ns: u64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_idle_strategy_init_null(
        state: *mut *mut ::std::os::raw::c_void,
        env_var: *const ::std::os::raw::c_char,
        load_args: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aeron_agent_runner_stct {
    pub role_name: *const ::std::os::raw::c_char,
    pub agent_state: *mut ::std::os::raw::c_void,
    pub idle_strategy_state: *mut ::std::os::raw::c_void,
    pub on_start_state: *mut ::std::os::raw::c_void,
    pub on_start: aeron_agent_on_start_func_t,
    pub do_work: aeron_agent_do_work_func_t,
    pub on_close: aeron_agent_on_close_func_t,
    pub idle_strategy: aeron_idle_strategy_func_t,
    pub thread: aeron_thread_t,
    pub running: bool,
    pub state: u8,
}
#[test]
fn bindgen_test_layout_aeron_agent_runner_stct() {
    const UNINIT: ::std::mem::MaybeUninit<aeron_agent_runner_stct> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_agent_runner_stct>(),
        80usize,
        concat!("Size of: ", stringify!(aeron_agent_runner_stct))
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_agent_runner_stct>(),
        8usize,
        concat!("Alignment of ", stringify!(aeron_agent_runner_stct))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).role_name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_agent_runner_stct),
            "::",
            stringify!(role_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).agent_state) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_agent_runner_stct),
            "::",
            stringify!(agent_state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).idle_strategy_state) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_agent_runner_stct),
            "::",
            stringify!(idle_strategy_state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).on_start_state) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_agent_runner_stct),
            "::",
            stringify!(on_start_state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).on_start) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_agent_runner_stct),
            "::",
            stringify!(on_start)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).do_work) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_agent_runner_stct),
            "::",
            stringify!(do_work)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).on_close) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_agent_runner_stct),
            "::",
            stringify!(on_close)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).idle_strategy) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_agent_runner_stct),
            "::",
            stringify!(idle_strategy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).thread) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_agent_runner_stct),
            "::",
            stringify!(thread)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).running) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_agent_runner_stct),
            "::",
            stringify!(running)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
        73usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_agent_runner_stct),
            "::",
            stringify!(state)
        )
    );
}
pub type aeron_agent_runner_t = aeron_agent_runner_stct;
extern "C" {
    pub fn aeron_idle_strategy_load(
        idle_strategy_name: *const ::std::os::raw::c_char,
        idle_strategy_state: *mut *mut ::std::os::raw::c_void,
        env_var: *const ::std::os::raw::c_char,
        load_args: *const ::std::os::raw::c_char,
    ) -> aeron_idle_strategy_func_t;
}
extern "C" {
    pub fn aeron_agent_on_start_load(
        name: *const ::std::os::raw::c_char,
    ) -> aeron_agent_on_start_func_t;
}
extern "C" {
    pub fn aeron_agent_init(
        runner: *mut aeron_agent_runner_t,
        role_name: *const ::std::os::raw::c_char,
        state: *mut ::std::os::raw::c_void,
        on_start: aeron_agent_on_start_func_t,
        on_start_state: *mut ::std::os::raw::c_void,
        do_work: aeron_agent_do_work_func_t,
        on_close: aeron_agent_on_close_func_t,
        idle_strategy_func: aeron_idle_strategy_func_t,
        idle_strategy_state: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_agent_start(runner: *mut aeron_agent_runner_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_agent_stop(runner: *mut aeron_agent_runner_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_agent_close(runner: *mut aeron_agent_runner_t) -> ::std::os::raw::c_int;
}
#[repr(C, packed(4))]
#[derive(Copy, Clone)]
pub struct aeron_stream_position_counter_key_layout_stct {
    pub registration_id: i64,
    pub session_id: i32,
    pub stream_id: i32,
    pub channel_length: i32,
    pub channel: [::std::os::raw::c_char; 92usize],
}
#[test]
fn bindgen_test_layout_aeron_stream_position_counter_key_layout_stct() {
    const UNINIT: ::std::mem::MaybeUninit<aeron_stream_position_counter_key_layout_stct> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_stream_position_counter_key_layout_stct>(),
        112usize,
        concat!(
            "Size of: ",
            stringify!(aeron_stream_position_counter_key_layout_stct)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_stream_position_counter_key_layout_stct>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(aeron_stream_position_counter_key_layout_stct)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).registration_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_stream_position_counter_key_layout_stct),
            "::",
            stringify!(registration_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).session_id) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_stream_position_counter_key_layout_stct),
            "::",
            stringify!(session_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stream_id) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_stream_position_counter_key_layout_stct),
            "::",
            stringify!(stream_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).channel_length) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_stream_position_counter_key_layout_stct),
            "::",
            stringify!(channel_length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).channel) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_stream_position_counter_key_layout_stct),
            "::",
            stringify!(channel)
        )
    );
}
pub type aeron_stream_position_counter_key_layout_t = aeron_stream_position_counter_key_layout_stct;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aeron_channel_endpoint_status_key_layout_stct {
    pub channel_length: i32,
    pub channel: [::std::os::raw::c_char; 108usize],
}
#[test]
fn bindgen_test_layout_aeron_channel_endpoint_status_key_layout_stct() {
    const UNINIT: ::std::mem::MaybeUninit<aeron_channel_endpoint_status_key_layout_stct> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_channel_endpoint_status_key_layout_stct>(),
        112usize,
        concat!(
            "Size of: ",
            stringify!(aeron_channel_endpoint_status_key_layout_stct)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_channel_endpoint_status_key_layout_stct>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(aeron_channel_endpoint_status_key_layout_stct)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).channel_length) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_channel_endpoint_status_key_layout_stct),
            "::",
            stringify!(channel_length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).channel) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_channel_endpoint_status_key_layout_stct),
            "::",
            stringify!(channel)
        )
    );
}
pub type aeron_channel_endpoint_status_key_layout_t = aeron_channel_endpoint_status_key_layout_stct;
#[repr(C, packed(4))]
#[derive(Copy, Clone)]
pub struct aeron_heartbeat_timestamp_key_layout_stct {
    pub registration_id: i64,
}
#[test]
fn bindgen_test_layout_aeron_heartbeat_timestamp_key_layout_stct() {
    const UNINIT: ::std::mem::MaybeUninit<aeron_heartbeat_timestamp_key_layout_stct> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_heartbeat_timestamp_key_layout_stct>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(aeron_heartbeat_timestamp_key_layout_stct)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_heartbeat_timestamp_key_layout_stct>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(aeron_heartbeat_timestamp_key_layout_stct)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).registration_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_heartbeat_timestamp_key_layout_stct),
            "::",
            stringify!(registration_id)
        )
    );
}
pub type aeron_heartbeat_timestamp_key_layout_t = aeron_heartbeat_timestamp_key_layout_stct;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aeron_local_sockaddr_key_layout_stct {
    pub channel_status_id: i32,
    pub local_sockaddr_len: i32,
    pub local_sockaddr: [::std::os::raw::c_char; 104usize],
}
#[test]
fn bindgen_test_layout_aeron_local_sockaddr_key_layout_stct() {
    const UNINIT: ::std::mem::MaybeUninit<aeron_local_sockaddr_key_layout_stct> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_local_sockaddr_key_layout_stct>(),
        112usize,
        concat!(
            "Size of: ",
            stringify!(aeron_local_sockaddr_key_layout_stct)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_local_sockaddr_key_layout_stct>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(aeron_local_sockaddr_key_layout_stct)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).channel_status_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_local_sockaddr_key_layout_stct),
            "::",
            stringify!(channel_status_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).local_sockaddr_len) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_local_sockaddr_key_layout_stct),
            "::",
            stringify!(local_sockaddr_len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).local_sockaddr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_local_sockaddr_key_layout_stct),
            "::",
            stringify!(local_sockaddr)
        )
    );
}
pub type aeron_local_sockaddr_key_layout_t = aeron_local_sockaddr_key_layout_stct;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aeron_counters_manager_stct {
    pub values: *mut u8,
    pub metadata: *mut u8,
    pub values_length: usize,
    pub metadata_length: usize,
    pub max_counter_id: i32,
    pub id_high_water_mark: i32,
    pub free_list: *mut i32,
    pub free_list_index: i32,
    pub free_list_length: usize,
    pub cached_clock: *mut aeron_clock_cache_t,
    pub free_to_reuse_timeout_ms: i64,
}
#[test]
fn bindgen_test_layout_aeron_counters_manager_stct() {
    const UNINIT: ::std::mem::MaybeUninit<aeron_counters_manager_stct> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_counters_manager_stct>(),
        80usize,
        concat!("Size of: ", stringify!(aeron_counters_manager_stct))
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_counters_manager_stct>(),
        8usize,
        concat!("Alignment of ", stringify!(aeron_counters_manager_stct))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).values) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_counters_manager_stct),
            "::",
            stringify!(values)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).metadata) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_counters_manager_stct),
            "::",
            stringify!(metadata)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).values_length) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_counters_manager_stct),
            "::",
            stringify!(values_length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).metadata_length) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_counters_manager_stct),
            "::",
            stringify!(metadata_length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_counter_id) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_counters_manager_stct),
            "::",
            stringify!(max_counter_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).id_high_water_mark) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_counters_manager_stct),
            "::",
            stringify!(id_high_water_mark)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).free_list) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_counters_manager_stct),
            "::",
            stringify!(free_list)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).free_list_index) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_counters_manager_stct),
            "::",
            stringify!(free_list_index)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).free_list_length) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_counters_manager_stct),
            "::",
            stringify!(free_list_length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cached_clock) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_counters_manager_stct),
            "::",
            stringify!(cached_clock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).free_to_reuse_timeout_ms) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_counters_manager_stct),
            "::",
            stringify!(free_to_reuse_timeout_ms)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aeron_counters_reader_stct {
    pub values: *mut u8,
    pub metadata: *mut u8,
    pub values_length: usize,
    pub metadata_length: usize,
    pub max_counter_id: i32,
}
#[test]
fn bindgen_test_layout_aeron_counters_reader_stct() {
    const UNINIT: ::std::mem::MaybeUninit<aeron_counters_reader_stct> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_counters_reader_stct>(),
        40usize,
        concat!("Size of: ", stringify!(aeron_counters_reader_stct))
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_counters_reader_stct>(),
        8usize,
        concat!("Alignment of ", stringify!(aeron_counters_reader_stct))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).values) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_counters_reader_stct),
            "::",
            stringify!(values)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).metadata) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_counters_reader_stct),
            "::",
            stringify!(metadata)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).values_length) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_counters_reader_stct),
            "::",
            stringify!(values_length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).metadata_length) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_counters_reader_stct),
            "::",
            stringify!(metadata_length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_counter_id) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_counters_reader_stct),
            "::",
            stringify!(max_counter_id)
        )
    );
}
extern "C" {
    pub fn aeron_counters_manager_init(
        manager: *mut aeron_counters_manager_t,
        metadata_buffer: *mut u8,
        metadata_length: usize,
        values_buffer: *mut u8,
        values_length: usize,
        cached_clock: *mut aeron_clock_cache_t,
        free_to_reuse_timeout_ms: i64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_counters_manager_close(manager: *mut aeron_counters_manager_t);
}
extern "C" {
    pub fn aeron_counters_manager_allocate(
        manager: *mut aeron_counters_manager_t,
        type_id: i32,
        key: *const u8,
        key_length: usize,
        label: *const ::std::os::raw::c_char,
        label_length: usize,
    ) -> i32;
}
extern "C" {
    pub fn aeron_counters_manager_counter_registration_id(
        manager: *mut aeron_counters_manager_t,
        counter_id: i32,
        registration_id: i64,
    );
}
extern "C" {
    pub fn aeron_counters_manager_counter_owner_id(
        manager: *mut aeron_counters_manager_t,
        counter_id: i32,
        owner_id: i64,
    );
}
extern "C" {
    pub fn aeron_counters_manager_update_label(
        manager: *mut aeron_counters_manager_t,
        counter_id: i32,
        label_length: usize,
        label: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn aeron_counters_manager_append_to_label(
        manager: *mut aeron_counters_manager_t,
        counter_id: i32,
        length: usize,
        value: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn aeron_counters_manager_next_counter_id(manager: *mut aeron_counters_manager_t) -> i32;
}
extern "C" {
    pub fn aeron_counters_manager_free(
        manager: *mut aeron_counters_manager_t,
        counter_id: i32,
    ) -> ::std::os::raw::c_int;
}
pub type aeron_counters_reader_foreach_metadata_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        id: i32,
        type_id: i32,
        key: *const u8,
        key_length: usize,
        label: *const u8,
        label_length: usize,
        clientd: *mut ::std::os::raw::c_void,
    ),
>;
extern "C" {
    pub fn aeron_counters_reader_foreach_metadata(
        metadata_buffer: *mut u8,
        metadata_length: usize,
        func: aeron_counters_reader_foreach_metadata_func_t,
        clientd: *mut ::std::os::raw::c_void,
    );
}
pub const aeron_system_counter_enum_stct_AERON_SYSTEM_COUNTER_BYTES_SENT:
    aeron_system_counter_enum_stct = 0;
pub const aeron_system_counter_enum_stct_AERON_SYSTEM_COUNTER_BYTES_RECEIVED:
    aeron_system_counter_enum_stct = 1;
pub const aeron_system_counter_enum_stct_AERON_SYSTEM_COUNTER_RECEIVER_PROXY_FAILS:
    aeron_system_counter_enum_stct = 2;
pub const aeron_system_counter_enum_stct_AERON_SYSTEM_COUNTER_SENDER_PROXY_FAILS:
    aeron_system_counter_enum_stct = 3;
pub const aeron_system_counter_enum_stct_AERON_SYSTEM_COUNTER_CONDUCTOR_PROXY_FAILS:
    aeron_system_counter_enum_stct = 4;
pub const aeron_system_counter_enum_stct_AERON_SYSTEM_COUNTER_NAK_MESSAGES_SENT:
    aeron_system_counter_enum_stct = 5;
pub const aeron_system_counter_enum_stct_AERON_SYSTEM_COUNTER_NAK_MESSAGES_RECEIVED:
    aeron_system_counter_enum_stct = 6;
pub const aeron_system_counter_enum_stct_AERON_SYSTEM_COUNTER_STATUS_MESSAGES_SENT:
    aeron_system_counter_enum_stct = 7;
pub const aeron_system_counter_enum_stct_AERON_SYSTEM_COUNTER_STATUS_MESSAGES_RECEIVED:
    aeron_system_counter_enum_stct = 8;
pub const aeron_system_counter_enum_stct_AERON_SYSTEM_COUNTER_HEARTBEATS_SENT:
    aeron_system_counter_enum_stct = 9;
pub const aeron_system_counter_enum_stct_AERON_SYSTEM_COUNTER_HEARTBEATS_RECEIVED:
    aeron_system_counter_enum_stct = 10;
pub const aeron_system_counter_enum_stct_AERON_SYSTEM_COUNTER_RETRANSMITS_SENT:
    aeron_system_counter_enum_stct = 11;
pub const aeron_system_counter_enum_stct_AERON_SYSTEM_COUNTER_FLOW_CONTROL_UNDER_RUNS:
    aeron_system_counter_enum_stct = 12;
pub const aeron_system_counter_enum_stct_AERON_SYSTEM_COUNTER_FLOW_CONTROL_OVER_RUNS:
    aeron_system_counter_enum_stct = 13;
pub const aeron_system_counter_enum_stct_AERON_SYSTEM_COUNTER_INVALID_PACKETS:
    aeron_system_counter_enum_stct = 14;
pub const aeron_system_counter_enum_stct_AERON_SYSTEM_COUNTER_ERRORS:
    aeron_system_counter_enum_stct = 15;
pub const aeron_system_counter_enum_stct_AERON_SYSTEM_COUNTER_SHORT_SENDS:
    aeron_system_counter_enum_stct = 16;
pub const aeron_system_counter_enum_stct_AERON_SYSTEM_COUNTER_FREE_FAILS:
    aeron_system_counter_enum_stct = 17;
pub const aeron_system_counter_enum_stct_AERON_SYSTEM_COUNTER_SENDER_FLOW_CONTROL_LIMITS:
    aeron_system_counter_enum_stct = 18;
pub const aeron_system_counter_enum_stct_AERON_SYSTEM_COUNTER_UNBLOCKED_PUBLICATIONS:
    aeron_system_counter_enum_stct = 19;
pub const aeron_system_counter_enum_stct_AERON_SYSTEM_COUNTER_UNBLOCKED_COMMANDS:
    aeron_system_counter_enum_stct = 20;
pub const aeron_system_counter_enum_stct_AERON_SYSTEM_COUNTER_POSSIBLE_TTL_ASYMMETRY:
    aeron_system_counter_enum_stct = 21;
pub const aeron_system_counter_enum_stct_AERON_SYSTEM_COUNTER_CONTROLLABLE_IDLE_STRATEGY:
    aeron_system_counter_enum_stct = 22;
pub const aeron_system_counter_enum_stct_AERON_SYSTEM_COUNTER_LOSS_GAP_FILLS:
    aeron_system_counter_enum_stct = 23;
pub const aeron_system_counter_enum_stct_AERON_SYSTEM_COUNTER_CLIENT_TIMEOUTS:
    aeron_system_counter_enum_stct = 24;
pub const aeron_system_counter_enum_stct_AERON_SYSTEM_COUNTER_RESOLUTION_CHANGES:
    aeron_system_counter_enum_stct = 25;
pub const aeron_system_counter_enum_stct_AERON_SYSTEM_COUNTER_CONDUCTOR_MAX_CYCLE_TIME:
    aeron_system_counter_enum_stct = 26;
pub const aeron_system_counter_enum_stct_AERON_SYSTEM_COUNTER_CONDUCTOR_CYCLE_TIME_THRESHOLD_EXCEEDED : aeron_system_counter_enum_stct = 27 ;
pub const aeron_system_counter_enum_stct_AERON_SYSTEM_COUNTER_SENDER_MAX_CYCLE_TIME:
    aeron_system_counter_enum_stct = 28;
pub const aeron_system_counter_enum_stct_AERON_SYSTEM_COUNTER_SENDER_CYCLE_TIME_THRESHOLD_EXCEEDED : aeron_system_counter_enum_stct = 29 ;
pub const aeron_system_counter_enum_stct_AERON_SYSTEM_COUNTER_RECEIVER_MAX_CYCLE_TIME:
    aeron_system_counter_enum_stct = 30;
pub const aeron_system_counter_enum_stct_AERON_SYSTEM_COUNTER_RECEIVER_CYCLE_TIME_THRESHOLD_EXCEEDED : aeron_system_counter_enum_stct = 31 ;
pub const aeron_system_counter_enum_stct_AERON_SYSTEM_COUNTER_NAME_RESOLVER_MAX_TIME:
    aeron_system_counter_enum_stct = 32;
pub const aeron_system_counter_enum_stct_AERON_SYSTEM_COUNTER_NAME_RESOLVER_TIME_THRESHOLD_EXCEEDED : aeron_system_counter_enum_stct = 33 ;
pub const aeron_system_counter_enum_stct_AERON_SYSTEM_COUNTER_DUMMY_LAST:
    aeron_system_counter_enum_stct = 34;
pub type aeron_system_counter_enum_stct = ::std::os::raw::c_uint;
pub use self::aeron_system_counter_enum_stct as aeron_system_counter_enum_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aeron_system_counter_stct {
    pub label: *const ::std::os::raw::c_char,
    pub id: i32,
}
#[test]
fn bindgen_test_layout_aeron_system_counter_stct() {
    const UNINIT: ::std::mem::MaybeUninit<aeron_system_counter_stct> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_system_counter_stct>(),
        16usize,
        concat!("Size of: ", stringify!(aeron_system_counter_stct))
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_system_counter_stct>(),
        8usize,
        concat!("Alignment of ", stringify!(aeron_system_counter_stct))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).label) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_system_counter_stct),
            "::",
            stringify!(label)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_system_counter_stct),
            "::",
            stringify!(id)
        )
    );
}
pub type aeron_system_counter_t = aeron_system_counter_stct;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aeron_system_counters_stct {
    pub counter_ids: *mut i32,
    pub manager: *mut aeron_counters_manager_t,
}
#[test]
fn bindgen_test_layout_aeron_system_counters_stct() {
    const UNINIT: ::std::mem::MaybeUninit<aeron_system_counters_stct> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_system_counters_stct>(),
        16usize,
        concat!("Size of: ", stringify!(aeron_system_counters_stct))
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_system_counters_stct>(),
        8usize,
        concat!("Alignment of ", stringify!(aeron_system_counters_stct))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).counter_ids) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_system_counters_stct),
            "::",
            stringify!(counter_ids)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).manager) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_system_counters_stct),
            "::",
            stringify!(manager)
        )
    );
}
pub type aeron_system_counters_t = aeron_system_counters_stct;
extern "C" {
    pub fn aeron_system_counters_init(
        counters: *mut aeron_system_counters_t,
        manager: *mut aeron_counters_manager_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_system_counters_close(counters: *mut aeron_system_counters_t);
}
#[repr(C, packed(4))]
#[derive(Copy, Clone)]
pub struct aeron_cnc_metadata_stct {
    pub cnc_version: i32,
    pub to_driver_buffer_length: i32,
    pub to_clients_buffer_length: i32,
    pub counter_metadata_buffer_length: i32,
    pub counter_values_buffer_length: i32,
    pub error_log_buffer_length: i32,
    pub client_liveness_timeout: i64,
    pub start_timestamp: i64,
    pub pid: i64,
}
#[test]
fn bindgen_test_layout_aeron_cnc_metadata_stct() {
    const UNINIT: ::std::mem::MaybeUninit<aeron_cnc_metadata_stct> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_cnc_metadata_stct>(),
        48usize,
        concat!("Size of: ", stringify!(aeron_cnc_metadata_stct))
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_cnc_metadata_stct>(),
        4usize,
        concat!("Alignment of ", stringify!(aeron_cnc_metadata_stct))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cnc_version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_cnc_metadata_stct),
            "::",
            stringify!(cnc_version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).to_driver_buffer_length) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_cnc_metadata_stct),
            "::",
            stringify!(to_driver_buffer_length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).to_clients_buffer_length) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_cnc_metadata_stct),
            "::",
            stringify!(to_clients_buffer_length)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).counter_metadata_buffer_length) as usize - ptr as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_cnc_metadata_stct),
            "::",
            stringify!(counter_metadata_buffer_length)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).counter_values_buffer_length) as usize - ptr as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_cnc_metadata_stct),
            "::",
            stringify!(counter_values_buffer_length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).error_log_buffer_length) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_cnc_metadata_stct),
            "::",
            stringify!(error_log_buffer_length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).client_liveness_timeout) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_cnc_metadata_stct),
            "::",
            stringify!(client_liveness_timeout)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).start_timestamp) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_cnc_metadata_stct),
            "::",
            stringify!(start_timestamp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pid) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_cnc_metadata_stct),
            "::",
            stringify!(pid)
        )
    );
}
pub type aeron_cnc_metadata_t = aeron_cnc_metadata_stct;
pub const aeron_cnc_load_result_stct_AERON_CNC_LOAD_FAILED: aeron_cnc_load_result_stct = -1;
pub const aeron_cnc_load_result_stct_AERON_CNC_LOAD_SUCCESS: aeron_cnc_load_result_stct = 0;
pub const aeron_cnc_load_result_stct_AERON_CNC_LOAD_AWAIT_FILE: aeron_cnc_load_result_stct = 1;
pub const aeron_cnc_load_result_stct_AERON_CNC_LOAD_AWAIT_MMAP: aeron_cnc_load_result_stct = 2;
pub const aeron_cnc_load_result_stct_AERON_CNC_LOAD_AWAIT_VERSION: aeron_cnc_load_result_stct = 3;
pub const aeron_cnc_load_result_stct_AERON_CNC_LOAD_AWAIT_CNC_DATA: aeron_cnc_load_result_stct = 4;
pub type aeron_cnc_load_result_stct = ::std::os::raw::c_int;
pub use self::aeron_cnc_load_result_stct as aeron_cnc_load_result_t;
extern "C" {
    pub fn aeron_cnc_version_volatile(metadata: *mut aeron_cnc_metadata_t) -> i32;
}
extern "C" {
    pub fn aeron_cnc_map_file_and_load_metadata(
        dir: *const ::std::os::raw::c_char,
        mapped_file: *mut aeron_mapped_file_t,
        metadata: *mut *mut aeron_cnc_metadata_t,
    ) -> aeron_cnc_load_result_t;
}
extern "C" {
    pub fn aeron_cnc_resolve_filename(
        directory: *const ::std::os::raw::c_char,
        filename_buffer: *mut ::std::os::raw::c_char,
        filename_buffer_length: usize,
    ) -> ::std::os::raw::c_int;
}
pub type aeron_duty_cycle_tracker_update_func_t =
    ::std::option::Option<unsafe extern "C" fn(state: *mut ::std::os::raw::c_void, now_ns: i64)>;
pub type aeron_duty_cycle_tracker_measure_and_update_func_t =
    ::std::option::Option<unsafe extern "C" fn(state: *mut ::std::os::raw::c_void, now_ns: i64)>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aeron_duty_cycle_tracker_stct {
    pub update: aeron_duty_cycle_tracker_update_func_t,
    pub measure_and_update: aeron_duty_cycle_tracker_measure_and_update_func_t,
    pub state: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_aeron_duty_cycle_tracker_stct() {
    const UNINIT: ::std::mem::MaybeUninit<aeron_duty_cycle_tracker_stct> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_duty_cycle_tracker_stct>(),
        24usize,
        concat!("Size of: ", stringify!(aeron_duty_cycle_tracker_stct))
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_duty_cycle_tracker_stct>(),
        8usize,
        concat!("Alignment of ", stringify!(aeron_duty_cycle_tracker_stct))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).update) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_duty_cycle_tracker_stct),
            "::",
            stringify!(update)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).measure_and_update) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_duty_cycle_tracker_stct),
            "::",
            stringify!(measure_and_update)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_duty_cycle_tracker_stct),
            "::",
            stringify!(state)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aeron_duty_cycle_stall_tracker_stct {
    pub tracker: aeron_duty_cycle_tracker_stct,
    pub lhs_padding: [::std::os::raw::c_char; 56usize],
    pub last_time_of_update_ns: i64,
    pub rhs_padding: [::std::os::raw::c_char; 56usize],
    pub cycle_threshold_ns: u64,
    pub max_cycle_time_counter: *mut i64,
    pub cycle_time_threshold_exceeded_counter: *mut i64,
}
#[test]
fn bindgen_test_layout_aeron_duty_cycle_stall_tracker_stct() {
    const UNINIT: ::std::mem::MaybeUninit<aeron_duty_cycle_stall_tracker_stct> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_duty_cycle_stall_tracker_stct>(),
        168usize,
        concat!("Size of: ", stringify!(aeron_duty_cycle_stall_tracker_stct))
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_duty_cycle_stall_tracker_stct>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(aeron_duty_cycle_stall_tracker_stct)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tracker) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_duty_cycle_stall_tracker_stct),
            "::",
            stringify!(tracker)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lhs_padding) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_duty_cycle_stall_tracker_stct),
            "::",
            stringify!(lhs_padding)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).last_time_of_update_ns) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_duty_cycle_stall_tracker_stct),
            "::",
            stringify!(last_time_of_update_ns)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rhs_padding) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_duty_cycle_stall_tracker_stct),
            "::",
            stringify!(rhs_padding)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cycle_threshold_ns) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_duty_cycle_stall_tracker_stct),
            "::",
            stringify!(cycle_threshold_ns)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_cycle_time_counter) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_duty_cycle_stall_tracker_stct),
            "::",
            stringify!(max_cycle_time_counter)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).cycle_time_threshold_exceeded_counter) as usize
                - ptr as usize
        },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_duty_cycle_stall_tracker_stct),
            "::",
            stringify!(cycle_time_threshold_exceeded_counter)
        )
    );
}
pub type aeron_duty_cycle_stall_tracker_t = aeron_duty_cycle_stall_tracker_stct;
pub type aeron_driver_conductor_proxy_t = aeron_driver_conductor_proxy_stct;
pub type aeron_driver_sender_proxy_t = aeron_driver_sender_proxy_stct;
pub type aeron_driver_receiver_proxy_t = aeron_driver_receiver_proxy_stct;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aeron_dl_loaded_libs_state_stct {
    _unused: [u8; 0],
}
pub type aeron_dl_loaded_libs_state_t = aeron_dl_loaded_libs_state_stct;
pub type aeron_driver_conductor_to_driver_interceptor_func_t = aeron_rb_handler_t;
pub type aeron_driver_conductor_to_client_interceptor_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        conductor: *mut aeron_driver_conductor_t,
        msg_type_id: i32,
        message: *const ::std::os::raw::c_void,
        length: usize,
    ),
>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aeron_driver_context_bindings_clientd_entry_stct {
    pub name: *const ::std::os::raw::c_char,
    pub clientd: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_aeron_driver_context_bindings_clientd_entry_stct() {
    const UNINIT: ::std::mem::MaybeUninit<aeron_driver_context_bindings_clientd_entry_stct> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_driver_context_bindings_clientd_entry_stct>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(aeron_driver_context_bindings_clientd_entry_stct)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_driver_context_bindings_clientd_entry_stct>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(aeron_driver_context_bindings_clientd_entry_stct)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_context_bindings_clientd_entry_stct),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).clientd) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_context_bindings_clientd_entry_stct),
            "::",
            stringify!(clientd)
        )
    );
}
pub type aeron_driver_context_bindings_clientd_entry_t =
    aeron_driver_context_bindings_clientd_entry_stct;
pub type aeron_driver_name_resolver_on_neighbor_change_func_t =
    ::std::option::Option<unsafe extern "C" fn(addr: *const sockaddr_storage)>;
pub type aeron_driver_flow_control_strategy_on_receiver_change_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        receiver_id: i64,
        session_id: i32,
        stream_id: i32,
        channel_length: usize,
        channel: *const ::std::os::raw::c_char,
        receiver_count: usize,
    ),
>;
pub type aeron_driver_name_resolver_on_resolve_t = ::std::option::Option<
    unsafe extern "C" fn(
        name_resolver: *mut aeron_name_resolver_t,
        duration_ns: i64,
        hostname: *const ::std::os::raw::c_char,
        is_re_resolution: bool,
        address: *mut sockaddr_storage,
    ),
>;
pub type aeron_driver_name_resolver_on_lookup_t = ::std::option::Option<
    unsafe extern "C" fn(
        name_resolver: *mut aeron_name_resolver_t,
        duration_ns: i64,
        name: *const ::std::os::raw::c_char,
        is_re_lookup: bool,
        resolved_name: *const ::std::os::raw::c_char,
    ),
>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aeron_driver_context_stct {
    pub aeron_dir: *mut ::std::os::raw::c_char,
    pub threading_mode: aeron_threading_mode_t,
    pub receiver_group_consideration: aeron_inferable_boolean_t,
    pub dirs_delete_on_start: bool,
    pub dirs_delete_on_shutdown: bool,
    pub warn_if_dirs_exist: bool,
    pub term_buffer_sparse_file: bool,
    pub perform_storage_checks: bool,
    pub spies_simulate_connection: bool,
    pub print_configuration_on_start: bool,
    pub reliable_stream: bool,
    pub tether_subscriptions: bool,
    pub rejoin_stream: bool,
    pub ats_enabled: bool,
    pub connect_enabled: bool,
    pub driver_timeout_ms: u64,
    pub client_liveness_timeout_ns: u64,
    pub publication_linger_timeout_ns: u64,
    pub status_message_timeout_ns: u64,
    pub image_liveness_timeout_ns: u64,
    pub publication_unblock_timeout_ns: u64,
    pub publication_connection_timeout_ns: u64,
    pub timer_interval_ns: u64,
    pub counter_free_to_reuse_ns: u64,
    pub untethered_window_limit_timeout_ns: u64,
    pub untethered_resting_timeout_ns: u64,
    pub retransmit_unicast_delay_ns: u64,
    pub retransmit_unicast_linger_ns: u64,
    pub nak_unicast_delay_ns: u64,
    pub nak_multicast_max_backoff_ns: u64,
    pub re_resolution_check_interval_ns: u64,
    pub to_driver_buffer_length: usize,
    pub to_clients_buffer_length: usize,
    pub counters_values_buffer_length: usize,
    pub error_buffer_length: usize,
    pub term_buffer_length: usize,
    pub ipc_term_buffer_length: usize,
    pub mtu_length: usize,
    pub ipc_mtu_length: usize,
    pub ipc_publication_window_length: usize,
    pub publication_window_length: usize,
    pub socket_rcvbuf: usize,
    pub socket_sndbuf: usize,
    pub send_to_sm_poll_ratio: usize,
    pub initial_window_length: usize,
    pub loss_report_length: usize,
    pub file_page_size: usize,
    pub nak_multicast_group_size: usize,
    pub publication_reserved_session_id_low: i32,
    pub publication_reserved_session_id_high: i32,
    pub multicast_ttl: u8,
    pub receiver_io_vector_capacity: u32,
    pub sender_io_vector_capacity: u32,
    pub network_publication_max_messages_per_send: u32,
    pub resource_free_limit: u32,
    pub conductor_cpu_affinity_no: i32,
    pub receiver_cpu_affinity_no: i32,
    pub sender_cpu_affinity_no: i32,
    pub receiver_group_tag: aeron_driver_context_stct__bindgen_ty_1,
    pub flow_control: aeron_driver_context_stct__bindgen_ty_2,
    pub cnc_map: aeron_mapped_file_t,
    pub loss_report: aeron_mapped_file_t,
    pub to_driver_buffer: *mut u8,
    pub to_clients_buffer: *mut u8,
    pub counters_values_buffer: *mut u8,
    pub counters_metadata_buffer: *mut u8,
    pub error_buffer: *mut u8,
    pub nano_clock: aeron_clock_func_t,
    pub epoch_clock: aeron_clock_func_t,
    pub cached_clock: *mut aeron_clock_cache_t,
    pub sender_cached_clock: *mut aeron_clock_cache_t,
    pub receiver_cached_clock: *mut aeron_clock_cache_t,
    pub sender_command_queue: aeron_mpsc_rb_t,
    pub receiver_command_queue: aeron_mpsc_rb_t,
    pub conductor_command_queue: aeron_mpsc_rb_t,
    pub agent_on_start_func: aeron_agent_on_start_func_t,
    pub agent_on_start_state: *mut ::std::os::raw::c_void,
    pub conductor_idle_strategy_func: aeron_idle_strategy_func_t,
    pub conductor_idle_strategy_state: *mut ::std::os::raw::c_void,
    pub conductor_idle_strategy_init_args: *mut ::std::os::raw::c_char,
    pub conductor_idle_strategy_name: *const ::std::os::raw::c_char,
    pub shared_idle_strategy_func: aeron_idle_strategy_func_t,
    pub shared_idle_strategy_state: *mut ::std::os::raw::c_void,
    pub shared_idle_strategy_init_args: *mut ::std::os::raw::c_char,
    pub shared_idle_strategy_name: *const ::std::os::raw::c_char,
    pub shared_network_idle_strategy_func: aeron_idle_strategy_func_t,
    pub shared_network_idle_strategy_state: *mut ::std::os::raw::c_void,
    pub shared_network_idle_strategy_init_args: *mut ::std::os::raw::c_char,
    pub shared_network_idle_strategy_name: *const ::std::os::raw::c_char,
    pub sender_idle_strategy_func: aeron_idle_strategy_func_t,
    pub sender_idle_strategy_state: *mut ::std::os::raw::c_void,
    pub sender_idle_strategy_init_args: *mut ::std::os::raw::c_char,
    pub sender_idle_strategy_name: *const ::std::os::raw::c_char,
    pub receiver_idle_strategy_func: aeron_idle_strategy_func_t,
    pub receiver_idle_strategy_state: *mut ::std::os::raw::c_void,
    pub receiver_idle_strategy_init_args: *mut ::std::os::raw::c_char,
    pub receiver_idle_strategy_name: *const ::std::os::raw::c_char,
    pub usable_fs_space_func: aeron_usable_fs_space_func_t,
    pub raw_log_map_func: aeron_raw_log_map_func_t,
    pub raw_log_close_func: aeron_raw_log_close_func_t,
    pub raw_log_free_func: aeron_raw_log_free_func_t,
    pub unicast_flow_control_supplier_func: aeron_flow_control_strategy_supplier_func_t,
    pub multicast_flow_control_supplier_func: aeron_flow_control_strategy_supplier_func_t,
    pub congestion_control_supplier_func: aeron_congestion_control_strategy_supplier_func_t,
    pub conductor_proxy: *mut aeron_driver_conductor_proxy_t,
    pub sender_proxy: *mut aeron_driver_sender_proxy_t,
    pub receiver_proxy: *mut aeron_driver_receiver_proxy_t,
    pub counters_manager: *mut aeron_counters_manager_t,
    pub system_counters: *mut aeron_system_counters_t,
    pub error_log: *mut aeron_distinct_error_log_t,
    pub to_driver_interceptor_func: aeron_driver_conductor_to_driver_interceptor_func_t,
    pub to_client_interceptor_func: aeron_driver_conductor_to_client_interceptor_func_t,
    pub remove_publication_cleanup_func: aeron_on_remove_publication_cleanup_func_t,
    pub remove_subscription_cleanup_func: aeron_on_remove_subscription_cleanup_func_t,
    pub remove_image_cleanup_func: aeron_on_remove_image_cleanup_func_t,
    pub sender_proxy_on_add_endpoint_func: aeron_on_endpoint_change_func_t,
    pub sender_proxy_on_remove_endpoint_func: aeron_on_endpoint_change_func_t,
    pub receiver_proxy_on_add_endpoint_func: aeron_on_endpoint_change_func_t,
    pub receiver_proxy_on_remove_endpoint_func: aeron_on_endpoint_change_func_t,
    pub untethered_subscription_state_change_func:
        aeron_untethered_subscription_state_change_func_t,
    pub name_resolution_on_neighbor_added_func:
        aeron_driver_name_resolver_on_neighbor_change_func_t,
    pub name_resolution_on_neighbor_removed_func:
        aeron_driver_name_resolver_on_neighbor_change_func_t,
    pub flow_control_on_receiver_added_func:
        aeron_driver_flow_control_strategy_on_receiver_change_func_t,
    pub flow_control_on_receiver_removed_func:
        aeron_driver_flow_control_strategy_on_receiver_change_func_t,
    pub termination_validator_func: aeron_driver_termination_validator_func_t,
    pub termination_validator_state: *mut ::std::os::raw::c_void,
    pub termination_hook_func: aeron_driver_termination_hook_func_t,
    pub termination_hook_state: *mut ::std::os::raw::c_void,
    pub udp_channel_transport_bindings: *mut aeron_udp_channel_transport_bindings_t,
    pub conductor_udp_channel_transport_bindings: *mut aeron_udp_channel_transport_bindings_t,
    pub udp_channel_outgoing_interceptor_bindings: *mut aeron_udp_channel_interceptor_bindings_t,
    pub udp_channel_incoming_interceptor_bindings: *mut aeron_udp_channel_interceptor_bindings_t,
    pub next_receiver_id: i64,
    pub unicast_delay_feedback_generator: aeron_feedback_delay_generator_state_t,
    pub multicast_delay_feedback_generator: aeron_feedback_delay_generator_state_t,
    pub resolver_name: *const ::std::os::raw::c_char,
    pub resolver_interface: *const ::std::os::raw::c_char,
    pub resolver_bootstrap_neighbor: *const ::std::os::raw::c_char,
    pub name_resolver_supplier_func: aeron_name_resolver_supplier_func_t,
    pub driver_name_resolver_bootstrap_resolver_supplier_func: aeron_name_resolver_supplier_func_t,
    pub name_resolver_init_args: *const ::std::os::raw::c_char,
    pub on_name_resolve_func: aeron_driver_name_resolver_on_resolve_t,
    pub on_name_lookup_func: aeron_driver_name_resolver_on_lookup_t,
    pub conductor_duty_cycle_tracker: *mut aeron_duty_cycle_tracker_t,
    pub sender_duty_cycle_tracker: *mut aeron_duty_cycle_tracker_t,
    pub receiver_duty_cycle_tracker: *mut aeron_duty_cycle_tracker_t,
    pub name_resolver_time_tracker: *mut aeron_duty_cycle_tracker_t,
    pub conductor_duty_cycle_stall_tracker: aeron_duty_cycle_stall_tracker_t,
    pub sender_duty_cycle_stall_tracker: aeron_duty_cycle_stall_tracker_t,
    pub receiver_duty_cycle_stall_tracker: aeron_duty_cycle_stall_tracker_t,
    pub name_resolver_time_stall_tracker: aeron_duty_cycle_stall_tracker_t,
    pub dynamic_libs: *mut aeron_dl_loaded_libs_state_t,
    pub bindings_clientd_entries: *mut aeron_driver_context_bindings_clientd_entry_t,
    pub num_bindings_clientd_entries: usize,
    pub os_buffer_lengths: aeron_driver_context_stct__bindgen_ty_3,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aeron_driver_context_stct__bindgen_ty_1 {
    pub is_present: bool,
    pub value: i64,
}
#[test]
fn bindgen_test_layout_aeron_driver_context_stct__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<aeron_driver_context_stct__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_driver_context_stct__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(aeron_driver_context_stct__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_driver_context_stct__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(aeron_driver_context_stct__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).is_present) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_context_stct__bindgen_ty_1),
            "::",
            stringify!(is_present)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_context_stct__bindgen_ty_1),
            "::",
            stringify!(value)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aeron_driver_context_stct__bindgen_ty_2 {
    pub group_min_size: i32,
    pub receiver_timeout_ns: u64,
    pub group_tag: i64,
}
#[test]
fn bindgen_test_layout_aeron_driver_context_stct__bindgen_ty_2() {
    const UNINIT: ::std::mem::MaybeUninit<aeron_driver_context_stct__bindgen_ty_2> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_driver_context_stct__bindgen_ty_2>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(aeron_driver_context_stct__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_driver_context_stct__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(aeron_driver_context_stct__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).group_min_size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_context_stct__bindgen_ty_2),
            "::",
            stringify!(group_min_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).receiver_timeout_ns) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_context_stct__bindgen_ty_2),
            "::",
            stringify!(receiver_timeout_ns)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).group_tag) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_context_stct__bindgen_ty_2),
            "::",
            stringify!(group_tag)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aeron_driver_context_stct__bindgen_ty_3 {
    pub default_so_sndbuf: usize,
    pub max_so_sndbuf: usize,
    pub default_so_rcvbuf: usize,
    pub max_so_rcvbuf: usize,
}
#[test]
fn bindgen_test_layout_aeron_driver_context_stct__bindgen_ty_3() {
    const UNINIT: ::std::mem::MaybeUninit<aeron_driver_context_stct__bindgen_ty_3> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_driver_context_stct__bindgen_ty_3>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(aeron_driver_context_stct__bindgen_ty_3)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_driver_context_stct__bindgen_ty_3>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(aeron_driver_context_stct__bindgen_ty_3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).default_so_sndbuf) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_context_stct__bindgen_ty_3),
            "::",
            stringify!(default_so_sndbuf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_so_sndbuf) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_context_stct__bindgen_ty_3),
            "::",
            stringify!(max_so_sndbuf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).default_so_rcvbuf) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_context_stct__bindgen_ty_3),
            "::",
            stringify!(default_so_rcvbuf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_so_rcvbuf) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_context_stct__bindgen_ty_3),
            "::",
            stringify!(max_so_rcvbuf)
        )
    );
}
#[test]
fn bindgen_test_layout_aeron_driver_context_stct() {
    const UNINIT: ::std::mem::MaybeUninit<aeron_driver_context_stct> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_driver_context_stct>(),
        1984usize,
        concat!("Size of: ", stringify!(aeron_driver_context_stct))
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_driver_context_stct>(),
        8usize,
        concat!("Alignment of ", stringify!(aeron_driver_context_stct))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).aeron_dir) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_context_stct),
            "::",
            stringify!(aeron_dir)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).threading_mode) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_context_stct),
            "::",
            stringify!(threading_mode)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).receiver_group_consideration) as usize - ptr as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_context_stct),
            "::",
            stringify!(receiver_group_consideration)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dirs_delete_on_start) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_context_stct),
            "::",
            stringify!(dirs_delete_on_start)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dirs_delete_on_shutdown) as usize - ptr as usize },
        17usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_context_stct),
            "::",
            stringify!(dirs_delete_on_shutdown)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).warn_if_dirs_exist) as usize - ptr as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_context_stct),
            "::",
            stringify!(warn_if_dirs_exist)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).term_buffer_sparse_file) as usize - ptr as usize },
        19usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_context_stct),
            "::",
            stringify!(term_buffer_sparse_file)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).perform_storage_checks) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_context_stct),
            "::",
            stringify!(perform_storage_checks)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).spies_simulate_connection) as usize - ptr as usize },
        21usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_context_stct),
            "::",
            stringify!(spies_simulate_connection)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).print_configuration_on_start) as usize - ptr as usize
        },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_context_stct),
            "::",
            stringify!(print_configuration_on_start)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reliable_stream) as usize - ptr as usize },
        23usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_context_stct),
            "::",
            stringify!(reliable_stream)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tether_subscriptions) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_context_stct),
            "::",
            stringify!(tether_subscriptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rejoin_stream) as usize - ptr as usize },
        25usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_context_stct),
            "::",
            stringify!(rejoin_stream)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ats_enabled) as usize - ptr as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_context_stct),
            "::",
            stringify!(ats_enabled)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).connect_enabled) as usize - ptr as usize },
        27usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_context_stct),
            "::",
            stringify!(connect_enabled)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).driver_timeout_ms) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_context_stct),
            "::",
            stringify!(driver_timeout_ms)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).client_liveness_timeout_ns) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_context_stct),
            "::",
            stringify!(client_liveness_timeout_ns)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).publication_linger_timeout_ns) as usize - ptr as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_context_stct),
            "::",
            stringify!(publication_linger_timeout_ns)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).status_message_timeout_ns) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_context_stct),
            "::",
            stringify!(status_message_timeout_ns)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).image_liveness_timeout_ns) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_context_stct),
            "::",
            stringify!(image_liveness_timeout_ns)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).publication_unblock_timeout_ns) as usize - ptr as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_context_stct),
            "::",
            stringify!(publication_unblock_timeout_ns)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).publication_connection_timeout_ns) as usize - ptr as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_context_stct),
            "::",
            stringify!(publication_connection_timeout_ns)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timer_interval_ns) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_context_stct),
            "::",
            stringify!(timer_interval_ns)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).counter_free_to_reuse_ns) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_context_stct),
            "::",
            stringify!(counter_free_to_reuse_ns)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).untethered_window_limit_timeout_ns) as usize - ptr as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_context_stct),
            "::",
            stringify!(untethered_window_limit_timeout_ns)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).untethered_resting_timeout_ns) as usize - ptr as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_context_stct),
            "::",
            stringify!(untethered_resting_timeout_ns)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).retransmit_unicast_delay_ns) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_context_stct),
            "::",
            stringify!(retransmit_unicast_delay_ns)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).retransmit_unicast_linger_ns) as usize - ptr as usize
        },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_context_stct),
            "::",
            stringify!(retransmit_unicast_linger_ns)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nak_unicast_delay_ns) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_context_stct),
            "::",
            stringify!(nak_unicast_delay_ns)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).nak_multicast_max_backoff_ns) as usize - ptr as usize
        },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_context_stct),
            "::",
            stringify!(nak_multicast_max_backoff_ns)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).re_resolution_check_interval_ns) as usize - ptr as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_context_stct),
            "::",
            stringify!(re_resolution_check_interval_ns)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).to_driver_buffer_length) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_context_stct),
            "::",
            stringify!(to_driver_buffer_length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).to_clients_buffer_length) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_context_stct),
            "::",
            stringify!(to_clients_buffer_length)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).counters_values_buffer_length) as usize - ptr as usize
        },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_context_stct),
            "::",
            stringify!(counters_values_buffer_length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).error_buffer_length) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_context_stct),
            "::",
            stringify!(error_buffer_length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).term_buffer_length) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_context_stct),
            "::",
            stringify!(term_buffer_length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ipc_term_buffer_length) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_context_stct),
            "::",
            stringify!(ipc_term_buffer_length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mtu_length) as usize - ptr as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_context_stct),
            "::",
            stringify!(mtu_length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ipc_mtu_length) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_context_stct),
            "::",
            stringify!(ipc_mtu_length)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ipc_publication_window_length) as usize - ptr as usize
        },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_context_stct),
            "::",
            stringify!(ipc_publication_window_length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).publication_window_length) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_context_stct),
            "::",
            stringify!(publication_window_length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).socket_rcvbuf) as usize - ptr as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_context_stct),
            "::",
            stringify!(socket_rcvbuf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).socket_sndbuf) as usize - ptr as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_context_stct),
            "::",
            stringify!(socket_sndbuf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).send_to_sm_poll_ratio) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_context_stct),
            "::",
            stringify!(send_to_sm_poll_ratio)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).initial_window_length) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_context_stct),
            "::",
            stringify!(initial_window_length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).loss_report_length) as usize - ptr as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_context_stct),
            "::",
            stringify!(loss_report_length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).file_page_size) as usize - ptr as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_context_stct),
            "::",
            stringify!(file_page_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nak_multicast_group_size) as usize - ptr as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_context_stct),
            "::",
            stringify!(nak_multicast_group_size)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).publication_reserved_session_id_low) as usize - ptr as usize
        },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_context_stct),
            "::",
            stringify!(publication_reserved_session_id_low)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).publication_reserved_session_id_high) as usize
                - ptr as usize
        },
        300usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_context_stct),
            "::",
            stringify!(publication_reserved_session_id_high)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).multicast_ttl) as usize - ptr as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_context_stct),
            "::",
            stringify!(multicast_ttl)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).receiver_io_vector_capacity) as usize - ptr as usize },
        308usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_context_stct),
            "::",
            stringify!(receiver_io_vector_capacity)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sender_io_vector_capacity) as usize - ptr as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_context_stct),
            "::",
            stringify!(sender_io_vector_capacity)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).network_publication_max_messages_per_send) as usize
                - ptr as usize
        },
        316usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_context_stct),
            "::",
            stringify!(network_publication_max_messages_per_send)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).resource_free_limit) as usize - ptr as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_context_stct),
            "::",
            stringify!(resource_free_limit)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).conductor_cpu_affinity_no) as usize - ptr as usize },
        324usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_context_stct),
            "::",
            stringify!(conductor_cpu_affinity_no)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).receiver_cpu_affinity_no) as usize - ptr as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_context_stct),
            "::",
            stringify!(receiver_cpu_affinity_no)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sender_cpu_affinity_no) as usize - ptr as usize },
        332usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_context_stct),
            "::",
            stringify!(sender_cpu_affinity_no)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).receiver_group_tag) as usize - ptr as usize },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_context_stct),
            "::",
            stringify!(receiver_group_tag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flow_control) as usize - ptr as usize },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_context_stct),
            "::",
            stringify!(flow_control)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cnc_map) as usize - ptr as usize },
        376usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_context_stct),
            "::",
            stringify!(cnc_map)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).loss_report) as usize - ptr as usize },
        392usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_context_stct),
            "::",
            stringify!(loss_report)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).to_driver_buffer) as usize - ptr as usize },
        408usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_context_stct),
            "::",
            stringify!(to_driver_buffer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).to_clients_buffer) as usize - ptr as usize },
        416usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_context_stct),
            "::",
            stringify!(to_clients_buffer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).counters_values_buffer) as usize - ptr as usize },
        424usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_context_stct),
            "::",
            stringify!(counters_values_buffer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).counters_metadata_buffer) as usize - ptr as usize },
        432usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_context_stct),
            "::",
            stringify!(counters_metadata_buffer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).error_buffer) as usize - ptr as usize },
        440usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_context_stct),
            "::",
            stringify!(error_buffer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nano_clock) as usize - ptr as usize },
        448usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_context_stct),
            "::",
            stringify!(nano_clock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).epoch_clock) as usize - ptr as usize },
        456usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_context_stct),
            "::",
            stringify!(epoch_clock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cached_clock) as usize - ptr as usize },
        464usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_context_stct),
            "::",
            stringify!(cached_clock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sender_cached_clock) as usize - ptr as usize },
        472usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_context_stct),
            "::",
            stringify!(sender_cached_clock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).receiver_cached_clock) as usize - ptr as usize },
        480usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_context_stct),
            "::",
            stringify!(receiver_cached_clock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sender_command_queue) as usize - ptr as usize },
        488usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_context_stct),
            "::",
            stringify!(sender_command_queue)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).receiver_command_queue) as usize - ptr as usize },
        520usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_context_stct),
            "::",
            stringify!(receiver_command_queue)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).conductor_command_queue) as usize - ptr as usize },
        552usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_context_stct),
            "::",
            stringify!(conductor_command_queue)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).agent_on_start_func) as usize - ptr as usize },
        584usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_context_stct),
            "::",
            stringify!(agent_on_start_func)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).agent_on_start_state) as usize - ptr as usize },
        592usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_context_stct),
            "::",
            stringify!(agent_on_start_state)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).conductor_idle_strategy_func) as usize - ptr as usize
        },
        600usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_context_stct),
            "::",
            stringify!(conductor_idle_strategy_func)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).conductor_idle_strategy_state) as usize - ptr as usize
        },
        608usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_context_stct),
            "::",
            stringify!(conductor_idle_strategy_state)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).conductor_idle_strategy_init_args) as usize - ptr as usize
        },
        616usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_context_stct),
            "::",
            stringify!(conductor_idle_strategy_init_args)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).conductor_idle_strategy_name) as usize - ptr as usize
        },
        624usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_context_stct),
            "::",
            stringify!(conductor_idle_strategy_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).shared_idle_strategy_func) as usize - ptr as usize },
        632usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_context_stct),
            "::",
            stringify!(shared_idle_strategy_func)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).shared_idle_strategy_state) as usize - ptr as usize },
        640usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_context_stct),
            "::",
            stringify!(shared_idle_strategy_state)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).shared_idle_strategy_init_args) as usize - ptr as usize
        },
        648usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_context_stct),
            "::",
            stringify!(shared_idle_strategy_init_args)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).shared_idle_strategy_name) as usize - ptr as usize },
        656usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_context_stct),
            "::",
            stringify!(shared_idle_strategy_name)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).shared_network_idle_strategy_func) as usize - ptr as usize
        },
        664usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_context_stct),
            "::",
            stringify!(shared_network_idle_strategy_func)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).shared_network_idle_strategy_state) as usize - ptr as usize
        },
        672usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_context_stct),
            "::",
            stringify!(shared_network_idle_strategy_state)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).shared_network_idle_strategy_init_args) as usize
                - ptr as usize
        },
        680usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_context_stct),
            "::",
            stringify!(shared_network_idle_strategy_init_args)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).shared_network_idle_strategy_name) as usize - ptr as usize
        },
        688usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_context_stct),
            "::",
            stringify!(shared_network_idle_strategy_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sender_idle_strategy_func) as usize - ptr as usize },
        696usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_context_stct),
            "::",
            stringify!(sender_idle_strategy_func)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sender_idle_strategy_state) as usize - ptr as usize },
        704usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_context_stct),
            "::",
            stringify!(sender_idle_strategy_state)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).sender_idle_strategy_init_args) as usize - ptr as usize
        },
        712usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_context_stct),
            "::",
            stringify!(sender_idle_strategy_init_args)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sender_idle_strategy_name) as usize - ptr as usize },
        720usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_context_stct),
            "::",
            stringify!(sender_idle_strategy_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).receiver_idle_strategy_func) as usize - ptr as usize },
        728usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_context_stct),
            "::",
            stringify!(receiver_idle_strategy_func)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).receiver_idle_strategy_state) as usize - ptr as usize
        },
        736usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_context_stct),
            "::",
            stringify!(receiver_idle_strategy_state)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).receiver_idle_strategy_init_args) as usize - ptr as usize
        },
        744usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_context_stct),
            "::",
            stringify!(receiver_idle_strategy_init_args)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).receiver_idle_strategy_name) as usize - ptr as usize },
        752usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_context_stct),
            "::",
            stringify!(receiver_idle_strategy_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).usable_fs_space_func) as usize - ptr as usize },
        760usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_context_stct),
            "::",
            stringify!(usable_fs_space_func)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).raw_log_map_func) as usize - ptr as usize },
        768usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_context_stct),
            "::",
            stringify!(raw_log_map_func)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).raw_log_close_func) as usize - ptr as usize },
        776usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_context_stct),
            "::",
            stringify!(raw_log_close_func)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).raw_log_free_func) as usize - ptr as usize },
        784usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_context_stct),
            "::",
            stringify!(raw_log_free_func)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).unicast_flow_control_supplier_func) as usize - ptr as usize
        },
        792usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_context_stct),
            "::",
            stringify!(unicast_flow_control_supplier_func)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).multicast_flow_control_supplier_func) as usize
                - ptr as usize
        },
        800usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_context_stct),
            "::",
            stringify!(multicast_flow_control_supplier_func)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).congestion_control_supplier_func) as usize - ptr as usize
        },
        808usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_context_stct),
            "::",
            stringify!(congestion_control_supplier_func)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).conductor_proxy) as usize - ptr as usize },
        816usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_context_stct),
            "::",
            stringify!(conductor_proxy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sender_proxy) as usize - ptr as usize },
        824usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_context_stct),
            "::",
            stringify!(sender_proxy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).receiver_proxy) as usize - ptr as usize },
        832usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_context_stct),
            "::",
            stringify!(receiver_proxy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).counters_manager) as usize - ptr as usize },
        840usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_context_stct),
            "::",
            stringify!(counters_manager)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).system_counters) as usize - ptr as usize },
        848usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_context_stct),
            "::",
            stringify!(system_counters)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).error_log) as usize - ptr as usize },
        856usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_context_stct),
            "::",
            stringify!(error_log)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).to_driver_interceptor_func) as usize - ptr as usize },
        864usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_context_stct),
            "::",
            stringify!(to_driver_interceptor_func)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).to_client_interceptor_func) as usize - ptr as usize },
        872usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_context_stct),
            "::",
            stringify!(to_client_interceptor_func)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).remove_publication_cleanup_func) as usize - ptr as usize
        },
        880usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_context_stct),
            "::",
            stringify!(remove_publication_cleanup_func)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).remove_subscription_cleanup_func) as usize - ptr as usize
        },
        888usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_context_stct),
            "::",
            stringify!(remove_subscription_cleanup_func)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).remove_image_cleanup_func) as usize - ptr as usize },
        896usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_context_stct),
            "::",
            stringify!(remove_image_cleanup_func)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).sender_proxy_on_add_endpoint_func) as usize - ptr as usize
        },
        904usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_context_stct),
            "::",
            stringify!(sender_proxy_on_add_endpoint_func)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).sender_proxy_on_remove_endpoint_func) as usize
                - ptr as usize
        },
        912usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_context_stct),
            "::",
            stringify!(sender_proxy_on_remove_endpoint_func)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).receiver_proxy_on_add_endpoint_func) as usize - ptr as usize
        },
        920usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_context_stct),
            "::",
            stringify!(receiver_proxy_on_add_endpoint_func)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).receiver_proxy_on_remove_endpoint_func) as usize
                - ptr as usize
        },
        928usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_context_stct),
            "::",
            stringify!(receiver_proxy_on_remove_endpoint_func)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).untethered_subscription_state_change_func) as usize
                - ptr as usize
        },
        936usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_context_stct),
            "::",
            stringify!(untethered_subscription_state_change_func)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).name_resolution_on_neighbor_added_func) as usize
                - ptr as usize
        },
        944usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_context_stct),
            "::",
            stringify!(name_resolution_on_neighbor_added_func)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).name_resolution_on_neighbor_removed_func) as usize
                - ptr as usize
        },
        952usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_context_stct),
            "::",
            stringify!(name_resolution_on_neighbor_removed_func)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).flow_control_on_receiver_added_func) as usize - ptr as usize
        },
        960usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_context_stct),
            "::",
            stringify!(flow_control_on_receiver_added_func)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).flow_control_on_receiver_removed_func) as usize
                - ptr as usize
        },
        968usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_context_stct),
            "::",
            stringify!(flow_control_on_receiver_removed_func)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).termination_validator_func) as usize - ptr as usize },
        976usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_context_stct),
            "::",
            stringify!(termination_validator_func)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).termination_validator_state) as usize - ptr as usize },
        984usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_context_stct),
            "::",
            stringify!(termination_validator_state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).termination_hook_func) as usize - ptr as usize },
        992usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_context_stct),
            "::",
            stringify!(termination_hook_func)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).termination_hook_state) as usize - ptr as usize },
        1000usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_context_stct),
            "::",
            stringify!(termination_hook_state)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).udp_channel_transport_bindings) as usize - ptr as usize
        },
        1008usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_context_stct),
            "::",
            stringify!(udp_channel_transport_bindings)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).conductor_udp_channel_transport_bindings) as usize
                - ptr as usize
        },
        1016usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_context_stct),
            "::",
            stringify!(conductor_udp_channel_transport_bindings)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).udp_channel_outgoing_interceptor_bindings) as usize
                - ptr as usize
        },
        1024usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_context_stct),
            "::",
            stringify!(udp_channel_outgoing_interceptor_bindings)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).udp_channel_incoming_interceptor_bindings) as usize
                - ptr as usize
        },
        1032usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_context_stct),
            "::",
            stringify!(udp_channel_incoming_interceptor_bindings)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next_receiver_id) as usize - ptr as usize },
        1040usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_context_stct),
            "::",
            stringify!(next_receiver_id)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).unicast_delay_feedback_generator) as usize - ptr as usize
        },
        1048usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_context_stct),
            "::",
            stringify!(unicast_delay_feedback_generator)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).multicast_delay_feedback_generator) as usize - ptr as usize
        },
        1104usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_context_stct),
            "::",
            stringify!(multicast_delay_feedback_generator)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).resolver_name) as usize - ptr as usize },
        1160usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_context_stct),
            "::",
            stringify!(resolver_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).resolver_interface) as usize - ptr as usize },
        1168usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_context_stct),
            "::",
            stringify!(resolver_interface)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).resolver_bootstrap_neighbor) as usize - ptr as usize },
        1176usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_context_stct),
            "::",
            stringify!(resolver_bootstrap_neighbor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name_resolver_supplier_func) as usize - ptr as usize },
        1184usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_context_stct),
            "::",
            stringify!(name_resolver_supplier_func)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).driver_name_resolver_bootstrap_resolver_supplier_func)
                as usize
                - ptr as usize
        },
        1192usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_context_stct),
            "::",
            stringify!(driver_name_resolver_bootstrap_resolver_supplier_func)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name_resolver_init_args) as usize - ptr as usize },
        1200usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_context_stct),
            "::",
            stringify!(name_resolver_init_args)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).on_name_resolve_func) as usize - ptr as usize },
        1208usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_context_stct),
            "::",
            stringify!(on_name_resolve_func)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).on_name_lookup_func) as usize - ptr as usize },
        1216usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_context_stct),
            "::",
            stringify!(on_name_lookup_func)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).conductor_duty_cycle_tracker) as usize - ptr as usize
        },
        1224usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_context_stct),
            "::",
            stringify!(conductor_duty_cycle_tracker)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sender_duty_cycle_tracker) as usize - ptr as usize },
        1232usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_context_stct),
            "::",
            stringify!(sender_duty_cycle_tracker)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).receiver_duty_cycle_tracker) as usize - ptr as usize },
        1240usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_context_stct),
            "::",
            stringify!(receiver_duty_cycle_tracker)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name_resolver_time_tracker) as usize - ptr as usize },
        1248usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_context_stct),
            "::",
            stringify!(name_resolver_time_tracker)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).conductor_duty_cycle_stall_tracker) as usize - ptr as usize
        },
        1256usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_context_stct),
            "::",
            stringify!(conductor_duty_cycle_stall_tracker)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).sender_duty_cycle_stall_tracker) as usize - ptr as usize
        },
        1424usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_context_stct),
            "::",
            stringify!(sender_duty_cycle_stall_tracker)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).receiver_duty_cycle_stall_tracker) as usize - ptr as usize
        },
        1592usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_context_stct),
            "::",
            stringify!(receiver_duty_cycle_stall_tracker)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).name_resolver_time_stall_tracker) as usize - ptr as usize
        },
        1760usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_context_stct),
            "::",
            stringify!(name_resolver_time_stall_tracker)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dynamic_libs) as usize - ptr as usize },
        1928usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_context_stct),
            "::",
            stringify!(dynamic_libs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bindings_clientd_entries) as usize - ptr as usize },
        1936usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_context_stct),
            "::",
            stringify!(bindings_clientd_entries)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).num_bindings_clientd_entries) as usize - ptr as usize
        },
        1944usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_context_stct),
            "::",
            stringify!(num_bindings_clientd_entries)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).os_buffer_lengths) as usize - ptr as usize },
        1952usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_context_stct),
            "::",
            stringify!(os_buffer_lengths)
        )
    );
}
extern "C" {
    pub fn aeron_config_parse_inferable_boolean(
        inferable_boolean: *const ::std::os::raw::c_char,
        def: aeron_inferable_boolean_t,
    ) -> aeron_inferable_boolean_t;
}
extern "C" {
    pub fn aeron_driver_threading_mode_to_string(
        mode: aeron_threading_mode_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn aeron_driver_context_print_configuration(context: *mut aeron_driver_context_t);
}
extern "C" {
    pub fn aeron_driver_fill_cnc_metadata(context: *mut aeron_driver_context_t);
}
extern "C" {
    pub fn aeron_driver_validate_unblock_timeout(
        context: *mut aeron_driver_context_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_driver_validate_untethered_timeouts(
        context: *mut aeron_driver_context_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_driver_context_validate_mtu_length(mtu_length: u64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_cnc_length(context: *mut aeron_driver_context_t) -> usize;
}
extern "C" {
    pub fn aeron_driver_context_bindings_clientd_create_entries(
        context: *mut aeron_driver_context_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_driver_context_bindings_clientd_delete_entries(
        context: *mut aeron_driver_context_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_driver_context_bindings_clientd_find_first_free_index(
        context: *mut aeron_driver_context_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_driver_context_bindings_clientd_find(
        context: *mut aeron_driver_context_t,
        name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_driver_context_bindings_clientd_get_or_find_first_free_entry(
        context: *mut aeron_driver_context_t,
        name: *const ::std::os::raw::c_char,
    ) -> *mut aeron_driver_context_bindings_clientd_entry_t;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aeron_broadcast_transmitter_stct {
    pub buffer: *mut u8,
    pub descriptor: *mut aeron_broadcast_descriptor_t,
    pub capacity: usize,
    pub max_message_length: usize,
}
#[test]
fn bindgen_test_layout_aeron_broadcast_transmitter_stct() {
    const UNINIT: ::std::mem::MaybeUninit<aeron_broadcast_transmitter_stct> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_broadcast_transmitter_stct>(),
        32usize,
        concat!("Size of: ", stringify!(aeron_broadcast_transmitter_stct))
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_broadcast_transmitter_stct>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(aeron_broadcast_transmitter_stct)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buffer) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_broadcast_transmitter_stct),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).descriptor) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_broadcast_transmitter_stct),
            "::",
            stringify!(descriptor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).capacity) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_broadcast_transmitter_stct),
            "::",
            stringify!(capacity)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_message_length) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_broadcast_transmitter_stct),
            "::",
            stringify!(max_message_length)
        )
    );
}
pub type aeron_broadcast_transmitter_t = aeron_broadcast_transmitter_stct;
extern "C" {
    pub fn aeron_broadcast_transmitter_init(
        transmitter: *mut aeron_broadcast_transmitter_t,
        buffer: *mut ::std::os::raw::c_void,
        length: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_broadcast_transmitter_transmit(
        transmitter: *mut aeron_broadcast_transmitter_t,
        msg_type_id: i32,
        msg: *const ::std::os::raw::c_void,
        length: usize,
    ) -> ::std::os::raw::c_int;
}
#[repr(C, packed(4))]
#[derive(Copy, Clone)]
pub struct aeron_correlated_command_stct {
    pub client_id: i64,
    pub correlation_id: i64,
}
#[test]
fn bindgen_test_layout_aeron_correlated_command_stct() {
    const UNINIT: ::std::mem::MaybeUninit<aeron_correlated_command_stct> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_correlated_command_stct>(),
        16usize,
        concat!("Size of: ", stringify!(aeron_correlated_command_stct))
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_correlated_command_stct>(),
        4usize,
        concat!("Alignment of ", stringify!(aeron_correlated_command_stct))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).client_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_correlated_command_stct),
            "::",
            stringify!(client_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).correlation_id) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_correlated_command_stct),
            "::",
            stringify!(correlation_id)
        )
    );
}
pub type aeron_correlated_command_t = aeron_correlated_command_stct;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aeron_publication_command_stct {
    pub correlated: aeron_correlated_command_t,
    pub stream_id: i32,
    pub channel_length: i32,
}
#[test]
fn bindgen_test_layout_aeron_publication_command_stct() {
    const UNINIT: ::std::mem::MaybeUninit<aeron_publication_command_stct> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_publication_command_stct>(),
        24usize,
        concat!("Size of: ", stringify!(aeron_publication_command_stct))
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_publication_command_stct>(),
        4usize,
        concat!("Alignment of ", stringify!(aeron_publication_command_stct))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).correlated) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_publication_command_stct),
            "::",
            stringify!(correlated)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stream_id) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_publication_command_stct),
            "::",
            stringify!(stream_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).channel_length) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_publication_command_stct),
            "::",
            stringify!(channel_length)
        )
    );
}
pub type aeron_publication_command_t = aeron_publication_command_stct;
#[repr(C, packed(4))]
#[derive(Copy, Clone)]
pub struct aeron_publication_buffers_ready_stct {
    pub correlation_id: i64,
    pub registration_id: i64,
    pub session_id: i32,
    pub stream_id: i32,
    pub position_limit_counter_id: i32,
    pub channel_status_indicator_id: i32,
    pub log_file_length: i32,
}
#[test]
fn bindgen_test_layout_aeron_publication_buffers_ready_stct() {
    const UNINIT: ::std::mem::MaybeUninit<aeron_publication_buffers_ready_stct> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_publication_buffers_ready_stct>(),
        36usize,
        concat!(
            "Size of: ",
            stringify!(aeron_publication_buffers_ready_stct)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_publication_buffers_ready_stct>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(aeron_publication_buffers_ready_stct)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).correlation_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_publication_buffers_ready_stct),
            "::",
            stringify!(correlation_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).registration_id) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_publication_buffers_ready_stct),
            "::",
            stringify!(registration_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).session_id) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_publication_buffers_ready_stct),
            "::",
            stringify!(session_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stream_id) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_publication_buffers_ready_stct),
            "::",
            stringify!(stream_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).position_limit_counter_id) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_publication_buffers_ready_stct),
            "::",
            stringify!(position_limit_counter_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).channel_status_indicator_id) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_publication_buffers_ready_stct),
            "::",
            stringify!(channel_status_indicator_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).log_file_length) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_publication_buffers_ready_stct),
            "::",
            stringify!(log_file_length)
        )
    );
}
pub type aeron_publication_buffers_ready_t = aeron_publication_buffers_ready_stct;
#[repr(C, packed(4))]
#[derive(Copy, Clone)]
pub struct aeron_subscription_command_stct {
    pub correlated: aeron_correlated_command_t,
    pub registration_correlation_id: i64,
    pub stream_id: i32,
    pub channel_length: i32,
}
#[test]
fn bindgen_test_layout_aeron_subscription_command_stct() {
    const UNINIT: ::std::mem::MaybeUninit<aeron_subscription_command_stct> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_subscription_command_stct>(),
        32usize,
        concat!("Size of: ", stringify!(aeron_subscription_command_stct))
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_subscription_command_stct>(),
        4usize,
        concat!("Alignment of ", stringify!(aeron_subscription_command_stct))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).correlated) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_subscription_command_stct),
            "::",
            stringify!(correlated)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).registration_correlation_id) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_subscription_command_stct),
            "::",
            stringify!(registration_correlation_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stream_id) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_subscription_command_stct),
            "::",
            stringify!(stream_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).channel_length) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_subscription_command_stct),
            "::",
            stringify!(channel_length)
        )
    );
}
pub type aeron_subscription_command_t = aeron_subscription_command_stct;
#[repr(C, packed(4))]
#[derive(Copy, Clone)]
pub struct aeron_subscription_ready_stct {
    pub correlation_id: i64,
    pub channel_status_indicator_id: i32,
}
#[test]
fn bindgen_test_layout_aeron_subscription_ready_stct() {
    const UNINIT: ::std::mem::MaybeUninit<aeron_subscription_ready_stct> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_subscription_ready_stct>(),
        12usize,
        concat!("Size of: ", stringify!(aeron_subscription_ready_stct))
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_subscription_ready_stct>(),
        4usize,
        concat!("Alignment of ", stringify!(aeron_subscription_ready_stct))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).correlation_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_subscription_ready_stct),
            "::",
            stringify!(correlation_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).channel_status_indicator_id) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_subscription_ready_stct),
            "::",
            stringify!(channel_status_indicator_id)
        )
    );
}
pub type aeron_subscription_ready_t = aeron_subscription_ready_stct;
#[repr(C, packed(4))]
#[derive(Copy, Clone)]
pub struct aeron_image_buffers_ready_stct {
    pub correlation_id: i64,
    pub session_id: i32,
    pub stream_id: i32,
    pub subscriber_registration_id: i64,
    pub subscriber_position_id: i32,
}
#[test]
fn bindgen_test_layout_aeron_image_buffers_ready_stct() {
    const UNINIT: ::std::mem::MaybeUninit<aeron_image_buffers_ready_stct> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_image_buffers_ready_stct>(),
        28usize,
        concat!("Size of: ", stringify!(aeron_image_buffers_ready_stct))
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_image_buffers_ready_stct>(),
        4usize,
        concat!("Alignment of ", stringify!(aeron_image_buffers_ready_stct))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).correlation_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_image_buffers_ready_stct),
            "::",
            stringify!(correlation_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).session_id) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_image_buffers_ready_stct),
            "::",
            stringify!(session_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stream_id) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_image_buffers_ready_stct),
            "::",
            stringify!(stream_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).subscriber_registration_id) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_image_buffers_ready_stct),
            "::",
            stringify!(subscriber_registration_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).subscriber_position_id) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_image_buffers_ready_stct),
            "::",
            stringify!(subscriber_position_id)
        )
    );
}
pub type aeron_image_buffers_ready_t = aeron_image_buffers_ready_stct;
#[repr(C, packed(4))]
#[derive(Copy, Clone)]
pub struct aeron_operation_succeeded_stct {
    pub correlation_id: i64,
}
#[test]
fn bindgen_test_layout_aeron_operation_succeeded_stct() {
    const UNINIT: ::std::mem::MaybeUninit<aeron_operation_succeeded_stct> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_operation_succeeded_stct>(),
        8usize,
        concat!("Size of: ", stringify!(aeron_operation_succeeded_stct))
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_operation_succeeded_stct>(),
        4usize,
        concat!("Alignment of ", stringify!(aeron_operation_succeeded_stct))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).correlation_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_operation_succeeded_stct),
            "::",
            stringify!(correlation_id)
        )
    );
}
pub type aeron_operation_succeeded_t = aeron_operation_succeeded_stct;
#[repr(C, packed(4))]
#[derive(Copy, Clone)]
pub struct aeron_error_response_stct {
    pub offending_command_correlation_id: i64,
    pub error_code: i32,
    pub error_message_length: i32,
}
#[test]
fn bindgen_test_layout_aeron_error_response_stct() {
    const UNINIT: ::std::mem::MaybeUninit<aeron_error_response_stct> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_error_response_stct>(),
        16usize,
        concat!("Size of: ", stringify!(aeron_error_response_stct))
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_error_response_stct>(),
        4usize,
        concat!("Alignment of ", stringify!(aeron_error_response_stct))
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).offending_command_correlation_id) as usize - ptr as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_error_response_stct),
            "::",
            stringify!(offending_command_correlation_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).error_code) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_error_response_stct),
            "::",
            stringify!(error_code)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).error_message_length) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_error_response_stct),
            "::",
            stringify!(error_message_length)
        )
    );
}
pub type aeron_error_response_t = aeron_error_response_stct;
#[repr(C, packed(4))]
#[derive(Copy, Clone)]
pub struct aeron_remove_command_stct {
    pub correlated: aeron_correlated_command_t,
    pub registration_id: i64,
}
#[test]
fn bindgen_test_layout_aeron_remove_command_stct() {
    const UNINIT: ::std::mem::MaybeUninit<aeron_remove_command_stct> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_remove_command_stct>(),
        24usize,
        concat!("Size of: ", stringify!(aeron_remove_command_stct))
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_remove_command_stct>(),
        4usize,
        concat!("Alignment of ", stringify!(aeron_remove_command_stct))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).correlated) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_remove_command_stct),
            "::",
            stringify!(correlated)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).registration_id) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_remove_command_stct),
            "::",
            stringify!(registration_id)
        )
    );
}
pub type aeron_remove_command_t = aeron_remove_command_stct;
#[repr(C, packed(4))]
#[derive(Copy, Clone)]
pub struct aeron_image_message_stct {
    pub correlation_id: i64,
    pub subscription_registration_id: i64,
    pub stream_id: i32,
    pub channel_length: i32,
}
#[test]
fn bindgen_test_layout_aeron_image_message_stct() {
    const UNINIT: ::std::mem::MaybeUninit<aeron_image_message_stct> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_image_message_stct>(),
        24usize,
        concat!("Size of: ", stringify!(aeron_image_message_stct))
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_image_message_stct>(),
        4usize,
        concat!("Alignment of ", stringify!(aeron_image_message_stct))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).correlation_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_image_message_stct),
            "::",
            stringify!(correlation_id)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).subscription_registration_id) as usize - ptr as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_image_message_stct),
            "::",
            stringify!(subscription_registration_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stream_id) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_image_message_stct),
            "::",
            stringify!(stream_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).channel_length) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_image_message_stct),
            "::",
            stringify!(channel_length)
        )
    );
}
pub type aeron_image_message_t = aeron_image_message_stct;
#[repr(C, packed(4))]
#[derive(Copy, Clone)]
pub struct aeron_destination_command_stct {
    pub correlated: aeron_correlated_command_t,
    pub registration_id: i64,
    pub channel_length: i32,
}
#[test]
fn bindgen_test_layout_aeron_destination_command_stct() {
    const UNINIT: ::std::mem::MaybeUninit<aeron_destination_command_stct> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_destination_command_stct>(),
        28usize,
        concat!("Size of: ", stringify!(aeron_destination_command_stct))
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_destination_command_stct>(),
        4usize,
        concat!("Alignment of ", stringify!(aeron_destination_command_stct))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).correlated) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_destination_command_stct),
            "::",
            stringify!(correlated)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).registration_id) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_destination_command_stct),
            "::",
            stringify!(registration_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).channel_length) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_destination_command_stct),
            "::",
            stringify!(channel_length)
        )
    );
}
pub type aeron_destination_command_t = aeron_destination_command_stct;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aeron_counter_command_stct {
    pub correlated: aeron_correlated_command_t,
    pub type_id: i32,
}
#[test]
fn bindgen_test_layout_aeron_counter_command_stct() {
    const UNINIT: ::std::mem::MaybeUninit<aeron_counter_command_stct> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_counter_command_stct>(),
        20usize,
        concat!("Size of: ", stringify!(aeron_counter_command_stct))
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_counter_command_stct>(),
        4usize,
        concat!("Alignment of ", stringify!(aeron_counter_command_stct))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).correlated) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_counter_command_stct),
            "::",
            stringify!(correlated)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_id) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_counter_command_stct),
            "::",
            stringify!(type_id)
        )
    );
}
pub type aeron_counter_command_t = aeron_counter_command_stct;
#[repr(C, packed(4))]
#[derive(Copy, Clone)]
pub struct aeron_counter_update_stct {
    pub correlation_id: i64,
    pub counter_id: i32,
}
#[test]
fn bindgen_test_layout_aeron_counter_update_stct() {
    const UNINIT: ::std::mem::MaybeUninit<aeron_counter_update_stct> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_counter_update_stct>(),
        12usize,
        concat!("Size of: ", stringify!(aeron_counter_update_stct))
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_counter_update_stct>(),
        4usize,
        concat!("Alignment of ", stringify!(aeron_counter_update_stct))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).correlation_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_counter_update_stct),
            "::",
            stringify!(correlation_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).counter_id) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_counter_update_stct),
            "::",
            stringify!(counter_id)
        )
    );
}
pub type aeron_counter_update_t = aeron_counter_update_stct;
#[repr(C, packed(4))]
#[derive(Copy, Clone)]
pub struct aeron_client_timeout_stct {
    pub client_id: i64,
}
#[test]
fn bindgen_test_layout_aeron_client_timeout_stct() {
    const UNINIT: ::std::mem::MaybeUninit<aeron_client_timeout_stct> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_client_timeout_stct>(),
        8usize,
        concat!("Size of: ", stringify!(aeron_client_timeout_stct))
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_client_timeout_stct>(),
        4usize,
        concat!("Alignment of ", stringify!(aeron_client_timeout_stct))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).client_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_client_timeout_stct),
            "::",
            stringify!(client_id)
        )
    );
}
pub type aeron_client_timeout_t = aeron_client_timeout_stct;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aeron_terminate_driver_command_stct {
    pub correlated: aeron_correlated_command_t,
    pub token_length: i32,
}
#[test]
fn bindgen_test_layout_aeron_terminate_driver_command_stct() {
    const UNINIT: ::std::mem::MaybeUninit<aeron_terminate_driver_command_stct> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_terminate_driver_command_stct>(),
        20usize,
        concat!("Size of: ", stringify!(aeron_terminate_driver_command_stct))
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_terminate_driver_command_stct>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(aeron_terminate_driver_command_stct)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).correlated) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_terminate_driver_command_stct),
            "::",
            stringify!(correlated)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).token_length) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_terminate_driver_command_stct),
            "::",
            stringify!(token_length)
        )
    );
}
pub type aeron_terminate_driver_command_t = aeron_terminate_driver_command_stct;
pub mod aeron_ipc_publication_state_enum {
    pub type Type = ::std::os::raw::c_uint;
    pub const AERON_IPC_PUBLICATION_STATE_ACTIVE: Type = 0;
    pub const AERON_IPC_PUBLICATION_STATE_DRAINING: Type = 1;
    pub const AERON_IPC_PUBLICATION_STATE_LINGER: Type = 2;
    pub const AERON_IPC_PUBLICATION_STATE_DONE: Type = 3;
}
pub use self::aeron_ipc_publication_state_enum::Type as aeron_ipc_publication_state_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aeron_ipc_publication_stct {
    pub mapped_raw_log: aeron_mapped_raw_log_t,
    pub log_meta_data: *mut aeron_logbuffer_metadata_t,
    pub pub_lmt_position: aeron_position_t,
    pub pub_pos_position: aeron_position_t,
    pub conductor_fields: aeron_ipc_publication_stct_aeron_ipc_publication_conductor_fields_stct,
    pub position_bits_to_shift: usize,
    pub term_window_length: i64,
    pub trip_gain: i64,
    pub unblock_timeout_ns: i64,
    pub initial_term_id: i32,
    pub is_exclusive: bool,
    pub tag: i64,
    pub session_id: i32,
    pub stream_id: i32,
    pub starting_term_id: i32,
    pub starting_term_offset: usize,
    pub channel_length: i32,
    pub channel: *mut ::std::os::raw::c_char,
    pub log_file_name_length: usize,
    pub log_file_name: *mut ::std::os::raw::c_char,
    pub raw_log_close_func: aeron_raw_log_close_func_t,
    pub raw_log_free_func: aeron_raw_log_free_func_t,
    pub untethered_subscription_state_change_func:
        aeron_untethered_subscription_state_change_func_t,
    pub unblocked_publications_counter: *mut i64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aeron_ipc_publication_stct_aeron_ipc_publication_conductor_fields_stct {
    pub has_reached_end_of_life: bool,
    pub state: aeron_ipc_publication_state_t,
    pub refcnt: i32,
    pub managed_resource: aeron_driver_managed_resource_t,
    pub subscribable: aeron_subscribable_t,
    pub trip_limit: i64,
    pub clean_position: i64,
    pub consumer_position: i64,
    pub last_consumer_position: i64,
    pub time_of_last_consumer_position_change_ns: i64,
}
#[test]
fn bindgen_test_layout_aeron_ipc_publication_stct_aeron_ipc_publication_conductor_fields_stct() {
    const UNINIT: ::std::mem::MaybeUninit<
        aeron_ipc_publication_stct_aeron_ipc_publication_conductor_fields_stct,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_ipc_publication_stct_aeron_ipc_publication_conductor_fields_stct>(
        ),
        152usize,
        concat!(
            "Size of: ",
            stringify!(aeron_ipc_publication_stct_aeron_ipc_publication_conductor_fields_stct)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<
            aeron_ipc_publication_stct_aeron_ipc_publication_conductor_fields_stct,
        >(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(aeron_ipc_publication_stct_aeron_ipc_publication_conductor_fields_stct)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_reached_end_of_life) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_ipc_publication_stct_aeron_ipc_publication_conductor_fields_stct),
            "::",
            stringify!(has_reached_end_of_life)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_ipc_publication_stct_aeron_ipc_publication_conductor_fields_stct),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).refcnt) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_ipc_publication_stct_aeron_ipc_publication_conductor_fields_stct),
            "::",
            stringify!(refcnt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).managed_resource) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_ipc_publication_stct_aeron_ipc_publication_conductor_fields_stct),
            "::",
            stringify!(managed_resource)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).subscribable) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_ipc_publication_stct_aeron_ipc_publication_conductor_fields_stct),
            "::",
            stringify!(subscribable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).trip_limit) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_ipc_publication_stct_aeron_ipc_publication_conductor_fields_stct),
            "::",
            stringify!(trip_limit)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).clean_position) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_ipc_publication_stct_aeron_ipc_publication_conductor_fields_stct),
            "::",
            stringify!(clean_position)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).consumer_position) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_ipc_publication_stct_aeron_ipc_publication_conductor_fields_stct),
            "::",
            stringify!(consumer_position)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).last_consumer_position) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_ipc_publication_stct_aeron_ipc_publication_conductor_fields_stct),
            "::",
            stringify!(last_consumer_position)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).time_of_last_consumer_position_change_ns) as usize
                - ptr as usize
        },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_ipc_publication_stct_aeron_ipc_publication_conductor_fields_stct),
            "::",
            stringify!(time_of_last_consumer_position_change_ns)
        )
    );
}
#[test]
fn bindgen_test_layout_aeron_ipc_publication_stct() {
    const UNINIT: ::std::mem::MaybeUninit<aeron_ipc_publication_stct> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_ipc_publication_stct>(),
        416usize,
        concat!("Size of: ", stringify!(aeron_ipc_publication_stct))
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_ipc_publication_stct>(),
        8usize,
        concat!("Alignment of ", stringify!(aeron_ipc_publication_stct))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mapped_raw_log) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_ipc_publication_stct),
            "::",
            stringify!(mapped_raw_log)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).log_meta_data) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_ipc_publication_stct),
            "::",
            stringify!(log_meta_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pub_lmt_position) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_ipc_publication_stct),
            "::",
            stringify!(pub_lmt_position)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pub_pos_position) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_ipc_publication_stct),
            "::",
            stringify!(pub_pos_position)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).conductor_fields) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_ipc_publication_stct),
            "::",
            stringify!(conductor_fields)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).position_bits_to_shift) as usize - ptr as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_ipc_publication_stct),
            "::",
            stringify!(position_bits_to_shift)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).term_window_length) as usize - ptr as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_ipc_publication_stct),
            "::",
            stringify!(term_window_length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).trip_gain) as usize - ptr as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_ipc_publication_stct),
            "::",
            stringify!(trip_gain)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unblock_timeout_ns) as usize - ptr as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_ipc_publication_stct),
            "::",
            stringify!(unblock_timeout_ns)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).initial_term_id) as usize - ptr as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_ipc_publication_stct),
            "::",
            stringify!(initial_term_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).is_exclusive) as usize - ptr as usize },
        316usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_ipc_publication_stct),
            "::",
            stringify!(is_exclusive)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tag) as usize - ptr as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_ipc_publication_stct),
            "::",
            stringify!(tag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).session_id) as usize - ptr as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_ipc_publication_stct),
            "::",
            stringify!(session_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stream_id) as usize - ptr as usize },
        332usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_ipc_publication_stct),
            "::",
            stringify!(stream_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).starting_term_id) as usize - ptr as usize },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_ipc_publication_stct),
            "::",
            stringify!(starting_term_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).starting_term_offset) as usize - ptr as usize },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_ipc_publication_stct),
            "::",
            stringify!(starting_term_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).channel_length) as usize - ptr as usize },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_ipc_publication_stct),
            "::",
            stringify!(channel_length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).channel) as usize - ptr as usize },
        360usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_ipc_publication_stct),
            "::",
            stringify!(channel)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).log_file_name_length) as usize - ptr as usize },
        368usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_ipc_publication_stct),
            "::",
            stringify!(log_file_name_length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).log_file_name) as usize - ptr as usize },
        376usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_ipc_publication_stct),
            "::",
            stringify!(log_file_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).raw_log_close_func) as usize - ptr as usize },
        384usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_ipc_publication_stct),
            "::",
            stringify!(raw_log_close_func)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).raw_log_free_func) as usize - ptr as usize },
        392usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_ipc_publication_stct),
            "::",
            stringify!(raw_log_free_func)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).untethered_subscription_state_change_func) as usize
                - ptr as usize
        },
        400usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_ipc_publication_stct),
            "::",
            stringify!(untethered_subscription_state_change_func)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).unblocked_publications_counter) as usize - ptr as usize
        },
        408usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_ipc_publication_stct),
            "::",
            stringify!(unblocked_publications_counter)
        )
    );
}
pub type aeron_ipc_publication_t = aeron_ipc_publication_stct;
extern "C" {
    pub fn aeron_ipc_publication_create(
        publication: *mut *mut aeron_ipc_publication_t,
        context: *mut aeron_driver_context_t,
        session_id: i32,
        stream_id: i32,
        registration_id: i64,
        pub_pos_position: *mut aeron_position_t,
        pub_lmt_position: *mut aeron_position_t,
        initial_term_id: i32,
        params: *mut aeron_driver_uri_publication_params_t,
        is_exclusive: bool,
        system_counters: *mut aeron_system_counters_t,
        channel_length: usize,
        channel: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_ipc_publication_close(
        counters_manager: *mut aeron_counters_manager_t,
        publication: *mut aeron_ipc_publication_t,
    );
}
extern "C" {
    pub fn aeron_ipc_publication_free(publication: *mut aeron_ipc_publication_t) -> bool;
}
extern "C" {
    pub fn aeron_ipc_publication_update_pub_lmt(
        publication: *mut aeron_ipc_publication_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_ipc_publication_clean_buffer(
        publication: *mut aeron_ipc_publication_t,
        position: i64,
    );
}
extern "C" {
    pub fn aeron_ipc_publication_on_time_event(
        conductor: *mut aeron_driver_conductor_t,
        publication: *mut aeron_ipc_publication_t,
        now_ns: i64,
        now_ms: i64,
    );
}
extern "C" {
    pub fn aeron_ipc_publication_incref(clientd: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn aeron_ipc_publication_decref(clientd: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn aeron_ipc_publication_check_for_blocked_publisher(
        publication: *mut aeron_ipc_publication_t,
        producer_position: i64,
        now_ns: i64,
    );
}
extern "C" {
    pub fn aeron_format_date(str_: *mut ::std::os::raw::c_char, count: usize, timestamp: i64);
}
extern "C" {
    pub fn aeron_format_number_to_locale(
        value: ::std::os::raw::c_longlong,
        buffer: *mut ::std::os::raw::c_char,
        buffer_len: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn aeron_format_to_hex(
        str_: *mut ::std::os::raw::c_char,
        str_length: usize,
        data: *mut u8,
        data_len: usize,
    );
}
extern "C" {
    pub fn aeron_tokenise(
        input: *mut ::std::os::raw::c_char,
        delimiter: ::std::os::raw::c_char,
        max_tokens: ::std::os::raw::c_int,
        tokens: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aeron_per_thread_error_stct {
    pub errcode: ::std::os::raw::c_int,
    pub offset: usize,
    pub errmsg: [::std::os::raw::c_char; 8192usize],
}
#[test]
fn bindgen_test_layout_aeron_per_thread_error_stct() {
    const UNINIT: ::std::mem::MaybeUninit<aeron_per_thread_error_stct> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_per_thread_error_stct>(),
        8208usize,
        concat!("Size of: ", stringify!(aeron_per_thread_error_stct))
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_per_thread_error_stct>(),
        8usize,
        concat!("Alignment of ", stringify!(aeron_per_thread_error_stct))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).errcode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_per_thread_error_stct),
            "::",
            stringify!(errcode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).offset) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_per_thread_error_stct),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).errmsg) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_per_thread_error_stct),
            "::",
            stringify!(errmsg)
        )
    );
}
pub type aeron_per_thread_error_t = aeron_per_thread_error_stct;
extern "C" {
    pub fn aeron_set_errno(errcode: ::std::os::raw::c_int);
}
extern "C" {
    pub fn aeron_error_code_str(errcode: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn aeron_err_set(
        errcode: ::std::os::raw::c_int,
        function: *const ::std::os::raw::c_char,
        filename: *const ::std::os::raw::c_char,
        line_number: ::std::os::raw::c_int,
        format: *const ::std::os::raw::c_char,
        ...
    );
}
extern "C" {
    pub fn aeron_err_append(
        function: *const ::std::os::raw::c_char,
        filename: *const ::std::os::raw::c_char,
        line_number: ::std::os::raw::c_int,
        format: *const ::std::os::raw::c_char,
        ...
    );
}
extern "C" {
    pub fn aeron_err_clear();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aeron_str_to_ptr_hash_map_key_stct {
    pub str_: *const ::std::os::raw::c_char,
    pub hash_code: u64,
    pub str_length: usize,
}
#[test]
fn bindgen_test_layout_aeron_str_to_ptr_hash_map_key_stct() {
    const UNINIT: ::std::mem::MaybeUninit<aeron_str_to_ptr_hash_map_key_stct> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_str_to_ptr_hash_map_key_stct>(),
        24usize,
        concat!("Size of: ", stringify!(aeron_str_to_ptr_hash_map_key_stct))
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_str_to_ptr_hash_map_key_stct>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(aeron_str_to_ptr_hash_map_key_stct)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).str_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_str_to_ptr_hash_map_key_stct),
            "::",
            stringify!(str_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hash_code) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_str_to_ptr_hash_map_key_stct),
            "::",
            stringify!(hash_code)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).str_length) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_str_to_ptr_hash_map_key_stct),
            "::",
            stringify!(str_length)
        )
    );
}
pub type aeron_str_to_ptr_hash_map_key_t = aeron_str_to_ptr_hash_map_key_stct;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aeron_str_to_ptr_hash_map_stct {
    pub keys: *mut aeron_str_to_ptr_hash_map_key_t,
    pub values: *mut *mut ::std::os::raw::c_void,
    pub load_factor: f32,
    pub capacity: usize,
    pub size: usize,
    pub resize_threshold: usize,
}
#[test]
fn bindgen_test_layout_aeron_str_to_ptr_hash_map_stct() {
    const UNINIT: ::std::mem::MaybeUninit<aeron_str_to_ptr_hash_map_stct> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_str_to_ptr_hash_map_stct>(),
        48usize,
        concat!("Size of: ", stringify!(aeron_str_to_ptr_hash_map_stct))
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_str_to_ptr_hash_map_stct>(),
        8usize,
        concat!("Alignment of ", stringify!(aeron_str_to_ptr_hash_map_stct))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).keys) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_str_to_ptr_hash_map_stct),
            "::",
            stringify!(keys)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).values) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_str_to_ptr_hash_map_stct),
            "::",
            stringify!(values)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).load_factor) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_str_to_ptr_hash_map_stct),
            "::",
            stringify!(load_factor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).capacity) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_str_to_ptr_hash_map_stct),
            "::",
            stringify!(capacity)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_str_to_ptr_hash_map_stct),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).resize_threshold) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_str_to_ptr_hash_map_stct),
            "::",
            stringify!(resize_threshold)
        )
    );
}
pub type aeron_str_to_ptr_hash_map_t = aeron_str_to_ptr_hash_map_stct;
pub type aeron_str_to_ptr_hash_map_for_each_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        clientd: *mut ::std::os::raw::c_void,
        key: *const ::std::os::raw::c_char,
        key_len: usize,
        value: *mut ::std::os::raw::c_void,
    ),
>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aeron_int64_to_ptr_hash_map_stct {
    pub keys: *mut i64,
    pub values: *mut *mut ::std::os::raw::c_void,
    pub load_factor: f32,
    pub capacity: usize,
    pub size: usize,
    pub resize_threshold: usize,
}
#[test]
fn bindgen_test_layout_aeron_int64_to_ptr_hash_map_stct() {
    const UNINIT: ::std::mem::MaybeUninit<aeron_int64_to_ptr_hash_map_stct> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_int64_to_ptr_hash_map_stct>(),
        48usize,
        concat!("Size of: ", stringify!(aeron_int64_to_ptr_hash_map_stct))
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_int64_to_ptr_hash_map_stct>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(aeron_int64_to_ptr_hash_map_stct)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).keys) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_int64_to_ptr_hash_map_stct),
            "::",
            stringify!(keys)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).values) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_int64_to_ptr_hash_map_stct),
            "::",
            stringify!(values)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).load_factor) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_int64_to_ptr_hash_map_stct),
            "::",
            stringify!(load_factor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).capacity) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_int64_to_ptr_hash_map_stct),
            "::",
            stringify!(capacity)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_int64_to_ptr_hash_map_stct),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).resize_threshold) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_int64_to_ptr_hash_map_stct),
            "::",
            stringify!(resize_threshold)
        )
    );
}
pub type aeron_int64_to_ptr_hash_map_t = aeron_int64_to_ptr_hash_map_stct;
pub type aeron_int64_to_ptr_hash_map_for_each_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        clientd: *mut ::std::os::raw::c_void,
        key: i64,
        value: *mut ::std::os::raw::c_void,
    ),
>;
pub type aeron_int64_to_ptr_hash_map_predicate_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        clientd: *mut ::std::os::raw::c_void,
        key: i64,
        value: *mut ::std::os::raw::c_void,
    ) -> bool,
>;
pub type aeron_uri_hostname_resolver_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        clientd: *mut ::std::os::raw::c_void,
        host: *const ::std::os::raw::c_char,
        hints: *mut addrinfo,
        info: *mut *mut addrinfo,
    ) -> ::std::os::raw::c_int,
>;
pub type aeron_getifaddrs_func_t =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut *mut ifaddrs) -> ::std::os::raw::c_int>;
pub type aeron_freeifaddrs_func_t = ::std::option::Option<unsafe extern "C" fn(arg1: *mut ifaddrs)>;
pub type aeron_ifaddr_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        clientd: *mut ::std::os::raw::c_void,
        name: *const ::std::os::raw::c_char,
        addr: *mut sockaddr,
        netmask: *mut sockaddr,
        flags: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn aeron_ip_addr_resolver(
        host: *const ::std::os::raw::c_char,
        sockaddr: *mut sockaddr_storage,
        family_hint: ::std::os::raw::c_int,
        protocol: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_udp_port_resolver(
        port_str: *const ::std::os::raw::c_char,
        optional: bool,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_try_parse_ipv4(
        host: *const ::std::os::raw::c_char,
        sockaddr: *mut sockaddr_storage,
    ) -> bool;
}
extern "C" {
    pub fn aeron_ipv4_addr_resolver(
        host: *const ::std::os::raw::c_char,
        protocol: ::std::os::raw::c_int,
        sockaddr: *mut sockaddr_storage,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_try_parse_ipv6(
        host: *const ::std::os::raw::c_char,
        sockaddr: *mut sockaddr_storage,
    ) -> bool;
}
extern "C" {
    pub fn aeron_ipv6_addr_resolver(
        host: *const ::std::os::raw::c_char,
        protocol: ::std::os::raw::c_int,
        sockaddr: *mut sockaddr_storage,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_lookup_interfaces(
        func: aeron_ifaddr_func_t,
        clientd: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_lookup_interfaces_from_ifaddrs(
        func: aeron_ifaddr_func_t,
        clientd: *mut ::std::os::raw::c_void,
        ifaddrs: *mut ifaddrs,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_set_getifaddrs(
        get_func: aeron_getifaddrs_func_t,
        free_func: aeron_freeifaddrs_func_t,
    );
}
extern "C" {
    pub fn aeron_interface_parse_and_resolve(
        interface_str: *const ::std::os::raw::c_char,
        sockaddr: *mut sockaddr_storage,
        prefixlen: *mut usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_set_ipv4_wildcard_host_and_port(sockaddr: *mut sockaddr_storage);
}
extern "C" {
    pub fn aeron_set_ipv6_wildcard_host_and_port(sockaddr: *mut sockaddr_storage);
}
extern "C" {
    pub fn aeron_ipv4_does_prefix_match(
        in_addr1: *mut in_addr,
        in_addr2: *mut in_addr,
        prefixlen: usize,
    ) -> bool;
}
extern "C" {
    pub fn aeron_ipv6_does_prefix_match(
        in6_addr1: *mut in6_addr,
        in6_addr2: *mut in6_addr,
        prefixlen: usize,
    ) -> bool;
}
extern "C" {
    pub fn aeron_ipv4_netmask_to_prefixlen(netmask: *mut in_addr) -> usize;
}
extern "C" {
    pub fn aeron_ipv6_netmask_to_prefixlen(netmask: *mut in6_addr) -> usize;
}
extern "C" {
    pub fn aeron_find_interface(
        interface_str: *const ::std::os::raw::c_char,
        if_addr: *mut sockaddr_storage,
        if_index: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_find_unicast_interface(
        family: ::std::os::raw::c_int,
        interface_str: *const ::std::os::raw::c_char,
        interface_addr: *mut sockaddr_storage,
        interface_index: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_is_addr_multicast(addr: *mut sockaddr_storage) -> bool;
}
extern "C" {
    pub fn aeron_is_wildcard_addr(addr: *mut sockaddr_storage) -> bool;
}
extern "C" {
    pub fn aeron_is_wildcard_port(addr: *mut sockaddr_storage) -> bool;
}
extern "C" {
    pub fn aeron_format_source_identity(
        buffer: *mut ::std::os::raw::c_char,
        length: usize,
        addr: *mut sockaddr_storage,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_netutil_get_so_buf_lengths(
        default_so_rcvbuf: *mut usize,
        default_so_sndbuf: *mut usize,
    ) -> ::std::os::raw::c_int;
}
pub mod aeron_retransmit_action_state_enum {
    pub type Type = ::std::os::raw::c_uint;
    pub const AERON_RETRANSMIT_ACTION_STATE_DELAYED: Type = 0;
    pub const AERON_RETRANSMIT_ACTION_STATE_LINGERING: Type = 1;
    pub const AERON_RETRANSMIT_ACTION_STATE_INACTIVE: Type = 2;
}
pub use self::aeron_retransmit_action_state_enum::Type as aeron_retransmit_action_state_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aeron_retransmit_action_stct {
    pub expiry_ns: i64,
    pub term_id: i32,
    pub term_offset: i32,
    pub length: usize,
    pub state: aeron_retransmit_action_state_t,
}
#[test]
fn bindgen_test_layout_aeron_retransmit_action_stct() {
    const UNINIT: ::std::mem::MaybeUninit<aeron_retransmit_action_stct> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_retransmit_action_stct>(),
        32usize,
        concat!("Size of: ", stringify!(aeron_retransmit_action_stct))
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_retransmit_action_stct>(),
        8usize,
        concat!("Alignment of ", stringify!(aeron_retransmit_action_stct))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).expiry_ns) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_retransmit_action_stct),
            "::",
            stringify!(expiry_ns)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).term_id) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_retransmit_action_stct),
            "::",
            stringify!(term_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).term_offset) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_retransmit_action_stct),
            "::",
            stringify!(term_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_retransmit_action_stct),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_retransmit_action_stct),
            "::",
            stringify!(state)
        )
    );
}
pub type aeron_retransmit_action_t = aeron_retransmit_action_stct;
pub type aeron_retransmit_handler_resend_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        clientd: *mut ::std::os::raw::c_void,
        term_id: i32,
        term_offset: i32,
        length: usize,
    ) -> ::std::os::raw::c_int,
>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aeron_retransmit_handler_stct {
    pub retransmit_action_pool: [aeron_retransmit_action_t; 16usize],
    pub active_retransmits_map: aeron_int64_to_ptr_hash_map_t,
    pub delay_timeout_ns: u64,
    pub linger_timeout_ns: u64,
    pub invalid_packets_counter: *mut i64,
}
#[test]
fn bindgen_test_layout_aeron_retransmit_handler_stct() {
    const UNINIT: ::std::mem::MaybeUninit<aeron_retransmit_handler_stct> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_retransmit_handler_stct>(),
        584usize,
        concat!("Size of: ", stringify!(aeron_retransmit_handler_stct))
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_retransmit_handler_stct>(),
        8usize,
        concat!("Alignment of ", stringify!(aeron_retransmit_handler_stct))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).retransmit_action_pool) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_retransmit_handler_stct),
            "::",
            stringify!(retransmit_action_pool)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).active_retransmits_map) as usize - ptr as usize },
        512usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_retransmit_handler_stct),
            "::",
            stringify!(active_retransmits_map)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).delay_timeout_ns) as usize - ptr as usize },
        560usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_retransmit_handler_stct),
            "::",
            stringify!(delay_timeout_ns)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).linger_timeout_ns) as usize - ptr as usize },
        568usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_retransmit_handler_stct),
            "::",
            stringify!(linger_timeout_ns)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).invalid_packets_counter) as usize - ptr as usize },
        576usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_retransmit_handler_stct),
            "::",
            stringify!(invalid_packets_counter)
        )
    );
}
pub type aeron_retransmit_handler_t = aeron_retransmit_handler_stct;
extern "C" {
    pub fn aeron_retransmit_handler_init(
        handler: *mut aeron_retransmit_handler_t,
        invalid_packets_counter: *mut i64,
        delay_timeout_ns: u64,
        linger_timeout_ns: u64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_retransmit_handler_close(
        handler: *mut aeron_retransmit_handler_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_retransmit_handler_on_nak(
        handler: *mut aeron_retransmit_handler_t,
        term_id: i32,
        term_offset: i32,
        length: usize,
        term_length: usize,
        now_ns: i64,
        resend: aeron_retransmit_handler_resend_func_t,
        resend_clientd: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_retransmit_handler_process_timeouts(
        handler: *mut aeron_retransmit_handler_t,
        now_ns: i64,
        resend: aeron_retransmit_handler_resend_func_t,
        resend_clientd: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
pub mod aeron_network_publication_state_enum {
    pub type Type = ::std::os::raw::c_uint;
    pub const AERON_NETWORK_PUBLICATION_STATE_ACTIVE: Type = 0;
    pub const AERON_NETWORK_PUBLICATION_STATE_DRAINING: Type = 1;
    pub const AERON_NETWORK_PUBLICATION_STATE_LINGER: Type = 2;
    pub const AERON_NETWORK_PUBLICATION_STATE_DONE: Type = 3;
}
pub use self::aeron_network_publication_state_enum::Type as aeron_network_publication_state_t;
pub type aeron_send_channel_endpoint_t = aeron_send_channel_endpoint_stct;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aeron_network_publication_stct {
    pub conductor_fields:
        aeron_network_publication_stct_aeron_network_publication_conductor_fields_stct,
    pub conductor_fields_pad: [u8; 120usize],
    pub mapped_raw_log: aeron_mapped_raw_log_t,
    pub pub_pos_position: aeron_position_t,
    pub pub_lmt_position: aeron_position_t,
    pub snd_pos_position: aeron_position_t,
    pub snd_lmt_position: aeron_position_t,
    pub snd_bpe_counter: aeron_atomic_counter_t,
    pub retransmit_handler: aeron_retransmit_handler_t,
    pub log_meta_data: *mut aeron_logbuffer_metadata_t,
    pub endpoint: *mut aeron_send_channel_endpoint_t,
    pub flow_control: *mut aeron_flow_control_strategy_t,
    pub cached_clock: *mut aeron_clock_cache_t,
    pub sender_fields_pad_lhs: [u8; 64usize],
    pub has_initial_connection: bool,
    pub track_sender_limits: bool,
    pub time_of_last_data_or_heartbeat_ns: i64,
    pub current_messages_per_send: usize,
    pub status_message_deadline_ns: i64,
    pub time_of_last_setup_ns: i64,
    pub sender_fields_pad_rhs: [u8; 64usize],
    pub log_file_name: *mut ::std::os::raw::c_char,
    pub term_buffer_length: i64,
    pub term_window_length: i64,
    pub trip_gain: i64,
    pub linger_timeout_ns: i64,
    pub unblock_timeout_ns: i64,
    pub connection_timeout_ns: i64,
    pub tag: i64,
    pub session_id: i32,
    pub stream_id: i32,
    pub initial_term_id: i32,
    pub starting_term_id: i32,
    pub term_length_mask: i32,
    pub starting_term_offset: usize,
    pub log_file_name_length: usize,
    pub position_bits_to_shift: usize,
    pub mtu_length: usize,
    pub max_messages_per_send: usize,
    pub spies_simulate_connection: bool,
    pub signal_eos: bool,
    pub is_setup_elicited: bool,
    pub is_exclusive: bool,
    pub has_receivers: bool,
    pub has_spies: bool,
    pub is_connected: bool,
    pub is_end_of_stream: bool,
    pub has_sender_released: bool,
    pub has_received_sm_eos: bool,
    pub raw_log_close_func: aeron_raw_log_close_func_t,
    pub raw_log_free_func: aeron_raw_log_free_func_t,
    pub untethered_subscription_state_change_func:
        aeron_untethered_subscription_state_change_func_t,
    pub short_sends_counter: *mut i64,
    pub heartbeats_sent_counter: *mut i64,
    pub sender_flow_control_limits_counter: *mut i64,
    pub retransmits_sent_counter: *mut i64,
    pub unblocked_publications_counter: *mut i64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aeron_network_publication_stct_aeron_network_publication_conductor_fields_stct {
    pub has_reached_end_of_life: bool,
    pub state: aeron_network_publication_state_t,
    pub refcnt: i32,
    pub managed_resource: aeron_driver_managed_resource_t,
    pub subscribable: aeron_subscribable_t,
    pub clean_position: i64,
    pub time_of_last_activity_ns: i64,
    pub last_snd_pos: i64,
}
#[test]
fn bindgen_test_layout_aeron_network_publication_stct_aeron_network_publication_conductor_fields_stct(
) {
    const UNINIT: ::std::mem::MaybeUninit<
        aeron_network_publication_stct_aeron_network_publication_conductor_fields_stct,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<
            aeron_network_publication_stct_aeron_network_publication_conductor_fields_stct,
        >(),
        136usize,
        concat!(
            "Size of: ",
            stringify!(
                aeron_network_publication_stct_aeron_network_publication_conductor_fields_stct
            )
        )
    );
    assert_eq!(
        ::std::mem::align_of::<
            aeron_network_publication_stct_aeron_network_publication_conductor_fields_stct,
        >(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(
                aeron_network_publication_stct_aeron_network_publication_conductor_fields_stct
            )
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_reached_end_of_life) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(
                aeron_network_publication_stct_aeron_network_publication_conductor_fields_stct
            ),
            "::",
            stringify!(has_reached_end_of_life)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(
                aeron_network_publication_stct_aeron_network_publication_conductor_fields_stct
            ),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).refcnt) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(
                aeron_network_publication_stct_aeron_network_publication_conductor_fields_stct
            ),
            "::",
            stringify!(refcnt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).managed_resource) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(
                aeron_network_publication_stct_aeron_network_publication_conductor_fields_stct
            ),
            "::",
            stringify!(managed_resource)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).subscribable) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(
                aeron_network_publication_stct_aeron_network_publication_conductor_fields_stct
            ),
            "::",
            stringify!(subscribable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).clean_position) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(
                aeron_network_publication_stct_aeron_network_publication_conductor_fields_stct
            ),
            "::",
            stringify!(clean_position)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).time_of_last_activity_ns) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(
                aeron_network_publication_stct_aeron_network_publication_conductor_fields_stct
            ),
            "::",
            stringify!(time_of_last_activity_ns)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).last_snd_pos) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(
                aeron_network_publication_stct_aeron_network_publication_conductor_fields_stct
            ),
            "::",
            stringify!(last_snd_pos)
        )
    );
}
#[test]
fn bindgen_test_layout_aeron_network_publication_stct() {
    const UNINIT: ::std::mem::MaybeUninit<aeron_network_publication_stct> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_network_publication_stct>(),
        1416usize,
        concat!("Size of: ", stringify!(aeron_network_publication_stct))
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_network_publication_stct>(),
        8usize,
        concat!("Alignment of ", stringify!(aeron_network_publication_stct))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).conductor_fields) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_network_publication_stct),
            "::",
            stringify!(conductor_fields)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).conductor_fields_pad) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_network_publication_stct),
            "::",
            stringify!(conductor_fields_pad)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mapped_raw_log) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_network_publication_stct),
            "::",
            stringify!(mapped_raw_log)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pub_pos_position) as usize - ptr as usize },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_network_publication_stct),
            "::",
            stringify!(pub_pos_position)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pub_lmt_position) as usize - ptr as usize },
        360usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_network_publication_stct),
            "::",
            stringify!(pub_lmt_position)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).snd_pos_position) as usize - ptr as usize },
        376usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_network_publication_stct),
            "::",
            stringify!(snd_pos_position)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).snd_lmt_position) as usize - ptr as usize },
        392usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_network_publication_stct),
            "::",
            stringify!(snd_lmt_position)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).snd_bpe_counter) as usize - ptr as usize },
        408usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_network_publication_stct),
            "::",
            stringify!(snd_bpe_counter)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).retransmit_handler) as usize - ptr as usize },
        424usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_network_publication_stct),
            "::",
            stringify!(retransmit_handler)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).log_meta_data) as usize - ptr as usize },
        1008usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_network_publication_stct),
            "::",
            stringify!(log_meta_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).endpoint) as usize - ptr as usize },
        1016usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_network_publication_stct),
            "::",
            stringify!(endpoint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flow_control) as usize - ptr as usize },
        1024usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_network_publication_stct),
            "::",
            stringify!(flow_control)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cached_clock) as usize - ptr as usize },
        1032usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_network_publication_stct),
            "::",
            stringify!(cached_clock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sender_fields_pad_lhs) as usize - ptr as usize },
        1040usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_network_publication_stct),
            "::",
            stringify!(sender_fields_pad_lhs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_initial_connection) as usize - ptr as usize },
        1104usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_network_publication_stct),
            "::",
            stringify!(has_initial_connection)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).track_sender_limits) as usize - ptr as usize },
        1105usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_network_publication_stct),
            "::",
            stringify!(track_sender_limits)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).time_of_last_data_or_heartbeat_ns) as usize - ptr as usize
        },
        1112usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_network_publication_stct),
            "::",
            stringify!(time_of_last_data_or_heartbeat_ns)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).current_messages_per_send) as usize - ptr as usize },
        1120usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_network_publication_stct),
            "::",
            stringify!(current_messages_per_send)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).status_message_deadline_ns) as usize - ptr as usize },
        1128usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_network_publication_stct),
            "::",
            stringify!(status_message_deadline_ns)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).time_of_last_setup_ns) as usize - ptr as usize },
        1136usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_network_publication_stct),
            "::",
            stringify!(time_of_last_setup_ns)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sender_fields_pad_rhs) as usize - ptr as usize },
        1144usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_network_publication_stct),
            "::",
            stringify!(sender_fields_pad_rhs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).log_file_name) as usize - ptr as usize },
        1208usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_network_publication_stct),
            "::",
            stringify!(log_file_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).term_buffer_length) as usize - ptr as usize },
        1216usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_network_publication_stct),
            "::",
            stringify!(term_buffer_length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).term_window_length) as usize - ptr as usize },
        1224usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_network_publication_stct),
            "::",
            stringify!(term_window_length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).trip_gain) as usize - ptr as usize },
        1232usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_network_publication_stct),
            "::",
            stringify!(trip_gain)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).linger_timeout_ns) as usize - ptr as usize },
        1240usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_network_publication_stct),
            "::",
            stringify!(linger_timeout_ns)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unblock_timeout_ns) as usize - ptr as usize },
        1248usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_network_publication_stct),
            "::",
            stringify!(unblock_timeout_ns)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).connection_timeout_ns) as usize - ptr as usize },
        1256usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_network_publication_stct),
            "::",
            stringify!(connection_timeout_ns)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tag) as usize - ptr as usize },
        1264usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_network_publication_stct),
            "::",
            stringify!(tag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).session_id) as usize - ptr as usize },
        1272usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_network_publication_stct),
            "::",
            stringify!(session_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stream_id) as usize - ptr as usize },
        1276usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_network_publication_stct),
            "::",
            stringify!(stream_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).initial_term_id) as usize - ptr as usize },
        1280usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_network_publication_stct),
            "::",
            stringify!(initial_term_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).starting_term_id) as usize - ptr as usize },
        1284usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_network_publication_stct),
            "::",
            stringify!(starting_term_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).term_length_mask) as usize - ptr as usize },
        1288usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_network_publication_stct),
            "::",
            stringify!(term_length_mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).starting_term_offset) as usize - ptr as usize },
        1296usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_network_publication_stct),
            "::",
            stringify!(starting_term_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).log_file_name_length) as usize - ptr as usize },
        1304usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_network_publication_stct),
            "::",
            stringify!(log_file_name_length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).position_bits_to_shift) as usize - ptr as usize },
        1312usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_network_publication_stct),
            "::",
            stringify!(position_bits_to_shift)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mtu_length) as usize - ptr as usize },
        1320usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_network_publication_stct),
            "::",
            stringify!(mtu_length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_messages_per_send) as usize - ptr as usize },
        1328usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_network_publication_stct),
            "::",
            stringify!(max_messages_per_send)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).spies_simulate_connection) as usize - ptr as usize },
        1336usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_network_publication_stct),
            "::",
            stringify!(spies_simulate_connection)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).signal_eos) as usize - ptr as usize },
        1337usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_network_publication_stct),
            "::",
            stringify!(signal_eos)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).is_setup_elicited) as usize - ptr as usize },
        1338usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_network_publication_stct),
            "::",
            stringify!(is_setup_elicited)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).is_exclusive) as usize - ptr as usize },
        1339usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_network_publication_stct),
            "::",
            stringify!(is_exclusive)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_receivers) as usize - ptr as usize },
        1340usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_network_publication_stct),
            "::",
            stringify!(has_receivers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_spies) as usize - ptr as usize },
        1341usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_network_publication_stct),
            "::",
            stringify!(has_spies)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).is_connected) as usize - ptr as usize },
        1342usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_network_publication_stct),
            "::",
            stringify!(is_connected)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).is_end_of_stream) as usize - ptr as usize },
        1343usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_network_publication_stct),
            "::",
            stringify!(is_end_of_stream)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_sender_released) as usize - ptr as usize },
        1344usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_network_publication_stct),
            "::",
            stringify!(has_sender_released)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_received_sm_eos) as usize - ptr as usize },
        1345usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_network_publication_stct),
            "::",
            stringify!(has_received_sm_eos)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).raw_log_close_func) as usize - ptr as usize },
        1352usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_network_publication_stct),
            "::",
            stringify!(raw_log_close_func)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).raw_log_free_func) as usize - ptr as usize },
        1360usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_network_publication_stct),
            "::",
            stringify!(raw_log_free_func)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).untethered_subscription_state_change_func) as usize
                - ptr as usize
        },
        1368usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_network_publication_stct),
            "::",
            stringify!(untethered_subscription_state_change_func)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).short_sends_counter) as usize - ptr as usize },
        1376usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_network_publication_stct),
            "::",
            stringify!(short_sends_counter)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).heartbeats_sent_counter) as usize - ptr as usize },
        1384usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_network_publication_stct),
            "::",
            stringify!(heartbeats_sent_counter)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).sender_flow_control_limits_counter) as usize - ptr as usize
        },
        1392usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_network_publication_stct),
            "::",
            stringify!(sender_flow_control_limits_counter)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).retransmits_sent_counter) as usize - ptr as usize },
        1400usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_network_publication_stct),
            "::",
            stringify!(retransmits_sent_counter)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).unblocked_publications_counter) as usize - ptr as usize
        },
        1408usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_network_publication_stct),
            "::",
            stringify!(unblocked_publications_counter)
        )
    );
}
extern "C" {
    pub fn aeron_network_publication_create(
        publication: *mut *mut aeron_network_publication_t,
        endpoint: *mut aeron_send_channel_endpoint_t,
        context: *mut aeron_driver_context_t,
        registration_id: i64,
        session_id: i32,
        stream_id: i32,
        initial_term_id: i32,
        pub_pos_position: *mut aeron_position_t,
        pub_lmt_position: *mut aeron_position_t,
        snd_pos_position: *mut aeron_position_t,
        snd_lmt_position: *mut aeron_position_t,
        snd_bpe_counter: *mut aeron_atomic_counter_t,
        flow_control_strategy: *mut aeron_flow_control_strategy_t,
        params: *mut aeron_driver_uri_publication_params_t,
        is_exclusive: bool,
        system_counters: *mut aeron_system_counters_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_network_publication_close(
        counters_manager: *mut aeron_counters_manager_t,
        publication: *mut aeron_network_publication_t,
    );
}
extern "C" {
    pub fn aeron_network_publication_free(publication: *mut aeron_network_publication_t) -> bool;
}
extern "C" {
    pub fn aeron_network_publication_incref(clientd: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn aeron_network_publication_decref(clientd: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn aeron_network_publication_on_time_event(
        conductor: *mut aeron_driver_conductor_t,
        publication: *mut aeron_network_publication_t,
        now_ns: i64,
        now_ms: i64,
    );
}
extern "C" {
    pub fn aeron_network_publication_send(
        publication: *mut aeron_network_publication_t,
        now_ns: i64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_network_publication_resend(
        clientd: *mut ::std::os::raw::c_void,
        term_id: i32,
        term_offset: i32,
        length: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_network_publication_send_data(
        publication: *mut aeron_network_publication_t,
        now_ns: i64,
        snd_pos: i64,
        term_offset: i32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_network_publication_on_nak(
        publication: *mut aeron_network_publication_t,
        term_id: i32,
        term_offset: i32,
        length: i32,
    );
}
extern "C" {
    pub fn aeron_network_publication_on_status_message(
        publication: *mut aeron_network_publication_t,
        buffer: *const u8,
        length: usize,
        addr: *mut sockaddr_storage,
    );
}
extern "C" {
    pub fn aeron_network_publication_on_rttm(
        publication: *mut aeron_network_publication_t,
        buffer: *const u8,
        length: usize,
        addr: *mut sockaddr_storage,
    );
}
extern "C" {
    pub fn aeron_network_publication_clean_buffer(
        publication: *mut aeron_network_publication_t,
        position: i64,
    );
}
extern "C" {
    pub fn aeron_network_publication_update_pub_lmt(
        publication: *mut aeron_network_publication_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_network_publication_check_for_blocked_publisher(
        publication: *mut aeron_network_publication_t,
        now_ns: i64,
        producer_position: i64,
        snd_pos: i64,
    );
}
pub type aeron_name_resolver_resolve_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        resolver: *mut aeron_name_resolver_t,
        name: *const ::std::os::raw::c_char,
        uri_param_name: *const ::std::os::raw::c_char,
        is_re_resolution: bool,
        address: *mut sockaddr_storage,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " Resolves a name to a host:port string.\n\n @return 0 if not found, 1 if found, -1 on error."]
pub type aeron_name_resolver_lookup_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        resolver: *mut aeron_name_resolver_t,
        name: *const ::std::os::raw::c_char,
        uri_param_name: *const ::std::os::raw::c_char,
        is_re_lookup: bool,
        resolved_name: *mut *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int,
>;
pub type aeron_name_resolver_do_work_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        resolver: *mut aeron_name_resolver_t,
        now_ms: i64,
    ) -> ::std::os::raw::c_int,
>;
pub type aeron_name_resolver_close_func_t = ::std::option::Option<
    unsafe extern "C" fn(resolver: *mut aeron_name_resolver_t) -> ::std::os::raw::c_int,
>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aeron_name_resolver_stct {
    pub name: *const ::std::os::raw::c_char,
    pub lookup_func: aeron_name_resolver_lookup_func_t,
    pub resolve_func: aeron_name_resolver_resolve_func_t,
    pub do_work_func: aeron_name_resolver_do_work_func_t,
    pub close_func: aeron_name_resolver_close_func_t,
    pub state: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_aeron_name_resolver_stct() {
    const UNINIT: ::std::mem::MaybeUninit<aeron_name_resolver_stct> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_name_resolver_stct>(),
        48usize,
        concat!("Size of: ", stringify!(aeron_name_resolver_stct))
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_name_resolver_stct>(),
        8usize,
        concat!("Alignment of ", stringify!(aeron_name_resolver_stct))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_name_resolver_stct),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lookup_func) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_name_resolver_stct),
            "::",
            stringify!(lookup_func)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).resolve_func) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_name_resolver_stct),
            "::",
            stringify!(resolve_func)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).do_work_func) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_name_resolver_stct),
            "::",
            stringify!(do_work_func)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).close_func) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_name_resolver_stct),
            "::",
            stringify!(close_func)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_name_resolver_stct),
            "::",
            stringify!(state)
        )
    );
}
extern "C" {
    pub fn aeron_name_resolver_supplier_load(
        name: *const ::std::os::raw::c_char,
    ) -> aeron_name_resolver_supplier_func_t;
}
extern "C" {
    pub fn aeron_name_resolver_init(
        resolver: *mut aeron_name_resolver_t,
        args: *const ::std::os::raw::c_char,
        context: *mut aeron_driver_context_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_default_name_resolver_supplier(
        resolver: *mut aeron_name_resolver_t,
        args: *const ::std::os::raw::c_char,
        context: *mut aeron_driver_context_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_default_name_resolver_resolve(
        resolver: *mut aeron_name_resolver_t,
        name: *const ::std::os::raw::c_char,
        uri_param_name: *const ::std::os::raw::c_char,
        is_re_resolution: bool,
        address: *mut sockaddr_storage,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_default_name_resolver_lookup(
        resolver: *mut aeron_name_resolver_t,
        name: *const ::std::os::raw::c_char,
        uri_param_name: *const ::std::os::raw::c_char,
        is_re_lookup: bool,
        resolved_name: *mut *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_default_name_resolver_do_work(
        resolver: *mut aeron_name_resolver_t,
        now_ms: i64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_default_name_resolver_close(
        resolver: *mut aeron_name_resolver_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_name_resolver_resolve_host_and_port(
        resolver: *mut aeron_name_resolver_t,
        name: *const ::std::os::raw::c_char,
        uri_param_name: *const ::std::os::raw::c_char,
        is_re_resolution: bool,
        sockaddr: *mut sockaddr_storage,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aeron_udp_channel_stct {
    pub original_uri: [::std::os::raw::c_char; 384usize],
    pub canonical_form: [::std::os::raw::c_char; 384usize],
    pub uri: aeron_uri_t,
    pub remote_data: sockaddr_storage,
    pub local_data: sockaddr_storage,
    pub remote_control: sockaddr_storage,
    pub local_control: sockaddr_storage,
    pub tag_id: i64,
    pub interface_index: ::std::os::raw::c_uint,
    pub uri_length: usize,
    pub canonical_length: usize,
    pub multicast_ttl: u8,
    pub has_explicit_endpoint: bool,
    pub has_explicit_control: bool,
    pub is_manual_control_mode: bool,
    pub is_dynamic_control_mode: bool,
    pub is_multicast: bool,
    pub ats_status: aeron_uri_ats_status_t,
    pub socket_sndbuf_length: usize,
    pub socket_rcvbuf_length: usize,
    pub receiver_window_length: usize,
    pub media_rcv_timestamp_offset: i32,
    pub channel_rcv_timestamp_offset: i32,
    pub channel_snd_timestamp_offset: i32,
}
#[test]
fn bindgen_test_layout_aeron_udp_channel_stct() {
    const UNINIT: ::std::mem::MaybeUninit<aeron_udp_channel_stct> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_udp_channel_stct>(),
        1832usize,
        concat!("Size of: ", stringify!(aeron_udp_channel_stct))
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_udp_channel_stct>(),
        8usize,
        concat!("Alignment of ", stringify!(aeron_udp_channel_stct))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).original_uri) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_udp_channel_stct),
            "::",
            stringify!(original_uri)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).canonical_form) as usize - ptr as usize },
        384usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_udp_channel_stct),
            "::",
            stringify!(canonical_form)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uri) as usize - ptr as usize },
        768usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_udp_channel_stct),
            "::",
            stringify!(uri)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).remote_data) as usize - ptr as usize },
        1232usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_udp_channel_stct),
            "::",
            stringify!(remote_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).local_data) as usize - ptr as usize },
        1360usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_udp_channel_stct),
            "::",
            stringify!(local_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).remote_control) as usize - ptr as usize },
        1488usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_udp_channel_stct),
            "::",
            stringify!(remote_control)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).local_control) as usize - ptr as usize },
        1616usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_udp_channel_stct),
            "::",
            stringify!(local_control)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tag_id) as usize - ptr as usize },
        1744usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_udp_channel_stct),
            "::",
            stringify!(tag_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).interface_index) as usize - ptr as usize },
        1752usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_udp_channel_stct),
            "::",
            stringify!(interface_index)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uri_length) as usize - ptr as usize },
        1760usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_udp_channel_stct),
            "::",
            stringify!(uri_length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).canonical_length) as usize - ptr as usize },
        1768usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_udp_channel_stct),
            "::",
            stringify!(canonical_length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).multicast_ttl) as usize - ptr as usize },
        1776usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_udp_channel_stct),
            "::",
            stringify!(multicast_ttl)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_explicit_endpoint) as usize - ptr as usize },
        1777usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_udp_channel_stct),
            "::",
            stringify!(has_explicit_endpoint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_explicit_control) as usize - ptr as usize },
        1778usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_udp_channel_stct),
            "::",
            stringify!(has_explicit_control)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).is_manual_control_mode) as usize - ptr as usize },
        1779usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_udp_channel_stct),
            "::",
            stringify!(is_manual_control_mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).is_dynamic_control_mode) as usize - ptr as usize },
        1780usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_udp_channel_stct),
            "::",
            stringify!(is_dynamic_control_mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).is_multicast) as usize - ptr as usize },
        1781usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_udp_channel_stct),
            "::",
            stringify!(is_multicast)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ats_status) as usize - ptr as usize },
        1784usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_udp_channel_stct),
            "::",
            stringify!(ats_status)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).socket_sndbuf_length) as usize - ptr as usize },
        1792usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_udp_channel_stct),
            "::",
            stringify!(socket_sndbuf_length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).socket_rcvbuf_length) as usize - ptr as usize },
        1800usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_udp_channel_stct),
            "::",
            stringify!(socket_rcvbuf_length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).receiver_window_length) as usize - ptr as usize },
        1808usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_udp_channel_stct),
            "::",
            stringify!(receiver_window_length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).media_rcv_timestamp_offset) as usize - ptr as usize },
        1816usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_udp_channel_stct),
            "::",
            stringify!(media_rcv_timestamp_offset)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).channel_rcv_timestamp_offset) as usize - ptr as usize
        },
        1820usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_udp_channel_stct),
            "::",
            stringify!(channel_rcv_timestamp_offset)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).channel_snd_timestamp_offset) as usize - ptr as usize
        },
        1824usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_udp_channel_stct),
            "::",
            stringify!(channel_snd_timestamp_offset)
        )
    );
}
extern "C" {
    pub fn aeron_udp_channel_parse(
        uri_length: usize,
        uri: *const ::std::os::raw::c_char,
        resolver: *mut aeron_name_resolver_t,
        channel: *mut *mut aeron_udp_channel_t,
        is_destination: bool,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_udp_channel_delete(channel: *mut aeron_udp_channel_t);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aeron_udp_channel_transport_stct {
    pub fd: aeron_socket_t,
    pub recv_fd: aeron_socket_t,
    pub data_paths: *mut aeron_udp_channel_data_paths_t,
    pub connected_address: *mut sockaddr_storage,
    pub dispatch_clientd: *mut ::std::os::raw::c_void,
    pub bindings_clientd: *mut ::std::os::raw::c_void,
    pub destination_clientd: *mut ::std::os::raw::c_void,
    pub interceptor_clientds: [*mut ::std::os::raw::c_void; 2usize],
    pub timestamp_flags: u32,
}
#[test]
fn bindgen_test_layout_aeron_udp_channel_transport_stct() {
    const UNINIT: ::std::mem::MaybeUninit<aeron_udp_channel_transport_stct> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_udp_channel_transport_stct>(),
        72usize,
        concat!("Size of: ", stringify!(aeron_udp_channel_transport_stct))
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_udp_channel_transport_stct>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(aeron_udp_channel_transport_stct)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fd) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_udp_channel_transport_stct),
            "::",
            stringify!(fd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).recv_fd) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_udp_channel_transport_stct),
            "::",
            stringify!(recv_fd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data_paths) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_udp_channel_transport_stct),
            "::",
            stringify!(data_paths)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).connected_address) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_udp_channel_transport_stct),
            "::",
            stringify!(connected_address)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dispatch_clientd) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_udp_channel_transport_stct),
            "::",
            stringify!(dispatch_clientd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bindings_clientd) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_udp_channel_transport_stct),
            "::",
            stringify!(bindings_clientd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).destination_clientd) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_udp_channel_transport_stct),
            "::",
            stringify!(destination_clientd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).interceptor_clientds) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_udp_channel_transport_stct),
            "::",
            stringify!(interceptor_clientds)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timestamp_flags) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_udp_channel_transport_stct),
            "::",
            stringify!(timestamp_flags)
        )
    );
}
extern "C" {
    pub fn aeron_udp_channel_transport_init(
        transport: *mut aeron_udp_channel_transport_t,
        bind_addr: *mut sockaddr_storage,
        multicast_if_addr: *mut sockaddr_storage,
        connect_addr: *mut sockaddr_storage,
        multicast_if_index: ::std::os::raw::c_uint,
        ttl: u8,
        socket_rcvbuf: usize,
        socket_sndbuf: usize,
        is_media_timestamping: bool,
        context: *mut aeron_driver_context_t,
        affinity: aeron_udp_channel_transport_affinity_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_udp_channel_transport_reconnect(
        transport: *mut aeron_udp_channel_transport_t,
        connect_addr: *mut sockaddr_storage,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_udp_channel_transport_close(
        transport: *mut aeron_udp_channel_transport_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_udp_channel_transport_recvmmsg(
        transport: *mut aeron_udp_channel_transport_t,
        msgvec: *mut mmsghdr,
        vlen: usize,
        bytes_rcved: *mut i64,
        recv_func: aeron_udp_transport_recv_func_t,
        clientd: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_udp_channel_transport_send(
        data_paths: *mut aeron_udp_channel_data_paths_t,
        transport: *mut aeron_udp_channel_transport_t,
        address: *mut sockaddr_storage,
        iov: *mut iovec,
        iov_length: usize,
        bytes_sent: *mut i64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_udp_channel_transport_get_so_rcvbuf(
        transport: *mut aeron_udp_channel_transport_t,
        so_rcvbuf: *mut usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_udp_channel_transport_bind_addr_and_port(
        transport: *mut aeron_udp_channel_transport_t,
        buffer: *mut ::std::os::raw::c_char,
        length: usize,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aeron_udp_destination_entry_stct {
    pub padding_before: [u8; 64usize],
    pub time_of_last_activity_ns: i64,
    pub destination_timeout_ns: i64,
    pub receiver_id: i64,
    pub is_receiver_id_valid: bool,
    pub uri: *mut aeron_uri_t,
    pub addr: sockaddr_storage,
    pub padding_after: [u8; 64usize],
}
#[test]
fn bindgen_test_layout_aeron_udp_destination_entry_stct() {
    const UNINIT: ::std::mem::MaybeUninit<aeron_udp_destination_entry_stct> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_udp_destination_entry_stct>(),
        296usize,
        concat!("Size of: ", stringify!(aeron_udp_destination_entry_stct))
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_udp_destination_entry_stct>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(aeron_udp_destination_entry_stct)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).padding_before) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_udp_destination_entry_stct),
            "::",
            stringify!(padding_before)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).time_of_last_activity_ns) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_udp_destination_entry_stct),
            "::",
            stringify!(time_of_last_activity_ns)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).destination_timeout_ns) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_udp_destination_entry_stct),
            "::",
            stringify!(destination_timeout_ns)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).receiver_id) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_udp_destination_entry_stct),
            "::",
            stringify!(receiver_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).is_receiver_id_valid) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_udp_destination_entry_stct),
            "::",
            stringify!(is_receiver_id_valid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uri) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_udp_destination_entry_stct),
            "::",
            stringify!(uri)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).addr) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_udp_destination_entry_stct),
            "::",
            stringify!(addr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).padding_after) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_udp_destination_entry_stct),
            "::",
            stringify!(padding_after)
        )
    );
}
pub type aeron_udp_destination_entry_t = aeron_udp_destination_entry_stct;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aeron_udp_destination_tracker_stct {
    pub padding_before: [u8; 64usize],
    pub destinations:
        aeron_udp_destination_tracker_stct_aeron_udp_destination_tracker_destinations_stct,
    pub is_manual_control_mode: bool,
    pub cached_clock: *mut aeron_clock_cache_t,
    pub destination_timeout_ns: i64,
    pub data_paths: *mut aeron_udp_channel_data_paths_t,
    pub num_destinations_addr: *mut i64,
    pub round_robin_index: ::std::os::raw::c_int,
    pub padding_after: [u8; 64usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aeron_udp_destination_tracker_stct_aeron_udp_destination_tracker_destinations_stct {
    pub array: *mut aeron_udp_destination_entry_t,
    pub length: usize,
    pub capacity: usize,
}
#[test]
fn bindgen_test_layout_aeron_udp_destination_tracker_stct_aeron_udp_destination_tracker_destinations_stct(
) {
    const UNINIT: ::std::mem::MaybeUninit<
        aeron_udp_destination_tracker_stct_aeron_udp_destination_tracker_destinations_stct,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<
            aeron_udp_destination_tracker_stct_aeron_udp_destination_tracker_destinations_stct,
        >(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(
                aeron_udp_destination_tracker_stct_aeron_udp_destination_tracker_destinations_stct
            )
        )
    );
    assert_eq!(
        ::std::mem::align_of::<
            aeron_udp_destination_tracker_stct_aeron_udp_destination_tracker_destinations_stct,
        >(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(
                aeron_udp_destination_tracker_stct_aeron_udp_destination_tracker_destinations_stct
            )
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).array) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(
                aeron_udp_destination_tracker_stct_aeron_udp_destination_tracker_destinations_stct
            ),
            "::",
            stringify!(array)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(
                aeron_udp_destination_tracker_stct_aeron_udp_destination_tracker_destinations_stct
            ),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).capacity) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(
                aeron_udp_destination_tracker_stct_aeron_udp_destination_tracker_destinations_stct
            ),
            "::",
            stringify!(capacity)
        )
    );
}
#[test]
fn bindgen_test_layout_aeron_udp_destination_tracker_stct() {
    const UNINIT: ::std::mem::MaybeUninit<aeron_udp_destination_tracker_stct> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_udp_destination_tracker_stct>(),
        200usize,
        concat!("Size of: ", stringify!(aeron_udp_destination_tracker_stct))
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_udp_destination_tracker_stct>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(aeron_udp_destination_tracker_stct)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).padding_before) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_udp_destination_tracker_stct),
            "::",
            stringify!(padding_before)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).destinations) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_udp_destination_tracker_stct),
            "::",
            stringify!(destinations)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).is_manual_control_mode) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_udp_destination_tracker_stct),
            "::",
            stringify!(is_manual_control_mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cached_clock) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_udp_destination_tracker_stct),
            "::",
            stringify!(cached_clock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).destination_timeout_ns) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_udp_destination_tracker_stct),
            "::",
            stringify!(destination_timeout_ns)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data_paths) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_udp_destination_tracker_stct),
            "::",
            stringify!(data_paths)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num_destinations_addr) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_udp_destination_tracker_stct),
            "::",
            stringify!(num_destinations_addr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).round_robin_index) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_udp_destination_tracker_stct),
            "::",
            stringify!(round_robin_index)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).padding_after) as usize - ptr as usize },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_udp_destination_tracker_stct),
            "::",
            stringify!(padding_after)
        )
    );
}
pub type aeron_udp_destination_tracker_t = aeron_udp_destination_tracker_stct;
extern "C" {
    pub fn aeron_udp_destination_tracker_init(
        tracker: *mut aeron_udp_destination_tracker_t,
        data_paths: *mut aeron_udp_channel_data_paths_t,
        cached_clock: *mut aeron_clock_cache_t,
        is_manual_control_model: bool,
        timeout_ns: i64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_udp_destination_tracker_close(
        tracker: *mut aeron_udp_destination_tracker_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_udp_destination_tracker_send(
        tracker: *mut aeron_udp_destination_tracker_t,
        transport: *mut aeron_udp_channel_transport_t,
        iov: *mut iovec,
        iov_length: usize,
        bytes_sent: *mut i64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_udp_destination_tracker_on_status_message(
        tracker: *mut aeron_udp_destination_tracker_t,
        buffer: *const u8,
        len: usize,
        addr: *mut sockaddr_storage,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_udp_destination_tracker_manual_add_destination(
        tracker: *mut aeron_udp_destination_tracker_t,
        now_ns: i64,
        uri: *mut aeron_uri_t,
        addr: *mut sockaddr_storage,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_udp_destination_tracker_remove_destination(
        tracker: *mut aeron_udp_destination_tracker_t,
        addr: *mut sockaddr_storage,
        removed_uri: *mut *mut aeron_uri_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_udp_destination_tracker_check_for_re_resolution(
        tracker: *mut aeron_udp_destination_tracker_t,
        endpoint: *mut aeron_send_channel_endpoint_t,
        now_ns: i64,
        conductor_proxy: *mut aeron_driver_conductor_proxy_t,
    );
}
extern "C" {
    pub fn aeron_udp_destination_tracker_resolution_change(
        tracker: *mut aeron_udp_destination_tracker_t,
        endpoint_name: *const ::std::os::raw::c_char,
        addr: *mut sockaddr_storage,
    );
}
pub type aeron_driver_sender_t = aeron_driver_sender_stct;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aeron_driver_sender_proxy_stct {
    pub sender: *mut aeron_driver_sender_t,
    pub threading_mode: aeron_threading_mode_t,
    pub on_add_endpoint_func: aeron_on_endpoint_change_func_t,
    pub on_remove_endpoint_func: aeron_on_endpoint_change_func_t,
    pub command_queue: *mut aeron_mpsc_rb_t,
    pub fail_counter: *mut i64,
}
#[test]
fn bindgen_test_layout_aeron_driver_sender_proxy_stct() {
    const UNINIT: ::std::mem::MaybeUninit<aeron_driver_sender_proxy_stct> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_driver_sender_proxy_stct>(),
        48usize,
        concat!("Size of: ", stringify!(aeron_driver_sender_proxy_stct))
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_driver_sender_proxy_stct>(),
        8usize,
        concat!("Alignment of ", stringify!(aeron_driver_sender_proxy_stct))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sender) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_sender_proxy_stct),
            "::",
            stringify!(sender)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).threading_mode) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_sender_proxy_stct),
            "::",
            stringify!(threading_mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).on_add_endpoint_func) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_sender_proxy_stct),
            "::",
            stringify!(on_add_endpoint_func)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).on_remove_endpoint_func) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_sender_proxy_stct),
            "::",
            stringify!(on_remove_endpoint_func)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).command_queue) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_sender_proxy_stct),
            "::",
            stringify!(command_queue)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fail_counter) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_sender_proxy_stct),
            "::",
            stringify!(fail_counter)
        )
    );
}
extern "C" {
    pub fn aeron_driver_sender_proxy_on_add_endpoint(
        sender_proxy: *mut aeron_driver_sender_proxy_t,
        endpoint: *mut aeron_send_channel_endpoint_t,
    );
}
extern "C" {
    pub fn aeron_driver_sender_proxy_on_remove_endpoint(
        sender_proxy: *mut aeron_driver_sender_proxy_t,
        endpoint: *mut aeron_send_channel_endpoint_t,
    );
}
extern "C" {
    pub fn aeron_driver_sender_proxy_on_add_publication(
        sender_proxy: *mut aeron_driver_sender_proxy_t,
        publication: *mut aeron_network_publication_t,
    );
}
extern "C" {
    pub fn aeron_driver_sender_proxy_on_remove_publication(
        sender_proxy: *mut aeron_driver_sender_proxy_t,
        publication: *mut aeron_network_publication_t,
    );
}
extern "C" {
    pub fn aeron_driver_sender_proxy_on_resolution_change(
        sender_proxy: *mut aeron_driver_sender_proxy_t,
        endpoint_name: *const ::std::os::raw::c_char,
        endpoint: *mut aeron_send_channel_endpoint_t,
        new_addr: *mut sockaddr_storage,
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aeron_command_destination_stct {
    pub base: aeron_command_base_t,
    pub control_address: sockaddr_storage,
    pub endpoint: *mut ::std::os::raw::c_void,
    pub uri: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_aeron_command_destination_stct() {
    const UNINIT: ::std::mem::MaybeUninit<aeron_command_destination_stct> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_command_destination_stct>(),
        160usize,
        concat!("Size of: ", stringify!(aeron_command_destination_stct))
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_command_destination_stct>(),
        8usize,
        concat!("Alignment of ", stringify!(aeron_command_destination_stct))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_command_destination_stct),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).control_address) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_command_destination_stct),
            "::",
            stringify!(control_address)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).endpoint) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_command_destination_stct),
            "::",
            stringify!(endpoint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uri) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_command_destination_stct),
            "::",
            stringify!(uri)
        )
    );
}
pub type aeron_command_destination_t = aeron_command_destination_stct;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aeron_command_sender_resolution_change_stct {
    pub base: aeron_command_base_t,
    pub endpoint_name: *const ::std::os::raw::c_char,
    pub endpoint: *mut ::std::os::raw::c_void,
    pub new_addr: sockaddr_storage,
}
#[test]
fn bindgen_test_layout_aeron_command_sender_resolution_change_stct() {
    const UNINIT: ::std::mem::MaybeUninit<aeron_command_sender_resolution_change_stct> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_command_sender_resolution_change_stct>(),
        160usize,
        concat!(
            "Size of: ",
            stringify!(aeron_command_sender_resolution_change_stct)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_command_sender_resolution_change_stct>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(aeron_command_sender_resolution_change_stct)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_command_sender_resolution_change_stct),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).endpoint_name) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_command_sender_resolution_change_stct),
            "::",
            stringify!(endpoint_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).endpoint) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_command_sender_resolution_change_stct),
            "::",
            stringify!(endpoint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).new_addr) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_command_sender_resolution_change_stct),
            "::",
            stringify!(new_addr)
        )
    );
}
pub type aeron_command_sender_resolution_change_t = aeron_command_sender_resolution_change_stct;
extern "C" {
    pub fn aeron_driver_sender_proxy_on_add_destination(
        sender_proxy: *mut aeron_driver_sender_proxy_t,
        endpoint: *mut aeron_send_channel_endpoint_t,
        uri: *mut aeron_uri_t,
        addr: *mut sockaddr_storage,
    );
}
extern "C" {
    pub fn aeron_driver_sender_proxy_on_remove_destination(
        sender_proxy: *mut aeron_driver_sender_proxy_t,
        endpoint: *mut aeron_send_channel_endpoint_t,
        addr: *mut sockaddr_storage,
    );
}
extern "C" {
    pub fn aeron_driver_sender_proxy_on_delete_cmd(
        sender_proxy: *mut aeron_driver_sender_proxy_t,
        cmd: *mut aeron_command_base_t,
    );
}
pub mod aeron_send_channel_endpoint_status_enum {
    pub type Type = ::std::os::raw::c_uint;
    pub const AERON_SEND_CHANNEL_ENDPOINT_STATUS_ACTIVE: Type = 0;
    pub const AERON_SEND_CHANNEL_ENDPOINT_STATUS_CLOSING: Type = 1;
}
pub use self::aeron_send_channel_endpoint_status_enum::Type as aeron_send_channel_endpoint_status_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aeron_send_channel_endpoint_stct {
    pub conductor_fields:
        aeron_send_channel_endpoint_stct_aeron_send_channel_endpoint_conductor_fields_stct,
    pub has_sender_released: bool,
    pub transport: aeron_udp_channel_transport_t,
    pub channel_status: aeron_atomic_counter_t,
    pub local_sockaddr_indicator: aeron_atomic_counter_t,
    pub tracker_num_destinations: aeron_atomic_counter_t,
    pub destination_tracker: *mut aeron_udp_destination_tracker_t,
    pub sender_proxy: *mut aeron_driver_sender_proxy_t,
    pub publication_dispatch_map: aeron_int64_to_ptr_hash_map_t,
    pub transport_bindings: *mut aeron_udp_channel_transport_bindings_t,
    pub data_paths: *mut aeron_udp_channel_data_paths_t,
    pub current_data_addr: sockaddr_storage,
    pub cached_clock: *mut aeron_clock_cache_t,
    pub time_of_last_sm_ns: i64,
    pub padding: [u8; 64usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aeron_send_channel_endpoint_stct_aeron_send_channel_endpoint_conductor_fields_stct {
    pub managed_resource: aeron_driver_managed_resource_t,
    pub refcnt: i32,
    pub has_reached_end_of_life: bool,
    pub udp_channel: *mut aeron_udp_channel_t,
    pub status: aeron_send_channel_endpoint_status_t,
    pub socket_sndbuf: usize,
    pub socket_rcvbuf: usize,
}
#[test]
fn bindgen_test_layout_aeron_send_channel_endpoint_stct_aeron_send_channel_endpoint_conductor_fields_stct(
) {
    const UNINIT: ::std::mem::MaybeUninit<
        aeron_send_channel_endpoint_stct_aeron_send_channel_endpoint_conductor_fields_stct,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<
            aeron_send_channel_endpoint_stct_aeron_send_channel_endpoint_conductor_fields_stct,
        >(),
        80usize,
        concat!(
            "Size of: ",
            stringify!(
                aeron_send_channel_endpoint_stct_aeron_send_channel_endpoint_conductor_fields_stct
            )
        )
    );
    assert_eq!(
        ::std::mem::align_of::<
            aeron_send_channel_endpoint_stct_aeron_send_channel_endpoint_conductor_fields_stct,
        >(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(
                aeron_send_channel_endpoint_stct_aeron_send_channel_endpoint_conductor_fields_stct
            )
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).managed_resource) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(
                aeron_send_channel_endpoint_stct_aeron_send_channel_endpoint_conductor_fields_stct
            ),
            "::",
            stringify!(managed_resource)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).refcnt) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(
                aeron_send_channel_endpoint_stct_aeron_send_channel_endpoint_conductor_fields_stct
            ),
            "::",
            stringify!(refcnt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_reached_end_of_life) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(
                aeron_send_channel_endpoint_stct_aeron_send_channel_endpoint_conductor_fields_stct
            ),
            "::",
            stringify!(has_reached_end_of_life)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).udp_channel) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(
                aeron_send_channel_endpoint_stct_aeron_send_channel_endpoint_conductor_fields_stct
            ),
            "::",
            stringify!(udp_channel)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).status) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(
                aeron_send_channel_endpoint_stct_aeron_send_channel_endpoint_conductor_fields_stct
            ),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).socket_sndbuf) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(
                aeron_send_channel_endpoint_stct_aeron_send_channel_endpoint_conductor_fields_stct
            ),
            "::",
            stringify!(socket_sndbuf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).socket_rcvbuf) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(
                aeron_send_channel_endpoint_stct_aeron_send_channel_endpoint_conductor_fields_stct
            ),
            "::",
            stringify!(socket_rcvbuf)
        )
    );
}
#[test]
fn bindgen_test_layout_aeron_send_channel_endpoint_stct() {
    const UNINIT: ::std::mem::MaybeUninit<aeron_send_channel_endpoint_stct> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_send_channel_endpoint_stct>(),
        496usize,
        concat!("Size of: ", stringify!(aeron_send_channel_endpoint_stct))
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_send_channel_endpoint_stct>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(aeron_send_channel_endpoint_stct)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).conductor_fields) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_send_channel_endpoint_stct),
            "::",
            stringify!(conductor_fields)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_sender_released) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_send_channel_endpoint_stct),
            "::",
            stringify!(has_sender_released)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).transport) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_send_channel_endpoint_stct),
            "::",
            stringify!(transport)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).channel_status) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_send_channel_endpoint_stct),
            "::",
            stringify!(channel_status)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).local_sockaddr_indicator) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_send_channel_endpoint_stct),
            "::",
            stringify!(local_sockaddr_indicator)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tracker_num_destinations) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_send_channel_endpoint_stct),
            "::",
            stringify!(tracker_num_destinations)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).destination_tracker) as usize - ptr as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_send_channel_endpoint_stct),
            "::",
            stringify!(destination_tracker)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sender_proxy) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_send_channel_endpoint_stct),
            "::",
            stringify!(sender_proxy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).publication_dispatch_map) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_send_channel_endpoint_stct),
            "::",
            stringify!(publication_dispatch_map)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).transport_bindings) as usize - ptr as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_send_channel_endpoint_stct),
            "::",
            stringify!(transport_bindings)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data_paths) as usize - ptr as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_send_channel_endpoint_stct),
            "::",
            stringify!(data_paths)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).current_data_addr) as usize - ptr as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_send_channel_endpoint_stct),
            "::",
            stringify!(current_data_addr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cached_clock) as usize - ptr as usize },
        416usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_send_channel_endpoint_stct),
            "::",
            stringify!(cached_clock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).time_of_last_sm_ns) as usize - ptr as usize },
        424usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_send_channel_endpoint_stct),
            "::",
            stringify!(time_of_last_sm_ns)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).padding) as usize - ptr as usize },
        432usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_send_channel_endpoint_stct),
            "::",
            stringify!(padding)
        )
    );
}
extern "C" {
    pub fn aeron_send_channel_endpoint_create(
        endpoint: *mut *mut aeron_send_channel_endpoint_t,
        channel: *mut aeron_udp_channel_t,
        context: *mut aeron_driver_context_t,
        counters_manager: *mut aeron_counters_manager_t,
        registration_id: i64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_send_channel_endpoint_delete(
        counters_manager: *mut aeron_counters_manager_t,
        endpoint: *mut aeron_send_channel_endpoint_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_send_channel_endpoint_incref(clientd: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn aeron_send_channel_endpoint_decref(clientd: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn aeron_send_channel_send(
        endpoint: *mut aeron_send_channel_endpoint_t,
        iov: *mut iovec,
        iov_length: usize,
        bytes_sent: *mut i64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_send_channel_endpoint_add_publication(
        endpoint: *mut aeron_send_channel_endpoint_t,
        publication: *mut aeron_network_publication_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_send_channel_endpoint_remove_publication(
        endpoint: *mut aeron_send_channel_endpoint_t,
        publication: *mut aeron_network_publication_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_send_channel_endpoint_dispatch(
        data_paths: *mut aeron_udp_channel_data_paths_t,
        transport: *mut aeron_udp_channel_transport_t,
        sender_clientd: *mut ::std::os::raw::c_void,
        endpoint_clientd: *mut ::std::os::raw::c_void,
        destination_clientd: *mut ::std::os::raw::c_void,
        buffer: *mut u8,
        length: usize,
        addr: *mut sockaddr_storage,
        media_timestamp: *mut timespec,
    );
}
extern "C" {
    pub fn aeron_send_channel_endpoint_on_nak(
        endpoint: *mut aeron_send_channel_endpoint_t,
        buffer: *mut u8,
        length: usize,
        addr: *mut sockaddr_storage,
    );
}
extern "C" {
    pub fn aeron_send_channel_endpoint_on_status_message(
        endpoint: *mut aeron_send_channel_endpoint_t,
        buffer: *mut u8,
        length: usize,
        addr: *mut sockaddr_storage,
    );
}
extern "C" {
    pub fn aeron_send_channel_endpoint_on_rttm(
        endpoint: *mut aeron_send_channel_endpoint_t,
        buffer: *mut u8,
        length: usize,
        addr: *mut sockaddr_storage,
    );
}
extern "C" {
    pub fn aeron_send_channel_endpoint_check_for_re_resolution(
        endpoint: *mut aeron_send_channel_endpoint_t,
        now_ns: i64,
        conductor_proxy: *mut aeron_driver_conductor_proxy_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_send_channel_endpoint_resolution_change(
        context: *mut aeron_driver_context_t,
        endpoint: *mut aeron_send_channel_endpoint_t,
        endpoint_name: *const ::std::os::raw::c_char,
        new_addr: *mut sockaddr_storage,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aeron_int64_counter_map_stct {
    pub entries: *mut i64,
    pub load_factor: f32,
    pub entries_length: usize,
    pub size: usize,
    pub resize_threshold: usize,
    pub initial_value: i64,
}
#[test]
fn bindgen_test_layout_aeron_int64_counter_map_stct() {
    const UNINIT: ::std::mem::MaybeUninit<aeron_int64_counter_map_stct> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_int64_counter_map_stct>(),
        48usize,
        concat!("Size of: ", stringify!(aeron_int64_counter_map_stct))
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_int64_counter_map_stct>(),
        8usize,
        concat!("Alignment of ", stringify!(aeron_int64_counter_map_stct))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).entries) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_int64_counter_map_stct),
            "::",
            stringify!(entries)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).load_factor) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_int64_counter_map_stct),
            "::",
            stringify!(load_factor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).entries_length) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_int64_counter_map_stct),
            "::",
            stringify!(entries_length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_int64_counter_map_stct),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).resize_threshold) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_int64_counter_map_stct),
            "::",
            stringify!(resize_threshold)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).initial_value) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_int64_counter_map_stct),
            "::",
            stringify!(initial_value)
        )
    );
}
pub type aeron_int64_counter_map_t = aeron_int64_counter_map_stct;
pub type aeron_int64_counter_map_for_each_func_t = ::std::option::Option<
    unsafe extern "C" fn(clientd: *mut ::std::os::raw::c_void, key: i64, value: i64),
>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aeron_int64_to_tagged_ptr_entry_stct {
    pub value: *mut ::std::os::raw::c_void,
    pub internal_flags: u32,
    pub tag: u32,
}
#[test]
fn bindgen_test_layout_aeron_int64_to_tagged_ptr_entry_stct() {
    const UNINIT: ::std::mem::MaybeUninit<aeron_int64_to_tagged_ptr_entry_stct> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_int64_to_tagged_ptr_entry_stct>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(aeron_int64_to_tagged_ptr_entry_stct)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_int64_to_tagged_ptr_entry_stct>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(aeron_int64_to_tagged_ptr_entry_stct)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_int64_to_tagged_ptr_entry_stct),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).internal_flags) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_int64_to_tagged_ptr_entry_stct),
            "::",
            stringify!(internal_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tag) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_int64_to_tagged_ptr_entry_stct),
            "::",
            stringify!(tag)
        )
    );
}
pub type aeron_int64_to_tagged_ptr_entry_t = aeron_int64_to_tagged_ptr_entry_stct;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aeron_int64_to_tagged_ptr_hash_map_stct {
    pub keys: *mut i64,
    pub entries: *mut aeron_int64_to_tagged_ptr_entry_t,
    pub load_factor: f32,
    pub capacity: usize,
    pub size: usize,
    pub resize_threshold: usize,
}
#[test]
fn bindgen_test_layout_aeron_int64_to_tagged_ptr_hash_map_stct() {
    const UNINIT: ::std::mem::MaybeUninit<aeron_int64_to_tagged_ptr_hash_map_stct> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_int64_to_tagged_ptr_hash_map_stct>(),
        48usize,
        concat!(
            "Size of: ",
            stringify!(aeron_int64_to_tagged_ptr_hash_map_stct)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_int64_to_tagged_ptr_hash_map_stct>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(aeron_int64_to_tagged_ptr_hash_map_stct)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).keys) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_int64_to_tagged_ptr_hash_map_stct),
            "::",
            stringify!(keys)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).entries) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_int64_to_tagged_ptr_hash_map_stct),
            "::",
            stringify!(entries)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).load_factor) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_int64_to_tagged_ptr_hash_map_stct),
            "::",
            stringify!(load_factor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).capacity) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_int64_to_tagged_ptr_hash_map_stct),
            "::",
            stringify!(capacity)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_int64_to_tagged_ptr_hash_map_stct),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).resize_threshold) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_int64_to_tagged_ptr_hash_map_stct),
            "::",
            stringify!(resize_threshold)
        )
    );
}
pub type aeron_int64_to_tagged_ptr_hash_map_t = aeron_int64_to_tagged_ptr_hash_map_stct;
pub type aeron_int64_to_tagged_ptr_hash_map_for_each_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        clientd: *mut ::std::os::raw::c_void,
        key: i64,
        tag: u32,
        value: *mut ::std::os::raw::c_void,
    ),
>;
pub type aeron_int64_to_tagged_ptr_hash_map_predicate_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        clientd: *mut ::std::os::raw::c_void,
        key: i64,
        tag: u32,
        value: *mut ::std::os::raw::c_void,
    ) -> bool,
>;
pub const aeron_driver_conductor_resource_type_en_AERON_DRIVER_CONDUCTOR_RESOURCE_TYPE_CLIENT:
    aeron_driver_conductor_resource_type_en = 0;
pub const aeron_driver_conductor_resource_type_en_AERON_DRIVER_CONDUCTOR_RESOURCE_TYPE_IPC_PUBLICATION : aeron_driver_conductor_resource_type_en = 1 ;
pub const aeron_driver_conductor_resource_type_en_AERON_DRIVER_CONDUCTOR_RESOURCE_TYPE_NETWORK_PUBLICATION : aeron_driver_conductor_resource_type_en = 2 ;
pub const aeron_driver_conductor_resource_type_en_AERON_DRIVER_CONDUCTOR_RESOURCE_TYPE_SEND_CHANNEL_ENDPOINT : aeron_driver_conductor_resource_type_en = 3 ;
pub const aeron_driver_conductor_resource_type_en_AERON_DRIVER_CONDUCTOR_RESOURCE_TYPE_PUBLICATION_IMAGE : aeron_driver_conductor_resource_type_en = 4 ;
pub const aeron_driver_conductor_resource_type_en_AERON_DRIVER_CONDUCTOR_RESOURCE_TYPE_LINGER_RESOURCE : aeron_driver_conductor_resource_type_en = 5 ;
pub type aeron_driver_conductor_resource_type_en = ::std::os::raw::c_uint;
pub use self::aeron_driver_conductor_resource_type_en as aeron_driver_conductor_resource_type_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aeron_driver_conductor_proxy_stct {
    pub conductor: *mut aeron_driver_conductor_t,
    pub threading_mode: aeron_threading_mode_t,
    pub command_queue: *mut aeron_mpsc_rb_t,
    pub fail_counter: *mut i64,
}
#[test]
fn bindgen_test_layout_aeron_driver_conductor_proxy_stct() {
    const UNINIT: ::std::mem::MaybeUninit<aeron_driver_conductor_proxy_stct> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_driver_conductor_proxy_stct>(),
        32usize,
        concat!("Size of: ", stringify!(aeron_driver_conductor_proxy_stct))
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_driver_conductor_proxy_stct>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(aeron_driver_conductor_proxy_stct)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).conductor) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_conductor_proxy_stct),
            "::",
            stringify!(conductor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).threading_mode) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_conductor_proxy_stct),
            "::",
            stringify!(threading_mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).command_queue) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_conductor_proxy_stct),
            "::",
            stringify!(command_queue)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fail_counter) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_conductor_proxy_stct),
            "::",
            stringify!(fail_counter)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aeron_command_create_publication_image_stct {
    pub base: aeron_command_base_t,
    pub session_id: i32,
    pub stream_id: i32,
    pub initial_term_id: i32,
    pub active_term_id: i32,
    pub term_offset: i32,
    pub term_length: i32,
    pub mtu_length: i32,
    pub control_address: sockaddr_storage,
    pub src_address: sockaddr_storage,
    pub endpoint: *mut ::std::os::raw::c_void,
    pub destination: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_aeron_command_create_publication_image_stct() {
    const UNINIT: ::std::mem::MaybeUninit<aeron_command_create_publication_image_stct> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_command_create_publication_image_stct>(),
        320usize,
        concat!(
            "Size of: ",
            stringify!(aeron_command_create_publication_image_stct)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_command_create_publication_image_stct>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(aeron_command_create_publication_image_stct)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_command_create_publication_image_stct),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).session_id) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_command_create_publication_image_stct),
            "::",
            stringify!(session_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stream_id) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_command_create_publication_image_stct),
            "::",
            stringify!(stream_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).initial_term_id) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_command_create_publication_image_stct),
            "::",
            stringify!(initial_term_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).active_term_id) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_command_create_publication_image_stct),
            "::",
            stringify!(active_term_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).term_offset) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_command_create_publication_image_stct),
            "::",
            stringify!(term_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).term_length) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_command_create_publication_image_stct),
            "::",
            stringify!(term_length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mtu_length) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_command_create_publication_image_stct),
            "::",
            stringify!(mtu_length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).control_address) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_command_create_publication_image_stct),
            "::",
            stringify!(control_address)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).src_address) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_command_create_publication_image_stct),
            "::",
            stringify!(src_address)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).endpoint) as usize - ptr as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_command_create_publication_image_stct),
            "::",
            stringify!(endpoint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).destination) as usize - ptr as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_command_create_publication_image_stct),
            "::",
            stringify!(destination)
        )
    );
}
pub type aeron_command_create_publication_image_t = aeron_command_create_publication_image_stct;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aeron_command_re_resolve_stct {
    pub base: aeron_command_base_t,
    pub endpoint_name: *const ::std::os::raw::c_char,
    pub endpoint: *mut ::std::os::raw::c_void,
    pub destination: *mut ::std::os::raw::c_void,
    pub existing_addr: sockaddr_storage,
}
#[test]
fn bindgen_test_layout_aeron_command_re_resolve_stct() {
    const UNINIT: ::std::mem::MaybeUninit<aeron_command_re_resolve_stct> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_command_re_resolve_stct>(),
        168usize,
        concat!("Size of: ", stringify!(aeron_command_re_resolve_stct))
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_command_re_resolve_stct>(),
        8usize,
        concat!("Alignment of ", stringify!(aeron_command_re_resolve_stct))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_command_re_resolve_stct),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).endpoint_name) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_command_re_resolve_stct),
            "::",
            stringify!(endpoint_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).endpoint) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_command_re_resolve_stct),
            "::",
            stringify!(endpoint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).destination) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_command_re_resolve_stct),
            "::",
            stringify!(destination)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).existing_addr) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_command_re_resolve_stct),
            "::",
            stringify!(existing_addr)
        )
    );
}
pub type aeron_command_re_resolve_t = aeron_command_re_resolve_stct;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aeron_command_delete_destination_stct {
    pub base: aeron_command_base_t,
    pub destination: *mut ::std::os::raw::c_void,
    pub channel: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_aeron_command_delete_destination_stct() {
    const UNINIT: ::std::mem::MaybeUninit<aeron_command_delete_destination_stct> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_command_delete_destination_stct>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(aeron_command_delete_destination_stct)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_command_delete_destination_stct>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(aeron_command_delete_destination_stct)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_command_delete_destination_stct),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).destination) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_command_delete_destination_stct),
            "::",
            stringify!(destination)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).channel) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_command_delete_destination_stct),
            "::",
            stringify!(channel)
        )
    );
}
pub type aeron_command_delete_destination_t = aeron_command_delete_destination_stct;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aeron_command_release_resource_stct {
    pub base: aeron_command_base_t,
    pub resource_type: aeron_driver_conductor_resource_type_t,
}
#[test]
fn bindgen_test_layout_aeron_command_release_resource_stct() {
    const UNINIT: ::std::mem::MaybeUninit<aeron_command_release_resource_stct> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_command_release_resource_stct>(),
        24usize,
        concat!("Size of: ", stringify!(aeron_command_release_resource_stct))
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_command_release_resource_stct>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(aeron_command_release_resource_stct)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_command_release_resource_stct),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).resource_type) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_command_release_resource_stct),
            "::",
            stringify!(resource_type)
        )
    );
}
pub type aeron_command_release_resource_t = aeron_command_release_resource_stct;
extern "C" {
    pub fn aeron_driver_conductor_proxy_on_create_publication_image_cmd(
        conductor_proxy: *mut aeron_driver_conductor_proxy_t,
        session_id: i32,
        stream_id: i32,
        initial_term_id: i32,
        active_term_id: i32,
        term_offset: i32,
        term_length: i32,
        mtu_length: i32,
        control_address: *mut sockaddr_storage,
        src_address: *mut sockaddr_storage,
        endpoint: *mut ::std::os::raw::c_void,
        destination: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn aeron_driver_conductor_proxy_on_re_resolve_endpoint(
        conductor_proxy: *mut aeron_driver_conductor_proxy_t,
        endpoint_name: *const ::std::os::raw::c_char,
        endpoint: *mut ::std::os::raw::c_void,
        existing_addr: *mut sockaddr_storage,
    );
}
extern "C" {
    pub fn aeron_driver_conductor_proxy_on_re_resolve_control(
        conductor_proxy: *mut aeron_driver_conductor_proxy_t,
        endpoint_name: *const ::std::os::raw::c_char,
        endpoint: *mut ::std::os::raw::c_void,
        destination: *mut ::std::os::raw::c_void,
        existing_addr: *mut sockaddr_storage,
    );
}
extern "C" {
    pub fn aeron_driver_conductor_proxy_on_delete_receive_destination(
        conductor_proxy: *mut aeron_driver_conductor_proxy_t,
        destination: *mut ::std::os::raw::c_void,
        channel: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn aeron_driver_conductor_proxy_on_delete_send_destination(
        conductor_proxy: *mut aeron_driver_conductor_proxy_t,
        removed_uri: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn aeron_driver_conductor_proxy_on_receive_endpoint_removed(
        conductor_proxy: *mut aeron_driver_conductor_proxy_t,
        endpoint: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn aeron_driver_conductor_proxy_on_release_resource(
        conductor_proxy: *mut aeron_driver_conductor_proxy_t,
        managed_resource: *mut ::std::os::raw::c_void,
        resource_type: aeron_driver_conductor_resource_type_t,
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aeron_receive_destination_stct {
    pub conductor_fields:
        aeron_receive_destination_stct_aeron_receive_destination_conductor_fields_stct,
    pub transport: aeron_udp_channel_transport_t,
    pub data_paths: *mut aeron_udp_channel_data_paths_t,
    pub local_sockaddr_indicator: aeron_atomic_counter_t,
    pub current_control_addr: sockaddr_storage,
    pub so_rcvbuf: usize,
    pub has_control_addr: bool,
    pub time_of_last_activity_ns: i64,
    pub padding: [u8; 64usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aeron_receive_destination_stct_aeron_receive_destination_conductor_fields_stct {
    pub udp_channel: *mut aeron_udp_channel_t,
}
#[test]
fn bindgen_test_layout_aeron_receive_destination_stct_aeron_receive_destination_conductor_fields_stct(
) {
    const UNINIT: ::std::mem::MaybeUninit<
        aeron_receive_destination_stct_aeron_receive_destination_conductor_fields_stct,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<
            aeron_receive_destination_stct_aeron_receive_destination_conductor_fields_stct,
        >(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(
                aeron_receive_destination_stct_aeron_receive_destination_conductor_fields_stct
            )
        )
    );
    assert_eq!(
        ::std::mem::align_of::<
            aeron_receive_destination_stct_aeron_receive_destination_conductor_fields_stct,
        >(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(
                aeron_receive_destination_stct_aeron_receive_destination_conductor_fields_stct
            )
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).udp_channel) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(
                aeron_receive_destination_stct_aeron_receive_destination_conductor_fields_stct
            ),
            "::",
            stringify!(udp_channel)
        )
    );
}
#[test]
fn bindgen_test_layout_aeron_receive_destination_stct() {
    const UNINIT: ::std::mem::MaybeUninit<aeron_receive_destination_stct> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_receive_destination_stct>(),
        320usize,
        concat!("Size of: ", stringify!(aeron_receive_destination_stct))
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_receive_destination_stct>(),
        8usize,
        concat!("Alignment of ", stringify!(aeron_receive_destination_stct))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).conductor_fields) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_receive_destination_stct),
            "::",
            stringify!(conductor_fields)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).transport) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_receive_destination_stct),
            "::",
            stringify!(transport)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data_paths) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_receive_destination_stct),
            "::",
            stringify!(data_paths)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).local_sockaddr_indicator) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_receive_destination_stct),
            "::",
            stringify!(local_sockaddr_indicator)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).current_control_addr) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_receive_destination_stct),
            "::",
            stringify!(current_control_addr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).so_rcvbuf) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_receive_destination_stct),
            "::",
            stringify!(so_rcvbuf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_control_addr) as usize - ptr as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_receive_destination_stct),
            "::",
            stringify!(has_control_addr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).time_of_last_activity_ns) as usize - ptr as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_receive_destination_stct),
            "::",
            stringify!(time_of_last_activity_ns)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).padding) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_receive_destination_stct),
            "::",
            stringify!(padding)
        )
    );
}
pub type aeron_receive_destination_t = aeron_receive_destination_stct;
extern "C" {
    pub fn aeron_receive_destination_create(
        destination: *mut *mut aeron_receive_destination_t,
        destination_channel: *mut aeron_udp_channel_t,
        endpoint_channel: *mut aeron_udp_channel_t,
        context: *mut aeron_driver_context_t,
        counters_manager: *mut aeron_counters_manager_t,
        registration_id: i64,
        channel_status_counter_id: i32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_receive_destination_delete(
        destination: *mut aeron_receive_destination_t,
        counters_manager: *mut aeron_counters_manager_t,
    );
}
pub type aeron_receive_channel_endpoint_t = aeron_receive_channel_endpoint_stct;
pub type aeron_driver_receiver_t = aeron_driver_receiver_stct;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aeron_data_packet_dispatcher_stct {
    pub ignored_sessions_map: aeron_int64_to_ptr_hash_map_t,
    pub session_by_stream_id_map: aeron_int64_to_ptr_hash_map_t,
    pub tokens: aeron_data_packet_dispatcher_stct_aeron_data_packet_dispatcher_tokens_stct,
    pub conductor_proxy: *mut aeron_driver_conductor_proxy_t,
    pub receiver: *mut aeron_driver_receiver_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aeron_data_packet_dispatcher_stct_aeron_data_packet_dispatcher_tokens_stct {
    pub subscribed: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_aeron_data_packet_dispatcher_stct_aeron_data_packet_dispatcher_tokens_stct()
{
    const UNINIT: ::std::mem::MaybeUninit<
        aeron_data_packet_dispatcher_stct_aeron_data_packet_dispatcher_tokens_stct,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<
            aeron_data_packet_dispatcher_stct_aeron_data_packet_dispatcher_tokens_stct,
        >(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(aeron_data_packet_dispatcher_stct_aeron_data_packet_dispatcher_tokens_stct)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<
            aeron_data_packet_dispatcher_stct_aeron_data_packet_dispatcher_tokens_stct,
        >(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(aeron_data_packet_dispatcher_stct_aeron_data_packet_dispatcher_tokens_stct)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).subscribed) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_data_packet_dispatcher_stct_aeron_data_packet_dispatcher_tokens_stct),
            "::",
            stringify!(subscribed)
        )
    );
}
#[test]
fn bindgen_test_layout_aeron_data_packet_dispatcher_stct() {
    const UNINIT: ::std::mem::MaybeUninit<aeron_data_packet_dispatcher_stct> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_data_packet_dispatcher_stct>(),
        120usize,
        concat!("Size of: ", stringify!(aeron_data_packet_dispatcher_stct))
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_data_packet_dispatcher_stct>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(aeron_data_packet_dispatcher_stct)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ignored_sessions_map) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_data_packet_dispatcher_stct),
            "::",
            stringify!(ignored_sessions_map)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).session_by_stream_id_map) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_data_packet_dispatcher_stct),
            "::",
            stringify!(session_by_stream_id_map)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tokens) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_data_packet_dispatcher_stct),
            "::",
            stringify!(tokens)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).conductor_proxy) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_data_packet_dispatcher_stct),
            "::",
            stringify!(conductor_proxy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).receiver) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_data_packet_dispatcher_stct),
            "::",
            stringify!(receiver)
        )
    );
}
extern "C" {
    pub fn aeron_data_packet_dispatcher_init(
        dispatcher: *mut aeron_data_packet_dispatcher_t,
        conductor_proxy: *mut aeron_driver_conductor_proxy_t,
        receiver: *mut aeron_driver_receiver_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_data_packet_dispatcher_close(
        dispatcher: *mut aeron_data_packet_dispatcher_t,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aeron_data_packet_dispatcher_stream_interest_stct {
    pub is_all_sessions: bool,
    pub image_by_session_id_map: aeron_int64_to_tagged_ptr_hash_map_t,
    pub subscribed_sessions: aeron_int64_to_ptr_hash_map_t,
}
#[test]
fn bindgen_test_layout_aeron_data_packet_dispatcher_stream_interest_stct() {
    const UNINIT: ::std::mem::MaybeUninit<aeron_data_packet_dispatcher_stream_interest_stct> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_data_packet_dispatcher_stream_interest_stct>(),
        104usize,
        concat!(
            "Size of: ",
            stringify!(aeron_data_packet_dispatcher_stream_interest_stct)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_data_packet_dispatcher_stream_interest_stct>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(aeron_data_packet_dispatcher_stream_interest_stct)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).is_all_sessions) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_data_packet_dispatcher_stream_interest_stct),
            "::",
            stringify!(is_all_sessions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).image_by_session_id_map) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_data_packet_dispatcher_stream_interest_stct),
            "::",
            stringify!(image_by_session_id_map)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).subscribed_sessions) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_data_packet_dispatcher_stream_interest_stct),
            "::",
            stringify!(subscribed_sessions)
        )
    );
}
pub type aeron_data_packet_dispatcher_stream_interest_t =
    aeron_data_packet_dispatcher_stream_interest_stct;
extern "C" {
    pub fn aeron_data_packet_dispatcher_add_subscription(
        dispatcher: *mut aeron_data_packet_dispatcher_t,
        stream_id: i32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_data_packet_dispatcher_add_subscription_by_session(
        dispatcher: *mut aeron_data_packet_dispatcher_t,
        stream_id: i32,
        session_id: i32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_data_packet_dispatcher_remove_subscription(
        dispatcher: *mut aeron_data_packet_dispatcher_t,
        stream_id: i32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_data_packet_dispatcher_remove_subscription_by_session(
        dispatcher: *mut aeron_data_packet_dispatcher_t,
        stream_id: i32,
        session_id: i32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_data_packet_dispatcher_add_publication_image(
        dispatcher: *mut aeron_data_packet_dispatcher_t,
        image: *mut aeron_publication_image_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_data_packet_dispatcher_remove_publication_image(
        dispatcher: *mut aeron_data_packet_dispatcher_t,
        image: *mut aeron_publication_image_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_data_packet_dispatcher_has_interest_in(
        dispatcher: *mut aeron_data_packet_dispatcher_t,
        stream_id: i32,
        session_id: i32,
    ) -> bool;
}
extern "C" {
    pub fn aeron_data_packet_dispatcher_on_data(
        dispatcher: *mut aeron_data_packet_dispatcher_t,
        endpoint: *mut aeron_receive_channel_endpoint_t,
        destination: *mut aeron_receive_destination_t,
        header: *mut aeron_data_header_t,
        buffer: *mut u8,
        length: usize,
        addr: *mut sockaddr_storage,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_data_packet_dispatcher_on_setup(
        dispatcher: *mut aeron_data_packet_dispatcher_t,
        endpoint: *mut aeron_receive_channel_endpoint_t,
        destination: *mut aeron_receive_destination_t,
        header: *mut aeron_setup_header_t,
        buffer: *mut u8,
        length: usize,
        addr: *mut sockaddr_storage,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_data_packet_dispatcher_on_rttm(
        dispatcher: *mut aeron_data_packet_dispatcher_t,
        endpoint: *mut aeron_receive_channel_endpoint_t,
        destination: *mut aeron_receive_destination_t,
        header: *mut aeron_rttm_header_t,
        buffer: *mut u8,
        length: usize,
        addr: *mut sockaddr_storage,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_data_packet_dispatcher_elicit_setup_from_source(
        dispatcher: *mut aeron_data_packet_dispatcher_t,
        stream_interest: *mut aeron_data_packet_dispatcher_stream_interest_t,
        endpoint: *mut aeron_receive_channel_endpoint_t,
        destination: *mut aeron_receive_destination_t,
        addr: *mut sockaddr_storage,
        stream_id: i32,
        session_id: i32,
    ) -> ::std::os::raw::c_int;
}
pub mod aeron_receive_channel_endpoint_status_enum {
    pub type Type = ::std::os::raw::c_uint;
    pub const AERON_RECEIVE_CHANNEL_ENDPOINT_STATUS_ACTIVE: Type = 0;
    pub const AERON_RECEIVE_CHANNEL_ENDPOINT_STATUS_CLOSING: Type = 1;
    pub const AERON_RECEIVE_CHANNEL_ENDPOINT_STATUS_CLOSED: Type = 2;
}
pub use self::aeron_receive_channel_endpoint_status_enum::Type as aeron_receive_channel_endpoint_status_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aeron_receive_destination_entry_stct {
    pub destination: *mut aeron_receive_destination_t,
}
#[test]
fn bindgen_test_layout_aeron_receive_destination_entry_stct() {
    const UNINIT: ::std::mem::MaybeUninit<aeron_receive_destination_entry_stct> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_receive_destination_entry_stct>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(aeron_receive_destination_entry_stct)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_receive_destination_entry_stct>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(aeron_receive_destination_entry_stct)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).destination) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_receive_destination_entry_stct),
            "::",
            stringify!(destination)
        )
    );
}
pub type aeron_receive_destination_entry_t = aeron_receive_destination_entry_stct;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aeron_receive_channel_endpoint_stct {
    pub conductor_fields:
        aeron_receive_channel_endpoint_stct_aeron_receive_channel_endpoint_conductor_fields_stct,
    pub destinations: aeron_receive_channel_endpoint_stct_destination_stct,
    pub dispatcher: aeron_data_packet_dispatcher_t,
    pub stream_id_to_refcnt_map: aeron_int64_counter_map_t,
    pub stream_and_session_id_to_refcnt_map: aeron_int64_counter_map_t,
    pub channel_status: aeron_atomic_counter_t,
    pub receiver_proxy: *mut aeron_driver_receiver_proxy_t,
    pub transport_bindings: *mut aeron_udp_channel_transport_bindings_t,
    pub cached_clock: *mut aeron_clock_cache_t,
    pub receiver_id: i64,
    pub has_receiver_released: bool,
    pub group_tag: aeron_receive_channel_endpoint_stct__bindgen_ty_1,
    pub short_sends_counter: *mut i64,
    pub possible_ttl_asymmetry_counter: *mut i64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aeron_receive_channel_endpoint_stct_aeron_receive_channel_endpoint_conductor_fields_stct
{
    pub managed_resource: aeron_driver_managed_resource_t,
    pub udp_channel: *mut aeron_udp_channel_t,
    pub status: aeron_receive_channel_endpoint_status_t,
    pub image_ref_count: i64,
}
#[test]
fn bindgen_test_layout_aeron_receive_channel_endpoint_stct_aeron_receive_channel_endpoint_conductor_fields_stct(
) {
    const UNINIT: ::std::mem::MaybeUninit<
        aeron_receive_channel_endpoint_stct_aeron_receive_channel_endpoint_conductor_fields_stct,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq ! (:: std :: mem :: size_of :: < aeron_receive_channel_endpoint_stct_aeron_receive_channel_endpoint_conductor_fields_stct > () , 64usize , concat ! ("Size of: " , stringify ! (aeron_receive_channel_endpoint_stct_aeron_receive_channel_endpoint_conductor_fields_stct)));
    assert_eq ! (:: std :: mem :: align_of :: < aeron_receive_channel_endpoint_stct_aeron_receive_channel_endpoint_conductor_fields_stct > () , 8usize , concat ! ("Alignment of " , stringify ! (aeron_receive_channel_endpoint_stct_aeron_receive_channel_endpoint_conductor_fields_stct)));
    assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . managed_resource) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (aeron_receive_channel_endpoint_stct_aeron_receive_channel_endpoint_conductor_fields_stct) , "::" , stringify ! (managed_resource)));
    assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . udp_channel) as usize - ptr as usize } , 40usize , concat ! ("Offset of field: " , stringify ! (aeron_receive_channel_endpoint_stct_aeron_receive_channel_endpoint_conductor_fields_stct) , "::" , stringify ! (udp_channel)));
    assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . status) as usize - ptr as usize } , 48usize , concat ! ("Offset of field: " , stringify ! (aeron_receive_channel_endpoint_stct_aeron_receive_channel_endpoint_conductor_fields_stct) , "::" , stringify ! (status)));
    assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . image_ref_count) as usize - ptr as usize } , 56usize , concat ! ("Offset of field: " , stringify ! (aeron_receive_channel_endpoint_stct_aeron_receive_channel_endpoint_conductor_fields_stct) , "::" , stringify ! (image_ref_count)));
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aeron_receive_channel_endpoint_stct_destination_stct {
    pub length: usize,
    pub capacity: usize,
    pub array: *mut aeron_receive_destination_entry_t,
}
#[test]
fn bindgen_test_layout_aeron_receive_channel_endpoint_stct_destination_stct() {
    const UNINIT: ::std::mem::MaybeUninit<aeron_receive_channel_endpoint_stct_destination_stct> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_receive_channel_endpoint_stct_destination_stct>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(aeron_receive_channel_endpoint_stct_destination_stct)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_receive_channel_endpoint_stct_destination_stct>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(aeron_receive_channel_endpoint_stct_destination_stct)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_receive_channel_endpoint_stct_destination_stct),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).capacity) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_receive_channel_endpoint_stct_destination_stct),
            "::",
            stringify!(capacity)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).array) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_receive_channel_endpoint_stct_destination_stct),
            "::",
            stringify!(array)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aeron_receive_channel_endpoint_stct__bindgen_ty_1 {
    pub is_present: bool,
    pub value: i64,
}
#[test]
fn bindgen_test_layout_aeron_receive_channel_endpoint_stct__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<aeron_receive_channel_endpoint_stct__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_receive_channel_endpoint_stct__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(aeron_receive_channel_endpoint_stct__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_receive_channel_endpoint_stct__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(aeron_receive_channel_endpoint_stct__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).is_present) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_receive_channel_endpoint_stct__bindgen_ty_1),
            "::",
            stringify!(is_present)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_receive_channel_endpoint_stct__bindgen_ty_1),
            "::",
            stringify!(value)
        )
    );
}
#[test]
fn bindgen_test_layout_aeron_receive_channel_endpoint_stct() {
    const UNINIT: ::std::mem::MaybeUninit<aeron_receive_channel_endpoint_stct> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_receive_channel_endpoint_stct>(),
        392usize,
        concat!("Size of: ", stringify!(aeron_receive_channel_endpoint_stct))
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_receive_channel_endpoint_stct>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(aeron_receive_channel_endpoint_stct)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).conductor_fields) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_receive_channel_endpoint_stct),
            "::",
            stringify!(conductor_fields)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).destinations) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_receive_channel_endpoint_stct),
            "::",
            stringify!(destinations)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dispatcher) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_receive_channel_endpoint_stct),
            "::",
            stringify!(dispatcher)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stream_id_to_refcnt_map) as usize - ptr as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_receive_channel_endpoint_stct),
            "::",
            stringify!(stream_id_to_refcnt_map)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).stream_and_session_id_to_refcnt_map) as usize - ptr as usize
        },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_receive_channel_endpoint_stct),
            "::",
            stringify!(stream_and_session_id_to_refcnt_map)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).channel_status) as usize - ptr as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_receive_channel_endpoint_stct),
            "::",
            stringify!(channel_status)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).receiver_proxy) as usize - ptr as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_receive_channel_endpoint_stct),
            "::",
            stringify!(receiver_proxy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).transport_bindings) as usize - ptr as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_receive_channel_endpoint_stct),
            "::",
            stringify!(transport_bindings)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cached_clock) as usize - ptr as usize },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_receive_channel_endpoint_stct),
            "::",
            stringify!(cached_clock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).receiver_id) as usize - ptr as usize },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_receive_channel_endpoint_stct),
            "::",
            stringify!(receiver_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_receiver_released) as usize - ptr as usize },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_receive_channel_endpoint_stct),
            "::",
            stringify!(has_receiver_released)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).group_tag) as usize - ptr as usize },
        360usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_receive_channel_endpoint_stct),
            "::",
            stringify!(group_tag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).short_sends_counter) as usize - ptr as usize },
        376usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_receive_channel_endpoint_stct),
            "::",
            stringify!(short_sends_counter)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).possible_ttl_asymmetry_counter) as usize - ptr as usize
        },
        384usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_receive_channel_endpoint_stct),
            "::",
            stringify!(possible_ttl_asymmetry_counter)
        )
    );
}
extern "C" {
    pub fn aeron_receive_channel_endpoint_create(
        endpoint: *mut *mut aeron_receive_channel_endpoint_t,
        channel: *mut aeron_udp_channel_t,
        straight_through_destination: *mut aeron_receive_destination_t,
        status_indicator: *mut aeron_atomic_counter_t,
        system_counters: *mut aeron_system_counters_t,
        context: *mut aeron_driver_context_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_receive_channel_endpoint_delete(
        counters_manager: *mut aeron_counters_manager_t,
        endpoint: *mut aeron_receive_channel_endpoint_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_receive_channel_endpoint_close(
        endpoint: *mut aeron_receive_channel_endpoint_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_receive_channel_endpoint_send(
        endpoint: *mut aeron_receive_channel_endpoint_t,
        destination: *mut aeron_receive_destination_t,
        address: *mut sockaddr_storage,
        iov: *mut iovec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_receive_channel_endpoint_send_sm(
        endpoint: *mut aeron_receive_channel_endpoint_t,
        destination: *mut aeron_receive_destination_t,
        control_addr: *mut sockaddr_storage,
        stream_id: i32,
        session_id: i32,
        term_id: i32,
        term_offset: i32,
        receiver_window: i32,
        flags: u8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_receive_channel_endpoint_send_nak(
        endpoint: *mut aeron_receive_channel_endpoint_t,
        destination: *mut aeron_receive_destination_t,
        addr: *mut sockaddr_storage,
        stream_id: i32,
        session_id: i32,
        term_id: i32,
        term_offset: i32,
        length: i32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_receive_channel_endpoint_send_rttm(
        endpoint: *mut aeron_receive_channel_endpoint_t,
        destination: *mut aeron_receive_destination_t,
        addr: *mut sockaddr_storage,
        stream_id: i32,
        session_id: i32,
        echo_timestamp: i64,
        reception_delta: i64,
        is_reply: bool,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_receive_channel_endpoint_dispatch(
        data_paths: *mut aeron_udp_channel_data_paths_t,
        transport: *mut aeron_udp_channel_transport_t,
        receiver_clientd: *mut ::std::os::raw::c_void,
        endpoint_clientd: *mut ::std::os::raw::c_void,
        destination_clientd: *mut ::std::os::raw::c_void,
        buffer: *mut u8,
        length: usize,
        addr: *mut sockaddr_storage,
        media_receive_timestamp: *mut timespec,
    );
}
extern "C" {
    pub fn aeron_receive_channel_endpoint_on_data(
        endpoint: *mut aeron_receive_channel_endpoint_t,
        destination: *mut aeron_receive_destination_t,
        buffer: *mut u8,
        length: usize,
        addr: *mut sockaddr_storage,
        media_receive_timestamp: *mut timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_receive_channel_endpoint_on_setup(
        endpoint: *mut aeron_receive_channel_endpoint_t,
        destination: *mut aeron_receive_destination_t,
        buffer: *mut u8,
        length: usize,
        addr: *mut sockaddr_storage,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_receive_channel_endpoint_on_rttm(
        endpoint: *mut aeron_receive_channel_endpoint_t,
        destination: *mut aeron_receive_destination_t,
        buffer: *mut u8,
        length: usize,
        addr: *mut sockaddr_storage,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_receive_channel_endpoint_try_remove_endpoint(
        endpoint: *mut aeron_receive_channel_endpoint_t,
    );
}
extern "C" {
    pub fn aeron_receive_channel_endpoint_incref_to_stream(
        endpoint: *mut aeron_receive_channel_endpoint_t,
        stream_id: i32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_receive_channel_endpoint_decref_to_stream(
        endpoint: *mut aeron_receive_channel_endpoint_t,
        stream_id: i32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_receive_channel_endpoint_incref_to_stream_and_session(
        endpoint: *mut aeron_receive_channel_endpoint_t,
        stream_id: i32,
        session_id: i32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_receive_channel_endpoint_decref_to_stream_and_session(
        endpoint: *mut aeron_receive_channel_endpoint_t,
        stream_id: i32,
        session_id: i32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_receive_channel_endpoint_on_add_subscription(
        endpoint: *mut aeron_receive_channel_endpoint_t,
        stream_id: i32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_receive_channel_endpoint_on_remove_subscription(
        endpoint: *mut aeron_receive_channel_endpoint_t,
        stream_id: i32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_receive_channel_endpoint_on_add_subscription_by_session(
        endpoint: *mut aeron_receive_channel_endpoint_t,
        stream_id: i32,
        session_id: i32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_receive_channel_endpoint_on_remove_subscription_by_session(
        endpoint: *mut aeron_receive_channel_endpoint_t,
        stream_id: i32,
        session_id: i32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_receive_channel_endpoint_add_destination(
        endpoint: *mut aeron_receive_channel_endpoint_t,
        destination: *mut aeron_receive_destination_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_receive_channel_endpoint_remove_destination(
        endpoint: *mut aeron_receive_channel_endpoint_t,
        channel: *mut aeron_udp_channel_t,
        destination_out: *mut *mut aeron_receive_destination_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_receive_channel_endpoint_on_add_publication_image(
        endpoint: *mut aeron_receive_channel_endpoint_t,
        image: *mut aeron_publication_image_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_receive_channel_endpoint_on_remove_publication_image(
        endpoint: *mut aeron_receive_channel_endpoint_t,
        image: *mut aeron_publication_image_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_receiver_channel_endpoint_validate_sender_mtu_length(
        endpoint: *mut aeron_receive_channel_endpoint_t,
        sender_mtu_length: usize,
        window_max_length: usize,
        ctx: *mut aeron_driver_context_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_receive_channel_endpoint_check_for_re_resolution(
        endpoint: *mut aeron_receive_channel_endpoint_t,
        now_ns: i64,
        conductor_proxy: *mut aeron_driver_conductor_proxy_t,
    );
}
extern "C" {
    pub fn aeron_receive_channel_endpoint_update_control_address(
        endpoint: *mut aeron_receive_channel_endpoint_t,
        destination: *mut aeron_receive_destination_t,
        address: *mut sockaddr_storage,
    );
}
extern "C" {
    pub fn aeron_receive_channel_endpoint_add_poll_transports(
        endpoint: *mut aeron_receive_channel_endpoint_t,
        poller: *mut aeron_udp_transport_poller_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_receive_channel_endpoint_remove_poll_transports(
        endpoint: *mut aeron_receive_channel_endpoint_t,
        poller: *mut aeron_udp_transport_poller_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_receive_channel_endpoint_add_pending_setup(
        endpoint: *mut aeron_receive_channel_endpoint_t,
        receiver: *mut aeron_driver_receiver_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_receive_channel_endpoint_add_pending_setup_destination(
        endpoint: *mut aeron_receive_channel_endpoint_t,
        receiver: *mut aeron_driver_receiver_t,
        destination: *mut aeron_receive_destination_t,
    ) -> ::std::os::raw::c_int;
}
pub type aeron_term_gap_scanner_on_gap_detected_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        clientd: *mut ::std::os::raw::c_void,
        term_id: i32,
        term_offset: i32,
        length: usize,
    ),
>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aeron_loss_detector_gap_stct {
    pub term_id: i32,
    pub term_offset: i32,
    pub length: usize,
}
#[test]
fn bindgen_test_layout_aeron_loss_detector_gap_stct() {
    const UNINIT: ::std::mem::MaybeUninit<aeron_loss_detector_gap_stct> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_loss_detector_gap_stct>(),
        16usize,
        concat!("Size of: ", stringify!(aeron_loss_detector_gap_stct))
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_loss_detector_gap_stct>(),
        8usize,
        concat!("Alignment of ", stringify!(aeron_loss_detector_gap_stct))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).term_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_loss_detector_gap_stct),
            "::",
            stringify!(term_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).term_offset) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_loss_detector_gap_stct),
            "::",
            stringify!(term_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_loss_detector_gap_stct),
            "::",
            stringify!(length)
        )
    );
}
pub type aeron_loss_detector_gap_t = aeron_loss_detector_gap_stct;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aeron_loss_detector_stct {
    pub on_gap_detected: aeron_term_gap_scanner_on_gap_detected_func_t,
    pub feedback_delay_state: *mut aeron_feedback_delay_generator_state_t,
    pub on_gap_detected_clientd: *mut ::std::os::raw::c_void,
    pub scanned_gap: aeron_loss_detector_gap_t,
    pub active_gap: aeron_loss_detector_gap_t,
    pub expiry_ns: i64,
}
#[test]
fn bindgen_test_layout_aeron_loss_detector_stct() {
    const UNINIT: ::std::mem::MaybeUninit<aeron_loss_detector_stct> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_loss_detector_stct>(),
        64usize,
        concat!("Size of: ", stringify!(aeron_loss_detector_stct))
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_loss_detector_stct>(),
        8usize,
        concat!("Alignment of ", stringify!(aeron_loss_detector_stct))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).on_gap_detected) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_loss_detector_stct),
            "::",
            stringify!(on_gap_detected)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).feedback_delay_state) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_loss_detector_stct),
            "::",
            stringify!(feedback_delay_state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).on_gap_detected_clientd) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_loss_detector_stct),
            "::",
            stringify!(on_gap_detected_clientd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).scanned_gap) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_loss_detector_stct),
            "::",
            stringify!(scanned_gap)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).active_gap) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_loss_detector_stct),
            "::",
            stringify!(active_gap)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).expiry_ns) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_loss_detector_stct),
            "::",
            stringify!(expiry_ns)
        )
    );
}
pub type aeron_loss_detector_t = aeron_loss_detector_stct;
extern "C" {
    pub fn aeron_loss_detector_init(
        detector: *mut aeron_loss_detector_t,
        feedback_delay_state: *mut aeron_feedback_delay_generator_state_t,
        on_gap_detected: aeron_term_gap_scanner_on_gap_detected_func_t,
        on_gap_detected_clientd: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_loss_detector_scan(
        detector: *mut aeron_loss_detector_t,
        loss_found: *mut bool,
        buffer: *const u8,
        rebuild_position: i64,
        hwm_position: i64,
        now_ns: i64,
        term_length_mask: usize,
        position_bits_to_shift: usize,
        initial_term_id: i32,
    ) -> i32;
}
extern "C" {
    pub fn aeron_feedback_delay_state_init(
        state: *mut aeron_feedback_delay_generator_state_t,
        delay_generator: aeron_feedback_delay_generator_func_t,
        delay_ns: i64,
        multicast_group_size: usize,
        should_immediate_feedback: bool,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_loss_detector_nak_multicast_delay_generator(
        state: *mut aeron_feedback_delay_generator_state_t,
    ) -> i64;
}
#[repr(C, packed(4))]
#[derive(Copy, Clone)]
pub struct aeron_loss_reporter_entry_stct {
    pub observation_count: i64,
    pub total_bytes_lost: i64,
    pub first_observation_timestamp: i64,
    pub last_observation_timestamp: i64,
    pub session_id: i32,
    pub stream_id: i32,
}
#[test]
fn bindgen_test_layout_aeron_loss_reporter_entry_stct() {
    const UNINIT: ::std::mem::MaybeUninit<aeron_loss_reporter_entry_stct> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_loss_reporter_entry_stct>(),
        40usize,
        concat!("Size of: ", stringify!(aeron_loss_reporter_entry_stct))
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_loss_reporter_entry_stct>(),
        4usize,
        concat!("Alignment of ", stringify!(aeron_loss_reporter_entry_stct))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).observation_count) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_loss_reporter_entry_stct),
            "::",
            stringify!(observation_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).total_bytes_lost) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_loss_reporter_entry_stct),
            "::",
            stringify!(total_bytes_lost)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).first_observation_timestamp) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_loss_reporter_entry_stct),
            "::",
            stringify!(first_observation_timestamp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).last_observation_timestamp) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_loss_reporter_entry_stct),
            "::",
            stringify!(last_observation_timestamp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).session_id) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_loss_reporter_entry_stct),
            "::",
            stringify!(session_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stream_id) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_loss_reporter_entry_stct),
            "::",
            stringify!(stream_id)
        )
    );
}
pub type aeron_loss_reporter_entry_t = aeron_loss_reporter_entry_stct;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aeron_loss_reporter_stct {
    pub buffer: *mut u8,
    pub next_record_offset: usize,
    pub capacity: usize,
}
#[test]
fn bindgen_test_layout_aeron_loss_reporter_stct() {
    const UNINIT: ::std::mem::MaybeUninit<aeron_loss_reporter_stct> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_loss_reporter_stct>(),
        24usize,
        concat!("Size of: ", stringify!(aeron_loss_reporter_stct))
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_loss_reporter_stct>(),
        8usize,
        concat!("Alignment of ", stringify!(aeron_loss_reporter_stct))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buffer) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_loss_reporter_stct),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next_record_offset) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_loss_reporter_stct),
            "::",
            stringify!(next_record_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).capacity) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_loss_reporter_stct),
            "::",
            stringify!(capacity)
        )
    );
}
pub type aeron_loss_reporter_t = aeron_loss_reporter_stct;
pub type aeron_loss_reporter_entry_offset_t = i64;
extern "C" {
    pub fn aeron_loss_reporter_init(
        reporter: *mut aeron_loss_reporter_t,
        buffer: *mut u8,
        length: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_loss_reporter_create_entry(
        reporter: *mut aeron_loss_reporter_t,
        initial_bytes_lost: i64,
        timestamp_ms: i64,
        session_id: i32,
        stream_id: i32,
        channel: *const ::std::os::raw::c_char,
        channel_length: usize,
        source: *const ::std::os::raw::c_char,
        source_length: usize,
    ) -> aeron_loss_reporter_entry_offset_t;
}
extern "C" {
    pub fn aeron_loss_reporter_resolve_filename(
        directory: *const ::std::os::raw::c_char,
        filename_buffer: *mut ::std::os::raw::c_char,
        filename_buffer_length: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_loss_reporter_read(
        buffer: *const u8,
        capacity: usize,
        entry_func: aeron_loss_reporter_read_entry_func_t,
        clientd: *mut ::std::os::raw::c_void,
    ) -> usize;
}
pub mod aeron_publication_image_state_enum {
    pub type Type = ::std::os::raw::c_uint;
    pub const AERON_PUBLICATION_IMAGE_STATE_ACTIVE: Type = 0;
    pub const AERON_PUBLICATION_IMAGE_STATE_DRAINING: Type = 1;
    pub const AERON_PUBLICATION_IMAGE_STATE_LINGER: Type = 2;
    pub const AERON_PUBLICATION_IMAGE_STATE_DONE: Type = 3;
}
pub use self::aeron_publication_image_state_enum::Type as aeron_publication_image_state_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aeron_publication_image_connection_stct {
    pub padding_before: [u8; 64usize],
    pub resolved_control_address_for_implicit_unicast_channels: sockaddr_storage,
    pub destination: *mut aeron_receive_destination_t,
    pub control_addr: *mut sockaddr_storage,
    pub is_eos: bool,
    pub time_of_last_activity_ns: i64,
    pub time_of_last_frame_ns: i64,
    pub padding_after: [u8; 64usize],
}
#[test]
fn bindgen_test_layout_aeron_publication_image_connection_stct() {
    const UNINIT: ::std::mem::MaybeUninit<aeron_publication_image_connection_stct> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_publication_image_connection_stct>(),
        296usize,
        concat!(
            "Size of: ",
            stringify!(aeron_publication_image_connection_stct)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_publication_image_connection_stct>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(aeron_publication_image_connection_stct)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).padding_before) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_publication_image_connection_stct),
            "::",
            stringify!(padding_before)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).resolved_control_address_for_implicit_unicast_channels)
                as usize
                - ptr as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_publication_image_connection_stct),
            "::",
            stringify!(resolved_control_address_for_implicit_unicast_channels)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).destination) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_publication_image_connection_stct),
            "::",
            stringify!(destination)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).control_addr) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_publication_image_connection_stct),
            "::",
            stringify!(control_addr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).is_eos) as usize - ptr as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_publication_image_connection_stct),
            "::",
            stringify!(is_eos)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).time_of_last_activity_ns) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_publication_image_connection_stct),
            "::",
            stringify!(time_of_last_activity_ns)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).time_of_last_frame_ns) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_publication_image_connection_stct),
            "::",
            stringify!(time_of_last_frame_ns)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).padding_after) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_publication_image_connection_stct),
            "::",
            stringify!(padding_after)
        )
    );
}
pub type aeron_publication_image_connection_t = aeron_publication_image_connection_stct;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aeron_publication_image_stct {
    pub padding_before: [u8; 64usize],
    pub conductor_fields:
        aeron_publication_image_stct_aeron_publication_image_conductor_fields_stct,
    pub padding_after: [u8; 64usize],
    pub connections: aeron_publication_image_stct_image_connection_entries,
    pub source_address: sockaddr_storage,
    pub source_identity_length: usize,
    pub source_identity: [::std::os::raw::c_char; 54usize],
    pub loss_detector: aeron_loss_detector_t,
    pub mapped_raw_log: aeron_mapped_raw_log_t,
    pub rcv_hwm_position: aeron_position_t,
    pub rcv_pos_position: aeron_position_t,
    pub log_meta_data: *mut aeron_logbuffer_metadata_t,
    pub endpoint: *mut aeron_receive_channel_endpoint_t,
    pub congestion_control: *mut aeron_congestion_control_strategy_t,
    pub nano_clock: aeron_clock_func_t,
    pub epoch_clock: aeron_clock_func_t,
    pub cached_clock: *mut aeron_clock_cache_t,
    pub loss_reporter: *mut aeron_loss_reporter_t,
    pub loss_reporter_offset: aeron_loss_reporter_entry_offset_t,
    pub log_file_name: *mut ::std::os::raw::c_char,
    pub session_id: i32,
    pub stream_id: i32,
    pub initial_term_id: i32,
    pub active_term_id: i32,
    pub term_length: i32,
    pub mtu_length: i32,
    pub term_length_mask: i32,
    pub log_file_name_length: usize,
    pub position_bits_to_shift: usize,
    pub raw_log_close_func: aeron_raw_log_close_func_t,
    pub raw_log_free_func: aeron_raw_log_free_func_t,
    pub untethered_subscription_state_change_func:
        aeron_untethered_subscription_state_change_func_t,
    pub last_loss_change_number: i64,
    pub begin_loss_change: i64,
    pub end_loss_change: i64,
    pub loss_term_id: i32,
    pub loss_term_offset: i32,
    pub loss_length: usize,
    pub begin_sm_change: i64,
    pub end_sm_change: i64,
    pub last_overrun_threshold: i64,
    pub next_sm_position: i64,
    pub next_sm_receiver_window_length: i32,
    pub max_receiver_window_length: i32,
    pub last_sm_change_number: i64,
    pub last_sm_position: i64,
    pub time_of_last_sm_ns: i64,
    pub sm_timeout_ns: i64,
    pub time_of_last_packet_ns: i64,
    pub is_end_of_stream: bool,
    pub is_sending_eos_sm: bool,
    pub has_receiver_released: bool,
    pub heartbeats_received_counter: *mut i64,
    pub flow_control_under_runs_counter: *mut i64,
    pub flow_control_over_runs_counter: *mut i64,
    pub status_messages_sent_counter: *mut i64,
    pub nak_messages_sent_counter: *mut i64,
    pub loss_gap_fills_counter: *mut i64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aeron_publication_image_stct_aeron_publication_image_conductor_fields_stct {
    pub is_reliable: bool,
    pub state: aeron_publication_image_state_t,
    pub managed_resource: aeron_driver_managed_resource_t,
    pub subscribable: aeron_subscribable_t,
    pub time_of_last_state_change_ns: i64,
    pub liveness_timeout_ns: i64,
    pub clean_position: i64,
    pub endpoint: *mut aeron_receive_channel_endpoint_t,
}
#[test]
fn bindgen_test_layout_aeron_publication_image_stct_aeron_publication_image_conductor_fields_stct()
{
    const UNINIT: ::std::mem::MaybeUninit<
        aeron_publication_image_stct_aeron_publication_image_conductor_fields_stct,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<
            aeron_publication_image_stct_aeron_publication_image_conductor_fields_stct,
        >(),
        136usize,
        concat!(
            "Size of: ",
            stringify!(aeron_publication_image_stct_aeron_publication_image_conductor_fields_stct)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<
            aeron_publication_image_stct_aeron_publication_image_conductor_fields_stct,
        >(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(aeron_publication_image_stct_aeron_publication_image_conductor_fields_stct)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).is_reliable) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_publication_image_stct_aeron_publication_image_conductor_fields_stct),
            "::",
            stringify!(is_reliable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_publication_image_stct_aeron_publication_image_conductor_fields_stct),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).managed_resource) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_publication_image_stct_aeron_publication_image_conductor_fields_stct),
            "::",
            stringify!(managed_resource)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).subscribable) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_publication_image_stct_aeron_publication_image_conductor_fields_stct),
            "::",
            stringify!(subscribable)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).time_of_last_state_change_ns) as usize - ptr as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_publication_image_stct_aeron_publication_image_conductor_fields_stct),
            "::",
            stringify!(time_of_last_state_change_ns)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).liveness_timeout_ns) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_publication_image_stct_aeron_publication_image_conductor_fields_stct),
            "::",
            stringify!(liveness_timeout_ns)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).clean_position) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_publication_image_stct_aeron_publication_image_conductor_fields_stct),
            "::",
            stringify!(clean_position)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).endpoint) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_publication_image_stct_aeron_publication_image_conductor_fields_stct),
            "::",
            stringify!(endpoint)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aeron_publication_image_stct_image_connection_entries {
    pub length: usize,
    pub capacity: usize,
    pub array: *mut aeron_publication_image_connection_t,
}
#[test]
fn bindgen_test_layout_aeron_publication_image_stct_image_connection_entries() {
    const UNINIT: ::std::mem::MaybeUninit<aeron_publication_image_stct_image_connection_entries> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_publication_image_stct_image_connection_entries>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(aeron_publication_image_stct_image_connection_entries)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_publication_image_stct_image_connection_entries>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(aeron_publication_image_stct_image_connection_entries)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_publication_image_stct_image_connection_entries),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).capacity) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_publication_image_stct_image_connection_entries),
            "::",
            stringify!(capacity)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).array) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_publication_image_stct_image_connection_entries),
            "::",
            stringify!(array)
        )
    );
}
#[test]
fn bindgen_test_layout_aeron_publication_image_stct() {
    const UNINIT: ::std::mem::MaybeUninit<aeron_publication_image_stct> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_publication_image_stct>(),
        984usize,
        concat!("Size of: ", stringify!(aeron_publication_image_stct))
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_publication_image_stct>(),
        8usize,
        concat!("Alignment of ", stringify!(aeron_publication_image_stct))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).padding_before) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_publication_image_stct),
            "::",
            stringify!(padding_before)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).conductor_fields) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_publication_image_stct),
            "::",
            stringify!(conductor_fields)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).padding_after) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_publication_image_stct),
            "::",
            stringify!(padding_after)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).connections) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_publication_image_stct),
            "::",
            stringify!(connections)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).source_address) as usize - ptr as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_publication_image_stct),
            "::",
            stringify!(source_address)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).source_identity_length) as usize - ptr as usize },
        416usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_publication_image_stct),
            "::",
            stringify!(source_identity_length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).source_identity) as usize - ptr as usize },
        424usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_publication_image_stct),
            "::",
            stringify!(source_identity)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).loss_detector) as usize - ptr as usize },
        480usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_publication_image_stct),
            "::",
            stringify!(loss_detector)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mapped_raw_log) as usize - ptr as usize },
        544usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_publication_image_stct),
            "::",
            stringify!(mapped_raw_log)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rcv_hwm_position) as usize - ptr as usize },
        632usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_publication_image_stct),
            "::",
            stringify!(rcv_hwm_position)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rcv_pos_position) as usize - ptr as usize },
        648usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_publication_image_stct),
            "::",
            stringify!(rcv_pos_position)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).log_meta_data) as usize - ptr as usize },
        664usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_publication_image_stct),
            "::",
            stringify!(log_meta_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).endpoint) as usize - ptr as usize },
        672usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_publication_image_stct),
            "::",
            stringify!(endpoint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).congestion_control) as usize - ptr as usize },
        680usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_publication_image_stct),
            "::",
            stringify!(congestion_control)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nano_clock) as usize - ptr as usize },
        688usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_publication_image_stct),
            "::",
            stringify!(nano_clock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).epoch_clock) as usize - ptr as usize },
        696usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_publication_image_stct),
            "::",
            stringify!(epoch_clock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cached_clock) as usize - ptr as usize },
        704usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_publication_image_stct),
            "::",
            stringify!(cached_clock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).loss_reporter) as usize - ptr as usize },
        712usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_publication_image_stct),
            "::",
            stringify!(loss_reporter)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).loss_reporter_offset) as usize - ptr as usize },
        720usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_publication_image_stct),
            "::",
            stringify!(loss_reporter_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).log_file_name) as usize - ptr as usize },
        728usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_publication_image_stct),
            "::",
            stringify!(log_file_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).session_id) as usize - ptr as usize },
        736usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_publication_image_stct),
            "::",
            stringify!(session_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stream_id) as usize - ptr as usize },
        740usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_publication_image_stct),
            "::",
            stringify!(stream_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).initial_term_id) as usize - ptr as usize },
        744usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_publication_image_stct),
            "::",
            stringify!(initial_term_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).active_term_id) as usize - ptr as usize },
        748usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_publication_image_stct),
            "::",
            stringify!(active_term_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).term_length) as usize - ptr as usize },
        752usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_publication_image_stct),
            "::",
            stringify!(term_length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mtu_length) as usize - ptr as usize },
        756usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_publication_image_stct),
            "::",
            stringify!(mtu_length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).term_length_mask) as usize - ptr as usize },
        760usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_publication_image_stct),
            "::",
            stringify!(term_length_mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).log_file_name_length) as usize - ptr as usize },
        768usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_publication_image_stct),
            "::",
            stringify!(log_file_name_length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).position_bits_to_shift) as usize - ptr as usize },
        776usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_publication_image_stct),
            "::",
            stringify!(position_bits_to_shift)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).raw_log_close_func) as usize - ptr as usize },
        784usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_publication_image_stct),
            "::",
            stringify!(raw_log_close_func)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).raw_log_free_func) as usize - ptr as usize },
        792usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_publication_image_stct),
            "::",
            stringify!(raw_log_free_func)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).untethered_subscription_state_change_func) as usize
                - ptr as usize
        },
        800usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_publication_image_stct),
            "::",
            stringify!(untethered_subscription_state_change_func)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).last_loss_change_number) as usize - ptr as usize },
        808usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_publication_image_stct),
            "::",
            stringify!(last_loss_change_number)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).begin_loss_change) as usize - ptr as usize },
        816usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_publication_image_stct),
            "::",
            stringify!(begin_loss_change)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).end_loss_change) as usize - ptr as usize },
        824usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_publication_image_stct),
            "::",
            stringify!(end_loss_change)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).loss_term_id) as usize - ptr as usize },
        832usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_publication_image_stct),
            "::",
            stringify!(loss_term_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).loss_term_offset) as usize - ptr as usize },
        836usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_publication_image_stct),
            "::",
            stringify!(loss_term_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).loss_length) as usize - ptr as usize },
        840usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_publication_image_stct),
            "::",
            stringify!(loss_length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).begin_sm_change) as usize - ptr as usize },
        848usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_publication_image_stct),
            "::",
            stringify!(begin_sm_change)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).end_sm_change) as usize - ptr as usize },
        856usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_publication_image_stct),
            "::",
            stringify!(end_sm_change)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).last_overrun_threshold) as usize - ptr as usize },
        864usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_publication_image_stct),
            "::",
            stringify!(last_overrun_threshold)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next_sm_position) as usize - ptr as usize },
        872usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_publication_image_stct),
            "::",
            stringify!(next_sm_position)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).next_sm_receiver_window_length) as usize - ptr as usize
        },
        880usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_publication_image_stct),
            "::",
            stringify!(next_sm_receiver_window_length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_receiver_window_length) as usize - ptr as usize },
        884usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_publication_image_stct),
            "::",
            stringify!(max_receiver_window_length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).last_sm_change_number) as usize - ptr as usize },
        888usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_publication_image_stct),
            "::",
            stringify!(last_sm_change_number)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).last_sm_position) as usize - ptr as usize },
        896usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_publication_image_stct),
            "::",
            stringify!(last_sm_position)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).time_of_last_sm_ns) as usize - ptr as usize },
        904usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_publication_image_stct),
            "::",
            stringify!(time_of_last_sm_ns)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sm_timeout_ns) as usize - ptr as usize },
        912usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_publication_image_stct),
            "::",
            stringify!(sm_timeout_ns)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).time_of_last_packet_ns) as usize - ptr as usize },
        920usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_publication_image_stct),
            "::",
            stringify!(time_of_last_packet_ns)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).is_end_of_stream) as usize - ptr as usize },
        928usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_publication_image_stct),
            "::",
            stringify!(is_end_of_stream)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).is_sending_eos_sm) as usize - ptr as usize },
        929usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_publication_image_stct),
            "::",
            stringify!(is_sending_eos_sm)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_receiver_released) as usize - ptr as usize },
        930usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_publication_image_stct),
            "::",
            stringify!(has_receiver_released)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).heartbeats_received_counter) as usize - ptr as usize },
        936usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_publication_image_stct),
            "::",
            stringify!(heartbeats_received_counter)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).flow_control_under_runs_counter) as usize - ptr as usize
        },
        944usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_publication_image_stct),
            "::",
            stringify!(flow_control_under_runs_counter)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).flow_control_over_runs_counter) as usize - ptr as usize
        },
        952usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_publication_image_stct),
            "::",
            stringify!(flow_control_over_runs_counter)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).status_messages_sent_counter) as usize - ptr as usize
        },
        960usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_publication_image_stct),
            "::",
            stringify!(status_messages_sent_counter)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nak_messages_sent_counter) as usize - ptr as usize },
        968usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_publication_image_stct),
            "::",
            stringify!(nak_messages_sent_counter)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).loss_gap_fills_counter) as usize - ptr as usize },
        976usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_publication_image_stct),
            "::",
            stringify!(loss_gap_fills_counter)
        )
    );
}
extern "C" {
    pub fn aeron_publication_image_create(
        image: *mut *mut aeron_publication_image_t,
        endpoint: *mut aeron_receive_channel_endpoint_t,
        destination: *mut aeron_receive_destination_t,
        context: *mut aeron_driver_context_t,
        correlation_id: i64,
        session_id: i32,
        stream_id: i32,
        initial_term_id: i32,
        active_term_id: i32,
        initial_term_offset: i32,
        rcv_hwm_position: *mut aeron_position_t,
        rcv_pos_position: *mut aeron_position_t,
        congestion_control: *mut aeron_congestion_control_strategy_t,
        control_address: *mut sockaddr_storage,
        source_address: *mut sockaddr_storage,
        term_buffer_length: i32,
        sender_mtu_length: i32,
        loss_reporter: *mut aeron_loss_reporter_t,
        is_reliable: bool,
        is_sparse: bool,
        treat_as_multicast: bool,
        system_counters: *mut aeron_system_counters_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_publication_image_close(
        counters_manager: *mut aeron_counters_manager_t,
        image: *mut aeron_publication_image_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_publication_image_free(image: *mut aeron_publication_image_t) -> bool;
}
extern "C" {
    pub fn aeron_publication_image_clean_buffer_to(
        image: *mut aeron_publication_image_t,
        position: i64,
    );
}
extern "C" {
    pub fn aeron_publication_image_on_gap_detected(
        clientd: *mut ::std::os::raw::c_void,
        term_id: i32,
        term_offset: i32,
        length: usize,
    );
}
extern "C" {
    pub fn aeron_publication_image_track_rebuild(
        image: *mut aeron_publication_image_t,
        now_ns: i64,
    );
}
extern "C" {
    pub fn aeron_publication_image_insert_packet(
        image: *mut aeron_publication_image_t,
        destination: *mut aeron_receive_destination_t,
        term_id: i32,
        term_offset: i32,
        buffer: *const u8,
        length: usize,
        addr: *mut sockaddr_storage,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_publication_image_on_rttm(
        image: *mut aeron_publication_image_t,
        header: *mut aeron_rttm_header_t,
        addr: *mut sockaddr_storage,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_publication_image_send_pending_status_message(
        image: *mut aeron_publication_image_t,
        now_ns: i64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_publication_image_send_pending_loss(
        image: *mut aeron_publication_image_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_publication_image_initiate_rttm(
        image: *mut aeron_publication_image_t,
        now_ns: i64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_publication_image_add_destination(
        image: *mut aeron_publication_image_t,
        destination: *mut aeron_receive_destination_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_publication_image_remove_destination(
        image: *mut aeron_publication_image_t,
        channel: *mut aeron_udp_channel_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_publication_image_add_connection_if_unknown(
        image: *mut aeron_publication_image_t,
        destination: *mut aeron_receive_destination_t,
        src_addr: *mut sockaddr_storage,
    );
}
extern "C" {
    pub fn aeron_publication_image_on_time_event(
        conductor: *mut aeron_driver_conductor_t,
        image: *mut aeron_publication_image_t,
        now_ns: i64,
        now_ms: i64,
    );
}
extern "C" {
    pub fn aeron_publication_image_receiver_release(image: *mut aeron_publication_image_t);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aeron_deque_stct {
    pub data: *mut u8,
    pub element_count: usize,
    pub element_size: usize,
    pub first_element: usize,
    pub last_element: usize,
}
#[test]
fn bindgen_test_layout_aeron_deque_stct() {
    const UNINIT: ::std::mem::MaybeUninit<aeron_deque_stct> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_deque_stct>(),
        40usize,
        concat!("Size of: ", stringify!(aeron_deque_stct))
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_deque_stct>(),
        8usize,
        concat!("Alignment of ", stringify!(aeron_deque_stct))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_deque_stct),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).element_count) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_deque_stct),
            "::",
            stringify!(element_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).element_size) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_deque_stct),
            "::",
            stringify!(element_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).first_element) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_deque_stct),
            "::",
            stringify!(first_element)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).last_element) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_deque_stct),
            "::",
            stringify!(last_element)
        )
    );
}
pub type aeron_deque_t = aeron_deque_stct;
extern "C" {
    pub fn aeron_deque_init(
        deque: *mut aeron_deque_t,
        initial_element_count: usize,
        element_size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_deque_close(deque: *mut aeron_deque_t);
}
extern "C" {
    #[doc = " Add value into the deque as the last element.  Will memcpy into the deque from the void pointer provided using\n the specified element size.  May need to allocate in order to increase the size of the dequeue.\n\n Errors:\n   ENOMEM if growing the array fails.\n\n @param deque to add the value too.\n @param value value to be added.\n @return 0 on success, -1 on failure."]
    pub fn aeron_deque_add_last(
        deque: *mut aeron_deque_t,
        value: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_deque_remove_first(
        deque: *mut aeron_deque_t,
        value: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aeron_publication_link_stct {
    pub resource: *mut aeron_driver_managed_resource_t,
    pub registration_id: i64,
}
#[test]
fn bindgen_test_layout_aeron_publication_link_stct() {
    const UNINIT: ::std::mem::MaybeUninit<aeron_publication_link_stct> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_publication_link_stct>(),
        16usize,
        concat!("Size of: ", stringify!(aeron_publication_link_stct))
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_publication_link_stct>(),
        8usize,
        concat!("Alignment of ", stringify!(aeron_publication_link_stct))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).resource) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_publication_link_stct),
            "::",
            stringify!(resource)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).registration_id) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_publication_link_stct),
            "::",
            stringify!(registration_id)
        )
    );
}
pub type aeron_publication_link_t = aeron_publication_link_stct;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aeron_counter_link_stct {
    pub counter_id: i32,
    pub registration_id: i64,
}
#[test]
fn bindgen_test_layout_aeron_counter_link_stct() {
    const UNINIT: ::std::mem::MaybeUninit<aeron_counter_link_stct> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_counter_link_stct>(),
        16usize,
        concat!("Size of: ", stringify!(aeron_counter_link_stct))
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_counter_link_stct>(),
        8usize,
        concat!("Alignment of ", stringify!(aeron_counter_link_stct))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).counter_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_counter_link_stct),
            "::",
            stringify!(counter_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).registration_id) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_counter_link_stct),
            "::",
            stringify!(registration_id)
        )
    );
}
pub type aeron_counter_link_t = aeron_counter_link_stct;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aeron_client_stct {
    pub reached_end_of_life: bool,
    pub closed_by_command: bool,
    pub client_id: i64,
    pub client_liveness_timeout_ms: i64,
    pub heartbeat_timestamp: aeron_atomic_counter_t,
    pub publication_links: aeron_client_stct_publication_link_stct,
    pub counter_links: aeron_client_stct_counter_link_stct,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aeron_client_stct_publication_link_stct {
    pub length: usize,
    pub capacity: usize,
    pub array: *mut aeron_publication_link_t,
}
#[test]
fn bindgen_test_layout_aeron_client_stct_publication_link_stct() {
    const UNINIT: ::std::mem::MaybeUninit<aeron_client_stct_publication_link_stct> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_client_stct_publication_link_stct>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(aeron_client_stct_publication_link_stct)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_client_stct_publication_link_stct>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(aeron_client_stct_publication_link_stct)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_client_stct_publication_link_stct),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).capacity) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_client_stct_publication_link_stct),
            "::",
            stringify!(capacity)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).array) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_client_stct_publication_link_stct),
            "::",
            stringify!(array)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aeron_client_stct_counter_link_stct {
    pub length: usize,
    pub capacity: usize,
    pub array: *mut aeron_counter_link_t,
}
#[test]
fn bindgen_test_layout_aeron_client_stct_counter_link_stct() {
    const UNINIT: ::std::mem::MaybeUninit<aeron_client_stct_counter_link_stct> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_client_stct_counter_link_stct>(),
        24usize,
        concat!("Size of: ", stringify!(aeron_client_stct_counter_link_stct))
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_client_stct_counter_link_stct>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(aeron_client_stct_counter_link_stct)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_client_stct_counter_link_stct),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).capacity) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_client_stct_counter_link_stct),
            "::",
            stringify!(capacity)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).array) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_client_stct_counter_link_stct),
            "::",
            stringify!(array)
        )
    );
}
#[test]
fn bindgen_test_layout_aeron_client_stct() {
    const UNINIT: ::std::mem::MaybeUninit<aeron_client_stct> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_client_stct>(),
        88usize,
        concat!("Size of: ", stringify!(aeron_client_stct))
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_client_stct>(),
        8usize,
        concat!("Alignment of ", stringify!(aeron_client_stct))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reached_end_of_life) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_client_stct),
            "::",
            stringify!(reached_end_of_life)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).closed_by_command) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_client_stct),
            "::",
            stringify!(closed_by_command)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).client_id) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_client_stct),
            "::",
            stringify!(client_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).client_liveness_timeout_ms) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_client_stct),
            "::",
            stringify!(client_liveness_timeout_ms)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).heartbeat_timestamp) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_client_stct),
            "::",
            stringify!(heartbeat_timestamp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).publication_links) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_client_stct),
            "::",
            stringify!(publication_links)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).counter_links) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_client_stct),
            "::",
            stringify!(counter_links)
        )
    );
}
pub type aeron_client_t = aeron_client_stct;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aeron_subscribable_list_entry_stct {
    pub counter_id: i32,
    pub subscribable: *mut aeron_subscribable_t,
}
#[test]
fn bindgen_test_layout_aeron_subscribable_list_entry_stct() {
    const UNINIT: ::std::mem::MaybeUninit<aeron_subscribable_list_entry_stct> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_subscribable_list_entry_stct>(),
        16usize,
        concat!("Size of: ", stringify!(aeron_subscribable_list_entry_stct))
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_subscribable_list_entry_stct>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(aeron_subscribable_list_entry_stct)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).counter_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_subscribable_list_entry_stct),
            "::",
            stringify!(counter_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).subscribable) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_subscribable_list_entry_stct),
            "::",
            stringify!(subscribable)
        )
    );
}
pub type aeron_subscribable_list_entry_t = aeron_subscribable_list_entry_stct;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aeron_subscription_link_stct {
    pub channel: [::std::os::raw::c_char; 384usize],
    pub is_tether: bool,
    pub is_sparse: bool,
    pub is_reliable: bool,
    pub is_rejoin: bool,
    pub has_session_id: bool,
    pub group: aeron_inferable_boolean_t,
    pub stream_id: i32,
    pub session_id: i32,
    pub channel_length: i32,
    pub registration_id: i64,
    pub client_id: i64,
    pub endpoint: *mut aeron_receive_channel_endpoint_t,
    pub spy_channel: *mut aeron_udp_channel_t,
    pub subscribable_list: aeron_subscription_link_stct_subscribable_list_stct,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aeron_subscription_link_stct_subscribable_list_stct {
    pub length: usize,
    pub capacity: usize,
    pub array: *mut aeron_subscribable_list_entry_t,
}
#[test]
fn bindgen_test_layout_aeron_subscription_link_stct_subscribable_list_stct() {
    const UNINIT: ::std::mem::MaybeUninit<aeron_subscription_link_stct_subscribable_list_stct> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_subscription_link_stct_subscribable_list_stct>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(aeron_subscription_link_stct_subscribable_list_stct)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_subscription_link_stct_subscribable_list_stct>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(aeron_subscription_link_stct_subscribable_list_stct)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_subscription_link_stct_subscribable_list_stct),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).capacity) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_subscription_link_stct_subscribable_list_stct),
            "::",
            stringify!(capacity)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).array) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_subscription_link_stct_subscribable_list_stct),
            "::",
            stringify!(array)
        )
    );
}
#[test]
fn bindgen_test_layout_aeron_subscription_link_stct() {
    const UNINIT: ::std::mem::MaybeUninit<aeron_subscription_link_stct> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_subscription_link_stct>(),
        464usize,
        concat!("Size of: ", stringify!(aeron_subscription_link_stct))
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_subscription_link_stct>(),
        8usize,
        concat!("Alignment of ", stringify!(aeron_subscription_link_stct))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).channel) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_subscription_link_stct),
            "::",
            stringify!(channel)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).is_tether) as usize - ptr as usize },
        384usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_subscription_link_stct),
            "::",
            stringify!(is_tether)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).is_sparse) as usize - ptr as usize },
        385usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_subscription_link_stct),
            "::",
            stringify!(is_sparse)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).is_reliable) as usize - ptr as usize },
        386usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_subscription_link_stct),
            "::",
            stringify!(is_reliable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).is_rejoin) as usize - ptr as usize },
        387usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_subscription_link_stct),
            "::",
            stringify!(is_rejoin)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_session_id) as usize - ptr as usize },
        388usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_subscription_link_stct),
            "::",
            stringify!(has_session_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).group) as usize - ptr as usize },
        392usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_subscription_link_stct),
            "::",
            stringify!(group)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stream_id) as usize - ptr as usize },
        396usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_subscription_link_stct),
            "::",
            stringify!(stream_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).session_id) as usize - ptr as usize },
        400usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_subscription_link_stct),
            "::",
            stringify!(session_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).channel_length) as usize - ptr as usize },
        404usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_subscription_link_stct),
            "::",
            stringify!(channel_length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).registration_id) as usize - ptr as usize },
        408usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_subscription_link_stct),
            "::",
            stringify!(registration_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).client_id) as usize - ptr as usize },
        416usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_subscription_link_stct),
            "::",
            stringify!(client_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).endpoint) as usize - ptr as usize },
        424usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_subscription_link_stct),
            "::",
            stringify!(endpoint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).spy_channel) as usize - ptr as usize },
        432usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_subscription_link_stct),
            "::",
            stringify!(spy_channel)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).subscribable_list) as usize - ptr as usize },
        440usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_subscription_link_stct),
            "::",
            stringify!(subscribable_list)
        )
    );
}
pub type aeron_subscription_link_t = aeron_subscription_link_stct;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aeron_ipc_publication_entry_stct {
    pub publication: *mut aeron_ipc_publication_t,
}
#[test]
fn bindgen_test_layout_aeron_ipc_publication_entry_stct() {
    const UNINIT: ::std::mem::MaybeUninit<aeron_ipc_publication_entry_stct> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_ipc_publication_entry_stct>(),
        8usize,
        concat!("Size of: ", stringify!(aeron_ipc_publication_entry_stct))
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_ipc_publication_entry_stct>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(aeron_ipc_publication_entry_stct)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).publication) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_ipc_publication_entry_stct),
            "::",
            stringify!(publication)
        )
    );
}
pub type aeron_ipc_publication_entry_t = aeron_ipc_publication_entry_stct;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aeron_network_publication_entry_stct {
    pub publication: *mut aeron_network_publication_t,
}
#[test]
fn bindgen_test_layout_aeron_network_publication_entry_stct() {
    const UNINIT: ::std::mem::MaybeUninit<aeron_network_publication_entry_stct> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_network_publication_entry_stct>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(aeron_network_publication_entry_stct)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_network_publication_entry_stct>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(aeron_network_publication_entry_stct)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).publication) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_network_publication_entry_stct),
            "::",
            stringify!(publication)
        )
    );
}
pub type aeron_network_publication_entry_t = aeron_network_publication_entry_stct;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aeron_send_channel_endpoint_entry_stct {
    pub endpoint: *mut aeron_send_channel_endpoint_t,
}
#[test]
fn bindgen_test_layout_aeron_send_channel_endpoint_entry_stct() {
    const UNINIT: ::std::mem::MaybeUninit<aeron_send_channel_endpoint_entry_stct> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_send_channel_endpoint_entry_stct>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(aeron_send_channel_endpoint_entry_stct)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_send_channel_endpoint_entry_stct>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(aeron_send_channel_endpoint_entry_stct)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).endpoint) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_send_channel_endpoint_entry_stct),
            "::",
            stringify!(endpoint)
        )
    );
}
pub type aeron_send_channel_endpoint_entry_t = aeron_send_channel_endpoint_entry_stct;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aeron_receive_channel_endpoint_entry_stct {
    pub endpoint: *mut aeron_receive_channel_endpoint_t,
}
#[test]
fn bindgen_test_layout_aeron_receive_channel_endpoint_entry_stct() {
    const UNINIT: ::std::mem::MaybeUninit<aeron_receive_channel_endpoint_entry_stct> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_receive_channel_endpoint_entry_stct>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(aeron_receive_channel_endpoint_entry_stct)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_receive_channel_endpoint_entry_stct>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(aeron_receive_channel_endpoint_entry_stct)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).endpoint) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_receive_channel_endpoint_entry_stct),
            "::",
            stringify!(endpoint)
        )
    );
}
pub type aeron_receive_channel_endpoint_entry_t = aeron_receive_channel_endpoint_entry_stct;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aeron_publication_image_entry_stct {
    pub image: *mut aeron_publication_image_t,
}
#[test]
fn bindgen_test_layout_aeron_publication_image_entry_stct() {
    const UNINIT: ::std::mem::MaybeUninit<aeron_publication_image_entry_stct> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_publication_image_entry_stct>(),
        8usize,
        concat!("Size of: ", stringify!(aeron_publication_image_entry_stct))
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_publication_image_entry_stct>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(aeron_publication_image_entry_stct)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).image) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_publication_image_entry_stct),
            "::",
            stringify!(image)
        )
    );
}
pub type aeron_publication_image_entry_t = aeron_publication_image_entry_stct;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aeron_linger_resource_entry_stct {
    pub has_reached_end_of_life: bool,
    pub buffer: *mut u8,
    pub timeout_ns: i64,
}
#[test]
fn bindgen_test_layout_aeron_linger_resource_entry_stct() {
    const UNINIT: ::std::mem::MaybeUninit<aeron_linger_resource_entry_stct> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_linger_resource_entry_stct>(),
        24usize,
        concat!("Size of: ", stringify!(aeron_linger_resource_entry_stct))
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_linger_resource_entry_stct>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(aeron_linger_resource_entry_stct)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_reached_end_of_life) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_linger_resource_entry_stct),
            "::",
            stringify!(has_reached_end_of_life)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buffer) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_linger_resource_entry_stct),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timeout_ns) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_linger_resource_entry_stct),
            "::",
            stringify!(timeout_ns)
        )
    );
}
pub type aeron_linger_resource_entry_t = aeron_linger_resource_entry_stct;
pub type aeron_end_of_life_resource_free_t =
    ::std::option::Option<unsafe extern "C" fn(resource: *mut ::std::os::raw::c_void) -> bool>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aeron_end_of_life_resource_stct {
    pub resource: *mut ::std::os::raw::c_void,
    pub free_func: aeron_end_of_life_resource_free_t,
}
#[test]
fn bindgen_test_layout_aeron_end_of_life_resource_stct() {
    const UNINIT: ::std::mem::MaybeUninit<aeron_end_of_life_resource_stct> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_end_of_life_resource_stct>(),
        16usize,
        concat!("Size of: ", stringify!(aeron_end_of_life_resource_stct))
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_end_of_life_resource_stct>(),
        8usize,
        concat!("Alignment of ", stringify!(aeron_end_of_life_resource_stct))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).resource) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_end_of_life_resource_stct),
            "::",
            stringify!(resource)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).free_func) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_end_of_life_resource_stct),
            "::",
            stringify!(free_func)
        )
    );
}
pub type aeron_end_of_life_resource_t = aeron_end_of_life_resource_stct;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aeron_driver_conductor_stct {
    pub context: *mut aeron_driver_context_t,
    pub to_driver_commands: aeron_mpsc_rb_t,
    pub to_clients: aeron_broadcast_transmitter_t,
    pub error_log: aeron_distinct_error_log_t,
    pub counters_manager: aeron_counters_manager_t,
    pub system_counters: aeron_system_counters_t,
    pub conductor_proxy: aeron_driver_conductor_proxy_t,
    pub loss_reporter: aeron_loss_reporter_t,
    pub name_resolver: aeron_name_resolver_t,
    pub send_channel_endpoint_by_channel_map: aeron_str_to_ptr_hash_map_t,
    pub receive_channel_endpoint_by_channel_map: aeron_str_to_ptr_hash_map_t,
    pub clients: aeron_driver_conductor_stct_client_stct,
    pub ipc_subscriptions: aeron_driver_conductor_stct_ipc_subscriptions_stct,
    pub ipc_publications: aeron_driver_conductor_stct_ipc_publication_stct,
    pub network_subscriptions: aeron_driver_conductor_stct_network_subscriptions_stct,
    pub spy_subscriptions: aeron_driver_conductor_stct_spy_subscriptions_stct,
    pub network_publications: aeron_driver_conductor_stct_network_publication_stct,
    pub send_channel_endpoints: aeron_driver_conductor_stct_send_channel_endpoint_stct,
    pub receive_channel_endpoints: aeron_driver_conductor_stct_receive_channel_endpoint_stct,
    pub publication_images: aeron_driver_conductor_stct_publication_image_stct,
    pub lingering_resources:
        aeron_driver_conductor_stct_aeron_driver_conductor_lingering_resources_stct,
    pub end_of_life_queue: aeron_deque_t,
    pub errors_counter: *mut i64,
    pub unblocked_commands_counter: *mut i64,
    pub client_timeouts_counter: *mut i64,
    pub clock_update_deadline_ns: i64,
    pub next_session_id: i32,
    pub publication_reserved_session_id_low: i32,
    pub publication_reserved_session_id_high: i32,
    pub timeout_check_deadline_ns: i64,
    pub time_of_last_to_driver_position_change_ns: i64,
    pub last_command_consumer_position: i64,
    pub padding: [u8; 64usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aeron_driver_conductor_stct_client_stct {
    pub length: usize,
    pub capacity: usize,
    pub array: *mut aeron_client_t,
    pub on_time_event: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut aeron_driver_conductor_t,
            arg2: *mut aeron_client_t,
            arg3: i64,
            arg4: i64,
        ),
    >,
    pub has_reached_end_of_life: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut aeron_driver_conductor_t,
            arg2: *mut aeron_client_t,
        ) -> bool,
    >,
    pub delete_func: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut aeron_driver_conductor_t, arg2: *mut aeron_client_t),
    >,
    pub free_func: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut aeron_driver_conductor_t, arg2: *mut aeron_client_t),
    >,
}
#[test]
fn bindgen_test_layout_aeron_driver_conductor_stct_client_stct() {
    const UNINIT: ::std::mem::MaybeUninit<aeron_driver_conductor_stct_client_stct> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_driver_conductor_stct_client_stct>(),
        56usize,
        concat!(
            "Size of: ",
            stringify!(aeron_driver_conductor_stct_client_stct)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_driver_conductor_stct_client_stct>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(aeron_driver_conductor_stct_client_stct)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_conductor_stct_client_stct),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).capacity) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_conductor_stct_client_stct),
            "::",
            stringify!(capacity)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).array) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_conductor_stct_client_stct),
            "::",
            stringify!(array)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).on_time_event) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_conductor_stct_client_stct),
            "::",
            stringify!(on_time_event)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_reached_end_of_life) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_conductor_stct_client_stct),
            "::",
            stringify!(has_reached_end_of_life)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).delete_func) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_conductor_stct_client_stct),
            "::",
            stringify!(delete_func)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).free_func) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_conductor_stct_client_stct),
            "::",
            stringify!(free_func)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aeron_driver_conductor_stct_ipc_subscriptions_stct {
    pub length: usize,
    pub capacity: usize,
    pub array: *mut aeron_subscription_link_t,
}
#[test]
fn bindgen_test_layout_aeron_driver_conductor_stct_ipc_subscriptions_stct() {
    const UNINIT: ::std::mem::MaybeUninit<aeron_driver_conductor_stct_ipc_subscriptions_stct> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_driver_conductor_stct_ipc_subscriptions_stct>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(aeron_driver_conductor_stct_ipc_subscriptions_stct)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_driver_conductor_stct_ipc_subscriptions_stct>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(aeron_driver_conductor_stct_ipc_subscriptions_stct)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_conductor_stct_ipc_subscriptions_stct),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).capacity) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_conductor_stct_ipc_subscriptions_stct),
            "::",
            stringify!(capacity)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).array) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_conductor_stct_ipc_subscriptions_stct),
            "::",
            stringify!(array)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aeron_driver_conductor_stct_ipc_publication_stct {
    pub length: usize,
    pub capacity: usize,
    pub array: *mut aeron_ipc_publication_entry_t,
    pub on_time_event: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut aeron_driver_conductor_t,
            arg2: *mut aeron_ipc_publication_entry_t,
            arg3: i64,
            arg4: i64,
        ),
    >,
    pub has_reached_end_of_life: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut aeron_driver_conductor_t,
            arg2: *mut aeron_ipc_publication_entry_t,
        ) -> bool,
    >,
    pub delete_func: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut aeron_driver_conductor_t,
            arg2: *mut aeron_ipc_publication_entry_t,
        ),
    >,
    pub free_func: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut aeron_driver_conductor_t,
            arg2: *mut aeron_ipc_publication_entry_t,
        ),
    >,
}
#[test]
fn bindgen_test_layout_aeron_driver_conductor_stct_ipc_publication_stct() {
    const UNINIT: ::std::mem::MaybeUninit<aeron_driver_conductor_stct_ipc_publication_stct> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_driver_conductor_stct_ipc_publication_stct>(),
        56usize,
        concat!(
            "Size of: ",
            stringify!(aeron_driver_conductor_stct_ipc_publication_stct)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_driver_conductor_stct_ipc_publication_stct>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(aeron_driver_conductor_stct_ipc_publication_stct)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_conductor_stct_ipc_publication_stct),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).capacity) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_conductor_stct_ipc_publication_stct),
            "::",
            stringify!(capacity)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).array) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_conductor_stct_ipc_publication_stct),
            "::",
            stringify!(array)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).on_time_event) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_conductor_stct_ipc_publication_stct),
            "::",
            stringify!(on_time_event)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_reached_end_of_life) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_conductor_stct_ipc_publication_stct),
            "::",
            stringify!(has_reached_end_of_life)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).delete_func) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_conductor_stct_ipc_publication_stct),
            "::",
            stringify!(delete_func)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).free_func) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_conductor_stct_ipc_publication_stct),
            "::",
            stringify!(free_func)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aeron_driver_conductor_stct_network_subscriptions_stct {
    pub length: usize,
    pub capacity: usize,
    pub array: *mut aeron_subscription_link_t,
}
#[test]
fn bindgen_test_layout_aeron_driver_conductor_stct_network_subscriptions_stct() {
    const UNINIT: ::std::mem::MaybeUninit<aeron_driver_conductor_stct_network_subscriptions_stct> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_driver_conductor_stct_network_subscriptions_stct>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(aeron_driver_conductor_stct_network_subscriptions_stct)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_driver_conductor_stct_network_subscriptions_stct>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(aeron_driver_conductor_stct_network_subscriptions_stct)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_conductor_stct_network_subscriptions_stct),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).capacity) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_conductor_stct_network_subscriptions_stct),
            "::",
            stringify!(capacity)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).array) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_conductor_stct_network_subscriptions_stct),
            "::",
            stringify!(array)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aeron_driver_conductor_stct_spy_subscriptions_stct {
    pub length: usize,
    pub capacity: usize,
    pub array: *mut aeron_subscription_link_t,
}
#[test]
fn bindgen_test_layout_aeron_driver_conductor_stct_spy_subscriptions_stct() {
    const UNINIT: ::std::mem::MaybeUninit<aeron_driver_conductor_stct_spy_subscriptions_stct> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_driver_conductor_stct_spy_subscriptions_stct>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(aeron_driver_conductor_stct_spy_subscriptions_stct)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_driver_conductor_stct_spy_subscriptions_stct>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(aeron_driver_conductor_stct_spy_subscriptions_stct)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_conductor_stct_spy_subscriptions_stct),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).capacity) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_conductor_stct_spy_subscriptions_stct),
            "::",
            stringify!(capacity)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).array) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_conductor_stct_spy_subscriptions_stct),
            "::",
            stringify!(array)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aeron_driver_conductor_stct_network_publication_stct {
    pub length: usize,
    pub capacity: usize,
    pub array: *mut aeron_network_publication_entry_t,
    pub on_time_event: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut aeron_driver_conductor_t,
            arg2: *mut aeron_network_publication_entry_t,
            arg3: i64,
            arg4: i64,
        ),
    >,
    pub has_reached_end_of_life: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut aeron_driver_conductor_t,
            arg2: *mut aeron_network_publication_entry_t,
        ) -> bool,
    >,
    pub delete_func: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut aeron_driver_conductor_t,
            arg2: *mut aeron_network_publication_entry_t,
        ),
    >,
    pub free_func: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut aeron_driver_conductor_t,
            arg2: *mut aeron_network_publication_entry_t,
        ),
    >,
}
#[test]
fn bindgen_test_layout_aeron_driver_conductor_stct_network_publication_stct() {
    const UNINIT: ::std::mem::MaybeUninit<aeron_driver_conductor_stct_network_publication_stct> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_driver_conductor_stct_network_publication_stct>(),
        56usize,
        concat!(
            "Size of: ",
            stringify!(aeron_driver_conductor_stct_network_publication_stct)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_driver_conductor_stct_network_publication_stct>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(aeron_driver_conductor_stct_network_publication_stct)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_conductor_stct_network_publication_stct),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).capacity) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_conductor_stct_network_publication_stct),
            "::",
            stringify!(capacity)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).array) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_conductor_stct_network_publication_stct),
            "::",
            stringify!(array)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).on_time_event) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_conductor_stct_network_publication_stct),
            "::",
            stringify!(on_time_event)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_reached_end_of_life) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_conductor_stct_network_publication_stct),
            "::",
            stringify!(has_reached_end_of_life)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).delete_func) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_conductor_stct_network_publication_stct),
            "::",
            stringify!(delete_func)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).free_func) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_conductor_stct_network_publication_stct),
            "::",
            stringify!(free_func)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aeron_driver_conductor_stct_send_channel_endpoint_stct {
    pub array: *mut aeron_send_channel_endpoint_entry_t,
    pub length: usize,
    pub capacity: usize,
    pub on_time_event: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut aeron_driver_conductor_t,
            arg2: *mut aeron_send_channel_endpoint_entry_t,
            arg3: i64,
            arg4: i64,
        ),
    >,
    pub has_reached_end_of_life: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut aeron_driver_conductor_t,
            arg2: *mut aeron_send_channel_endpoint_entry_t,
        ) -> bool,
    >,
    pub delete_func: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut aeron_driver_conductor_t,
            arg2: *mut aeron_send_channel_endpoint_entry_t,
        ),
    >,
    pub free_func: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut aeron_driver_conductor_t,
            arg2: *mut aeron_send_channel_endpoint_entry_t,
        ),
    >,
}
#[test]
fn bindgen_test_layout_aeron_driver_conductor_stct_send_channel_endpoint_stct() {
    const UNINIT: ::std::mem::MaybeUninit<aeron_driver_conductor_stct_send_channel_endpoint_stct> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_driver_conductor_stct_send_channel_endpoint_stct>(),
        56usize,
        concat!(
            "Size of: ",
            stringify!(aeron_driver_conductor_stct_send_channel_endpoint_stct)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_driver_conductor_stct_send_channel_endpoint_stct>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(aeron_driver_conductor_stct_send_channel_endpoint_stct)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).array) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_conductor_stct_send_channel_endpoint_stct),
            "::",
            stringify!(array)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_conductor_stct_send_channel_endpoint_stct),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).capacity) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_conductor_stct_send_channel_endpoint_stct),
            "::",
            stringify!(capacity)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).on_time_event) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_conductor_stct_send_channel_endpoint_stct),
            "::",
            stringify!(on_time_event)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_reached_end_of_life) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_conductor_stct_send_channel_endpoint_stct),
            "::",
            stringify!(has_reached_end_of_life)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).delete_func) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_conductor_stct_send_channel_endpoint_stct),
            "::",
            stringify!(delete_func)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).free_func) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_conductor_stct_send_channel_endpoint_stct),
            "::",
            stringify!(free_func)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aeron_driver_conductor_stct_receive_channel_endpoint_stct {
    pub length: usize,
    pub capacity: usize,
    pub array: *mut aeron_receive_channel_endpoint_entry_t,
    pub on_time_event: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut aeron_driver_conductor_t,
            arg2: *mut aeron_receive_channel_endpoint_entry_t,
            arg3: i64,
            arg4: i64,
        ),
    >,
    pub has_reached_end_of_life: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut aeron_driver_conductor_t,
            arg2: *mut aeron_receive_channel_endpoint_entry_t,
        ) -> bool,
    >,
    pub delete_func: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut aeron_driver_conductor_t,
            arg2: *mut aeron_receive_channel_endpoint_entry_t,
        ),
    >,
    pub free_func: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut aeron_driver_conductor_t,
            arg2: *mut aeron_receive_channel_endpoint_entry_t,
        ),
    >,
}
#[test]
fn bindgen_test_layout_aeron_driver_conductor_stct_receive_channel_endpoint_stct() {
    const UNINIT: ::std::mem::MaybeUninit<
        aeron_driver_conductor_stct_receive_channel_endpoint_stct,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_driver_conductor_stct_receive_channel_endpoint_stct>(),
        56usize,
        concat!(
            "Size of: ",
            stringify!(aeron_driver_conductor_stct_receive_channel_endpoint_stct)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_driver_conductor_stct_receive_channel_endpoint_stct>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(aeron_driver_conductor_stct_receive_channel_endpoint_stct)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_conductor_stct_receive_channel_endpoint_stct),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).capacity) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_conductor_stct_receive_channel_endpoint_stct),
            "::",
            stringify!(capacity)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).array) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_conductor_stct_receive_channel_endpoint_stct),
            "::",
            stringify!(array)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).on_time_event) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_conductor_stct_receive_channel_endpoint_stct),
            "::",
            stringify!(on_time_event)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_reached_end_of_life) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_conductor_stct_receive_channel_endpoint_stct),
            "::",
            stringify!(has_reached_end_of_life)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).delete_func) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_conductor_stct_receive_channel_endpoint_stct),
            "::",
            stringify!(delete_func)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).free_func) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_conductor_stct_receive_channel_endpoint_stct),
            "::",
            stringify!(free_func)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aeron_driver_conductor_stct_publication_image_stct {
    pub length: usize,
    pub capacity: usize,
    pub array: *mut aeron_publication_image_entry_t,
    pub on_time_event: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut aeron_driver_conductor_t,
            arg2: *mut aeron_publication_image_entry_t,
            arg3: i64,
            arg4: i64,
        ),
    >,
    pub has_reached_end_of_life: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut aeron_driver_conductor_t,
            arg2: *mut aeron_publication_image_entry_t,
        ) -> bool,
    >,
    pub delete_func: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut aeron_driver_conductor_t,
            arg2: *mut aeron_publication_image_entry_t,
        ),
    >,
    pub free_func: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut aeron_driver_conductor_t,
            arg2: *mut aeron_publication_image_entry_t,
        ),
    >,
}
#[test]
fn bindgen_test_layout_aeron_driver_conductor_stct_publication_image_stct() {
    const UNINIT: ::std::mem::MaybeUninit<aeron_driver_conductor_stct_publication_image_stct> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_driver_conductor_stct_publication_image_stct>(),
        56usize,
        concat!(
            "Size of: ",
            stringify!(aeron_driver_conductor_stct_publication_image_stct)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_driver_conductor_stct_publication_image_stct>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(aeron_driver_conductor_stct_publication_image_stct)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_conductor_stct_publication_image_stct),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).capacity) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_conductor_stct_publication_image_stct),
            "::",
            stringify!(capacity)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).array) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_conductor_stct_publication_image_stct),
            "::",
            stringify!(array)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).on_time_event) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_conductor_stct_publication_image_stct),
            "::",
            stringify!(on_time_event)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_reached_end_of_life) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_conductor_stct_publication_image_stct),
            "::",
            stringify!(has_reached_end_of_life)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).delete_func) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_conductor_stct_publication_image_stct),
            "::",
            stringify!(delete_func)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).free_func) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_conductor_stct_publication_image_stct),
            "::",
            stringify!(free_func)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aeron_driver_conductor_stct_aeron_driver_conductor_lingering_resources_stct {
    pub length: usize,
    pub capacity: usize,
    pub array: *mut aeron_linger_resource_entry_t,
    pub on_time_event: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut aeron_driver_conductor_t,
            arg2: *mut aeron_linger_resource_entry_t,
            arg3: i64,
            arg4: i64,
        ),
    >,
    pub has_reached_end_of_life: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut aeron_driver_conductor_t,
            arg2: *mut aeron_linger_resource_entry_t,
        ) -> bool,
    >,
    pub delete_func: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut aeron_driver_conductor_t,
            arg2: *mut aeron_linger_resource_entry_t,
        ),
    >,
    pub free_func: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut aeron_driver_conductor_t,
            arg2: *mut aeron_linger_resource_entry_t,
        ),
    >,
}
#[test]
fn bindgen_test_layout_aeron_driver_conductor_stct_aeron_driver_conductor_lingering_resources_stct()
{
    const UNINIT: ::std::mem::MaybeUninit<
        aeron_driver_conductor_stct_aeron_driver_conductor_lingering_resources_stct,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<
            aeron_driver_conductor_stct_aeron_driver_conductor_lingering_resources_stct,
        >(),
        56usize,
        concat!(
            "Size of: ",
            stringify!(aeron_driver_conductor_stct_aeron_driver_conductor_lingering_resources_stct)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<
            aeron_driver_conductor_stct_aeron_driver_conductor_lingering_resources_stct,
        >(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(aeron_driver_conductor_stct_aeron_driver_conductor_lingering_resources_stct)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_conductor_stct_aeron_driver_conductor_lingering_resources_stct),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).capacity) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_conductor_stct_aeron_driver_conductor_lingering_resources_stct),
            "::",
            stringify!(capacity)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).array) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_conductor_stct_aeron_driver_conductor_lingering_resources_stct),
            "::",
            stringify!(array)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).on_time_event) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_conductor_stct_aeron_driver_conductor_lingering_resources_stct),
            "::",
            stringify!(on_time_event)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_reached_end_of_life) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_conductor_stct_aeron_driver_conductor_lingering_resources_stct),
            "::",
            stringify!(has_reached_end_of_life)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).delete_func) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_conductor_stct_aeron_driver_conductor_lingering_resources_stct),
            "::",
            stringify!(delete_func)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).free_func) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_conductor_stct_aeron_driver_conductor_lingering_resources_stct),
            "::",
            stringify!(free_func)
        )
    );
}
#[test]
fn bindgen_test_layout_aeron_driver_conductor_stct() {
    const UNINIT: ::std::mem::MaybeUninit<aeron_driver_conductor_stct> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_driver_conductor_stct>(),
        1088usize,
        concat!("Size of: ", stringify!(aeron_driver_conductor_stct))
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_driver_conductor_stct>(),
        8usize,
        concat!("Alignment of ", stringify!(aeron_driver_conductor_stct))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).context) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_conductor_stct),
            "::",
            stringify!(context)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).to_driver_commands) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_conductor_stct),
            "::",
            stringify!(to_driver_commands)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).to_clients) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_conductor_stct),
            "::",
            stringify!(to_clients)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).error_log) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_conductor_stct),
            "::",
            stringify!(error_log)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).counters_manager) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_conductor_stct),
            "::",
            stringify!(counters_manager)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).system_counters) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_conductor_stct),
            "::",
            stringify!(system_counters)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).conductor_proxy) as usize - ptr as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_conductor_stct),
            "::",
            stringify!(conductor_proxy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).loss_reporter) as usize - ptr as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_conductor_stct),
            "::",
            stringify!(loss_reporter)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name_resolver) as usize - ptr as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_conductor_stct),
            "::",
            stringify!(name_resolver)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).send_channel_endpoint_by_channel_map) as usize
                - ptr as usize
        },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_conductor_stct),
            "::",
            stringify!(send_channel_endpoint_by_channel_map)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).receive_channel_endpoint_by_channel_map) as usize
                - ptr as usize
        },
        400usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_conductor_stct),
            "::",
            stringify!(receive_channel_endpoint_by_channel_map)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).clients) as usize - ptr as usize },
        448usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_conductor_stct),
            "::",
            stringify!(clients)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ipc_subscriptions) as usize - ptr as usize },
        504usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_conductor_stct),
            "::",
            stringify!(ipc_subscriptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ipc_publications) as usize - ptr as usize },
        528usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_conductor_stct),
            "::",
            stringify!(ipc_publications)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).network_subscriptions) as usize - ptr as usize },
        584usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_conductor_stct),
            "::",
            stringify!(network_subscriptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).spy_subscriptions) as usize - ptr as usize },
        608usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_conductor_stct),
            "::",
            stringify!(spy_subscriptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).network_publications) as usize - ptr as usize },
        632usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_conductor_stct),
            "::",
            stringify!(network_publications)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).send_channel_endpoints) as usize - ptr as usize },
        688usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_conductor_stct),
            "::",
            stringify!(send_channel_endpoints)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).receive_channel_endpoints) as usize - ptr as usize },
        744usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_conductor_stct),
            "::",
            stringify!(receive_channel_endpoints)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).publication_images) as usize - ptr as usize },
        800usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_conductor_stct),
            "::",
            stringify!(publication_images)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lingering_resources) as usize - ptr as usize },
        856usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_conductor_stct),
            "::",
            stringify!(lingering_resources)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).end_of_life_queue) as usize - ptr as usize },
        912usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_conductor_stct),
            "::",
            stringify!(end_of_life_queue)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).errors_counter) as usize - ptr as usize },
        952usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_conductor_stct),
            "::",
            stringify!(errors_counter)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unblocked_commands_counter) as usize - ptr as usize },
        960usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_conductor_stct),
            "::",
            stringify!(unblocked_commands_counter)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).client_timeouts_counter) as usize - ptr as usize },
        968usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_conductor_stct),
            "::",
            stringify!(client_timeouts_counter)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).clock_update_deadline_ns) as usize - ptr as usize },
        976usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_conductor_stct),
            "::",
            stringify!(clock_update_deadline_ns)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next_session_id) as usize - ptr as usize },
        984usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_conductor_stct),
            "::",
            stringify!(next_session_id)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).publication_reserved_session_id_low) as usize - ptr as usize
        },
        988usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_conductor_stct),
            "::",
            stringify!(publication_reserved_session_id_low)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).publication_reserved_session_id_high) as usize
                - ptr as usize
        },
        992usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_conductor_stct),
            "::",
            stringify!(publication_reserved_session_id_high)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timeout_check_deadline_ns) as usize - ptr as usize },
        1000usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_conductor_stct),
            "::",
            stringify!(timeout_check_deadline_ns)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).time_of_last_to_driver_position_change_ns) as usize
                - ptr as usize
        },
        1008usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_conductor_stct),
            "::",
            stringify!(time_of_last_to_driver_position_change_ns)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).last_command_consumer_position) as usize - ptr as usize
        },
        1016usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_conductor_stct),
            "::",
            stringify!(last_command_consumer_position)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).padding) as usize - ptr as usize },
        1024usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_conductor_stct),
            "::",
            stringify!(padding)
        )
    );
}
extern "C" {
    pub fn aeron_client_on_time_event(
        conductor: *mut aeron_driver_conductor_t,
        client: *mut aeron_client_t,
        now_ns: i64,
        now_ms: i64,
    );
}
extern "C" {
    pub fn aeron_client_has_reached_end_of_life(
        conductor: *mut aeron_driver_conductor_t,
        client: *mut aeron_client_t,
    ) -> bool;
}
extern "C" {
    pub fn aeron_driver_conductor_add_end_of_life_resource(
        conductor: *mut aeron_driver_conductor_t,
        resource: *mut ::std::os::raw::c_void,
        free_func: aeron_end_of_life_resource_free_t,
    );
}
extern "C" {
    pub fn aeron_client_delete(conductor: *mut aeron_driver_conductor_t, arg1: *mut aeron_client_t);
}
extern "C" {
    pub fn aeron_client_free(arg1: *mut ::std::os::raw::c_void) -> bool;
}
extern "C" {
    pub fn aeron_ipc_publication_entry_on_time_event(
        conductor: *mut aeron_driver_conductor_t,
        entry: *mut aeron_ipc_publication_entry_t,
        now_ns: i64,
        now_ms: i64,
    );
}
extern "C" {
    pub fn aeron_ipc_publication_entry_has_reached_end_of_life(
        conductor: *mut aeron_driver_conductor_t,
        entry: *mut aeron_ipc_publication_entry_t,
    ) -> bool;
}
extern "C" {
    pub fn aeron_ipc_publication_entry_delete(
        conductor: *mut aeron_driver_conductor_t,
        arg1: *mut aeron_ipc_publication_entry_t,
    );
}
extern "C" {
    pub fn aeron_ipc_publication_entry_free(
        conductor: *mut aeron_driver_conductor_t,
        entry: *mut aeron_ipc_publication_entry_t,
    );
}
extern "C" {
    pub fn aeron_network_publication_entry_on_time_event(
        conductor: *mut aeron_driver_conductor_t,
        entry: *mut aeron_network_publication_entry_t,
        now_ns: i64,
        now_ms: i64,
    );
}
extern "C" {
    pub fn aeron_network_publication_entry_has_reached_end_of_life(
        conductor: *mut aeron_driver_conductor_t,
        entry: *mut aeron_network_publication_entry_t,
    ) -> bool;
}
extern "C" {
    pub fn aeron_network_publication_entry_delete(
        conductor: *mut aeron_driver_conductor_t,
        arg1: *mut aeron_network_publication_entry_t,
    );
}
extern "C" {
    pub fn aeron_network_publication_entry_free(
        conductor: *mut aeron_driver_conductor_t,
        entry: *mut aeron_network_publication_entry_t,
    );
}
extern "C" {
    pub fn aeron_send_channel_endpoint_entry_on_time_event(
        conductor: *mut aeron_driver_conductor_t,
        entry: *mut aeron_send_channel_endpoint_entry_t,
        now_ns: i64,
        now_ms: i64,
    );
}
extern "C" {
    pub fn aeron_send_channel_endpoint_entry_has_reached_end_of_life(
        conductor: *mut aeron_driver_conductor_t,
        entry: *mut aeron_send_channel_endpoint_entry_t,
    ) -> bool;
}
extern "C" {
    pub fn aeron_send_channel_endpoint_entry_delete(
        conductor: *mut aeron_driver_conductor_t,
        arg1: *mut aeron_send_channel_endpoint_entry_t,
    );
}
extern "C" {
    pub fn aeron_receive_channel_endpoint_entry_on_time_event(
        conductor: *mut aeron_driver_conductor_t,
        entry: *mut aeron_receive_channel_endpoint_entry_t,
        now_ns: i64,
        now_ms: i64,
    );
}
extern "C" {
    pub fn aeron_receive_channel_endpoint_entry_has_reached_end_of_life(
        conductor: *mut aeron_driver_conductor_t,
        entry: *mut aeron_receive_channel_endpoint_entry_t,
    ) -> bool;
}
extern "C" {
    pub fn aeron_receive_channel_endpoint_entry_delete(
        conductor: *mut aeron_driver_conductor_t,
        arg1: *mut aeron_receive_channel_endpoint_entry_t,
    );
}
extern "C" {
    pub fn aeron_publication_image_entry_on_time_event(
        conductor: *mut aeron_driver_conductor_t,
        entry: *mut aeron_publication_image_entry_t,
        now_ns: i64,
        now_ms: i64,
    );
}
extern "C" {
    pub fn aeron_publication_image_entry_has_reached_end_of_life(
        conductor: *mut aeron_driver_conductor_t,
        entry: *mut aeron_publication_image_entry_t,
    ) -> bool;
}
extern "C" {
    pub fn aeron_publication_image_entry_delete(
        conductor: *mut aeron_driver_conductor_t,
        arg1: *mut aeron_publication_image_entry_t,
    );
}
extern "C" {
    pub fn aeron_publication_image_entry_free(
        conductor: *mut aeron_driver_conductor_t,
        entry: *mut aeron_publication_image_entry_t,
    );
}
extern "C" {
    pub fn aeron_linger_resource_entry_on_time_event(
        conductor: *mut aeron_driver_conductor_t,
        entry: *mut aeron_linger_resource_entry_t,
        now_ns: i64,
        now_ms: i64,
    );
}
extern "C" {
    pub fn aeron_linger_resource_entry_has_reached_end_of_life(
        conductor: *mut aeron_driver_conductor_t,
        entry: *mut aeron_linger_resource_entry_t,
    ) -> bool;
}
extern "C" {
    pub fn aeron_linger_resource_entry_delete(
        conductor: *mut aeron_driver_conductor_t,
        arg1: *mut aeron_linger_resource_entry_t,
    );
}
extern "C" {
    pub fn aeron_driver_conductor_image_transition_to_linger(
        conductor: *mut aeron_driver_conductor_t,
        image: *mut aeron_publication_image_t,
    );
}
extern "C" {
    pub fn aeron_driver_conductor_init(
        conductor: *mut aeron_driver_conductor_t,
        context: *mut aeron_driver_context_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_driver_conductor_client_transmit(
        conductor: *mut aeron_driver_conductor_t,
        msg_type_id: i32,
        message: *const ::std::os::raw::c_void,
        length: usize,
    );
}
extern "C" {
    pub fn aeron_driver_conductor_on_available_image(
        conductor: *mut aeron_driver_conductor_t,
        correlation_id: i64,
        stream_id: i32,
        session_id: i32,
        log_file_name: *const ::std::os::raw::c_char,
        log_file_name_length: usize,
        subscriber_position_id: i32,
        subscriber_registration_id: i64,
        source_identity: *const ::std::os::raw::c_char,
        source_identity_length: usize,
    );
}
extern "C" {
    pub fn aeron_driver_conductor_on_unavailable_image(
        conductor: *mut aeron_driver_conductor_t,
        correlation_id: i64,
        subscription_registration_id: i64,
        stream_id: i32,
        channel: *const ::std::os::raw::c_char,
        channel_length: usize,
    );
}
extern "C" {
    pub fn aeron_driver_conductor_on_counter_ready(
        conductor: *mut aeron_driver_conductor_t,
        registration_id: i64,
        counter_id: i32,
    );
}
extern "C" {
    pub fn aeron_driver_conductor_on_unavailable_counter(
        conductor: *mut aeron_driver_conductor_t,
        registration_id: i64,
        counter_id: i32,
    );
}
extern "C" {
    pub fn aeron_driver_conductor_on_client_timeout(
        conductor: *mut aeron_driver_conductor_t,
        correlation_id: i64,
    );
}
extern "C" {
    pub fn aeron_driver_conductor_cleanup_spies(
        conductor: *mut aeron_driver_conductor_t,
        publication: *mut aeron_network_publication_t,
    );
}
extern "C" {
    pub fn aeron_driver_conductor_cleanup_network_publication(
        conductor: *mut aeron_driver_conductor_t,
        publication: *mut aeron_network_publication_t,
    );
}
extern "C" {
    pub fn aeron_driver_conductor_on_command(
        msg_type_id: i32,
        message: *const ::std::os::raw::c_void,
        length: usize,
        clientd: *mut ::std::os::raw::c_void,
    ) -> aeron_rb_read_action_t;
}
extern "C" {
    pub fn aeron_driver_conductor_do_work(
        clientd: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_driver_conductor_on_close(clientd: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn aeron_driver_conductor_link_subscribable(
        conductor: *mut aeron_driver_conductor_t,
        link: *mut aeron_subscription_link_t,
        subscribable: *mut aeron_subscribable_t,
        original_registration_id: i64,
        session_id: i32,
        stream_id: i32,
        join_position: i64,
        now_ns: i64,
        source_identity_length: usize,
        source_identity: *const ::std::os::raw::c_char,
        log_file_name_length: usize,
        log_file_name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_driver_conductor_unlink_subscribable(
        link: *mut aeron_subscription_link_t,
        subscribable: *mut aeron_subscribable_t,
    );
}
extern "C" {
    pub fn aeron_driver_conductor_unlink_all_subscribable(
        conductor: *mut aeron_driver_conductor_t,
        link: *mut aeron_subscription_link_t,
    );
}
extern "C" {
    pub fn aeron_driver_conductor_on_add_ipc_publication(
        conductor: *mut aeron_driver_conductor_t,
        command: *mut aeron_publication_command_t,
        is_exclusive: bool,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_driver_conductor_on_add_network_publication(
        conductor: *mut aeron_driver_conductor_t,
        command: *mut aeron_publication_command_t,
        is_exclusive: bool,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_driver_conductor_on_remove_publication(
        conductor: *mut aeron_driver_conductor_t,
        command: *mut aeron_remove_command_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_driver_conductor_on_add_ipc_subscription(
        conductor: *mut aeron_driver_conductor_t,
        command: *mut aeron_subscription_command_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_driver_conductor_on_add_spy_subscription(
        conductor: *mut aeron_driver_conductor_t,
        command: *mut aeron_subscription_command_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_driver_conductor_on_add_network_subscription(
        conductor: *mut aeron_driver_conductor_t,
        command: *mut aeron_subscription_command_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_driver_conductor_on_remove_subscription(
        conductor: *mut aeron_driver_conductor_t,
        command: *mut aeron_remove_command_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_driver_conductor_on_client_keepalive(
        conductor: *mut aeron_driver_conductor_t,
        client_id: i64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_driver_conductor_on_add_send_destination(
        conductor: *mut aeron_driver_conductor_t,
        command: *mut aeron_destination_command_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_driver_conductor_on_remove_send_destination(
        conductor: *mut aeron_driver_conductor_t,
        command: *mut aeron_destination_command_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_driver_conductor_on_add_receive_ipc_destination(
        conductor: *mut aeron_driver_conductor_t,
        command: *mut aeron_destination_command_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_driver_conductor_on_add_receive_spy_destination(
        conductor: *mut aeron_driver_conductor_t,
        command: *mut aeron_destination_command_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_driver_conductor_on_add_receive_network_destination(
        conductor: *mut aeron_driver_conductor_t,
        command: *mut aeron_destination_command_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_driver_conductor_on_remove_receive_ipc_destination(
        conductor: *mut aeron_driver_conductor_t,
        command: *mut aeron_destination_command_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_driver_conductor_on_remove_receive_spy_destination(
        conductor: *mut aeron_driver_conductor_t,
        command: *mut aeron_destination_command_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_driver_conductor_on_remove_receive_network_destination(
        conductor: *mut aeron_driver_conductor_t,
        command: *mut aeron_destination_command_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_driver_conductor_on_delete_receive_destination(
        clientd: *mut ::std::os::raw::c_void,
        cmd: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn aeron_driver_conductor_on_delete_send_destination(
        clientd: *mut ::std::os::raw::c_void,
        cmd: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn aeron_driver_conductor_on_add_counter(
        conductor: *mut aeron_driver_conductor_t,
        command: *mut aeron_counter_command_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_driver_conductor_on_remove_counter(
        conductor: *mut aeron_driver_conductor_t,
        command: *mut aeron_remove_command_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_driver_conductor_on_client_close(
        conductor: *mut aeron_driver_conductor_t,
        command: *mut aeron_correlated_command_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_driver_conductor_on_terminate_driver(
        conductor: *mut aeron_driver_conductor_t,
        command: *mut aeron_terminate_driver_command_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_driver_conductor_on_create_publication_image(
        clientd: *mut ::std::os::raw::c_void,
        item: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn aeron_driver_conductor_on_linger_buffer(
        clientd: *mut ::std::os::raw::c_void,
        item: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn aeron_driver_conductor_on_re_resolve_endpoint(
        clientd: *mut ::std::os::raw::c_void,
        item: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn aeron_driver_conductor_on_re_resolve_control(
        clientd: *mut ::std::os::raw::c_void,
        item: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn aeron_driver_conductor_on_receive_endpoint_removed(
        clientd: *mut ::std::os::raw::c_void,
        item: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn aeron_driver_conductor_on_release_resource(
        clientd: *mut ::std::os::raw::c_void,
        item: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn aeron_driver_conductor_find_send_channel_endpoint_by_tag(
        conductor: *mut aeron_driver_conductor_t,
        channel_tag_id: i64,
    ) -> *mut aeron_send_channel_endpoint_t;
}
extern "C" {
    pub fn aeron_driver_conductor_find_receive_channel_endpoint_by_tag(
        conductor: *mut aeron_driver_conductor_t,
        channel_tag_id: i64,
    ) -> *mut aeron_receive_channel_endpoint_t;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aeron_udp_channel_transport_entry_stct {
    pub transport: *mut aeron_udp_channel_transport_t,
}
#[test]
fn bindgen_test_layout_aeron_udp_channel_transport_entry_stct() {
    const UNINIT: ::std::mem::MaybeUninit<aeron_udp_channel_transport_entry_stct> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_udp_channel_transport_entry_stct>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(aeron_udp_channel_transport_entry_stct)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_udp_channel_transport_entry_stct>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(aeron_udp_channel_transport_entry_stct)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).transport) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_udp_channel_transport_entry_stct),
            "::",
            stringify!(transport)
        )
    );
}
pub type aeron_udp_channel_transport_entry_t = aeron_udp_channel_transport_entry_stct;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aeron_udp_transport_poller_stct {
    pub transports: aeron_udp_transport_poller_stct_aeron_udp_channel_transports_stct,
    pub fd: ::std::os::raw::c_int,
    pub bindings_clientd: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aeron_udp_transport_poller_stct_aeron_udp_channel_transports_stct {
    pub array: *mut aeron_udp_channel_transport_entry_t,
    pub length: usize,
    pub capacity: usize,
}
#[test]
fn bindgen_test_layout_aeron_udp_transport_poller_stct_aeron_udp_channel_transports_stct() {
    const UNINIT: ::std::mem::MaybeUninit<
        aeron_udp_transport_poller_stct_aeron_udp_channel_transports_stct,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_udp_transport_poller_stct_aeron_udp_channel_transports_stct>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(aeron_udp_transport_poller_stct_aeron_udp_channel_transports_stct)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_udp_transport_poller_stct_aeron_udp_channel_transports_stct>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(aeron_udp_transport_poller_stct_aeron_udp_channel_transports_stct)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).array) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_udp_transport_poller_stct_aeron_udp_channel_transports_stct),
            "::",
            stringify!(array)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_udp_transport_poller_stct_aeron_udp_channel_transports_stct),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).capacity) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_udp_transport_poller_stct_aeron_udp_channel_transports_stct),
            "::",
            stringify!(capacity)
        )
    );
}
#[test]
fn bindgen_test_layout_aeron_udp_transport_poller_stct() {
    const UNINIT: ::std::mem::MaybeUninit<aeron_udp_transport_poller_stct> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_udp_transport_poller_stct>(),
        40usize,
        concat!("Size of: ", stringify!(aeron_udp_transport_poller_stct))
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_udp_transport_poller_stct>(),
        8usize,
        concat!("Alignment of ", stringify!(aeron_udp_transport_poller_stct))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).transports) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_udp_transport_poller_stct),
            "::",
            stringify!(transports)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fd) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_udp_transport_poller_stct),
            "::",
            stringify!(fd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bindings_clientd) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_udp_transport_poller_stct),
            "::",
            stringify!(bindings_clientd)
        )
    );
}
extern "C" {
    pub fn aeron_udp_transport_poller_init(
        poller: *mut aeron_udp_transport_poller_t,
        context: *mut aeron_driver_context_t,
        affinity: aeron_udp_channel_transport_affinity_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_udp_transport_poller_close(
        poller: *mut aeron_udp_transport_poller_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_udp_transport_poller_add(
        poller: *mut aeron_udp_transport_poller_t,
        transport: *mut aeron_udp_channel_transport_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_udp_transport_poller_remove(
        poller: *mut aeron_udp_transport_poller_t,
        transport: *mut aeron_udp_channel_transport_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_udp_transport_poller_poll(
        poller: *mut aeron_udp_transport_poller_t,
        msgvec: *mut mmsghdr,
        vlen: usize,
        bytes_rcved: *mut i64,
        recv_func: aeron_udp_transport_recv_func_t,
        recvmmsg_func: aeron_udp_channel_transport_recvmmsg_func_t,
        clientd: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_udp_transport_poller_check_send_endpoint_re_resolutions(
        poller: *mut aeron_udp_transport_poller_t,
        now_ns: i64,
        conductor_proxy: *mut aeron_driver_conductor_proxy_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_udp_transport_poller_check_receive_endpoint_re_resolutions(
        poller: *mut aeron_udp_transport_poller_t,
        now_ns: i64,
        conductor_proxy: *mut aeron_driver_conductor_proxy_t,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aeron_driver_sender_network_publication_entry_stct {
    pub publication: *mut aeron_network_publication_t,
}
#[test]
fn bindgen_test_layout_aeron_driver_sender_network_publication_entry_stct() {
    const UNINIT: ::std::mem::MaybeUninit<aeron_driver_sender_network_publication_entry_stct> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_driver_sender_network_publication_entry_stct>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(aeron_driver_sender_network_publication_entry_stct)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_driver_sender_network_publication_entry_stct>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(aeron_driver_sender_network_publication_entry_stct)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).publication) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_sender_network_publication_entry_stct),
            "::",
            stringify!(publication)
        )
    );
}
pub type aeron_driver_sender_network_publication_entry_t =
    aeron_driver_sender_network_publication_entry_stct;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aeron_driver_sender_stct {
    pub sender_proxy: aeron_driver_sender_proxy_t,
    pub poller: aeron_udp_transport_poller_t,
    pub network_publications:
        aeron_driver_sender_stct_aeron_driver_sender_network_publications_stct,
    pub recv_buffers: aeron_driver_sender_stct_aeron_driver_sender_buffers_stct,
    pub data_paths: aeron_udp_channel_data_paths_t,
    pub total_bytes_sent_counter: *mut i64,
    pub errors_counter: *mut i64,
    pub invalid_frames_counter: *mut i64,
    pub status_messages_received_counter: *mut i64,
    pub nak_messages_received_counter: *mut i64,
    pub resolution_changes_counter: *mut i64,
    pub context: *mut aeron_driver_context_t,
    pub poller_poll_func: aeron_udp_transport_poller_poll_func_t,
    pub recvmmsg_func: aeron_udp_channel_transport_recvmmsg_func_t,
    pub error_log: *mut aeron_distinct_error_log_t,
    pub status_message_read_timeout_ns: i64,
    pub control_poll_timeout_ns: i64,
    pub re_resolution_deadline_ns: i64,
    pub round_robin_index: usize,
    pub duty_cycle_counter: usize,
    pub duty_cycle_ratio: usize,
    pub padding: [u8; 64usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aeron_driver_sender_stct_aeron_driver_sender_network_publications_stct {
    pub array: *mut aeron_driver_sender_network_publication_entry_t,
    pub length: usize,
    pub capacity: usize,
}
#[test]
fn bindgen_test_layout_aeron_driver_sender_stct_aeron_driver_sender_network_publications_stct() {
    const UNINIT: ::std::mem::MaybeUninit<
        aeron_driver_sender_stct_aeron_driver_sender_network_publications_stct,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_driver_sender_stct_aeron_driver_sender_network_publications_stct>(
        ),
        24usize,
        concat!(
            "Size of: ",
            stringify!(aeron_driver_sender_stct_aeron_driver_sender_network_publications_stct)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<
            aeron_driver_sender_stct_aeron_driver_sender_network_publications_stct,
        >(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(aeron_driver_sender_stct_aeron_driver_sender_network_publications_stct)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).array) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_sender_stct_aeron_driver_sender_network_publications_stct),
            "::",
            stringify!(array)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_sender_stct_aeron_driver_sender_network_publications_stct),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).capacity) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_sender_stct_aeron_driver_sender_network_publications_stct),
            "::",
            stringify!(capacity)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aeron_driver_sender_stct_aeron_driver_sender_buffers_stct {
    pub vector_capacity: usize,
    pub buffers: [*mut u8; 16usize],
    pub iov: [iovec; 16usize],
    pub addrs: [sockaddr_storage; 16usize],
}
#[test]
fn bindgen_test_layout_aeron_driver_sender_stct_aeron_driver_sender_buffers_stct() {
    const UNINIT: ::std::mem::MaybeUninit<
        aeron_driver_sender_stct_aeron_driver_sender_buffers_stct,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_driver_sender_stct_aeron_driver_sender_buffers_stct>(),
        2440usize,
        concat!(
            "Size of: ",
            stringify!(aeron_driver_sender_stct_aeron_driver_sender_buffers_stct)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_driver_sender_stct_aeron_driver_sender_buffers_stct>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(aeron_driver_sender_stct_aeron_driver_sender_buffers_stct)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vector_capacity) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_sender_stct_aeron_driver_sender_buffers_stct),
            "::",
            stringify!(vector_capacity)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buffers) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_sender_stct_aeron_driver_sender_buffers_stct),
            "::",
            stringify!(buffers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).iov) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_sender_stct_aeron_driver_sender_buffers_stct),
            "::",
            stringify!(iov)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).addrs) as usize - ptr as usize },
        392usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_sender_stct_aeron_driver_sender_buffers_stct),
            "::",
            stringify!(addrs)
        )
    );
}
#[test]
fn bindgen_test_layout_aeron_driver_sender_stct() {
    const UNINIT: ::std::mem::MaybeUninit<aeron_driver_sender_stct> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_driver_sender_stct>(),
        2776usize,
        concat!("Size of: ", stringify!(aeron_driver_sender_stct))
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_driver_sender_stct>(),
        8usize,
        concat!("Alignment of ", stringify!(aeron_driver_sender_stct))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sender_proxy) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_sender_stct),
            "::",
            stringify!(sender_proxy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).poller) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_sender_stct),
            "::",
            stringify!(poller)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).network_publications) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_sender_stct),
            "::",
            stringify!(network_publications)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).recv_buffers) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_sender_stct),
            "::",
            stringify!(recv_buffers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data_paths) as usize - ptr as usize },
        2552usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_sender_stct),
            "::",
            stringify!(data_paths)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).total_bytes_sent_counter) as usize - ptr as usize },
        2584usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_sender_stct),
            "::",
            stringify!(total_bytes_sent_counter)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).errors_counter) as usize - ptr as usize },
        2592usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_sender_stct),
            "::",
            stringify!(errors_counter)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).invalid_frames_counter) as usize - ptr as usize },
        2600usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_sender_stct),
            "::",
            stringify!(invalid_frames_counter)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).status_messages_received_counter) as usize - ptr as usize
        },
        2608usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_sender_stct),
            "::",
            stringify!(status_messages_received_counter)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).nak_messages_received_counter) as usize - ptr as usize
        },
        2616usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_sender_stct),
            "::",
            stringify!(nak_messages_received_counter)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).resolution_changes_counter) as usize - ptr as usize },
        2624usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_sender_stct),
            "::",
            stringify!(resolution_changes_counter)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).context) as usize - ptr as usize },
        2632usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_sender_stct),
            "::",
            stringify!(context)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).poller_poll_func) as usize - ptr as usize },
        2640usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_sender_stct),
            "::",
            stringify!(poller_poll_func)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).recvmmsg_func) as usize - ptr as usize },
        2648usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_sender_stct),
            "::",
            stringify!(recvmmsg_func)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).error_log) as usize - ptr as usize },
        2656usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_sender_stct),
            "::",
            stringify!(error_log)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).status_message_read_timeout_ns) as usize - ptr as usize
        },
        2664usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_sender_stct),
            "::",
            stringify!(status_message_read_timeout_ns)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).control_poll_timeout_ns) as usize - ptr as usize },
        2672usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_sender_stct),
            "::",
            stringify!(control_poll_timeout_ns)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).re_resolution_deadline_ns) as usize - ptr as usize },
        2680usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_sender_stct),
            "::",
            stringify!(re_resolution_deadline_ns)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).round_robin_index) as usize - ptr as usize },
        2688usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_sender_stct),
            "::",
            stringify!(round_robin_index)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duty_cycle_counter) as usize - ptr as usize },
        2696usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_sender_stct),
            "::",
            stringify!(duty_cycle_counter)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duty_cycle_ratio) as usize - ptr as usize },
        2704usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_sender_stct),
            "::",
            stringify!(duty_cycle_ratio)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).padding) as usize - ptr as usize },
        2712usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_sender_stct),
            "::",
            stringify!(padding)
        )
    );
}
extern "C" {
    pub fn aeron_driver_sender_init(
        sender: *mut aeron_driver_sender_t,
        context: *mut aeron_driver_context_t,
        system_counters: *mut aeron_system_counters_t,
        error_log: *mut aeron_distinct_error_log_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_driver_sender_do_work(
        clientd: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_driver_sender_on_close(clientd: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn aeron_driver_sender_on_add_endpoint(
        clientd: *mut ::std::os::raw::c_void,
        command: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn aeron_driver_sender_on_remove_endpoint(
        clientd: *mut ::std::os::raw::c_void,
        command: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn aeron_driver_sender_on_add_publication(
        clientd: *mut ::std::os::raw::c_void,
        command: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn aeron_driver_sender_on_remove_publication(
        clientd: *mut ::std::os::raw::c_void,
        command: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn aeron_driver_sender_on_add_destination(
        clientd: *mut ::std::os::raw::c_void,
        command: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn aeron_driver_sender_on_remove_destination(
        clientd: *mut ::std::os::raw::c_void,
        command: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn aeron_driver_sender_on_resolution_change(
        clientd: *mut ::std::os::raw::c_void,
        command: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn aeron_driver_sender_do_send(
        sender: *mut aeron_driver_sender_t,
        now_ns: i64,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aeron_driver_receiver_proxy_stct {
    pub receiver: *mut aeron_driver_receiver_t,
    pub threading_mode: aeron_threading_mode_t,
    pub on_add_endpoint_func: aeron_on_endpoint_change_func_t,
    pub on_remove_endpoint_func: aeron_on_endpoint_change_func_t,
    pub command_queue: *mut aeron_mpsc_rb_t,
    pub fail_counter: *mut i64,
}
#[test]
fn bindgen_test_layout_aeron_driver_receiver_proxy_stct() {
    const UNINIT: ::std::mem::MaybeUninit<aeron_driver_receiver_proxy_stct> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_driver_receiver_proxy_stct>(),
        48usize,
        concat!("Size of: ", stringify!(aeron_driver_receiver_proxy_stct))
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_driver_receiver_proxy_stct>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(aeron_driver_receiver_proxy_stct)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).receiver) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_receiver_proxy_stct),
            "::",
            stringify!(receiver)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).threading_mode) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_receiver_proxy_stct),
            "::",
            stringify!(threading_mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).on_add_endpoint_func) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_receiver_proxy_stct),
            "::",
            stringify!(on_add_endpoint_func)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).on_remove_endpoint_func) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_receiver_proxy_stct),
            "::",
            stringify!(on_remove_endpoint_func)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).command_queue) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_receiver_proxy_stct),
            "::",
            stringify!(command_queue)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fail_counter) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_receiver_proxy_stct),
            "::",
            stringify!(fail_counter)
        )
    );
}
extern "C" {
    pub fn aeron_driver_receiver_proxy_on_add_endpoint(
        receiver_proxy: *mut aeron_driver_receiver_proxy_t,
        endpoint: *mut aeron_receive_channel_endpoint_t,
    );
}
extern "C" {
    pub fn aeron_driver_receiver_proxy_on_remove_endpoint(
        receiver_proxy: *mut aeron_driver_receiver_proxy_t,
        endpoint: *mut aeron_receive_channel_endpoint_t,
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aeron_command_subscription_stct {
    pub base: aeron_command_base_t,
    pub endpoint: *mut ::std::os::raw::c_void,
    pub stream_id: i32,
    pub session_id: i32,
}
#[test]
fn bindgen_test_layout_aeron_command_subscription_stct() {
    const UNINIT: ::std::mem::MaybeUninit<aeron_command_subscription_stct> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_command_subscription_stct>(),
        32usize,
        concat!("Size of: ", stringify!(aeron_command_subscription_stct))
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_command_subscription_stct>(),
        8usize,
        concat!("Alignment of ", stringify!(aeron_command_subscription_stct))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_command_subscription_stct),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).endpoint) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_command_subscription_stct),
            "::",
            stringify!(endpoint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stream_id) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_command_subscription_stct),
            "::",
            stringify!(stream_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).session_id) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_command_subscription_stct),
            "::",
            stringify!(session_id)
        )
    );
}
pub type aeron_command_subscription_t = aeron_command_subscription_stct;
extern "C" {
    pub fn aeron_driver_receiver_proxy_on_add_subscription(
        receiver_proxy: *mut aeron_driver_receiver_proxy_t,
        endpoint: *mut aeron_receive_channel_endpoint_t,
        stream_id: i32,
    );
}
extern "C" {
    pub fn aeron_driver_receiver_proxy_on_remove_subscription(
        receiver_proxy: *mut aeron_driver_receiver_proxy_t,
        endpoint: *mut aeron_receive_channel_endpoint_t,
        stream_id: i32,
    );
}
extern "C" {
    pub fn aeron_driver_receiver_proxy_on_add_subscription_by_session(
        receiver_proxy: *mut aeron_driver_receiver_proxy_t,
        endpoint: *mut aeron_receive_channel_endpoint_t,
        stream_id: i32,
        session_id: i32,
    );
}
extern "C" {
    pub fn aeron_driver_receiver_proxy_on_remove_subscription_by_session(
        receiver_proxy: *mut aeron_driver_receiver_proxy_t,
        endpoint: *mut aeron_receive_channel_endpoint_t,
        stream_id: i32,
        session_id: i32,
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aeron_command_add_rcv_destination_stct {
    pub base: aeron_command_base_t,
    pub endpoint: *mut ::std::os::raw::c_void,
    pub destination: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_aeron_command_add_rcv_destination_stct() {
    const UNINIT: ::std::mem::MaybeUninit<aeron_command_add_rcv_destination_stct> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_command_add_rcv_destination_stct>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(aeron_command_add_rcv_destination_stct)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_command_add_rcv_destination_stct>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(aeron_command_add_rcv_destination_stct)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_command_add_rcv_destination_stct),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).endpoint) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_command_add_rcv_destination_stct),
            "::",
            stringify!(endpoint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).destination) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_command_add_rcv_destination_stct),
            "::",
            stringify!(destination)
        )
    );
}
pub type aeron_command_add_rcv_destination_t = aeron_command_add_rcv_destination_stct;
extern "C" {
    pub fn aeron_driver_receiver_proxy_on_add_destination(
        receiver_proxy: *mut aeron_driver_receiver_proxy_t,
        endpoint: *mut aeron_receive_channel_endpoint_t,
        destination: *mut aeron_receive_destination_t,
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aeron_command_remove_rcv_destination_stct {
    pub base: aeron_command_base_t,
    pub endpoint: *mut ::std::os::raw::c_void,
    pub channel: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_aeron_command_remove_rcv_destination_stct() {
    const UNINIT: ::std::mem::MaybeUninit<aeron_command_remove_rcv_destination_stct> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_command_remove_rcv_destination_stct>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(aeron_command_remove_rcv_destination_stct)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_command_remove_rcv_destination_stct>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(aeron_command_remove_rcv_destination_stct)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_command_remove_rcv_destination_stct),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).endpoint) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_command_remove_rcv_destination_stct),
            "::",
            stringify!(endpoint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).channel) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_command_remove_rcv_destination_stct),
            "::",
            stringify!(channel)
        )
    );
}
pub type aeron_command_remove_rcv_destination_t = aeron_command_remove_rcv_destination_stct;
extern "C" {
    pub fn aeron_driver_receiver_proxy_on_remove_destination(
        receiver_proxy: *mut aeron_driver_receiver_proxy_t,
        endpoint: *mut aeron_receive_channel_endpoint_t,
        channel: *mut aeron_udp_channel_t,
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aeron_command_publication_image_stct {
    pub base: aeron_command_base_t,
    pub image: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_aeron_command_publication_image_stct() {
    const UNINIT: ::std::mem::MaybeUninit<aeron_command_publication_image_stct> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_command_publication_image_stct>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(aeron_command_publication_image_stct)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_command_publication_image_stct>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(aeron_command_publication_image_stct)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_command_publication_image_stct),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).image) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_command_publication_image_stct),
            "::",
            stringify!(image)
        )
    );
}
pub type aeron_command_publication_image_t = aeron_command_publication_image_stct;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aeron_command_on_remove_matching_state_stct {
    pub base: aeron_command_base_t,
    pub endpoint: *mut ::std::os::raw::c_void,
    pub session_id: i32,
    pub stream_id: i32,
    pub state: u32,
}
#[test]
fn bindgen_test_layout_aeron_command_on_remove_matching_state_stct() {
    const UNINIT: ::std::mem::MaybeUninit<aeron_command_on_remove_matching_state_stct> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_command_on_remove_matching_state_stct>(),
        40usize,
        concat!(
            "Size of: ",
            stringify!(aeron_command_on_remove_matching_state_stct)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_command_on_remove_matching_state_stct>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(aeron_command_on_remove_matching_state_stct)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_command_on_remove_matching_state_stct),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).endpoint) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_command_on_remove_matching_state_stct),
            "::",
            stringify!(endpoint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).session_id) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_command_on_remove_matching_state_stct),
            "::",
            stringify!(session_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stream_id) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_command_on_remove_matching_state_stct),
            "::",
            stringify!(stream_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_command_on_remove_matching_state_stct),
            "::",
            stringify!(state)
        )
    );
}
pub type aeron_command_on_remove_matching_state_t = aeron_command_on_remove_matching_state_stct;
extern "C" {
    pub fn aeron_driver_receiver_proxy_on_add_publication_image(
        receiver_proxy: *mut aeron_driver_receiver_proxy_t,
        endpoint: *mut aeron_receive_channel_endpoint_t,
        image: *mut aeron_publication_image_t,
    );
}
extern "C" {
    pub fn aeron_driver_receiver_proxy_on_remove_publication_image(
        receiver_proxy: *mut aeron_driver_receiver_proxy_t,
        image: *mut aeron_publication_image_t,
    );
}
extern "C" {
    pub fn aeron_driver_receiver_proxy_on_remove_cool_down(
        receiver_proxy: *mut aeron_driver_receiver_proxy_t,
        endpoint: *mut aeron_receive_channel_endpoint_t,
        session_id: i32,
        stream_id: i32,
    );
}
extern "C" {
    pub fn aeron_driver_receiver_proxy_on_remove_init_in_progress(
        receiver_proxy: *mut aeron_driver_receiver_proxy_t,
        endpoint: *mut aeron_receive_channel_endpoint_t,
        session_id: i32,
        stream_id: i32,
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aeron_command_receiver_resolution_change_stct {
    pub base: aeron_command_base_t,
    pub endpoint_name: *const ::std::os::raw::c_char,
    pub endpoint: *mut ::std::os::raw::c_void,
    pub destination: *mut ::std::os::raw::c_void,
    pub new_addr: sockaddr_storage,
}
#[test]
fn bindgen_test_layout_aeron_command_receiver_resolution_change_stct() {
    const UNINIT: ::std::mem::MaybeUninit<aeron_command_receiver_resolution_change_stct> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_command_receiver_resolution_change_stct>(),
        168usize,
        concat!(
            "Size of: ",
            stringify!(aeron_command_receiver_resolution_change_stct)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_command_receiver_resolution_change_stct>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(aeron_command_receiver_resolution_change_stct)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_command_receiver_resolution_change_stct),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).endpoint_name) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_command_receiver_resolution_change_stct),
            "::",
            stringify!(endpoint_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).endpoint) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_command_receiver_resolution_change_stct),
            "::",
            stringify!(endpoint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).destination) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_command_receiver_resolution_change_stct),
            "::",
            stringify!(destination)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).new_addr) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_command_receiver_resolution_change_stct),
            "::",
            stringify!(new_addr)
        )
    );
}
pub type aeron_command_receiver_resolution_change_t = aeron_command_receiver_resolution_change_stct;
extern "C" {
    pub fn aeron_driver_receiver_proxy_on_resolution_change(
        receiver_proxy: *mut aeron_driver_receiver_proxy_t,
        endpoint_name: *const ::std::os::raw::c_char,
        endpoint: *mut ::std::os::raw::c_void,
        destination: *mut ::std::os::raw::c_void,
        new_addr: *mut sockaddr_storage,
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aeron_driver_receiver_image_entry_stct {
    pub image: *mut aeron_publication_image_t,
}
#[test]
fn bindgen_test_layout_aeron_driver_receiver_image_entry_stct() {
    const UNINIT: ::std::mem::MaybeUninit<aeron_driver_receiver_image_entry_stct> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_driver_receiver_image_entry_stct>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(aeron_driver_receiver_image_entry_stct)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_driver_receiver_image_entry_stct>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(aeron_driver_receiver_image_entry_stct)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).image) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_receiver_image_entry_stct),
            "::",
            stringify!(image)
        )
    );
}
pub type aeron_driver_receiver_image_entry_t = aeron_driver_receiver_image_entry_stct;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aeron_driver_receiver_pending_setup_entry_stct {
    pub is_periodic: bool,
    pub session_id: i32,
    pub stream_id: i32,
    pub endpoint: *mut aeron_receive_channel_endpoint_t,
    pub destination: *mut aeron_receive_destination_t,
    pub time_of_status_message_ns: i64,
    pub control_addr: sockaddr_storage,
}
#[test]
fn bindgen_test_layout_aeron_driver_receiver_pending_setup_entry_stct() {
    const UNINIT: ::std::mem::MaybeUninit<aeron_driver_receiver_pending_setup_entry_stct> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_driver_receiver_pending_setup_entry_stct>(),
        168usize,
        concat!(
            "Size of: ",
            stringify!(aeron_driver_receiver_pending_setup_entry_stct)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_driver_receiver_pending_setup_entry_stct>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(aeron_driver_receiver_pending_setup_entry_stct)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).is_periodic) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_receiver_pending_setup_entry_stct),
            "::",
            stringify!(is_periodic)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).session_id) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_receiver_pending_setup_entry_stct),
            "::",
            stringify!(session_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stream_id) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_receiver_pending_setup_entry_stct),
            "::",
            stringify!(stream_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).endpoint) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_receiver_pending_setup_entry_stct),
            "::",
            stringify!(endpoint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).destination) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_receiver_pending_setup_entry_stct),
            "::",
            stringify!(destination)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).time_of_status_message_ns) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_receiver_pending_setup_entry_stct),
            "::",
            stringify!(time_of_status_message_ns)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).control_addr) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_receiver_pending_setup_entry_stct),
            "::",
            stringify!(control_addr)
        )
    );
}
pub type aeron_driver_receiver_pending_setup_entry_t =
    aeron_driver_receiver_pending_setup_entry_stct;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aeron_driver_receiver_stct {
    pub receiver_proxy: aeron_driver_receiver_proxy_t,
    pub poller: aeron_udp_transport_poller_t,
    pub recv_buffers: aeron_driver_receiver_stct_aeron_driver_receiver_buffers_stct,
    pub images: aeron_driver_receiver_stct_aeron_driver_receiver_images_stct,
    pub pending_setups: aeron_driver_receiver_stct_aeron_driver_receiver_pending_setups_stct,
    pub data_paths: aeron_udp_channel_data_paths_t,
    pub context: *mut aeron_driver_context_t,
    pub poller_poll_func: aeron_udp_transport_poller_poll_func_t,
    pub recvmmsg_func: aeron_udp_channel_transport_recvmmsg_func_t,
    pub error_log: *mut aeron_distinct_error_log_t,
    pub re_resolution_deadline_ns: i64,
    pub errors_counter: *mut i64,
    pub invalid_frames_counter: *mut i64,
    pub total_bytes_received_counter: *mut i64,
    pub resolution_changes_counter: *mut i64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aeron_driver_receiver_stct_aeron_driver_receiver_buffers_stct {
    pub vector_capacity: usize,
    pub buffers: [*mut u8; 16usize],
    pub iov: [iovec; 16usize],
    pub addrs: [sockaddr_storage; 16usize],
}
#[test]
fn bindgen_test_layout_aeron_driver_receiver_stct_aeron_driver_receiver_buffers_stct() {
    const UNINIT: ::std::mem::MaybeUninit<
        aeron_driver_receiver_stct_aeron_driver_receiver_buffers_stct,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_driver_receiver_stct_aeron_driver_receiver_buffers_stct>(),
        2440usize,
        concat!(
            "Size of: ",
            stringify!(aeron_driver_receiver_stct_aeron_driver_receiver_buffers_stct)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_driver_receiver_stct_aeron_driver_receiver_buffers_stct>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(aeron_driver_receiver_stct_aeron_driver_receiver_buffers_stct)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vector_capacity) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_receiver_stct_aeron_driver_receiver_buffers_stct),
            "::",
            stringify!(vector_capacity)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buffers) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_receiver_stct_aeron_driver_receiver_buffers_stct),
            "::",
            stringify!(buffers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).iov) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_receiver_stct_aeron_driver_receiver_buffers_stct),
            "::",
            stringify!(iov)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).addrs) as usize - ptr as usize },
        392usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_receiver_stct_aeron_driver_receiver_buffers_stct),
            "::",
            stringify!(addrs)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aeron_driver_receiver_stct_aeron_driver_receiver_images_stct {
    pub array: *mut aeron_driver_receiver_image_entry_t,
    pub length: usize,
    pub capacity: usize,
}
#[test]
fn bindgen_test_layout_aeron_driver_receiver_stct_aeron_driver_receiver_images_stct() {
    const UNINIT: ::std::mem::MaybeUninit<
        aeron_driver_receiver_stct_aeron_driver_receiver_images_stct,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_driver_receiver_stct_aeron_driver_receiver_images_stct>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(aeron_driver_receiver_stct_aeron_driver_receiver_images_stct)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_driver_receiver_stct_aeron_driver_receiver_images_stct>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(aeron_driver_receiver_stct_aeron_driver_receiver_images_stct)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).array) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_receiver_stct_aeron_driver_receiver_images_stct),
            "::",
            stringify!(array)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_receiver_stct_aeron_driver_receiver_images_stct),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).capacity) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_receiver_stct_aeron_driver_receiver_images_stct),
            "::",
            stringify!(capacity)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aeron_driver_receiver_stct_aeron_driver_receiver_pending_setups_stct {
    pub array: *mut aeron_driver_receiver_pending_setup_entry_t,
    pub length: usize,
    pub capacity: usize,
}
#[test]
fn bindgen_test_layout_aeron_driver_receiver_stct_aeron_driver_receiver_pending_setups_stct() {
    const UNINIT: ::std::mem::MaybeUninit<
        aeron_driver_receiver_stct_aeron_driver_receiver_pending_setups_stct,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_driver_receiver_stct_aeron_driver_receiver_pending_setups_stct>(
        ),
        24usize,
        concat!(
            "Size of: ",
            stringify!(aeron_driver_receiver_stct_aeron_driver_receiver_pending_setups_stct)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_driver_receiver_stct_aeron_driver_receiver_pending_setups_stct>(
        ),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(aeron_driver_receiver_stct_aeron_driver_receiver_pending_setups_stct)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).array) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_receiver_stct_aeron_driver_receiver_pending_setups_stct),
            "::",
            stringify!(array)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_receiver_stct_aeron_driver_receiver_pending_setups_stct),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).capacity) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_receiver_stct_aeron_driver_receiver_pending_setups_stct),
            "::",
            stringify!(capacity)
        )
    );
}
#[test]
fn bindgen_test_layout_aeron_driver_receiver_stct() {
    const UNINIT: ::std::mem::MaybeUninit<aeron_driver_receiver_stct> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_driver_receiver_stct>(),
        2680usize,
        concat!("Size of: ", stringify!(aeron_driver_receiver_stct))
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_driver_receiver_stct>(),
        8usize,
        concat!("Alignment of ", stringify!(aeron_driver_receiver_stct))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).receiver_proxy) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_receiver_stct),
            "::",
            stringify!(receiver_proxy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).poller) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_receiver_stct),
            "::",
            stringify!(poller)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).recv_buffers) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_receiver_stct),
            "::",
            stringify!(recv_buffers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).images) as usize - ptr as usize },
        2528usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_receiver_stct),
            "::",
            stringify!(images)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pending_setups) as usize - ptr as usize },
        2552usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_receiver_stct),
            "::",
            stringify!(pending_setups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data_paths) as usize - ptr as usize },
        2576usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_receiver_stct),
            "::",
            stringify!(data_paths)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).context) as usize - ptr as usize },
        2608usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_receiver_stct),
            "::",
            stringify!(context)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).poller_poll_func) as usize - ptr as usize },
        2616usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_receiver_stct),
            "::",
            stringify!(poller_poll_func)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).recvmmsg_func) as usize - ptr as usize },
        2624usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_receiver_stct),
            "::",
            stringify!(recvmmsg_func)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).error_log) as usize - ptr as usize },
        2632usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_receiver_stct),
            "::",
            stringify!(error_log)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).re_resolution_deadline_ns) as usize - ptr as usize },
        2640usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_receiver_stct),
            "::",
            stringify!(re_resolution_deadline_ns)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).errors_counter) as usize - ptr as usize },
        2648usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_receiver_stct),
            "::",
            stringify!(errors_counter)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).invalid_frames_counter) as usize - ptr as usize },
        2656usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_receiver_stct),
            "::",
            stringify!(invalid_frames_counter)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).total_bytes_received_counter) as usize - ptr as usize
        },
        2664usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_receiver_stct),
            "::",
            stringify!(total_bytes_received_counter)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).resolution_changes_counter) as usize - ptr as usize },
        2672usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_receiver_stct),
            "::",
            stringify!(resolution_changes_counter)
        )
    );
}
extern "C" {
    pub fn aeron_driver_receiver_init(
        receiver: *mut aeron_driver_receiver_t,
        context: *mut aeron_driver_context_t,
        system_counters: *mut aeron_system_counters_t,
        error_log: *mut aeron_distinct_error_log_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_driver_receiver_do_work(
        clientd: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aeron_driver_receiver_on_close(clientd: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn aeron_driver_receiver_on_add_endpoint(
        clientd: *mut ::std::os::raw::c_void,
        item: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn aeron_driver_receiver_on_remove_endpoint(
        clientd: *mut ::std::os::raw::c_void,
        item: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn aeron_driver_receiver_on_add_subscription(
        clientd: *mut ::std::os::raw::c_void,
        item: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn aeron_driver_receiver_on_remove_subscription(
        clientd: *mut ::std::os::raw::c_void,
        item: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn aeron_driver_receiver_on_add_subscription_by_session(
        clientd: *mut ::std::os::raw::c_void,
        item: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn aeron_driver_receiver_on_remove_subscription_by_session(
        clientd: *mut ::std::os::raw::c_void,
        item: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn aeron_driver_receiver_on_add_destination(
        clientd: *mut ::std::os::raw::c_void,
        item: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn aeron_driver_receiver_on_remove_destination(
        clientd: *mut ::std::os::raw::c_void,
        item: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn aeron_driver_receiver_on_add_publication_image(
        clientd: *mut ::std::os::raw::c_void,
        item: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn aeron_driver_receiver_on_remove_publication_image(
        clientd: *mut ::std::os::raw::c_void,
        item: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn aeron_driver_receiver_on_remove_matching_state(
        clientd: *mut ::std::os::raw::c_void,
        item: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn aeron_driver_receiver_on_resolution_change(
        clientd: *mut ::std::os::raw::c_void,
        item: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn aeron_driver_receiver_add_pending_setup(
        receiver: *mut aeron_driver_receiver_t,
        endpoint: *mut aeron_receive_channel_endpoint_t,
        destination: *mut aeron_receive_destination_t,
        session_id: i32,
        stream_id: i32,
        control_addr: *mut sockaddr_storage,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aeron_driver_stct {
    pub context: *mut aeron_driver_context_t,
    pub conductor: aeron_driver_conductor_t,
    pub sender: aeron_driver_sender_t,
    pub receiver: aeron_driver_receiver_t,
    pub runners: [aeron_agent_runner_t; 3usize],
}
#[test]
fn bindgen_test_layout_aeron_driver_stct() {
    const UNINIT: ::std::mem::MaybeUninit<aeron_driver_stct> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aeron_driver_stct>(),
        6792usize,
        concat!("Size of: ", stringify!(aeron_driver_stct))
    );
    assert_eq!(
        ::std::mem::align_of::<aeron_driver_stct>(),
        8usize,
        concat!("Alignment of ", stringify!(aeron_driver_stct))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).context) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_stct),
            "::",
            stringify!(context)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).conductor) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_stct),
            "::",
            stringify!(conductor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sender) as usize - ptr as usize },
        1096usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_stct),
            "::",
            stringify!(sender)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).receiver) as usize - ptr as usize },
        3872usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_stct),
            "::",
            stringify!(receiver)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).runners) as usize - ptr as usize },
        6552usize,
        concat!(
            "Offset of field: ",
            stringify!(aeron_driver_stct),
            "::",
            stringify!(runners)
        )
    );
}
extern "C" {
    pub fn aeron_is_driver_active_with_cnc(
        cnc_map: *mut aeron_mapped_file_t,
        timeout_ms: i64,
        now_ms: i64,
        log_func: aeron_log_func_t,
    ) -> bool;
}
