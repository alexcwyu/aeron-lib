/* automatically generated by rust-bindgen 0.66.1 */

#[allow(non_snake_case, non_camel_case_types, non_upper_case_globals)]
pub mod root {
    #[allow(unused_imports)]
    use self::super::root;
    pub const AERON_FILE_SEP: u8 = 47u8;
    pub const AERON_COMPILER_GCC: u32 = 1;
    pub const AERON_COMPILER_LLVM: u32 = 1;
    pub const AERON_CPU_X64: u32 = 1;
    pub mod std {
        #[allow(unused_imports)]
        use self::super::super::root;
        #[repr(C)]
        #[derive(Copy, Clone)]
        pub struct basic_string {
            pub _address: u8,
        }
        pub type basic_string__Char_alloc_type = u8;
        pub type basic_string__Alloc_traits = u8;
        pub type basic_string_traits_type = u8;
        pub type basic_string_value_type = u8;
        pub type basic_string_allocator_type = u8;
        pub type basic_string_size_type = u8;
        pub type basic_string_difference_type = u8;
        pub type basic_string_reference = u8;
        pub type basic_string_const_reference = u8;
        pub type basic_string_pointer = u8;
        pub type basic_string_const_pointer = u8;
        pub type basic_string_iterator = u8;
        pub type basic_string_const_iterator = u8;
        pub type basic_string_const_reverse_iterator = u8;
        pub type basic_string_reverse_iterator = u8;
        pub type basic_string___const_iterator = u8;
        #[repr(C)]
        #[derive(Copy, Clone)]
        pub struct basic_string__Alloc_hider {
            pub _address: u8,
        }
        pub const basic_string__S_local_capacity: root::std::basic_string__bindgen_ty_1 = 0;
        pub type basic_string__bindgen_ty_1 = i32;
        #[repr(C)]
        #[repr(align(8))]
        #[derive(Copy, Clone)]
        pub union basic_string__bindgen_ty_2 {
            pub _bindgen_opaque_blob: u64,
        }
        #[repr(C)]
        #[derive(Copy, Clone)]
        pub struct pair {
            pub _address: u8,
        }
        pub type pair_first_type = u8;
        pub type pair_second_type = u8;
        pub type pair__PCCP = u8;
        pub type pair__PCCFP = u8;
        #[repr(C)]
        #[derive(Copy, Clone)]
        pub struct pair___zero_as_null_pointer_constant {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Copy, Clone)]
        pub struct hash {
            pub _address: u8,
        }
        #[repr(C)]
        #[repr(align(8))]
        #[derive(Copy, Clone)]
        pub struct exception {
            pub _bindgen_opaque_blob: u64,
        }
        #[test]
        fn bindgen_test_layout_exception() {
            assert_eq!(
                ::std::mem::size_of::<exception>(),
                8usize,
                concat!("Size of: ", stringify!(exception))
            );
            assert_eq!(
                ::std::mem::align_of::<exception>(),
                8usize,
                concat!("Alignment of ", stringify!(exception))
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZNSt9exceptionC1Ev"]
            pub fn exception_exception(this: *mut root::std::exception);
        }
        extern "C" {
            #[link_name = "\u{1}_ZNSt9exceptionC1ERKS_"]
            pub fn exception_exception1(
                this: *mut root::std::exception,
                arg1: *const root::std::exception,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZNSt9exceptionC1EOS_"]
            pub fn exception_exception2(
                this: *mut root::std::exception,
                arg1: *mut root::std::exception,
            );
        }
        impl exception {
            #[inline]
            pub unsafe fn new() -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                exception_exception(__bindgen_tmp.as_mut_ptr());
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn new1(arg1: *const root::std::exception) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                exception_exception1(__bindgen_tmp.as_mut_ptr(), arg1);
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn new2(arg1: *mut root::std::exception) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                exception_exception2(__bindgen_tmp.as_mut_ptr(), arg1);
                __bindgen_tmp.assume_init()
            }
        }
        extern "C" {
            #[link_name = "\u{1}_ZNSt9exceptionD1Ev"]
            pub fn exception_exception_destructor(this: *mut root::std::exception);
        }
        extern "C" {
            #[link_name = "\u{1}_ZNKSt9exception4whatEv"]
            pub fn exception_what(
                this: *mut ::std::os::raw::c_void,
            ) -> *const ::std::os::raw::c_char;
        }
        #[repr(C)]
        #[derive(Copy, Clone)]
        pub struct allocator {
            pub _address: u8,
        }
        pub type allocator_value_type = u8;
        pub type allocator_size_type = u64;
        pub type allocator_difference_type = u64;
        pub type allocator_pointer = u8;
        pub type allocator_const_pointer = u8;
        pub type allocator_reference = u8;
        pub type allocator_const_reference = u8;
        #[repr(C)]
        #[derive(Copy, Clone)]
        pub struct allocator_rebind {
            pub _address: u8,
        }
        pub type allocator_rebind_other = u8;
        pub type allocator_propagate_on_container_move_assignment = u8;
        pub type allocator_is_always_equal = u8;
        #[repr(C)]
        #[derive(Copy, Clone)]
        pub struct equal_to {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Copy, Clone)]
        pub struct unordered_map {
            pub _address: u8,
        }
        pub type unordered_map__Hashtable = u8;
        pub type unordered_map_key_type = u8;
        pub type unordered_map_value_type = u8;
        pub type unordered_map_mapped_type = u8;
        pub type unordered_map_hasher = u8;
        pub type unordered_map_key_equal = u8;
        pub type unordered_map_allocator_type = u8;
        pub type unordered_map_pointer = u8;
        pub type unordered_map_const_pointer = u8;
        pub type unordered_map_reference = u8;
        pub type unordered_map_const_reference = u8;
        pub type unordered_map_iterator = u8;
        pub type unordered_map_const_iterator = u8;
        pub type unordered_map_local_iterator = u8;
        pub type unordered_map_const_local_iterator = u8;
        pub type unordered_map_size_type = u8;
        pub type unordered_map_difference_type = u8;
        #[repr(C)]
        #[derive(Copy, Clone)]
        pub struct vector {
            pub _address: u8,
        }
        pub type vector__Base = u8;
        pub type vector__Tp_alloc_type = u8;
        pub type vector__Alloc_traits = u8;
        pub type vector_value_type = u8;
        pub type vector_pointer = u8;
        pub type vector_const_pointer = u8;
        pub type vector_reference = u8;
        pub type vector_const_reference = u8;
        pub type vector_iterator = u8;
        pub type vector_const_iterator = u8;
        pub type vector_const_reverse_iterator = u8;
        pub type vector_reverse_iterator = u8;
        pub type vector_size_type = u64;
        pub type vector_difference_type = u64;
        pub type vector_allocator_type = u8;
        #[repr(C)]
        #[derive(Copy, Clone)]
        pub struct vector__Temporary_value {
            pub _address: u8,
        }
        #[repr(C)]
        #[repr(align(1))]
        #[derive(Copy, Clone)]
        pub union vector__Temporary_value__Storage {
            pub _bindgen_opaque_blob: u8,
        }
        pub type nano = u8;
        pub type milli = u8;
        pub mod chrono {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            #[repr(C)]
            #[derive(Copy, Clone)]
            pub struct duration {
                pub _address: u8,
            }
            pub type duration___is_float = u8;
            pub type duration___divide = u8;
            pub type duration___is_harmonic = u8;
            pub type duration_rep = u8;
            pub type duration_period = u8;
        }
        #[repr(C)]
        #[repr(align(8))]
        #[derive(Copy, Clone)]
        pub struct recursive_mutex {
            pub _bindgen_opaque_blob: [u64; 5usize],
        }
        pub type recursive_mutex_native_handle_type = u64;
        #[test]
        fn bindgen_test_layout_recursive_mutex() {
            assert_eq!(
                ::std::mem::size_of::<recursive_mutex>(),
                40usize,
                concat!("Size of: ", stringify!(recursive_mutex))
            );
            assert_eq!(
                ::std::mem::align_of::<recursive_mutex>(),
                8usize,
                concat!("Alignment of ", stringify!(recursive_mutex))
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZNSt15recursive_mutex4lockEv"]
            pub fn recursive_mutex_lock(this: *mut root::std::recursive_mutex);
        }
        extern "C" {
            #[link_name = "\u{1}_ZNSt15recursive_mutex8try_lockEv"]
            pub fn recursive_mutex_try_lock(this: *mut root::std::recursive_mutex) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNSt15recursive_mutex6unlockEv"]
            pub fn recursive_mutex_unlock(this: *mut root::std::recursive_mutex);
        }
        extern "C" {
            #[link_name = "\u{1}_ZNSt15recursive_mutex13native_handleEv"]
            pub fn recursive_mutex_native_handle(
                this: *mut root::std::recursive_mutex,
            ) -> root::std::recursive_mutex_native_handle_type;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNSt15recursive_mutexC1Ev"]
            pub fn recursive_mutex_recursive_mutex(this: *mut root::std::recursive_mutex);
        }
        extern "C" {
            #[link_name = "\u{1}_ZNSt15recursive_mutexD1Ev"]
            pub fn recursive_mutex_recursive_mutex_destructor(
                this: *mut root::std::recursive_mutex,
            );
        }
        impl recursive_mutex {
            #[inline]
            pub unsafe fn lock(&mut self) {
                recursive_mutex_lock(self)
            }
            #[inline]
            pub unsafe fn try_lock(&mut self) -> bool {
                recursive_mutex_try_lock(self)
            }
            #[inline]
            pub unsafe fn unlock(&mut self) {
                recursive_mutex_unlock(self)
            }
            #[inline]
            pub unsafe fn native_handle(
                &mut self,
            ) -> root::std::recursive_mutex_native_handle_type {
                recursive_mutex_native_handle(self)
            }
            #[inline]
            pub unsafe fn new() -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                recursive_mutex_recursive_mutex(__bindgen_tmp.as_mut_ptr());
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn destruct(&mut self) {
                recursive_mutex_recursive_mutex_destructor(self)
            }
        }
        #[repr(C)]
        #[derive(Copy, Clone)]
        pub struct function {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Copy, Clone)]
        pub struct default_delete {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Copy, Clone)]
        pub struct unique_ptr {
            pub _address: u8,
        }
        pub type unique_ptr__DeleterConstraint = u8;
        pub type unique_ptr_pointer = u8;
        pub type unique_ptr_element_type = u8;
        pub type unique_ptr_deleter_type = u8;
        pub type unique_ptr___safe_conversion_up = u8;
        pub type string = [u64; 4usize];
        #[repr(C)]
        #[derive(Copy, Clone)]
        pub struct shared_ptr {
            pub _address: u8,
        }
        pub type shared_ptr__Constructible = u8;
        pub type shared_ptr__Assignable = u8;
        pub type shared_ptr_element_type = u8;
        #[repr(C)]
        #[derive(Copy, Clone)]
        pub struct weak_ptr {
            pub _address: u8,
        }
        pub type weak_ptr__Constructible = u8;
        pub type weak_ptr__Assignable = u8;
        pub type array_value_type = u8;
        pub type array_pointer = u8;
        pub type array_const_pointer = u8;
        pub type array_reference = u8;
        pub type array_const_reference = u8;
        pub type array_iterator = u8;
        pub type array_const_iterator = u8;
        pub type array_size_type = u64;
        pub type array_difference_type = u64;
        pub type array_reverse_iterator = u8;
        pub type array_const_reverse_iterator = u8;
        #[repr(C)]
        #[derive(Copy, Clone)]
        pub struct char_traits {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Copy, Clone)]
        pub struct atomic {
            pub _address: u8,
        }
        pub type atomic_value_type = u8;
        #[repr(C)]
        #[derive(Copy, Clone)]
        pub struct deque {
            pub _address: u8,
        }
        pub type deque__Base = u8;
        pub type deque__Tp_alloc_type = u8;
        pub type deque__Alloc_traits = u8;
        pub type deque__Map_pointer = u8;
        pub type deque_value_type = u8;
        pub type deque_pointer = u8;
        pub type deque_const_pointer = u8;
        pub type deque_reference = u8;
        pub type deque_const_reference = u8;
        pub type deque_iterator = u8;
        pub type deque_const_iterator = u8;
        pub type deque_const_reverse_iterator = u8;
        pub type deque_reverse_iterator = u8;
        pub type deque_size_type = u64;
        pub type deque_difference_type = u64;
        pub type deque_allocator_type = u8;
        #[repr(C)]
        #[repr(align(8))]
        #[derive(Copy, Clone)]
        pub struct thread {
            pub _bindgen_opaque_blob: u64,
        }
        pub type thread_native_handle_type = u64;
        #[repr(C)]
        #[repr(align(8))]
        #[derive(Copy, Clone)]
        pub struct thread_id {
            pub _bindgen_opaque_blob: u64,
        }
        #[test]
        fn bindgen_test_layout_thread_id() {
            assert_eq!(
                ::std::mem::size_of::<thread_id>(),
                8usize,
                concat!("Size of: ", stringify!(thread_id))
            );
            assert_eq!(
                ::std::mem::align_of::<thread_id>(),
                8usize,
                concat!("Alignment of ", stringify!(thread_id))
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZNSt6thread2idC1Ev"]
            pub fn thread_id_id(this: *mut root::std::thread_id);
        }
        extern "C" {
            #[link_name = "\u{1}_ZNSt6thread2idC1Em"]
            pub fn thread_id_id1(
                this: *mut root::std::thread_id,
                __id: root::std::thread_native_handle_type,
            );
        }
        impl thread_id {
            #[inline]
            pub unsafe fn new() -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                thread_id_id(__bindgen_tmp.as_mut_ptr());
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn new1(__id: root::std::thread_native_handle_type) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                thread_id_id1(__bindgen_tmp.as_mut_ptr(), __id);
                __bindgen_tmp.assume_init()
            }
        }
        pub type thread___not_same = u8;
        #[repr(C)]
        #[repr(align(8))]
        #[derive(Copy, Clone)]
        pub struct thread__State {
            pub _bindgen_opaque_blob: u64,
        }
        #[test]
        fn bindgen_test_layout_thread__State() {
            assert_eq!(
                ::std::mem::size_of::<thread__State>(),
                8usize,
                concat!("Size of: ", stringify!(thread__State))
            );
            assert_eq!(
                ::std::mem::align_of::<thread__State>(),
                8usize,
                concat!("Alignment of ", stringify!(thread__State))
            );
        }
        pub type thread__State_ptr = u64;
        #[repr(C)]
        #[derive(Copy, Clone)]
        pub struct thread__State_impl {}
        #[repr(C)]
        #[derive(Copy, Clone)]
        pub struct thread__Invoker {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Copy, Clone)]
        pub struct thread__Invoker___result {
            pub _address: u8,
        }
        pub type thread__Call_wrapper = u8;
        #[test]
        fn bindgen_test_layout_thread() {
            assert_eq!(
                ::std::mem::size_of::<thread>(),
                8usize,
                concat!("Size of: ", stringify!(thread))
            );
            assert_eq!(
                ::std::mem::align_of::<thread>(),
                8usize,
                concat!("Alignment of ", stringify!(thread))
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZNSt6thread4swapERS_"]
            pub fn thread_swap(this: *mut root::std::thread, __t: *mut root::std::thread);
        }
        extern "C" {
            #[link_name = "\u{1}_ZNKSt6thread8joinableEv"]
            pub fn thread_joinable(this: *const root::std::thread) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNSt6thread4joinEv"]
            pub fn thread_join(this: *mut root::std::thread);
        }
        extern "C" {
            #[link_name = "\u{1}_ZNSt6thread6detachEv"]
            pub fn thread_detach(this: *mut root::std::thread);
        }
        extern "C" {
            #[link_name = "\u{1}_ZNKSt6thread6get_idEv"]
            pub fn thread_get_id(this: *const root::std::thread) -> root::std::thread_id;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNSt6thread13native_handleEv"]
            pub fn thread_native_handle(
                this: *mut root::std::thread,
            ) -> root::std::thread_native_handle_type;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNSt6thread20hardware_concurrencyEv"]
            pub fn thread_hardware_concurrency() -> ::std::os::raw::c_uint;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNSt6threadC1Ev"]
            pub fn thread_thread(this: *mut root::std::thread);
        }
        extern "C" {
            #[link_name = "\u{1}_ZNSt6threadC1EOS_"]
            pub fn thread_thread1(this: *mut root::std::thread, __t: *mut root::std::thread);
        }
        extern "C" {
            #[link_name = "\u{1}_ZNSt6threadD1Ev"]
            pub fn thread_thread_destructor(this: *mut root::std::thread);
        }
        impl thread {
            #[inline]
            pub unsafe fn swap(&mut self, __t: *mut root::std::thread) {
                thread_swap(self, __t)
            }
            #[inline]
            pub unsafe fn joinable(&self) -> bool {
                thread_joinable(self)
            }
            #[inline]
            pub unsafe fn join(&mut self) {
                thread_join(self)
            }
            #[inline]
            pub unsafe fn detach(&mut self) {
                thread_detach(self)
            }
            #[inline]
            pub unsafe fn get_id(&self) -> root::std::thread_id {
                thread_get_id(self)
            }
            #[inline]
            pub unsafe fn native_handle(&mut self) -> root::std::thread_native_handle_type {
                thread_native_handle(self)
            }
            #[inline]
            pub unsafe fn hardware_concurrency() -> ::std::os::raw::c_uint {
                thread_hardware_concurrency()
            }
            #[inline]
            pub unsafe fn new() -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                thread_thread(__bindgen_tmp.as_mut_ptr());
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn new1(__t: *mut root::std::thread) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                thread_thread1(__bindgen_tmp.as_mut_ptr(), __t);
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn destruct(&mut self) {
                thread_thread_destructor(self)
            }
        }
        extern "C" {
            #[link_name = "\u{1}_ZNSt6thread6_StateD1Ev"]
            pub fn thread__State__State_destructor(this: *mut root::std::thread__State);
        }
    }
    pub mod __gnu_cxx {
        #[allow(unused_imports)]
        use self::super::super::root;
    }
    pub type __off_t = ::std::os::raw::c_long;
    pub type off_t = root::__off_t;
    pub mod aeron {
        #[allow(unused_imports)]
        use self::super::super::root;
        pub mod util {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            pub type Iterator = [u8; 0usize];
            #[repr(C)]
            pub struct InvokeOnScopeExit {
                pub m_func: root::aeron::util::InvokeOnScopeExit_func_t,
            }
            pub type InvokeOnScopeExit_func_t = [u64; 4usize];
            #[test]
            fn bindgen_test_layout_InvokeOnScopeExit() {
                const UNINIT: ::std::mem::MaybeUninit<InvokeOnScopeExit> =
                    ::std::mem::MaybeUninit::uninit();
                let ptr = UNINIT.as_ptr();
                assert_eq!(
                    ::std::mem::size_of::<InvokeOnScopeExit>(),
                    32usize,
                    concat!("Size of: ", stringify!(InvokeOnScopeExit))
                );
                assert_eq!(
                    ::std::mem::align_of::<InvokeOnScopeExit>(),
                    8usize,
                    concat!("Alignment of ", stringify!(InvokeOnScopeExit))
                );
                assert_eq!(
                    unsafe { ::std::ptr::addr_of!((*ptr).m_func) as usize - ptr as usize },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(InvokeOnScopeExit),
                        "::",
                        stringify!(m_func)
                    )
                );
            }
            extern "C" {
                #[link_name = "\u{1}_ZN5aeron4util17InvokeOnScopeExitC1ERKSt8functionIFvvEE"]
                pub fn InvokeOnScopeExit_InvokeOnScopeExit(
                    this: *mut root::aeron::util::InvokeOnScopeExit,
                    func: *const root::aeron::util::InvokeOnScopeExit_func_t,
                );
            }
            extern "C" {
                #[link_name = "\u{1}_ZN5aeron4util17InvokeOnScopeExitD1Ev"]
                pub fn InvokeOnScopeExit_InvokeOnScopeExit_destructor(
                    this: *mut root::aeron::util::InvokeOnScopeExit,
                );
            }
            impl InvokeOnScopeExit {
                #[inline]
                pub unsafe fn new(
                    func: *const root::aeron::util::InvokeOnScopeExit_func_t,
                ) -> Self {
                    let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                    InvokeOnScopeExit_InvokeOnScopeExit(__bindgen_tmp.as_mut_ptr(), func);
                    __bindgen_tmp.assume_init()
                }
                #[inline]
                pub unsafe fn destruct(&mut self) {
                    InvokeOnScopeExit_InvokeOnScopeExit_destructor(self)
                }
            }
            #[repr(C)]
            pub struct OnScopeExit {
                pub m_holder: u64,
            }
            #[repr(C)]
            pub struct OnScopeExit_FuncHolderBase__bindgen_vtable(::std::os::raw::c_void);
            #[repr(C)]
            pub struct OnScopeExit_FuncHolderBase {
                pub vtable_: *const OnScopeExit_FuncHolderBase__bindgen_vtable,
            }
            #[test]
            fn bindgen_test_layout_OnScopeExit_FuncHolderBase() {
                assert_eq!(
                    ::std::mem::size_of::<OnScopeExit_FuncHolderBase>(),
                    8usize,
                    concat!("Size of: ", stringify!(OnScopeExit_FuncHolderBase))
                );
                assert_eq!(
                    ::std::mem::align_of::<OnScopeExit_FuncHolderBase>(),
                    8usize,
                    concat!("Alignment of ", stringify!(OnScopeExit_FuncHolderBase))
                );
            }
            #[repr(C)]
            pub struct OnScopeExit_FuncHolder<func_t> {
                pub _base: root::aeron::util::OnScopeExit_FuncHolderBase,
                pub f: func_t,
                pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<func_t>>,
            }
            #[test]
            fn bindgen_test_layout_OnScopeExit() {
                const UNINIT: ::std::mem::MaybeUninit<OnScopeExit> =
                    ::std::mem::MaybeUninit::uninit();
                let ptr = UNINIT.as_ptr();
                assert_eq!(
                    ::std::mem::size_of::<OnScopeExit>(),
                    8usize,
                    concat!("Size of: ", stringify!(OnScopeExit))
                );
                assert_eq!(
                    ::std::mem::align_of::<OnScopeExit>(),
                    8usize,
                    concat!("Alignment of ", stringify!(OnScopeExit))
                );
                assert_eq!(
                    unsafe { ::std::ptr::addr_of!((*ptr).m_holder) as usize - ptr as usize },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(OnScopeExit),
                        "::",
                        stringify!(m_holder)
                    )
                );
            }
            extern "C" {
                #[link_name = "\u{1}_ZN5aeron4util11OnScopeExit14FuncHolderBaseD1Ev"]
                pub fn OnScopeExit_FuncHolderBase_FuncHolderBase_destructor(
                    this: *mut root::aeron::util::OnScopeExit_FuncHolderBase,
                );
            }
            #[repr(C)]
            pub struct CallbackGuard {
                pub m_isInCallback: *mut bool,
            }
            #[test]
            fn bindgen_test_layout_CallbackGuard() {
                const UNINIT: ::std::mem::MaybeUninit<CallbackGuard> =
                    ::std::mem::MaybeUninit::uninit();
                let ptr = UNINIT.as_ptr();
                assert_eq!(
                    ::std::mem::size_of::<CallbackGuard>(),
                    8usize,
                    concat!("Size of: ", stringify!(CallbackGuard))
                );
                assert_eq!(
                    ::std::mem::align_of::<CallbackGuard>(),
                    8usize,
                    concat!("Alignment of ", stringify!(CallbackGuard))
                );
                assert_eq!(
                    unsafe { ::std::ptr::addr_of!((*ptr).m_isInCallback) as usize - ptr as usize },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(CallbackGuard),
                        "::",
                        stringify!(m_isInCallback)
                    )
                );
            }
            extern "C" {
                #[link_name = "\u{1}_ZN5aeron4util13CallbackGuardC1ERb"]
                pub fn CallbackGuard_CallbackGuard(
                    this: *mut root::aeron::util::CallbackGuard,
                    isInCallback: *mut bool,
                );
            }
            extern "C" {
                #[link_name = "\u{1}_ZN5aeron4util13CallbackGuardD1Ev"]
                pub fn CallbackGuard_CallbackGuard_destructor(
                    this: *mut root::aeron::util::CallbackGuard,
                );
            }
            impl CallbackGuard {
                #[inline]
                pub unsafe fn new(isInCallback: *mut bool) -> Self {
                    let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                    CallbackGuard_CallbackGuard(__bindgen_tmp.as_mut_ptr(), isInCallback);
                    __bindgen_tmp.assume_init()
                }
                #[inline]
                pub unsafe fn destruct(&mut self) {
                    CallbackGuard_CallbackGuard_destructor(self)
                }
            }
            pub type index_t = ::std::os::raw::c_int;
            pub type exception_handler_t = [u64; 4usize];
            pub const ExceptionCategory_EXCEPTION_CATEGORY_FATAL:
                root::aeron::util::ExceptionCategory = 0;
            pub const ExceptionCategory_EXCEPTION_CATEGORY_ERROR:
                root::aeron::util::ExceptionCategory = 1;
            pub const ExceptionCategory_EXCEPTION_CATEGORY_WARN:
                root::aeron::util::ExceptionCategory = 2;
            pub type ExceptionCategory = ::std::os::raw::c_long;
            #[repr(C)]
            pub struct SourcedException {
                pub _base: root::std::exception,
                pub m_where: root::std::string,
                pub m_what: root::std::string,
                pub m_category: root::aeron::util::ExceptionCategory,
            }
            #[test]
            fn bindgen_test_layout_SourcedException() {
                const UNINIT: ::std::mem::MaybeUninit<SourcedException> =
                    ::std::mem::MaybeUninit::uninit();
                let ptr = UNINIT.as_ptr();
                assert_eq!(
                    ::std::mem::size_of::<SourcedException>(),
                    80usize,
                    concat!("Size of: ", stringify!(SourcedException))
                );
                assert_eq!(
                    ::std::mem::align_of::<SourcedException>(),
                    8usize,
                    concat!("Alignment of ", stringify!(SourcedException))
                );
                assert_eq!(
                    unsafe { ::std::ptr::addr_of!((*ptr).m_where) as usize - ptr as usize },
                    8usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(SourcedException),
                        "::",
                        stringify!(m_where)
                    )
                );
                assert_eq!(
                    unsafe { ::std::ptr::addr_of!((*ptr).m_what) as usize - ptr as usize },
                    40usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(SourcedException),
                        "::",
                        stringify!(m_what)
                    )
                );
                assert_eq!(
                    unsafe { ::std::ptr::addr_of!((*ptr).m_category) as usize - ptr as usize },
                    72usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(SourcedException),
                        "::",
                        stringify!(m_category)
                    )
                );
            }
            extern "C" {
                #[link_name = "\u{1}_ZNK5aeron4util16SourcedException5whereEv"]
                pub fn SourcedException_where(
                    this: *const root::aeron::util::SourcedException,
                ) -> *const ::std::os::raw::c_char;
            }
            extern "C" {
                #[link_name = "\u{1}_ZNK5aeron4util16SourcedException8categoryEv"]
                pub fn SourcedException_category(
                    this: *const root::aeron::util::SourcedException,
                ) -> root::aeron::util::ExceptionCategory;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN5aeron4util16SourcedExceptionC1ENS0_17ExceptionCategoryERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESA_SA_i"]
                pub fn SourcedException_SourcedException(
                    this: *mut root::aeron::util::SourcedException,
                    category: root::aeron::util::ExceptionCategory,
                    what: *const root::std::string,
                    function: *const root::std::string,
                    file: *const root::std::string,
                    line: ::std::os::raw::c_int,
                );
            }
            extern "C" {
                #[link_name = "\u{1}_ZN5aeron4util16SourcedExceptionC1ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEES9_S9_i"]
                pub fn SourcedException_SourcedException1(
                    this: *mut root::aeron::util::SourcedException,
                    what: *const root::std::string,
                    function: *const root::std::string,
                    file: *const root::std::string,
                    line: ::std::os::raw::c_int,
                );
            }
            impl SourcedException {
                #[inline]
                pub unsafe fn where_(&self) -> *const ::std::os::raw::c_char {
                    SourcedException_where(self)
                }
                #[inline]
                pub unsafe fn category(&self) -> root::aeron::util::ExceptionCategory {
                    SourcedException_category(self)
                }
                #[inline]
                pub unsafe fn new(
                    category: root::aeron::util::ExceptionCategory,
                    what: *const root::std::string,
                    function: *const root::std::string,
                    file: *const root::std::string,
                    line: ::std::os::raw::c_int,
                ) -> Self {
                    let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                    SourcedException_SourcedException(
                        __bindgen_tmp.as_mut_ptr(),
                        category,
                        what,
                        function,
                        file,
                        line,
                    );
                    __bindgen_tmp.assume_init()
                }
                #[inline]
                pub unsafe fn new1(
                    what: *const root::std::string,
                    function: *const root::std::string,
                    file: *const root::std::string,
                    line: ::std::os::raw::c_int,
                ) -> Self {
                    let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                    SourcedException_SourcedException1(
                        __bindgen_tmp.as_mut_ptr(),
                        what,
                        function,
                        file,
                        line,
                    );
                    __bindgen_tmp.assume_init()
                }
            }
            extern "C" {
                #[link_name = "\u{1}_ZNK5aeron4util16SourcedException4whatEv"]
                pub fn SourcedException_what(
                    this: *mut ::std::os::raw::c_void,
                ) -> *const ::std::os::raw::c_char;
            }
            #[repr(C)]
            pub struct IOException {
                pub _base: root::aeron::util::SourcedException,
            }
            #[test]
            fn bindgen_test_layout_IOException() {
                assert_eq!(
                    ::std::mem::size_of::<IOException>(),
                    80usize,
                    concat!("Size of: ", stringify!(IOException))
                );
                assert_eq!(
                    ::std::mem::align_of::<IOException>(),
                    8usize,
                    concat!("Alignment of ", stringify!(IOException))
                );
            }
            extern "C" {
                #[link_name = "\u{1}_ZN5aeron4util11IOExceptionC1ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEES9_S9_i"]
                pub fn IOException_IOException(
                    this: *mut root::aeron::util::IOException,
                    what: *const root::std::string,
                    function: *const root::std::string,
                    file: *const root::std::string,
                    line: ::std::os::raw::c_int,
                );
            }
            impl IOException {
                #[inline]
                pub unsafe fn new(
                    what: *const root::std::string,
                    function: *const root::std::string,
                    file: *const root::std::string,
                    line: ::std::os::raw::c_int,
                ) -> Self {
                    let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                    IOException_IOException(__bindgen_tmp.as_mut_ptr(), what, function, file, line);
                    __bindgen_tmp.assume_init()
                }
            }
            #[repr(C)]
            pub struct FormatException {
                pub _base: root::aeron::util::SourcedException,
            }
            #[test]
            fn bindgen_test_layout_FormatException() {
                assert_eq!(
                    ::std::mem::size_of::<FormatException>(),
                    80usize,
                    concat!("Size of: ", stringify!(FormatException))
                );
                assert_eq!(
                    ::std::mem::align_of::<FormatException>(),
                    8usize,
                    concat!("Alignment of ", stringify!(FormatException))
                );
            }
            extern "C" {
                #[link_name = "\u{1}_ZN5aeron4util15FormatExceptionC1ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEES9_S9_i"]
                pub fn FormatException_FormatException(
                    this: *mut root::aeron::util::FormatException,
                    what: *const root::std::string,
                    function: *const root::std::string,
                    file: *const root::std::string,
                    line: ::std::os::raw::c_int,
                );
            }
            impl FormatException {
                #[inline]
                pub unsafe fn new(
                    what: *const root::std::string,
                    function: *const root::std::string,
                    file: *const root::std::string,
                    line: ::std::os::raw::c_int,
                ) -> Self {
                    let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                    FormatException_FormatException(
                        __bindgen_tmp.as_mut_ptr(),
                        what,
                        function,
                        file,
                        line,
                    );
                    __bindgen_tmp.assume_init()
                }
            }
            #[repr(C)]
            pub struct OutOfBoundsException {
                pub _base: root::aeron::util::SourcedException,
            }
            #[test]
            fn bindgen_test_layout_OutOfBoundsException() {
                assert_eq!(
                    ::std::mem::size_of::<OutOfBoundsException>(),
                    80usize,
                    concat!("Size of: ", stringify!(OutOfBoundsException))
                );
                assert_eq!(
                    ::std::mem::align_of::<OutOfBoundsException>(),
                    8usize,
                    concat!("Alignment of ", stringify!(OutOfBoundsException))
                );
            }
            extern "C" {
                #[link_name = "\u{1}_ZN5aeron4util20OutOfBoundsExceptionC1ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEES9_S9_i"]
                pub fn OutOfBoundsException_OutOfBoundsException(
                    this: *mut root::aeron::util::OutOfBoundsException,
                    what: *const root::std::string,
                    function: *const root::std::string,
                    file: *const root::std::string,
                    line: ::std::os::raw::c_int,
                );
            }
            impl OutOfBoundsException {
                #[inline]
                pub unsafe fn new(
                    what: *const root::std::string,
                    function: *const root::std::string,
                    file: *const root::std::string,
                    line: ::std::os::raw::c_int,
                ) -> Self {
                    let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                    OutOfBoundsException_OutOfBoundsException(
                        __bindgen_tmp.as_mut_ptr(),
                        what,
                        function,
                        file,
                        line,
                    );
                    __bindgen_tmp.assume_init()
                }
            }
            #[repr(C)]
            pub struct ParseException {
                pub _base: root::aeron::util::SourcedException,
            }
            #[test]
            fn bindgen_test_layout_ParseException() {
                assert_eq!(
                    ::std::mem::size_of::<ParseException>(),
                    80usize,
                    concat!("Size of: ", stringify!(ParseException))
                );
                assert_eq!(
                    ::std::mem::align_of::<ParseException>(),
                    8usize,
                    concat!("Alignment of ", stringify!(ParseException))
                );
            }
            extern "C" {
                #[link_name = "\u{1}_ZN5aeron4util14ParseExceptionC1ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEES9_S9_i"]
                pub fn ParseException_ParseException(
                    this: *mut root::aeron::util::ParseException,
                    what: *const root::std::string,
                    function: *const root::std::string,
                    file: *const root::std::string,
                    line: ::std::os::raw::c_int,
                );
            }
            impl ParseException {
                #[inline]
                pub unsafe fn new(
                    what: *const root::std::string,
                    function: *const root::std::string,
                    file: *const root::std::string,
                    line: ::std::os::raw::c_int,
                ) -> Self {
                    let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                    ParseException_ParseException(
                        __bindgen_tmp.as_mut_ptr(),
                        what,
                        function,
                        file,
                        line,
                    );
                    __bindgen_tmp.assume_init()
                }
            }
            #[repr(C)]
            pub struct ElementNotFound {
                pub _base: root::aeron::util::SourcedException,
            }
            #[test]
            fn bindgen_test_layout_ElementNotFound() {
                assert_eq!(
                    ::std::mem::size_of::<ElementNotFound>(),
                    80usize,
                    concat!("Size of: ", stringify!(ElementNotFound))
                );
                assert_eq!(
                    ::std::mem::align_of::<ElementNotFound>(),
                    8usize,
                    concat!("Alignment of ", stringify!(ElementNotFound))
                );
            }
            extern "C" {
                #[link_name = "\u{1}_ZN5aeron4util15ElementNotFoundC1ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEES9_S9_i"]
                pub fn ElementNotFound_ElementNotFound(
                    this: *mut root::aeron::util::ElementNotFound,
                    what: *const root::std::string,
                    function: *const root::std::string,
                    file: *const root::std::string,
                    line: ::std::os::raw::c_int,
                );
            }
            impl ElementNotFound {
                #[inline]
                pub unsafe fn new(
                    what: *const root::std::string,
                    function: *const root::std::string,
                    file: *const root::std::string,
                    line: ::std::os::raw::c_int,
                ) -> Self {
                    let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                    ElementNotFound_ElementNotFound(
                        __bindgen_tmp.as_mut_ptr(),
                        what,
                        function,
                        file,
                        line,
                    );
                    __bindgen_tmp.assume_init()
                }
            }
            #[repr(C)]
            pub struct IllegalArgumentException {
                pub _base: root::aeron::util::SourcedException,
            }
            #[test]
            fn bindgen_test_layout_IllegalArgumentException() {
                assert_eq!(
                    ::std::mem::size_of::<IllegalArgumentException>(),
                    80usize,
                    concat!("Size of: ", stringify!(IllegalArgumentException))
                );
                assert_eq!(
                    ::std::mem::align_of::<IllegalArgumentException>(),
                    8usize,
                    concat!("Alignment of ", stringify!(IllegalArgumentException))
                );
            }
            extern "C" {
                #[link_name = "\u{1}_ZN5aeron4util24IllegalArgumentExceptionC1ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEES9_S9_i"]
                pub fn IllegalArgumentException_IllegalArgumentException(
                    this: *mut root::aeron::util::IllegalArgumentException,
                    what: *const root::std::string,
                    function: *const root::std::string,
                    file: *const root::std::string,
                    line: ::std::os::raw::c_int,
                );
            }
            impl IllegalArgumentException {
                #[inline]
                pub unsafe fn new(
                    what: *const root::std::string,
                    function: *const root::std::string,
                    file: *const root::std::string,
                    line: ::std::os::raw::c_int,
                ) -> Self {
                    let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                    IllegalArgumentException_IllegalArgumentException(
                        __bindgen_tmp.as_mut_ptr(),
                        what,
                        function,
                        file,
                        line,
                    );
                    __bindgen_tmp.assume_init()
                }
            }
            #[repr(C)]
            pub struct IllegalStateException {
                pub _base: root::aeron::util::SourcedException,
            }
            #[test]
            fn bindgen_test_layout_IllegalStateException() {
                assert_eq!(
                    ::std::mem::size_of::<IllegalStateException>(),
                    80usize,
                    concat!("Size of: ", stringify!(IllegalStateException))
                );
                assert_eq!(
                    ::std::mem::align_of::<IllegalStateException>(),
                    8usize,
                    concat!("Alignment of ", stringify!(IllegalStateException))
                );
            }
            extern "C" {
                #[link_name = "\u{1}_ZN5aeron4util21IllegalStateExceptionC1ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEES9_S9_i"]
                pub fn IllegalStateException_IllegalStateException(
                    this: *mut root::aeron::util::IllegalStateException,
                    what: *const root::std::string,
                    function: *const root::std::string,
                    file: *const root::std::string,
                    line: ::std::os::raw::c_int,
                );
            }
            impl IllegalStateException {
                #[inline]
                pub unsafe fn new(
                    what: *const root::std::string,
                    function: *const root::std::string,
                    file: *const root::std::string,
                    line: ::std::os::raw::c_int,
                ) -> Self {
                    let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                    IllegalStateException_IllegalStateException(
                        __bindgen_tmp.as_mut_ptr(),
                        what,
                        function,
                        file,
                        line,
                    );
                    __bindgen_tmp.assume_init()
                }
            }
            #[repr(C)]
            pub struct DriverTimeoutException {
                pub _base: root::aeron::util::SourcedException,
            }
            #[test]
            fn bindgen_test_layout_DriverTimeoutException() {
                assert_eq!(
                    ::std::mem::size_of::<DriverTimeoutException>(),
                    80usize,
                    concat!("Size of: ", stringify!(DriverTimeoutException))
                );
                assert_eq!(
                    ::std::mem::align_of::<DriverTimeoutException>(),
                    8usize,
                    concat!("Alignment of ", stringify!(DriverTimeoutException))
                );
            }
            extern "C" {
                #[link_name = "\u{1}_ZN5aeron4util22DriverTimeoutExceptionC1ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEES9_S9_i"]
                pub fn DriverTimeoutException_DriverTimeoutException(
                    this: *mut root::aeron::util::DriverTimeoutException,
                    what: *const root::std::string,
                    function: *const root::std::string,
                    file: *const root::std::string,
                    line: ::std::os::raw::c_int,
                );
            }
            impl DriverTimeoutException {
                #[inline]
                pub unsafe fn new(
                    what: *const root::std::string,
                    function: *const root::std::string,
                    file: *const root::std::string,
                    line: ::std::os::raw::c_int,
                ) -> Self {
                    let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                    DriverTimeoutException_DriverTimeoutException(
                        __bindgen_tmp.as_mut_ptr(),
                        what,
                        function,
                        file,
                        line,
                    );
                    __bindgen_tmp.assume_init()
                }
            }
            #[repr(C)]
            pub struct ConductorServiceTimeoutException {
                pub _base: root::aeron::util::SourcedException,
            }
            #[test]
            fn bindgen_test_layout_ConductorServiceTimeoutException() {
                assert_eq!(
                    ::std::mem::size_of::<ConductorServiceTimeoutException>(),
                    80usize,
                    concat!("Size of: ", stringify!(ConductorServiceTimeoutException))
                );
                assert_eq!(
                    ::std::mem::align_of::<ConductorServiceTimeoutException>(),
                    8usize,
                    concat!(
                        "Alignment of ",
                        stringify!(ConductorServiceTimeoutException)
                    )
                );
            }
            extern "C" {
                #[link_name = "\u{1}_ZN5aeron4util32ConductorServiceTimeoutExceptionC1ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEES9_S9_i"]
                pub fn ConductorServiceTimeoutException_ConductorServiceTimeoutException(
                    this: *mut root::aeron::util::ConductorServiceTimeoutException,
                    what: *const root::std::string,
                    function: *const root::std::string,
                    file: *const root::std::string,
                    line: ::std::os::raw::c_int,
                );
            }
            impl ConductorServiceTimeoutException {
                #[inline]
                pub unsafe fn new(
                    what: *const root::std::string,
                    function: *const root::std::string,
                    file: *const root::std::string,
                    line: ::std::os::raw::c_int,
                ) -> Self {
                    let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                    ConductorServiceTimeoutException_ConductorServiceTimeoutException(
                        __bindgen_tmp.as_mut_ptr(),
                        what,
                        function,
                        file,
                        line,
                    );
                    __bindgen_tmp.assume_init()
                }
            }
            #[repr(C)]
            pub struct ClientTimeoutException {
                pub _base: root::aeron::util::SourcedException,
            }
            #[test]
            fn bindgen_test_layout_ClientTimeoutException() {
                assert_eq!(
                    ::std::mem::size_of::<ClientTimeoutException>(),
                    80usize,
                    concat!("Size of: ", stringify!(ClientTimeoutException))
                );
                assert_eq!(
                    ::std::mem::align_of::<ClientTimeoutException>(),
                    8usize,
                    concat!("Alignment of ", stringify!(ClientTimeoutException))
                );
            }
            extern "C" {
                #[link_name = "\u{1}_ZN5aeron4util22ClientTimeoutExceptionC1ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEES9_S9_i"]
                pub fn ClientTimeoutException_ClientTimeoutException(
                    this: *mut root::aeron::util::ClientTimeoutException,
                    what: *const root::std::string,
                    function: *const root::std::string,
                    file: *const root::std::string,
                    line: ::std::os::raw::c_int,
                );
            }
            impl ClientTimeoutException {
                #[inline]
                pub unsafe fn new(
                    what: *const root::std::string,
                    function: *const root::std::string,
                    file: *const root::std::string,
                    line: ::std::os::raw::c_int,
                ) -> Self {
                    let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                    ClientTimeoutException_ClientTimeoutException(
                        __bindgen_tmp.as_mut_ptr(),
                        what,
                        function,
                        file,
                        line,
                    );
                    __bindgen_tmp.assume_init()
                }
            }
            #[repr(C)]
            pub struct AeronException {
                pub _base: root::aeron::util::SourcedException,
            }
            #[test]
            fn bindgen_test_layout_AeronException() {
                assert_eq!(
                    ::std::mem::size_of::<AeronException>(),
                    80usize,
                    concat!("Size of: ", stringify!(AeronException))
                );
                assert_eq!(
                    ::std::mem::align_of::<AeronException>(),
                    8usize,
                    concat!("Alignment of ", stringify!(AeronException))
                );
            }
            extern "C" {
                #[link_name = "\u{1}_ZN5aeron4util14AeronExceptionC1ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEES9_S9_i"]
                pub fn AeronException_AeronException(
                    this: *mut root::aeron::util::AeronException,
                    what: *const root::std::string,
                    function: *const root::std::string,
                    file: *const root::std::string,
                    line: ::std::os::raw::c_int,
                );
            }
            impl AeronException {
                #[inline]
                pub unsafe fn new(
                    what: *const root::std::string,
                    function: *const root::std::string,
                    file: *const root::std::string,
                    line: ::std::os::raw::c_int,
                ) -> Self {
                    let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                    AeronException_AeronException(
                        __bindgen_tmp.as_mut_ptr(),
                        what,
                        function,
                        file,
                        line,
                    );
                    __bindgen_tmp.assume_init()
                }
            }
            #[repr(C)]
            pub struct UnknownSubscriptionException {
                pub _base: root::aeron::util::SourcedException,
            }
            #[test]
            fn bindgen_test_layout_UnknownSubscriptionException() {
                assert_eq!(
                    ::std::mem::size_of::<UnknownSubscriptionException>(),
                    80usize,
                    concat!("Size of: ", stringify!(UnknownSubscriptionException))
                );
                assert_eq!(
                    ::std::mem::align_of::<UnknownSubscriptionException>(),
                    8usize,
                    concat!("Alignment of ", stringify!(UnknownSubscriptionException))
                );
            }
            extern "C" {
                #[link_name = "\u{1}_ZN5aeron4util28UnknownSubscriptionExceptionC1ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEES9_S9_i"]
                pub fn UnknownSubscriptionException_UnknownSubscriptionException(
                    this: *mut root::aeron::util::UnknownSubscriptionException,
                    what: *const root::std::string,
                    function: *const root::std::string,
                    file: *const root::std::string,
                    line: ::std::os::raw::c_int,
                );
            }
            impl UnknownSubscriptionException {
                #[inline]
                pub unsafe fn new(
                    what: *const root::std::string,
                    function: *const root::std::string,
                    file: *const root::std::string,
                    line: ::std::os::raw::c_int,
                ) -> Self {
                    let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                    UnknownSubscriptionException_UnknownSubscriptionException(
                        __bindgen_tmp.as_mut_ptr(),
                        what,
                        function,
                        file,
                        line,
                    );
                    __bindgen_tmp.assume_init()
                }
            }
            #[repr(C)]
            pub struct ReentrantException {
                pub _base: root::aeron::util::SourcedException,
            }
            #[test]
            fn bindgen_test_layout_ReentrantException() {
                assert_eq!(
                    ::std::mem::size_of::<ReentrantException>(),
                    80usize,
                    concat!("Size of: ", stringify!(ReentrantException))
                );
                assert_eq!(
                    ::std::mem::align_of::<ReentrantException>(),
                    8usize,
                    concat!("Alignment of ", stringify!(ReentrantException))
                );
            }
            extern "C" {
                #[link_name = "\u{1}_ZN5aeron4util18ReentrantExceptionC1ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEES9_S9_i"]
                pub fn ReentrantException_ReentrantException(
                    this: *mut root::aeron::util::ReentrantException,
                    what: *const root::std::string,
                    function: *const root::std::string,
                    file: *const root::std::string,
                    line: ::std::os::raw::c_int,
                );
            }
            impl ReentrantException {
                #[inline]
                pub unsafe fn new(
                    what: *const root::std::string,
                    function: *const root::std::string,
                    file: *const root::std::string,
                    line: ::std::os::raw::c_int,
                ) -> Self {
                    let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                    ReentrantException_ReentrantException(
                        __bindgen_tmp.as_mut_ptr(),
                        what,
                        function,
                        file,
                        line,
                    );
                    __bindgen_tmp.assume_init()
                }
            }
            #[repr(C)]
            pub struct RegistrationException {
                pub _base: root::aeron::util::SourcedException,
                pub m_errorCode: ::std::os::raw::c_int,
            }
            #[test]
            fn bindgen_test_layout_RegistrationException() {
                const UNINIT: ::std::mem::MaybeUninit<RegistrationException> =
                    ::std::mem::MaybeUninit::uninit();
                let ptr = UNINIT.as_ptr();
                assert_eq!(
                    ::std::mem::size_of::<RegistrationException>(),
                    88usize,
                    concat!("Size of: ", stringify!(RegistrationException))
                );
                assert_eq!(
                    ::std::mem::align_of::<RegistrationException>(),
                    8usize,
                    concat!("Alignment of ", stringify!(RegistrationException))
                );
                assert_eq!(
                    unsafe { ::std::ptr::addr_of!((*ptr).m_errorCode) as usize - ptr as usize },
                    80usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(RegistrationException),
                        "::",
                        stringify!(m_errorCode)
                    )
                );
            }
            extern "C" {
                #[link_name = "\u{1}_ZNK5aeron4util21RegistrationException9errorCodeEv"]
                pub fn RegistrationException_errorCode(
                    this: *const root::aeron::util::RegistrationException,
                ) -> ::std::os::raw::c_int;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN5aeron4util21RegistrationExceptionC1EiNS0_17ExceptionCategoryERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESA_SA_i"]
                pub fn RegistrationException_RegistrationException(
                    this: *mut root::aeron::util::RegistrationException,
                    errorCode: ::std::os::raw::c_int,
                    exceptionCategory: root::aeron::util::ExceptionCategory,
                    what: *const root::std::string,
                    function: *const root::std::string,
                    file: *const root::std::string,
                    line: ::std::os::raw::c_int,
                );
            }
            impl RegistrationException {
                #[inline]
                pub unsafe fn errorCode(&self) -> ::std::os::raw::c_int {
                    RegistrationException_errorCode(self)
                }
                #[inline]
                pub unsafe fn new(
                    errorCode: ::std::os::raw::c_int,
                    exceptionCategory: root::aeron::util::ExceptionCategory,
                    what: *const root::std::string,
                    function: *const root::std::string,
                    file: *const root::std::string,
                    line: ::std::os::raw::c_int,
                ) -> Self {
                    let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                    RegistrationException_RegistrationException(
                        __bindgen_tmp.as_mut_ptr(),
                        errorCode,
                        exceptionCategory,
                        what,
                        function,
                        file,
                        line,
                    );
                    __bindgen_tmp.assume_init()
                }
            }
            #[repr(C)]
            pub struct TimeoutException {
                pub _base: root::aeron::util::AeronException,
            }
            #[test]
            fn bindgen_test_layout_TimeoutException() {
                assert_eq!(
                    ::std::mem::size_of::<TimeoutException>(),
                    80usize,
                    concat!("Size of: ", stringify!(TimeoutException))
                );
                assert_eq!(
                    ::std::mem::align_of::<TimeoutException>(),
                    8usize,
                    concat!("Alignment of ", stringify!(TimeoutException))
                );
            }
            extern "C" {
                #[link_name = "\u{1}_ZN5aeron4util16TimeoutExceptionC1ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEES9_S9_i"]
                pub fn TimeoutException_TimeoutException(
                    this: *mut root::aeron::util::TimeoutException,
                    what: *const root::std::string,
                    function: *const root::std::string,
                    file: *const root::std::string,
                    line: ::std::os::raw::c_int,
                );
            }
            impl TimeoutException {
                #[inline]
                pub unsafe fn new(
                    what: *const root::std::string,
                    function: *const root::std::string,
                    file: *const root::std::string,
                    line: ::std::os::raw::c_int,
                ) -> Self {
                    let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                    TimeoutException_TimeoutException(
                        __bindgen_tmp.as_mut_ptr(),
                        what,
                        function,
                        file,
                        line,
                    );
                    __bindgen_tmp.assume_init()
                }
            }
            #[repr(C)]
            pub struct ChannelEndpointException {
                pub _base: root::aeron::util::AeronException,
                pub m_statusIndicatorCounterId: ::std::os::raw::c_int,
            }
            #[test]
            fn bindgen_test_layout_ChannelEndpointException() {
                const UNINIT: ::std::mem::MaybeUninit<ChannelEndpointException> =
                    ::std::mem::MaybeUninit::uninit();
                let ptr = UNINIT.as_ptr();
                assert_eq!(
                    ::std::mem::size_of::<ChannelEndpointException>(),
                    88usize,
                    concat!("Size of: ", stringify!(ChannelEndpointException))
                );
                assert_eq!(
                    ::std::mem::align_of::<ChannelEndpointException>(),
                    8usize,
                    concat!("Alignment of ", stringify!(ChannelEndpointException))
                );
                assert_eq!(
                    unsafe {
                        ::std::ptr::addr_of!((*ptr).m_statusIndicatorCounterId) as usize
                            - ptr as usize
                    },
                    80usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(ChannelEndpointException),
                        "::",
                        stringify!(m_statusIndicatorCounterId)
                    )
                );
            }
            extern "C" {
                #[link_name = "\u{1}_ZNK5aeron4util24ChannelEndpointException17statusIndicatorIdEv"]
                pub fn ChannelEndpointException_statusIndicatorId(
                    this: *const root::aeron::util::ChannelEndpointException,
                ) -> ::std::os::raw::c_int;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN5aeron4util24ChannelEndpointExceptionC1EiRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEES9_S9_i"]
                pub fn ChannelEndpointException_ChannelEndpointException(
                    this: *mut root::aeron::util::ChannelEndpointException,
                    statusIndicatorCounterId: ::std::os::raw::c_int,
                    what: *const root::std::string,
                    function: *const root::std::string,
                    file: *const root::std::string,
                    line: ::std::os::raw::c_int,
                );
            }
            impl ChannelEndpointException {
                #[inline]
                pub unsafe fn statusIndicatorId(&self) -> ::std::os::raw::c_int {
                    ChannelEndpointException_statusIndicatorId(self)
                }
                #[inline]
                pub unsafe fn new(
                    statusIndicatorCounterId: ::std::os::raw::c_int,
                    what: *const root::std::string,
                    function: *const root::std::string,
                    file: *const root::std::string,
                    line: ::std::os::raw::c_int,
                ) -> Self {
                    let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                    ChannelEndpointException_ChannelEndpointException(
                        __bindgen_tmp.as_mut_ptr(),
                        statusIndicatorCounterId,
                        what,
                        function,
                        file,
                        line,
                    );
                    __bindgen_tmp.assume_init()
                }
            }
            extern "C" {
                #[link_name = "\u{1}_ZN5aeron4util10trimWSLeftENSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEPKc"]
                pub fn trimWSLeft(
                    str_: root::std::string,
                    wschars: *const ::std::os::raw::c_char,
                ) -> root::std::string;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN5aeron4util11trimWSRightENSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEPKc"]
                pub fn trimWSRight(
                    str_: root::std::string,
                    wschars: *const ::std::os::raw::c_char,
                ) -> root::std::string;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN5aeron4util10trimWSBothENSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEPKc"]
                pub fn trimWSBoth(
                    str_: root::std::string,
                    wschars: *const ::std::os::raw::c_char,
                ) -> root::std::string;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN5aeron4util10startsWithERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEmS8_"]
                pub fn startsWith(
                    input: *const root::std::string,
                    position: usize,
                    prefix: *const root::std::string,
                ) -> bool;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN5aeron4util8endsWithERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEES8_"]
                pub fn endsWith(
                    str_: *const root::std::string,
                    suffix: *const root::std::string,
                ) -> bool;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN5aeron4util9strPrintfB5cxx11EPKcz"]
                pub fn strPrintf(format: *const ::std::os::raw::c_char, ...) -> root::std::string;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN5aeron4util19continuationBarrierERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
                pub fn continuationBarrier(label: *const root::std::string) -> bool;
            }
            #[repr(C)]
            pub struct MemoryMappedFile {
                pub m_memory: *mut ::std::os::raw::c_uchar,
                pub m_memorySize: usize,
            }
            pub type MemoryMappedFile_ptr_t = [u64; 2usize];
            #[repr(C)]
            #[derive(Copy, Clone)]
            pub struct MemoryMappedFile_FileHandle {
                pub handle: ::std::os::raw::c_int,
            }
            #[test]
            fn bindgen_test_layout_MemoryMappedFile_FileHandle() {
                const UNINIT: ::std::mem::MaybeUninit<MemoryMappedFile_FileHandle> =
                    ::std::mem::MaybeUninit::uninit();
                let ptr = UNINIT.as_ptr();
                assert_eq!(
                    ::std::mem::size_of::<MemoryMappedFile_FileHandle>(),
                    4usize,
                    concat!("Size of: ", stringify!(MemoryMappedFile_FileHandle))
                );
                assert_eq!(
                    ::std::mem::align_of::<MemoryMappedFile_FileHandle>(),
                    4usize,
                    concat!("Alignment of ", stringify!(MemoryMappedFile_FileHandle))
                );
                assert_eq!(
                    unsafe { ::std::ptr::addr_of!((*ptr).handle) as usize - ptr as usize },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(MemoryMappedFile_FileHandle),
                        "::",
                        stringify!(handle)
                    )
                );
            }
            extern "C" {
                #[link_name = "\u{1}_ZN5aeron4util16MemoryMappedFile11m_page_sizeE"]
                pub static mut MemoryMappedFile_m_page_size: usize;
            }
            #[test]
            fn bindgen_test_layout_MemoryMappedFile() {
                const UNINIT: ::std::mem::MaybeUninit<MemoryMappedFile> =
                    ::std::mem::MaybeUninit::uninit();
                let ptr = UNINIT.as_ptr();
                assert_eq!(
                    ::std::mem::size_of::<MemoryMappedFile>(),
                    16usize,
                    concat!("Size of: ", stringify!(MemoryMappedFile))
                );
                assert_eq!(
                    ::std::mem::align_of::<MemoryMappedFile>(),
                    8usize,
                    concat!("Alignment of ", stringify!(MemoryMappedFile))
                );
                assert_eq!(
                    unsafe { ::std::ptr::addr_of!((*ptr).m_memory) as usize - ptr as usize },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(MemoryMappedFile),
                        "::",
                        stringify!(m_memory)
                    )
                );
                assert_eq!(
                    unsafe { ::std::ptr::addr_of!((*ptr).m_memorySize) as usize - ptr as usize },
                    8usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(MemoryMappedFile),
                        "::",
                        stringify!(m_memorySize)
                    )
                );
            }
            extern "C" {
                #[link_name = "\u{1}_ZN5aeron4util16MemoryMappedFile9createNewEPKclmb"]
                pub fn MemoryMappedFile_createNew(
                    filename: *const ::std::os::raw::c_char,
                    offset: root::off_t,
                    length: usize,
                    preTouch: bool,
                ) -> root::aeron::util::MemoryMappedFile_ptr_t;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN5aeron4util16MemoryMappedFile11mapExistingEPKclmbb"]
                pub fn MemoryMappedFile_mapExisting(
                    filename: *const ::std::os::raw::c_char,
                    offset: root::off_t,
                    length: usize,
                    readOnly: bool,
                    preTouch: bool,
                ) -> root::aeron::util::MemoryMappedFile_ptr_t;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN5aeron4util16MemoryMappedFile11mapExistingEPKcbb"]
                pub fn MemoryMappedFile_mapExisting1(
                    filename: *const ::std::os::raw::c_char,
                    readOnly: bool,
                    preTouch: bool,
                ) -> root::aeron::util::MemoryMappedFile_ptr_t;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN5aeron4util16MemoryMappedFile19mapExistingReadOnlyEPKc"]
                pub fn MemoryMappedFile_mapExistingReadOnly(
                    filename: *const ::std::os::raw::c_char,
                ) -> root::aeron::util::MemoryMappedFile_ptr_t;
            }
            extern "C" {
                #[link_name = "\u{1}_ZNK5aeron4util16MemoryMappedFile12getMemoryPtrEv"]
                pub fn MemoryMappedFile_getMemoryPtr(
                    this: *const root::aeron::util::MemoryMappedFile,
                ) -> *mut ::std::os::raw::c_uchar;
            }
            extern "C" {
                #[link_name = "\u{1}_ZNK5aeron4util16MemoryMappedFile13getMemorySizeEv"]
                pub fn MemoryMappedFile_getMemorySize(
                    this: *const root::aeron::util::MemoryMappedFile,
                ) -> usize;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN5aeron4util16MemoryMappedFile11getPageSizeEv"]
                pub fn MemoryMappedFile_getPageSize() -> usize;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN5aeron4util16MemoryMappedFile11getFileSizeEPKc"]
                pub fn MemoryMappedFile_getFileSize(
                    filename: *const ::std::os::raw::c_char,
                ) -> ::std::os::raw::c_long;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN5aeron4util16MemoryMappedFileD1Ev"]
                pub fn MemoryMappedFile_MemoryMappedFile_destructor(
                    this: *mut root::aeron::util::MemoryMappedFile,
                );
            }
            impl MemoryMappedFile {
                #[inline]
                pub unsafe fn createNew(
                    filename: *const ::std::os::raw::c_char,
                    offset: root::off_t,
                    length: usize,
                    preTouch: bool,
                ) -> root::aeron::util::MemoryMappedFile_ptr_t {
                    MemoryMappedFile_createNew(filename, offset, length, preTouch)
                }
                #[inline]
                pub unsafe fn mapExisting(
                    filename: *const ::std::os::raw::c_char,
                    offset: root::off_t,
                    length: usize,
                    readOnly: bool,
                    preTouch: bool,
                ) -> root::aeron::util::MemoryMappedFile_ptr_t {
                    MemoryMappedFile_mapExisting(filename, offset, length, readOnly, preTouch)
                }
                #[inline]
                pub unsafe fn mapExisting1(
                    filename: *const ::std::os::raw::c_char,
                    readOnly: bool,
                    preTouch: bool,
                ) -> root::aeron::util::MemoryMappedFile_ptr_t {
                    MemoryMappedFile_mapExisting1(filename, readOnly, preTouch)
                }
                #[inline]
                pub unsafe fn mapExistingReadOnly(
                    filename: *const ::std::os::raw::c_char,
                ) -> root::aeron::util::MemoryMappedFile_ptr_t {
                    MemoryMappedFile_mapExistingReadOnly(filename)
                }
                #[inline]
                pub unsafe fn getMemoryPtr(&self) -> *mut ::std::os::raw::c_uchar {
                    MemoryMappedFile_getMemoryPtr(self)
                }
                #[inline]
                pub unsafe fn getMemorySize(&self) -> usize {
                    MemoryMappedFile_getMemorySize(self)
                }
                #[inline]
                pub unsafe fn getPageSize() -> usize {
                    MemoryMappedFile_getPageSize()
                }
                #[inline]
                pub unsafe fn getFileSize(
                    filename: *const ::std::os::raw::c_char,
                ) -> ::std::os::raw::c_long {
                    MemoryMappedFile_getFileSize(filename)
                }
                #[inline]
                pub unsafe fn destruct(&mut self) {
                    MemoryMappedFile_MemoryMappedFile_destructor(self)
                }
            }
        }
        pub mod concurrent {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            pub mod atomic {
                #[allow(unused_imports)]
                use self::super::super::super::super::root;
                extern "C" {
                    #[link_name = "\u{1}_ZN5aeron10concurrent6atomic12thread_fenceEv"]
                    pub fn thread_fence();
                }
                extern "C" {
                    #[link_name = "\u{1}_ZN5aeron10concurrent6atomic5fenceEv"]
                    pub fn fence();
                }
                extern "C" {
                    #[link_name = "\u{1}_ZN5aeron10concurrent6atomic7acquireEv"]
                    pub fn acquire();
                }
                extern "C" {
                    #[link_name = "\u{1}_ZN5aeron10concurrent6atomic7releaseEv"]
                    pub fn release();
                }
                extern "C" {
                    #[link_name = "\u{1}_ZN5aeron10concurrent6atomic9cpu_pauseEv"]
                    pub fn cpu_pause();
                }
                extern "C" {
                    #[link_name = "\u{1}_ZN5aeron10concurrent6atomic16getInt32VolatileEPVi"]
                    pub fn getInt32Volatile(
                        source: *mut ::std::os::raw::c_int,
                    ) -> ::std::os::raw::c_int;
                }
                extern "C" {
                    #[link_name = "\u{1}_ZN5aeron10concurrent6atomic16putInt32VolatileEPVii"]
                    pub fn putInt32Volatile(
                        address: *mut ::std::os::raw::c_int,
                        value: ::std::os::raw::c_int,
                    );
                }
                extern "C" {
                    #[link_name = "\u{1}_ZN5aeron10concurrent6atomic15putInt32OrderedEPVii"]
                    pub fn putInt32Ordered(
                        address: *mut ::std::os::raw::c_int,
                        value: ::std::os::raw::c_int,
                    );
                }
                extern "C" {
                    #[link_name = "\u{1}_ZN5aeron10concurrent6atomic14putInt32AtomicEPVii"]
                    pub fn putInt32Atomic(
                        address: *mut ::std::os::raw::c_int,
                        value: ::std::os::raw::c_int,
                    );
                }
                extern "C" {
                    #[link_name = "\u{1}_ZN5aeron10concurrent6atomic16getInt64VolatileEPVl"]
                    pub fn getInt64Volatile(
                        source: *mut ::std::os::raw::c_long,
                    ) -> ::std::os::raw::c_long;
                }
                extern "C" {
                    #[link_name = "\u{1}_ZN5aeron10concurrent6atomic16putInt64VolatileEPVll"]
                    pub fn putInt64Volatile(
                        address: *mut ::std::os::raw::c_long,
                        value: ::std::os::raw::c_long,
                    );
                }
                extern "C" {
                    #[link_name = "\u{1}_ZN5aeron10concurrent6atomic15putInt64OrderedEPVll"]
                    pub fn putInt64Ordered(
                        address: *mut ::std::os::raw::c_long,
                        value: ::std::os::raw::c_long,
                    );
                }
                extern "C" {
                    #[link_name = "\u{1}_ZN5aeron10concurrent6atomic14putInt64AtomicEPVll"]
                    pub fn putInt64Atomic(
                        address: *mut ::std::os::raw::c_long,
                        value: ::std::os::raw::c_long,
                    );
                }
                extern "C" {
                    #[link_name = "\u{1}_ZN5aeron10concurrent6atomic14getAndAddInt64EPVll"]
                    pub fn getAndAddInt64(
                        address: *mut ::std::os::raw::c_long,
                        value: ::std::os::raw::c_long,
                    ) -> ::std::os::raw::c_long;
                }
                extern "C" {
                    #[link_name = "\u{1}_ZN5aeron10concurrent6atomic14getAndAddInt32EPVii"]
                    pub fn getAndAddInt32(
                        address: *mut ::std::os::raw::c_int,
                        value: ::std::os::raw::c_int,
                    ) -> ::std::os::raw::c_int;
                }
                extern "C" {
                    #[link_name = "\u{1}_ZN5aeron10concurrent6atomic4xchgEPVii"]
                    pub fn xchg(
                        address: *mut ::std::os::raw::c_int,
                        value: ::std::os::raw::c_int,
                    ) -> ::std::os::raw::c_int;
                }
                extern "C" {
                    #[link_name = "\u{1}_ZN5aeron10concurrent6atomic4xchgEPVll"]
                    pub fn xchg1(
                        address: *mut ::std::os::raw::c_long,
                        value: ::std::os::raw::c_long,
                    ) -> ::std::os::raw::c_long;
                }
                extern "C" {
                    #[link_name = "\u{1}_ZN5aeron10concurrent6atomic7cmpxchgEPViii"]
                    pub fn cmpxchg(
                        address: *mut ::std::os::raw::c_int,
                        expected: ::std::os::raw::c_int,
                        desired: ::std::os::raw::c_int,
                    ) -> ::std::os::raw::c_int;
                }
                extern "C" {
                    #[link_name = "\u{1}_ZN5aeron10concurrent6atomic7cmpxchgEPVlll"]
                    pub fn cmpxchg1(
                        address: *mut ::std::os::raw::c_long,
                        expected: ::std::os::raw::c_long,
                        desired: ::std::os::raw::c_long,
                    ) -> ::std::os::raw::c_long;
                }
            }
            #[repr(C)]
            #[derive(Copy, Clone)]
            pub struct AtomicBuffer {
                pub m_buffer: *mut ::std::os::raw::c_uchar,
                pub m_length: root::aeron::concurrent::AtomicBuffer_length_t,
            }
            pub type AtomicBuffer_length_t = ::std::os::raw::c_uint;
            #[test]
            fn bindgen_test_layout_AtomicBuffer() {
                const UNINIT: ::std::mem::MaybeUninit<AtomicBuffer> =
                    ::std::mem::MaybeUninit::uninit();
                let ptr = UNINIT.as_ptr();
                assert_eq!(
                    ::std::mem::size_of::<AtomicBuffer>(),
                    16usize,
                    concat!("Size of: ", stringify!(AtomicBuffer))
                );
                assert_eq!(
                    ::std::mem::align_of::<AtomicBuffer>(),
                    8usize,
                    concat!("Alignment of ", stringify!(AtomicBuffer))
                );
                assert_eq!(
                    unsafe { ::std::ptr::addr_of!((*ptr).m_buffer) as usize - ptr as usize },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(AtomicBuffer),
                        "::",
                        stringify!(m_buffer)
                    )
                );
                assert_eq!(
                    unsafe { ::std::ptr::addr_of!((*ptr).m_length) as usize - ptr as usize },
                    8usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(AtomicBuffer),
                        "::",
                        stringify!(m_length)
                    )
                );
            }
            extern "C" {
                #[link_name = "\u{1}_ZN5aeron10concurrent12AtomicBuffer4wrapEPhm"]
                pub fn AtomicBuffer_wrap(
                    this: *mut root::aeron::concurrent::AtomicBuffer,
                    buffer: *mut ::std::os::raw::c_uchar,
                    length: usize,
                );
            }
            extern "C" {
                #[link_name = "\u{1}_ZN5aeron10concurrent12AtomicBuffer4wrapERKS1_"]
                pub fn AtomicBuffer_wrap1(
                    this: *mut root::aeron::concurrent::AtomicBuffer,
                    buffer: *const root::aeron::concurrent::AtomicBuffer,
                );
            }
            extern "C" {
                #[link_name = "\u{1}_ZNK5aeron10concurrent12AtomicBuffer8capacityEv"]
                pub fn AtomicBuffer_capacity(
                    this: *const root::aeron::concurrent::AtomicBuffer,
                ) -> root::aeron::util::index_t;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN5aeron10concurrent12AtomicBuffer8capacityEm"]
                pub fn AtomicBuffer_capacity1(
                    this: *mut root::aeron::concurrent::AtomicBuffer,
                    length: usize,
                );
            }
            extern "C" {
                #[link_name = "\u{1}_ZNK5aeron10concurrent12AtomicBuffer6bufferEv"]
                pub fn AtomicBuffer_buffer(
                    this: *const root::aeron::concurrent::AtomicBuffer,
                ) -> *mut ::std::os::raw::c_uchar;
            }
            extern "C" {
                #[link_name = "\u{1}_ZNK5aeron10concurrent12AtomicBuffer7sbeDataEv"]
                pub fn AtomicBuffer_sbeData(
                    this: *const root::aeron::concurrent::AtomicBuffer,
                ) -> *mut ::std::os::raw::c_char;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN5aeron10concurrent12AtomicBuffer8putInt64Eil"]
                pub fn AtomicBuffer_putInt64(
                    this: *mut root::aeron::concurrent::AtomicBuffer,
                    offset: root::aeron::util::index_t,
                    v: ::std::os::raw::c_long,
                );
            }
            extern "C" {
                #[link_name = "\u{1}_ZNK5aeron10concurrent12AtomicBuffer8getInt64Ei"]
                pub fn AtomicBuffer_getInt64(
                    this: *const root::aeron::concurrent::AtomicBuffer,
                    offset: root::aeron::util::index_t,
                ) -> ::std::os::raw::c_long;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN5aeron10concurrent12AtomicBuffer8putInt32Eii"]
                pub fn AtomicBuffer_putInt32(
                    this: *mut root::aeron::concurrent::AtomicBuffer,
                    offset: root::aeron::util::index_t,
                    v: ::std::os::raw::c_int,
                );
            }
            extern "C" {
                #[link_name = "\u{1}_ZNK5aeron10concurrent12AtomicBuffer8getInt32Ei"]
                pub fn AtomicBuffer_getInt32(
                    this: *const root::aeron::concurrent::AtomicBuffer,
                    offset: root::aeron::util::index_t,
                ) -> ::std::os::raw::c_int;
            }
            extern "C" {
                #[link_name = "\u{1}_ZNK5aeron10concurrent12AtomicBuffer8getInt16Ei"]
                pub fn AtomicBuffer_getInt16(
                    this: *const root::aeron::concurrent::AtomicBuffer,
                    offset: root::aeron::util::index_t,
                ) -> ::std::os::raw::c_short;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN5aeron10concurrent12AtomicBuffer8putInt16Eis"]
                pub fn AtomicBuffer_putInt16(
                    this: *mut root::aeron::concurrent::AtomicBuffer,
                    offset: root::aeron::util::index_t,
                    v: ::std::os::raw::c_short,
                );
            }
            extern "C" {
                #[link_name = "\u{1}_ZNK5aeron10concurrent12AtomicBuffer9getUInt16Ei"]
                pub fn AtomicBuffer_getUInt16(
                    this: *const root::aeron::concurrent::AtomicBuffer,
                    offset: root::aeron::util::index_t,
                ) -> ::std::os::raw::c_ushort;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN5aeron10concurrent12AtomicBuffer9putUInt16Eit"]
                pub fn AtomicBuffer_putUInt16(
                    this: *mut root::aeron::concurrent::AtomicBuffer,
                    offset: root::aeron::util::index_t,
                    v: ::std::os::raw::c_ushort,
                );
            }
            extern "C" {
                #[link_name = "\u{1}_ZNK5aeron10concurrent12AtomicBuffer8getUInt8Ei"]
                pub fn AtomicBuffer_getUInt8(
                    this: *const root::aeron::concurrent::AtomicBuffer,
                    offset: root::aeron::util::index_t,
                ) -> ::std::os::raw::c_uchar;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN5aeron10concurrent12AtomicBuffer8putUInt8Eih"]
                pub fn AtomicBuffer_putUInt8(
                    this: *mut root::aeron::concurrent::AtomicBuffer,
                    offset: root::aeron::util::index_t,
                    v: ::std::os::raw::c_uchar,
                );
            }
            extern "C" {
                #[link_name = "\u{1}_ZN5aeron10concurrent12AtomicBuffer15putInt64OrderedEil"]
                pub fn AtomicBuffer_putInt64Ordered(
                    this: *mut root::aeron::concurrent::AtomicBuffer,
                    offset: root::aeron::util::index_t,
                    v: ::std::os::raw::c_long,
                );
            }
            extern "C" {
                #[link_name = "\u{1}_ZNK5aeron10concurrent12AtomicBuffer16getInt64VolatileEi"]
                pub fn AtomicBuffer_getInt64Volatile(
                    this: *const root::aeron::concurrent::AtomicBuffer,
                    offset: root::aeron::util::index_t,
                ) -> ::std::os::raw::c_long;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN5aeron10concurrent12AtomicBuffer15putInt32OrderedEii"]
                pub fn AtomicBuffer_putInt32Ordered(
                    this: *mut root::aeron::concurrent::AtomicBuffer,
                    offset: root::aeron::util::index_t,
                    v: ::std::os::raw::c_int,
                );
            }
            extern "C" {
                #[link_name = "\u{1}_ZNK5aeron10concurrent12AtomicBuffer16getInt32VolatileEi"]
                pub fn AtomicBuffer_getInt32Volatile(
                    this: *const root::aeron::concurrent::AtomicBuffer,
                    offset: root::aeron::util::index_t,
                ) -> ::std::os::raw::c_int;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN5aeron10concurrent12AtomicBuffer14putInt64AtomicEil"]
                pub fn AtomicBuffer_putInt64Atomic(
                    this: *mut root::aeron::concurrent::AtomicBuffer,
                    offset: root::aeron::util::index_t,
                    v: ::std::os::raw::c_long,
                );
            }
            extern "C" {
                #[link_name = "\u{1}_ZN5aeron10concurrent12AtomicBuffer14putInt32AtomicEii"]
                pub fn AtomicBuffer_putInt32Atomic(
                    this: *mut root::aeron::concurrent::AtomicBuffer,
                    offset: root::aeron::util::index_t,
                    v: ::std::os::raw::c_int,
                );
            }
            extern "C" {
                #[link_name = "\u{1}_ZN5aeron10concurrent12AtomicBuffer15addInt64OrderedEil"]
                pub fn AtomicBuffer_addInt64Ordered(
                    this: *mut root::aeron::concurrent::AtomicBuffer,
                    offset: root::aeron::util::index_t,
                    delta: ::std::os::raw::c_long,
                );
            }
            extern "C" {
                #[link_name = "\u{1}_ZN5aeron10concurrent12AtomicBuffer18compareAndSetInt64Eill"]
                pub fn AtomicBuffer_compareAndSetInt64(
                    this: *mut root::aeron::concurrent::AtomicBuffer,
                    offset: root::aeron::util::index_t,
                    expectedValue: ::std::os::raw::c_long,
                    updateValue: ::std::os::raw::c_long,
                ) -> bool;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN5aeron10concurrent12AtomicBuffer14getAndSetInt64Eil"]
                pub fn AtomicBuffer_getAndSetInt64(
                    this: *mut root::aeron::concurrent::AtomicBuffer,
                    offset: root::aeron::util::index_t,
                    value: ::std::os::raw::c_long,
                ) -> ::std::os::raw::c_long;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN5aeron10concurrent12AtomicBuffer14getAndSetInt32Eii"]
                pub fn AtomicBuffer_getAndSetInt32(
                    this: *mut root::aeron::concurrent::AtomicBuffer,
                    offset: root::aeron::util::index_t,
                    value: ::std::os::raw::c_int,
                ) -> ::std::os::raw::c_int;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN5aeron10concurrent12AtomicBuffer14getAndAddInt64Eil"]
                pub fn AtomicBuffer_getAndAddInt64(
                    this: *mut root::aeron::concurrent::AtomicBuffer,
                    offset: root::aeron::util::index_t,
                    delta: ::std::os::raw::c_long,
                ) -> ::std::os::raw::c_long;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN5aeron10concurrent12AtomicBuffer15addInt32OrderedEii"]
                pub fn AtomicBuffer_addInt32Ordered(
                    this: *mut root::aeron::concurrent::AtomicBuffer,
                    offset: root::aeron::util::index_t,
                    delta: ::std::os::raw::c_int,
                );
            }
            extern "C" {
                #[link_name = "\u{1}_ZN5aeron10concurrent12AtomicBuffer18compareAndSetInt32Eiii"]
                pub fn AtomicBuffer_compareAndSetInt32(
                    this: *mut root::aeron::concurrent::AtomicBuffer,
                    offset: root::aeron::util::index_t,
                    expectedValue: ::std::os::raw::c_int,
                    updateValue: ::std::os::raw::c_int,
                ) -> bool;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN5aeron10concurrent12AtomicBuffer14getAndAddInt32Eii"]
                pub fn AtomicBuffer_getAndAddInt32(
                    this: *mut root::aeron::concurrent::AtomicBuffer,
                    offset: root::aeron::util::index_t,
                    delta: ::std::os::raw::c_int,
                ) -> ::std::os::raw::c_int;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN5aeron10concurrent12AtomicBuffer8putBytesEiRKS1_ii"]
                pub fn AtomicBuffer_putBytes(
                    this: *mut root::aeron::concurrent::AtomicBuffer,
                    index: root::aeron::util::index_t,
                    srcBuffer: *const root::aeron::concurrent::AtomicBuffer,
                    srcIndex: root::aeron::util::index_t,
                    length: root::aeron::util::index_t,
                );
            }
            extern "C" {
                #[link_name = "\u{1}_ZN5aeron10concurrent12AtomicBuffer8putBytesEiPKhi"]
                pub fn AtomicBuffer_putBytes1(
                    this: *mut root::aeron::concurrent::AtomicBuffer,
                    index: root::aeron::util::index_t,
                    srcBuffer: *mut ::std::os::raw::c_uchar,
                    length: root::aeron::util::index_t,
                );
            }
            extern "C" {
                #[link_name = "\u{1}_ZNK5aeron10concurrent12AtomicBuffer8getBytesEiPhi"]
                pub fn AtomicBuffer_getBytes(
                    this: *const root::aeron::concurrent::AtomicBuffer,
                    index: root::aeron::util::index_t,
                    dst: *mut ::std::os::raw::c_uchar,
                    length: root::aeron::util::index_t,
                );
            }
            extern "C" {
                #[link_name = "\u{1}_ZN5aeron10concurrent12AtomicBuffer9setMemoryEimh"]
                pub fn AtomicBuffer_setMemory(
                    this: *mut root::aeron::concurrent::AtomicBuffer,
                    offset: root::aeron::util::index_t,
                    length: usize,
                    value: ::std::os::raw::c_uchar,
                );
            }
            extern "C" {
                #[link_name = "\u{1}_ZNK5aeron10concurrent12AtomicBuffer9getStringB5cxx11Ei"]
                pub fn AtomicBuffer_getString(
                    this: *const root::aeron::concurrent::AtomicBuffer,
                    offset: root::aeron::util::index_t,
                ) -> root::std::string;
            }
            extern "C" {
                #[link_name = "\u{1}_ZNK5aeron10concurrent12AtomicBuffer22getStringWithoutLengthB5cxx11Eim"]
                pub fn AtomicBuffer_getStringWithoutLength(
                    this: *const root::aeron::concurrent::AtomicBuffer,
                    offset: root::aeron::util::index_t,
                    length: usize,
                ) -> root::std::string;
            }
            extern "C" {
                #[link_name = "\u{1}_ZNK5aeron10concurrent12AtomicBuffer15getStringLengthEi"]
                pub fn AtomicBuffer_getStringLength(
                    this: *const root::aeron::concurrent::AtomicBuffer,
                    offset: root::aeron::util::index_t,
                ) -> ::std::os::raw::c_int;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN5aeron10concurrent12AtomicBuffer9putStringEiRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
                pub fn AtomicBuffer_putString(
                    this: *mut root::aeron::concurrent::AtomicBuffer,
                    offset: root::aeron::util::index_t,
                    value: *const root::std::string,
                ) -> ::std::os::raw::c_int;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN5aeron10concurrent12AtomicBuffer22putStringWithoutLengthEiRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
                pub fn AtomicBuffer_putStringWithoutLength(
                    this: *mut root::aeron::concurrent::AtomicBuffer,
                    offset: root::aeron::util::index_t,
                    value: *const root::std::string,
                ) -> ::std::os::raw::c_int;
            }
            extern "C" {
                #[link_name = "\u{1}_ZNK5aeron10concurrent12AtomicBuffer11boundsCheckEim"]
                pub fn AtomicBuffer_boundsCheck(
                    this: *const root::aeron::concurrent::AtomicBuffer,
                    index: root::aeron::util::index_t,
                    length: ::std::os::raw::c_ulong,
                );
            }
            extern "C" {
                #[link_name = "\u{1}_ZN5aeron10concurrent12AtomicBufferC1Ev"]
                pub fn AtomicBuffer_AtomicBuffer(this: *mut root::aeron::concurrent::AtomicBuffer);
            }
            extern "C" {
                #[link_name = "\u{1}_ZN5aeron10concurrent12AtomicBufferC1EPhm"]
                pub fn AtomicBuffer_AtomicBuffer1(
                    this: *mut root::aeron::concurrent::AtomicBuffer,
                    buffer: *mut ::std::os::raw::c_uchar,
                    length: usize,
                );
            }
            extern "C" {
                #[link_name = "\u{1}_ZN5aeron10concurrent12AtomicBufferC1EPhmh"]
                pub fn AtomicBuffer_AtomicBuffer2(
                    this: *mut root::aeron::concurrent::AtomicBuffer,
                    buffer: *mut ::std::os::raw::c_uchar,
                    length: usize,
                    initialValue: ::std::os::raw::c_uchar,
                );
            }
            impl AtomicBuffer {
                #[inline]
                pub unsafe fn wrap(&mut self, buffer: *mut ::std::os::raw::c_uchar, length: usize) {
                    AtomicBuffer_wrap(self, buffer, length)
                }
                #[inline]
                pub unsafe fn wrap1(
                    &mut self,
                    buffer: *const root::aeron::concurrent::AtomicBuffer,
                ) {
                    AtomicBuffer_wrap1(self, buffer)
                }
                #[inline]
                pub unsafe fn capacity(&self) -> root::aeron::util::index_t {
                    AtomicBuffer_capacity(self)
                }
                #[inline]
                pub unsafe fn capacity1(&mut self, length: usize) {
                    AtomicBuffer_capacity1(self, length)
                }
                #[inline]
                pub unsafe fn buffer(&self) -> *mut ::std::os::raw::c_uchar {
                    AtomicBuffer_buffer(self)
                }
                #[inline]
                pub unsafe fn sbeData(&self) -> *mut ::std::os::raw::c_char {
                    AtomicBuffer_sbeData(self)
                }
                #[inline]
                pub unsafe fn putInt64(
                    &mut self,
                    offset: root::aeron::util::index_t,
                    v: ::std::os::raw::c_long,
                ) {
                    AtomicBuffer_putInt64(self, offset, v)
                }
                #[inline]
                pub unsafe fn getInt64(
                    &self,
                    offset: root::aeron::util::index_t,
                ) -> ::std::os::raw::c_long {
                    AtomicBuffer_getInt64(self, offset)
                }
                #[inline]
                pub unsafe fn putInt32(
                    &mut self,
                    offset: root::aeron::util::index_t,
                    v: ::std::os::raw::c_int,
                ) {
                    AtomicBuffer_putInt32(self, offset, v)
                }
                #[inline]
                pub unsafe fn getInt32(
                    &self,
                    offset: root::aeron::util::index_t,
                ) -> ::std::os::raw::c_int {
                    AtomicBuffer_getInt32(self, offset)
                }
                #[inline]
                pub unsafe fn getInt16(
                    &self,
                    offset: root::aeron::util::index_t,
                ) -> ::std::os::raw::c_short {
                    AtomicBuffer_getInt16(self, offset)
                }
                #[inline]
                pub unsafe fn putInt16(
                    &mut self,
                    offset: root::aeron::util::index_t,
                    v: ::std::os::raw::c_short,
                ) {
                    AtomicBuffer_putInt16(self, offset, v)
                }
                #[inline]
                pub unsafe fn getUInt16(
                    &self,
                    offset: root::aeron::util::index_t,
                ) -> ::std::os::raw::c_ushort {
                    AtomicBuffer_getUInt16(self, offset)
                }
                #[inline]
                pub unsafe fn putUInt16(
                    &mut self,
                    offset: root::aeron::util::index_t,
                    v: ::std::os::raw::c_ushort,
                ) {
                    AtomicBuffer_putUInt16(self, offset, v)
                }
                #[inline]
                pub unsafe fn getUInt8(
                    &self,
                    offset: root::aeron::util::index_t,
                ) -> ::std::os::raw::c_uchar {
                    AtomicBuffer_getUInt8(self, offset)
                }
                #[inline]
                pub unsafe fn putUInt8(
                    &mut self,
                    offset: root::aeron::util::index_t,
                    v: ::std::os::raw::c_uchar,
                ) {
                    AtomicBuffer_putUInt8(self, offset, v)
                }
                #[inline]
                pub unsafe fn putInt64Ordered(
                    &mut self,
                    offset: root::aeron::util::index_t,
                    v: ::std::os::raw::c_long,
                ) {
                    AtomicBuffer_putInt64Ordered(self, offset, v)
                }
                #[inline]
                pub unsafe fn getInt64Volatile(
                    &self,
                    offset: root::aeron::util::index_t,
                ) -> ::std::os::raw::c_long {
                    AtomicBuffer_getInt64Volatile(self, offset)
                }
                #[inline]
                pub unsafe fn putInt32Ordered(
                    &mut self,
                    offset: root::aeron::util::index_t,
                    v: ::std::os::raw::c_int,
                ) {
                    AtomicBuffer_putInt32Ordered(self, offset, v)
                }
                #[inline]
                pub unsafe fn getInt32Volatile(
                    &self,
                    offset: root::aeron::util::index_t,
                ) -> ::std::os::raw::c_int {
                    AtomicBuffer_getInt32Volatile(self, offset)
                }
                #[inline]
                pub unsafe fn putInt64Atomic(
                    &mut self,
                    offset: root::aeron::util::index_t,
                    v: ::std::os::raw::c_long,
                ) {
                    AtomicBuffer_putInt64Atomic(self, offset, v)
                }
                #[inline]
                pub unsafe fn putInt32Atomic(
                    &mut self,
                    offset: root::aeron::util::index_t,
                    v: ::std::os::raw::c_int,
                ) {
                    AtomicBuffer_putInt32Atomic(self, offset, v)
                }
                #[inline]
                pub unsafe fn addInt64Ordered(
                    &mut self,
                    offset: root::aeron::util::index_t,
                    delta: ::std::os::raw::c_long,
                ) {
                    AtomicBuffer_addInt64Ordered(self, offset, delta)
                }
                #[inline]
                pub unsafe fn compareAndSetInt64(
                    &mut self,
                    offset: root::aeron::util::index_t,
                    expectedValue: ::std::os::raw::c_long,
                    updateValue: ::std::os::raw::c_long,
                ) -> bool {
                    AtomicBuffer_compareAndSetInt64(self, offset, expectedValue, updateValue)
                }
                #[inline]
                pub unsafe fn getAndSetInt64(
                    &mut self,
                    offset: root::aeron::util::index_t,
                    value: ::std::os::raw::c_long,
                ) -> ::std::os::raw::c_long {
                    AtomicBuffer_getAndSetInt64(self, offset, value)
                }
                #[inline]
                pub unsafe fn getAndSetInt32(
                    &mut self,
                    offset: root::aeron::util::index_t,
                    value: ::std::os::raw::c_int,
                ) -> ::std::os::raw::c_int {
                    AtomicBuffer_getAndSetInt32(self, offset, value)
                }
                #[inline]
                pub unsafe fn getAndAddInt64(
                    &mut self,
                    offset: root::aeron::util::index_t,
                    delta: ::std::os::raw::c_long,
                ) -> ::std::os::raw::c_long {
                    AtomicBuffer_getAndAddInt64(self, offset, delta)
                }
                #[inline]
                pub unsafe fn addInt32Ordered(
                    &mut self,
                    offset: root::aeron::util::index_t,
                    delta: ::std::os::raw::c_int,
                ) {
                    AtomicBuffer_addInt32Ordered(self, offset, delta)
                }
                #[inline]
                pub unsafe fn compareAndSetInt32(
                    &mut self,
                    offset: root::aeron::util::index_t,
                    expectedValue: ::std::os::raw::c_int,
                    updateValue: ::std::os::raw::c_int,
                ) -> bool {
                    AtomicBuffer_compareAndSetInt32(self, offset, expectedValue, updateValue)
                }
                #[inline]
                pub unsafe fn getAndAddInt32(
                    &mut self,
                    offset: root::aeron::util::index_t,
                    delta: ::std::os::raw::c_int,
                ) -> ::std::os::raw::c_int {
                    AtomicBuffer_getAndAddInt32(self, offset, delta)
                }
                #[inline]
                pub unsafe fn putBytes(
                    &mut self,
                    index: root::aeron::util::index_t,
                    srcBuffer: *const root::aeron::concurrent::AtomicBuffer,
                    srcIndex: root::aeron::util::index_t,
                    length: root::aeron::util::index_t,
                ) {
                    AtomicBuffer_putBytes(self, index, srcBuffer, srcIndex, length)
                }
                #[inline]
                pub unsafe fn putBytes1(
                    &mut self,
                    index: root::aeron::util::index_t,
                    srcBuffer: *mut ::std::os::raw::c_uchar,
                    length: root::aeron::util::index_t,
                ) {
                    AtomicBuffer_putBytes1(self, index, srcBuffer, length)
                }
                #[inline]
                pub unsafe fn getBytes(
                    &self,
                    index: root::aeron::util::index_t,
                    dst: *mut ::std::os::raw::c_uchar,
                    length: root::aeron::util::index_t,
                ) {
                    AtomicBuffer_getBytes(self, index, dst, length)
                }
                #[inline]
                pub unsafe fn setMemory(
                    &mut self,
                    offset: root::aeron::util::index_t,
                    length: usize,
                    value: ::std::os::raw::c_uchar,
                ) {
                    AtomicBuffer_setMemory(self, offset, length, value)
                }
                #[inline]
                pub unsafe fn getString(
                    &self,
                    offset: root::aeron::util::index_t,
                ) -> root::std::string {
                    AtomicBuffer_getString(self, offset)
                }
                #[inline]
                pub unsafe fn getStringWithoutLength(
                    &self,
                    offset: root::aeron::util::index_t,
                    length: usize,
                ) -> root::std::string {
                    AtomicBuffer_getStringWithoutLength(self, offset, length)
                }
                #[inline]
                pub unsafe fn getStringLength(
                    &self,
                    offset: root::aeron::util::index_t,
                ) -> ::std::os::raw::c_int {
                    AtomicBuffer_getStringLength(self, offset)
                }
                #[inline]
                pub unsafe fn putString(
                    &mut self,
                    offset: root::aeron::util::index_t,
                    value: *const root::std::string,
                ) -> ::std::os::raw::c_int {
                    AtomicBuffer_putString(self, offset, value)
                }
                #[inline]
                pub unsafe fn putStringWithoutLength(
                    &mut self,
                    offset: root::aeron::util::index_t,
                    value: *const root::std::string,
                ) -> ::std::os::raw::c_int {
                    AtomicBuffer_putStringWithoutLength(self, offset, value)
                }
                #[inline]
                pub unsafe fn boundsCheck(
                    &self,
                    index: root::aeron::util::index_t,
                    length: ::std::os::raw::c_ulong,
                ) {
                    AtomicBuffer_boundsCheck(self, index, length)
                }
                #[inline]
                pub unsafe fn new() -> Self {
                    let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                    AtomicBuffer_AtomicBuffer(__bindgen_tmp.as_mut_ptr());
                    __bindgen_tmp.assume_init()
                }
                #[inline]
                pub unsafe fn new1(buffer: *mut ::std::os::raw::c_uchar, length: usize) -> Self {
                    let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                    AtomicBuffer_AtomicBuffer1(__bindgen_tmp.as_mut_ptr(), buffer, length);
                    __bindgen_tmp.assume_init()
                }
                #[inline]
                pub unsafe fn new2(
                    buffer: *mut ::std::os::raw::c_uchar,
                    length: usize,
                    initialValue: ::std::os::raw::c_uchar,
                ) -> Self {
                    let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                    AtomicBuffer_AtomicBuffer2(
                        __bindgen_tmp.as_mut_ptr(),
                        buffer,
                        length,
                        initialValue,
                    );
                    __bindgen_tmp.assume_init()
                }
            }
            pub mod logbuffer {
                #[allow(unused_imports)]
                use self::super::super::super::super::root;
                pub mod DataFrameHeader {
                    #[allow(unused_imports)]
                    use self::super::super::super::super::super::root;
                    #[repr(C, packed(4))]
                    #[derive(Copy, Clone)]
                    pub struct DataFrameHeaderDefn {
                        pub frameLength: ::std::os::raw::c_int,
                        pub version: ::std::os::raw::c_uchar,
                        pub flags: ::std::os::raw::c_uchar,
                        pub type_: ::std::os::raw::c_ushort,
                        pub termOffset: ::std::os::raw::c_int,
                        pub sessionId: ::std::os::raw::c_int,
                        pub streamId: ::std::os::raw::c_int,
                        pub termId: ::std::os::raw::c_int,
                        pub reservedValue: ::std::os::raw::c_long,
                    }
                    #[test]
                    fn bindgen_test_layout_DataFrameHeaderDefn() {
                        const UNINIT: ::std::mem::MaybeUninit<DataFrameHeaderDefn> =
                            ::std::mem::MaybeUninit::uninit();
                        let ptr = UNINIT.as_ptr();
                        assert_eq!(
                            ::std::mem::size_of::<DataFrameHeaderDefn>(),
                            32usize,
                            concat!("Size of: ", stringify!(DataFrameHeaderDefn))
                        );
                        assert_eq!(
                            ::std::mem::align_of::<DataFrameHeaderDefn>(),
                            4usize,
                            concat!("Alignment of ", stringify!(DataFrameHeaderDefn))
                        );
                        assert_eq!(
                            unsafe {
                                ::std::ptr::addr_of!((*ptr).frameLength) as usize - ptr as usize
                            },
                            0usize,
                            concat!(
                                "Offset of field: ",
                                stringify!(DataFrameHeaderDefn),
                                "::",
                                stringify!(frameLength)
                            )
                        );
                        assert_eq!(
                            unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
                            4usize,
                            concat!(
                                "Offset of field: ",
                                stringify!(DataFrameHeaderDefn),
                                "::",
                                stringify!(version)
                            )
                        );
                        assert_eq!(
                            unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
                            5usize,
                            concat!(
                                "Offset of field: ",
                                stringify!(DataFrameHeaderDefn),
                                "::",
                                stringify!(flags)
                            )
                        );
                        assert_eq!(
                            unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
                            6usize,
                            concat!(
                                "Offset of field: ",
                                stringify!(DataFrameHeaderDefn),
                                "::",
                                stringify!(type_)
                            )
                        );
                        assert_eq!(
                            unsafe {
                                ::std::ptr::addr_of!((*ptr).termOffset) as usize - ptr as usize
                            },
                            8usize,
                            concat!(
                                "Offset of field: ",
                                stringify!(DataFrameHeaderDefn),
                                "::",
                                stringify!(termOffset)
                            )
                        );
                        assert_eq!(
                            unsafe {
                                ::std::ptr::addr_of!((*ptr).sessionId) as usize - ptr as usize
                            },
                            12usize,
                            concat!(
                                "Offset of field: ",
                                stringify!(DataFrameHeaderDefn),
                                "::",
                                stringify!(sessionId)
                            )
                        );
                        assert_eq!(
                            unsafe {
                                ::std::ptr::addr_of!((*ptr).streamId) as usize - ptr as usize
                            },
                            16usize,
                            concat!(
                                "Offset of field: ",
                                stringify!(DataFrameHeaderDefn),
                                "::",
                                stringify!(streamId)
                            )
                        );
                        assert_eq!(
                            unsafe { ::std::ptr::addr_of!((*ptr).termId) as usize - ptr as usize },
                            20usize,
                            concat!(
                                "Offset of field: ",
                                stringify!(DataFrameHeaderDefn),
                                "::",
                                stringify!(termId)
                            )
                        );
                        assert_eq!(
                            unsafe {
                                ::std::ptr::addr_of!((*ptr).reservedValue) as usize - ptr as usize
                            },
                            24usize,
                            concat!(
                                "Offset of field: ",
                                stringify!(DataFrameHeaderDefn),
                                "::",
                                stringify!(reservedValue)
                            )
                        );
                    }
                }
                #[repr(C)]
                #[derive(Copy, Clone)]
                pub struct BufferClaim {
                    pub m_buffer: root::aeron::concurrent::AtomicBuffer,
                }
                #[test]
                fn bindgen_test_layout_BufferClaim() {
                    const UNINIT: ::std::mem::MaybeUninit<BufferClaim> =
                        ::std::mem::MaybeUninit::uninit();
                    let ptr = UNINIT.as_ptr();
                    assert_eq!(
                        ::std::mem::size_of::<BufferClaim>(),
                        16usize,
                        concat!("Size of: ", stringify!(BufferClaim))
                    );
                    assert_eq!(
                        ::std::mem::align_of::<BufferClaim>(),
                        8usize,
                        concat!("Alignment of ", stringify!(BufferClaim))
                    );
                    assert_eq!(
                        unsafe { ::std::ptr::addr_of!((*ptr).m_buffer) as usize - ptr as usize },
                        0usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(BufferClaim),
                            "::",
                            stringify!(m_buffer)
                        )
                    );
                }
                extern "C" {
                    #[link_name = "\u{1}_ZN5aeron10concurrent9logbuffer11BufferClaim4wrapEPhi"]
                    pub fn BufferClaim_wrap(
                        this: *mut root::aeron::concurrent::logbuffer::BufferClaim,
                        buffer: *mut ::std::os::raw::c_uchar,
                        length: root::aeron::util::index_t,
                    );
                }
                extern "C" {
                    #[link_name = "\u{1}_ZN5aeron10concurrent9logbuffer11BufferClaim4wrapERNS0_12AtomicBufferEii"]
                    pub fn BufferClaim_wrap1(
                        this: *mut root::aeron::concurrent::logbuffer::BufferClaim,
                        buffer: *mut root::aeron::concurrent::AtomicBuffer,
                        offset: root::aeron::util::index_t,
                        length: root::aeron::util::index_t,
                    );
                }
                extern "C" {
                    #[link_name = "\u{1}_ZN5aeron10concurrent9logbuffer11BufferClaim6bufferEv"]
                    pub fn BufferClaim_buffer(
                        this: *mut root::aeron::concurrent::logbuffer::BufferClaim,
                    ) -> *mut root::aeron::concurrent::AtomicBuffer;
                }
                extern "C" {
                    #[link_name = "\u{1}_ZNK5aeron10concurrent9logbuffer11BufferClaim6offsetEv"]
                    pub fn BufferClaim_offset(
                        this: *const root::aeron::concurrent::logbuffer::BufferClaim,
                    ) -> root::aeron::util::index_t;
                }
                extern "C" {
                    #[link_name = "\u{1}_ZNK5aeron10concurrent9logbuffer11BufferClaim6lengthEv"]
                    pub fn BufferClaim_length(
                        this: *const root::aeron::concurrent::logbuffer::BufferClaim,
                    ) -> root::aeron::util::index_t;
                }
                extern "C" {
                    #[link_name = "\u{1}_ZNK5aeron10concurrent9logbuffer11BufferClaim5flagsEv"]
                    pub fn BufferClaim_flags(
                        this: *const root::aeron::concurrent::logbuffer::BufferClaim,
                    ) -> ::std::os::raw::c_uchar;
                }
                extern "C" {
                    #[link_name = "\u{1}_ZN5aeron10concurrent9logbuffer11BufferClaim5flagsEh"]
                    pub fn BufferClaim_flags1(
                        this: *mut root::aeron::concurrent::logbuffer::BufferClaim,
                        flags: ::std::os::raw::c_uchar,
                    ) -> *mut root::aeron::concurrent::logbuffer::BufferClaim;
                }
                extern "C" {
                    #[link_name = "\u{1}_ZNK5aeron10concurrent9logbuffer11BufferClaim10headerTypeEv"]
                    pub fn BufferClaim_headerType(
                        this: *const root::aeron::concurrent::logbuffer::BufferClaim,
                    ) -> ::std::os::raw::c_ushort;
                }
                extern "C" {
                    #[link_name = "\u{1}_ZN5aeron10concurrent9logbuffer11BufferClaim10headerTypeEt"]
                    pub fn BufferClaim_headerType1(
                        this: *mut root::aeron::concurrent::logbuffer::BufferClaim,
                        type_: ::std::os::raw::c_ushort,
                    ) -> *mut root::aeron::concurrent::logbuffer::BufferClaim;
                }
                extern "C" {
                    #[link_name = "\u{1}_ZNK5aeron10concurrent9logbuffer11BufferClaim13reservedValueEv"]
                    pub fn BufferClaim_reservedValue(
                        this: *const root::aeron::concurrent::logbuffer::BufferClaim,
                    ) -> ::std::os::raw::c_long;
                }
                extern "C" {
                    #[link_name = "\u{1}_ZN5aeron10concurrent9logbuffer11BufferClaim13reservedValueEl"]
                    pub fn BufferClaim_reservedValue1(
                        this: *mut root::aeron::concurrent::logbuffer::BufferClaim,
                        value: ::std::os::raw::c_long,
                    ) -> *mut root::aeron::concurrent::logbuffer::BufferClaim;
                }
                extern "C" {
                    #[link_name = "\u{1}_ZN5aeron10concurrent9logbuffer11BufferClaim6commitEv"]
                    pub fn BufferClaim_commit(
                        this: *mut root::aeron::concurrent::logbuffer::BufferClaim,
                    );
                }
                extern "C" {
                    #[link_name = "\u{1}_ZN5aeron10concurrent9logbuffer11BufferClaim5abortEv"]
                    pub fn BufferClaim_abort(
                        this: *mut root::aeron::concurrent::logbuffer::BufferClaim,
                    );
                }
                extern "C" {
                    #[link_name = "\u{1}_ZN5aeron10concurrent9logbuffer11BufferClaimC1Ev"]
                    pub fn BufferClaim_BufferClaim(
                        this: *mut root::aeron::concurrent::logbuffer::BufferClaim,
                    );
                }
                impl BufferClaim {
                    #[inline]
                    pub unsafe fn wrap(
                        &mut self,
                        buffer: *mut ::std::os::raw::c_uchar,
                        length: root::aeron::util::index_t,
                    ) {
                        BufferClaim_wrap(self, buffer, length)
                    }
                    #[inline]
                    pub unsafe fn wrap1(
                        &mut self,
                        buffer: *mut root::aeron::concurrent::AtomicBuffer,
                        offset: root::aeron::util::index_t,
                        length: root::aeron::util::index_t,
                    ) {
                        BufferClaim_wrap1(self, buffer, offset, length)
                    }
                    #[inline]
                    pub unsafe fn buffer(&mut self) -> *mut root::aeron::concurrent::AtomicBuffer {
                        BufferClaim_buffer(self)
                    }
                    #[inline]
                    pub unsafe fn offset(&self) -> root::aeron::util::index_t {
                        BufferClaim_offset(self)
                    }
                    #[inline]
                    pub unsafe fn length(&self) -> root::aeron::util::index_t {
                        BufferClaim_length(self)
                    }
                    #[inline]
                    pub unsafe fn flags(&self) -> ::std::os::raw::c_uchar {
                        BufferClaim_flags(self)
                    }
                    #[inline]
                    pub unsafe fn flags1(
                        &mut self,
                        flags: ::std::os::raw::c_uchar,
                    ) -> *mut root::aeron::concurrent::logbuffer::BufferClaim {
                        BufferClaim_flags1(self, flags)
                    }
                    #[inline]
                    pub unsafe fn headerType(&self) -> ::std::os::raw::c_ushort {
                        BufferClaim_headerType(self)
                    }
                    #[inline]
                    pub unsafe fn headerType1(
                        &mut self,
                        type_: ::std::os::raw::c_ushort,
                    ) -> *mut root::aeron::concurrent::logbuffer::BufferClaim {
                        BufferClaim_headerType1(self, type_)
                    }
                    #[inline]
                    pub unsafe fn reservedValue(&self) -> ::std::os::raw::c_long {
                        BufferClaim_reservedValue(self)
                    }
                    #[inline]
                    pub unsafe fn reservedValue1(
                        &mut self,
                        value: ::std::os::raw::c_long,
                    ) -> *mut root::aeron::concurrent::logbuffer::BufferClaim {
                        BufferClaim_reservedValue1(self, value)
                    }
                    #[inline]
                    pub unsafe fn commit(&mut self) {
                        BufferClaim_commit(self)
                    }
                    #[inline]
                    pub unsafe fn abort(&mut self) {
                        BufferClaim_abort(self)
                    }
                    #[inline]
                    pub unsafe fn new() -> Self {
                        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                        BufferClaim_BufferClaim(__bindgen_tmp.as_mut_ptr());
                        __bindgen_tmp.assume_init()
                    }
                }
                pub mod FrameDescriptor {
                    #[allow(unused_imports)]
                    use self::super::super::super::super::super::root;
                }
                #[repr(C)]
                #[derive(Copy, Clone)]
                pub struct HeaderWriter {
                    pub m_sessionId: ::std::os::raw::c_int,
                    pub m_streamId: ::std::os::raw::c_int,
                }
                #[test]
                fn bindgen_test_layout_HeaderWriter() {
                    const UNINIT: ::std::mem::MaybeUninit<HeaderWriter> =
                        ::std::mem::MaybeUninit::uninit();
                    let ptr = UNINIT.as_ptr();
                    assert_eq!(
                        ::std::mem::size_of::<HeaderWriter>(),
                        8usize,
                        concat!("Size of: ", stringify!(HeaderWriter))
                    );
                    assert_eq!(
                        ::std::mem::align_of::<HeaderWriter>(),
                        4usize,
                        concat!("Alignment of ", stringify!(HeaderWriter))
                    );
                    assert_eq!(
                        unsafe { ::std::ptr::addr_of!((*ptr).m_sessionId) as usize - ptr as usize },
                        0usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(HeaderWriter),
                            "::",
                            stringify!(m_sessionId)
                        )
                    );
                    assert_eq!(
                        unsafe { ::std::ptr::addr_of!((*ptr).m_streamId) as usize - ptr as usize },
                        4usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(HeaderWriter),
                            "::",
                            stringify!(m_streamId)
                        )
                    );
                }
                extern "C" {
                    #[link_name = "\u{1}_ZNK5aeron10concurrent9logbuffer12HeaderWriter5writeERNS0_12AtomicBufferEiii"]
                    pub fn HeaderWriter_write(
                        this: *const root::aeron::concurrent::logbuffer::HeaderWriter,
                        termBuffer: *mut root::aeron::concurrent::AtomicBuffer,
                        offset: root::aeron::util::index_t,
                        length: root::aeron::util::index_t,
                        termId: ::std::os::raw::c_int,
                    );
                }
                extern "C" {
                    #[link_name = "\u{1}_ZN5aeron10concurrent9logbuffer12HeaderWriterC1ENS0_12AtomicBufferE"]
                    pub fn HeaderWriter_HeaderWriter(
                        this: *mut root::aeron::concurrent::logbuffer::HeaderWriter,
                        defaultHdr: root::aeron::concurrent::AtomicBuffer,
                    );
                }
                impl HeaderWriter {
                    #[inline]
                    pub unsafe fn write(
                        &self,
                        termBuffer: *mut root::aeron::concurrent::AtomicBuffer,
                        offset: root::aeron::util::index_t,
                        length: root::aeron::util::index_t,
                        termId: ::std::os::raw::c_int,
                    ) {
                        HeaderWriter_write(self, termBuffer, offset, length, termId)
                    }
                    #[inline]
                    pub unsafe fn new(defaultHdr: root::aeron::concurrent::AtomicBuffer) -> Self {
                        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                        HeaderWriter_HeaderWriter(__bindgen_tmp.as_mut_ptr(), defaultHdr);
                        __bindgen_tmp.assume_init()
                    }
                }
                pub mod LogBufferDescriptor {
                    #[allow(unused_imports)]
                    use self::super::super::super::super::super::root;
                    #[repr(C, packed(4))]
                    #[derive(Copy, Clone)]
                    pub struct LogMetaDataDefn {
                        pub termTailCounters: [::std::os::raw::c_long; 3usize],
                        pub activeTermCount: ::std::os::raw::c_int,
                        pub pad1: [::std::os::raw::c_schar; 100usize],
                        pub endOfStreamPosition: ::std::os::raw::c_long,
                        pub isConnected: ::std::os::raw::c_int,
                        pub activeTransportCount: ::std::os::raw::c_int,
                        pub pad2: [::std::os::raw::c_schar; 112usize],
                        pub correlationId: ::std::os::raw::c_long,
                        pub initialTermId: ::std::os::raw::c_int,
                        pub defaultFrameHeaderLength: ::std::os::raw::c_int,
                        pub mtuLength: ::std::os::raw::c_int,
                        pub termLength: ::std::os::raw::c_int,
                        pub pageSize: ::std::os::raw::c_int,
                        pub pad3: [::std::os::raw::c_schar; 36usize],
                    }
                    #[test]
                    fn bindgen_test_layout_LogMetaDataDefn() {
                        const UNINIT: ::std::mem::MaybeUninit<LogMetaDataDefn> =
                            ::std::mem::MaybeUninit::uninit();
                        let ptr = UNINIT.as_ptr();
                        assert_eq!(
                            ::std::mem::size_of::<LogMetaDataDefn>(),
                            320usize,
                            concat!("Size of: ", stringify!(LogMetaDataDefn))
                        );
                        assert_eq!(
                            ::std::mem::align_of::<LogMetaDataDefn>(),
                            4usize,
                            concat!("Alignment of ", stringify!(LogMetaDataDefn))
                        );
                        assert_eq!(
                            unsafe {
                                ::std::ptr::addr_of!((*ptr).termTailCounters) as usize
                                    - ptr as usize
                            },
                            0usize,
                            concat!(
                                "Offset of field: ",
                                stringify!(LogMetaDataDefn),
                                "::",
                                stringify!(termTailCounters)
                            )
                        );
                        assert_eq!(
                            unsafe {
                                ::std::ptr::addr_of!((*ptr).activeTermCount) as usize - ptr as usize
                            },
                            24usize,
                            concat!(
                                "Offset of field: ",
                                stringify!(LogMetaDataDefn),
                                "::",
                                stringify!(activeTermCount)
                            )
                        );
                        assert_eq!(
                            unsafe { ::std::ptr::addr_of!((*ptr).pad1) as usize - ptr as usize },
                            28usize,
                            concat!(
                                "Offset of field: ",
                                stringify!(LogMetaDataDefn),
                                "::",
                                stringify!(pad1)
                            )
                        );
                        assert_eq!(
                            unsafe {
                                ::std::ptr::addr_of!((*ptr).endOfStreamPosition) as usize
                                    - ptr as usize
                            },
                            128usize,
                            concat!(
                                "Offset of field: ",
                                stringify!(LogMetaDataDefn),
                                "::",
                                stringify!(endOfStreamPosition)
                            )
                        );
                        assert_eq!(
                            unsafe {
                                ::std::ptr::addr_of!((*ptr).isConnected) as usize - ptr as usize
                            },
                            136usize,
                            concat!(
                                "Offset of field: ",
                                stringify!(LogMetaDataDefn),
                                "::",
                                stringify!(isConnected)
                            )
                        );
                        assert_eq!(
                            unsafe {
                                ::std::ptr::addr_of!((*ptr).activeTransportCount) as usize
                                    - ptr as usize
                            },
                            140usize,
                            concat!(
                                "Offset of field: ",
                                stringify!(LogMetaDataDefn),
                                "::",
                                stringify!(activeTransportCount)
                            )
                        );
                        assert_eq!(
                            unsafe { ::std::ptr::addr_of!((*ptr).pad2) as usize - ptr as usize },
                            144usize,
                            concat!(
                                "Offset of field: ",
                                stringify!(LogMetaDataDefn),
                                "::",
                                stringify!(pad2)
                            )
                        );
                        assert_eq!(
                            unsafe {
                                ::std::ptr::addr_of!((*ptr).correlationId) as usize - ptr as usize
                            },
                            256usize,
                            concat!(
                                "Offset of field: ",
                                stringify!(LogMetaDataDefn),
                                "::",
                                stringify!(correlationId)
                            )
                        );
                        assert_eq!(
                            unsafe {
                                ::std::ptr::addr_of!((*ptr).initialTermId) as usize - ptr as usize
                            },
                            264usize,
                            concat!(
                                "Offset of field: ",
                                stringify!(LogMetaDataDefn),
                                "::",
                                stringify!(initialTermId)
                            )
                        );
                        assert_eq!(
                            unsafe {
                                ::std::ptr::addr_of!((*ptr).defaultFrameHeaderLength) as usize
                                    - ptr as usize
                            },
                            268usize,
                            concat!(
                                "Offset of field: ",
                                stringify!(LogMetaDataDefn),
                                "::",
                                stringify!(defaultFrameHeaderLength)
                            )
                        );
                        assert_eq!(
                            unsafe {
                                ::std::ptr::addr_of!((*ptr).mtuLength) as usize - ptr as usize
                            },
                            272usize,
                            concat!(
                                "Offset of field: ",
                                stringify!(LogMetaDataDefn),
                                "::",
                                stringify!(mtuLength)
                            )
                        );
                        assert_eq!(
                            unsafe {
                                ::std::ptr::addr_of!((*ptr).termLength) as usize - ptr as usize
                            },
                            276usize,
                            concat!(
                                "Offset of field: ",
                                stringify!(LogMetaDataDefn),
                                "::",
                                stringify!(termLength)
                            )
                        );
                        assert_eq!(
                            unsafe {
                                ::std::ptr::addr_of!((*ptr).pageSize) as usize - ptr as usize
                            },
                            280usize,
                            concat!(
                                "Offset of field: ",
                                stringify!(LogMetaDataDefn),
                                "::",
                                stringify!(pageSize)
                            )
                        );
                        assert_eq!(
                            unsafe { ::std::ptr::addr_of!((*ptr).pad3) as usize - ptr as usize },
                            284usize,
                            concat!(
                                "Offset of field: ",
                                stringify!(LogMetaDataDefn),
                                "::",
                                stringify!(pad3)
                            )
                        );
                    }
                    extern "C" {
                        #[link_name = "\u{1}_ZN5aeron10concurrent9logbuffer19LogBufferDescriptor15checkTermLengthEi"]
                        pub fn checkTermLength(termLength: ::std::os::raw::c_int);
                    }
                    extern "C" {
                        #[link_name = "\u{1}_ZN5aeron10concurrent9logbuffer19LogBufferDescriptor13checkPageSizeEi"]
                        pub fn checkPageSize(pageSize: ::std::os::raw::c_int);
                    }
                    extern "C" {
                        #[link_name = "\u{1}_ZN5aeron10concurrent9logbuffer19LogBufferDescriptor13initialTermIdERKNS0_12AtomicBufferE"]
                        pub fn initialTermId(
                            logMetaDataBuffer: *const root::aeron::concurrent::AtomicBuffer,
                        ) -> ::std::os::raw::c_int;
                    }
                    extern "C" {
                        #[link_name = "\u{1}_ZN5aeron10concurrent9logbuffer19LogBufferDescriptor9mtuLengthERKNS0_12AtomicBufferE"]
                        pub fn mtuLength(
                            logMetaDataBuffer: *const root::aeron::concurrent::AtomicBuffer,
                        ) -> ::std::os::raw::c_int;
                    }
                    extern "C" {
                        #[link_name = "\u{1}_ZN5aeron10concurrent9logbuffer19LogBufferDescriptor10termLengthERKNS0_12AtomicBufferE"]
                        pub fn termLength(
                            logMetaDataBuffer: *const root::aeron::concurrent::AtomicBuffer,
                        ) -> ::std::os::raw::c_int;
                    }
                    extern "C" {
                        #[link_name = "\u{1}_ZN5aeron10concurrent9logbuffer19LogBufferDescriptor8pageSizeERKNS0_12AtomicBufferE"]
                        pub fn pageSize(
                            logMetaDataBuffer: *const root::aeron::concurrent::AtomicBuffer,
                        ) -> ::std::os::raw::c_int;
                    }
                    extern "C" {
                        #[link_name = "\u{1}_ZN5aeron10concurrent9logbuffer19LogBufferDescriptor15activeTermCountERKNS0_12AtomicBufferE"]
                        pub fn activeTermCount(
                            logMetaDataBuffer: *const root::aeron::concurrent::AtomicBuffer,
                        ) -> ::std::os::raw::c_int;
                    }
                    extern "C" {
                        #[link_name = "\u{1}_ZN5aeron10concurrent9logbuffer19LogBufferDescriptor22activeTermCountOrderedERNS0_12AtomicBufferEi"]
                        pub fn activeTermCountOrdered(
                            logMetaDataBuffer: *mut root::aeron::concurrent::AtomicBuffer,
                            activeTermId: ::std::os::raw::c_int,
                        );
                    }
                    extern "C" {
                        #[link_name = "\u{1}_ZN5aeron10concurrent9logbuffer19LogBufferDescriptor18casActiveTermCountERNS0_12AtomicBufferEii"]
                        pub fn casActiveTermCount(
                            logMetaDataBuffer: *mut root::aeron::concurrent::AtomicBuffer,
                            expectedTermCount: ::std::os::raw::c_int,
                            updateTermCount: ::std::os::raw::c_int,
                        ) -> bool;
                    }
                    extern "C" {
                        #[link_name = "\u{1}_ZN5aeron10concurrent9logbuffer19LogBufferDescriptor18nextPartitionIndexEi"]
                        pub fn nextPartitionIndex(
                            currentIndex: ::std::os::raw::c_int,
                        ) -> ::std::os::raw::c_int;
                    }
                    extern "C" {
                        #[link_name = "\u{1}_ZN5aeron10concurrent9logbuffer19LogBufferDescriptor22previousPartitionIndexEi"]
                        pub fn previousPartitionIndex(
                            currentIndex: ::std::os::raw::c_int,
                        ) -> ::std::os::raw::c_int;
                    }
                    extern "C" {
                        #[link_name = "\u{1}_ZN5aeron10concurrent9logbuffer19LogBufferDescriptor11isConnectedERKNS0_12AtomicBufferE"]
                        pub fn isConnected(
                            logMetaDataBuffer: *const root::aeron::concurrent::AtomicBuffer,
                        ) -> bool;
                    }
                    extern "C" {
                        #[link_name = "\u{1}_ZN5aeron10concurrent9logbuffer19LogBufferDescriptor11isConnectedERNS0_12AtomicBufferEb"]
                        pub fn isConnected1(
                            logMetaDataBuffer: *mut root::aeron::concurrent::AtomicBuffer,
                            isConnected: bool,
                        );
                    }
                    extern "C" {
                        #[link_name = "\u{1}_ZN5aeron10concurrent9logbuffer19LogBufferDescriptor20activeTransportCountERNS0_12AtomicBufferE"]
                        pub fn activeTransportCount(
                            logMegaDataBuffer: *mut root::aeron::concurrent::AtomicBuffer,
                        ) -> ::std::os::raw::c_int;
                    }
                    extern "C" {
                        #[link_name = "\u{1}_ZN5aeron10concurrent9logbuffer19LogBufferDescriptor20activeTransportCountERNS0_12AtomicBufferEi"]
                        pub fn activeTransportCount1(
                            logMetaDataBuffer: *mut root::aeron::concurrent::AtomicBuffer,
                            numberOfActiveTransports: ::std::os::raw::c_int,
                        );
                    }
                    extern "C" {
                        #[link_name = "\u{1}_ZN5aeron10concurrent9logbuffer19LogBufferDescriptor19endOfStreamPositionERKNS0_12AtomicBufferE"]
                        pub fn endOfStreamPosition(
                            logMetaDataBuffer: *const root::aeron::concurrent::AtomicBuffer,
                        ) -> ::std::os::raw::c_long;
                    }
                    extern "C" {
                        #[link_name = "\u{1}_ZN5aeron10concurrent9logbuffer19LogBufferDescriptor19endOfStreamPositionERNS0_12AtomicBufferEl"]
                        pub fn endOfStreamPosition1(
                            logMetaDataBuffer: *mut root::aeron::concurrent::AtomicBuffer,
                            position: ::std::os::raw::c_long,
                        );
                    }
                    extern "C" {
                        #[link_name = "\u{1}_ZN5aeron10concurrent9logbuffer19LogBufferDescriptor16computeTermCountEii"]
                        pub fn computeTermCount(
                            termId: ::std::os::raw::c_int,
                            initialTermId: ::std::os::raw::c_int,
                        ) -> ::std::os::raw::c_int;
                    }
                    extern "C" {
                        #[link_name = "\u{1}_ZN5aeron10concurrent9logbuffer19LogBufferDescriptor11indexByTermEii"]
                        pub fn indexByTerm(
                            initialTermId: ::std::os::raw::c_int,
                            activeTermId: ::std::os::raw::c_int,
                        ) -> ::std::os::raw::c_int;
                    }
                    extern "C" {
                        #[link_name = "\u{1}_ZN5aeron10concurrent9logbuffer19LogBufferDescriptor16indexByTermCountEl"]
                        pub fn indexByTermCount(
                            termCount: ::std::os::raw::c_long,
                        ) -> ::std::os::raw::c_int;
                    }
                    extern "C" {
                        #[link_name = "\u{1}_ZN5aeron10concurrent9logbuffer19LogBufferDescriptor15indexByPositionEli"]
                        pub fn indexByPosition(
                            position: ::std::os::raw::c_long,
                            positionBitsToShift: ::std::os::raw::c_int,
                        ) -> ::std::os::raw::c_int;
                    }
                    extern "C" {
                        #[link_name = "\u{1}_ZN5aeron10concurrent9logbuffer19LogBufferDescriptor15computePositionEiiii"]
                        pub fn computePosition(
                            activeTermId: ::std::os::raw::c_int,
                            termOffset: ::std::os::raw::c_int,
                            positionBitsToShift: ::std::os::raw::c_int,
                            initialTermId: ::std::os::raw::c_int,
                        ) -> ::std::os::raw::c_long;
                    }
                    extern "C" {
                        #[link_name = "\u{1}_ZN5aeron10concurrent9logbuffer19LogBufferDescriptor24computeTermBeginPositionEiii"]
                        pub fn computeTermBeginPosition(
                            activeTermId: ::std::os::raw::c_int,
                            positionBitsToShift: ::std::os::raw::c_int,
                            initialTermId: ::std::os::raw::c_int,
                        ) -> ::std::os::raw::c_long;
                    }
                    extern "C" {
                        #[link_name = "\u{1}_ZN5aeron10concurrent9logbuffer19LogBufferDescriptor15rawTailVolatileERKNS0_12AtomicBufferE"]
                        pub fn rawTailVolatile(
                            logMetaDataBuffer: *const root::aeron::concurrent::AtomicBuffer,
                        ) -> ::std::os::raw::c_long;
                    }
                    extern "C" {
                        #[link_name = "\u{1}_ZN5aeron10concurrent9logbuffer19LogBufferDescriptor15rawTailVolatileERKNS0_12AtomicBufferEi"]
                        pub fn rawTailVolatile1(
                            logMetaDataBuffer: *const root::aeron::concurrent::AtomicBuffer,
                            partitionIndex: ::std::os::raw::c_int,
                        ) -> ::std::os::raw::c_long;
                    }
                    extern "C" {
                        #[link_name = "\u{1}_ZN5aeron10concurrent9logbuffer19LogBufferDescriptor7rawTailERKNS0_12AtomicBufferE"]
                        pub fn rawTail(
                            logMetaDataBuffer: *const root::aeron::concurrent::AtomicBuffer,
                        ) -> ::std::os::raw::c_long;
                    }
                    extern "C" {
                        #[link_name = "\u{1}_ZN5aeron10concurrent9logbuffer19LogBufferDescriptor7rawTailERKNS0_12AtomicBufferEi"]
                        pub fn rawTail1(
                            logMetaDataBuffer: *const root::aeron::concurrent::AtomicBuffer,
                            partitionIndex: ::std::os::raw::c_int,
                        ) -> ::std::os::raw::c_long;
                    }
                    extern "C" {
                        #[link_name = "\u{1}_ZN5aeron10concurrent9logbuffer19LogBufferDescriptor6termIdEl"]
                        pub fn termId(rawTail: ::std::os::raw::c_long) -> ::std::os::raw::c_int;
                    }
                    extern "C" {
                        #[link_name = "\u{1}_ZN5aeron10concurrent9logbuffer19LogBufferDescriptor10termOffsetEll"]
                        pub fn termOffset(
                            rawTail: ::std::os::raw::c_long,
                            termLength: ::std::os::raw::c_long,
                        ) -> ::std::os::raw::c_int;
                    }
                    extern "C" {
                        #[link_name = "\u{1}_ZN5aeron10concurrent9logbuffer19LogBufferDescriptor10casRawTailERNS0_12AtomicBufferEill"]
                        pub fn casRawTail(
                            logMetaDataBuffer: *mut root::aeron::concurrent::AtomicBuffer,
                            partitionIndex: ::std::os::raw::c_int,
                            expectedRawTail: ::std::os::raw::c_long,
                            updateRawTail: ::std::os::raw::c_long,
                        ) -> bool;
                    }
                    extern "C" {
                        #[link_name = "\u{1}_ZN5aeron10concurrent9logbuffer19LogBufferDescriptor17tailCounterOffsetEi"]
                        pub fn tailCounterOffset(
                            partitionIndex: ::std::os::raw::c_int,
                        ) -> ::std::os::raw::c_int;
                    }
                    extern "C" {
                        #[link_name = "\u{1}_ZN5aeron10concurrent9logbuffer19LogBufferDescriptor18defaultFrameHeaderERNS0_12AtomicBufferE"]
                        pub fn defaultFrameHeader(
                            logMetaDataBuffer: *mut root::aeron::concurrent::AtomicBuffer,
                        ) -> root::aeron::concurrent::AtomicBuffer;
                    }
                    extern "C" {
                        #[link_name = "\u{1}_ZN5aeron10concurrent9logbuffer19LogBufferDescriptor9rotateLogERNS0_12AtomicBufferEii"]
                        pub fn rotateLog(
                            logMetaDataBuffer: *mut root::aeron::concurrent::AtomicBuffer,
                            currentTermCount: ::std::os::raw::c_int,
                            currentTermId: ::std::os::raw::c_int,
                        );
                    }
                    extern "C" {
                        #[link_name = "\u{1}_ZN5aeron10concurrent9logbuffer19LogBufferDescriptor24initializeTailWithTermIdERNS0_12AtomicBufferEii"]
                        pub fn initializeTailWithTermId(
                            logMetaDataBuffer: *mut root::aeron::concurrent::AtomicBuffer,
                            partitionIndex: ::std::os::raw::c_int,
                            termId: ::std::os::raw::c_int,
                        );
                    }
                }
                #[repr(C)]
                #[derive(Copy, Clone)]
                pub struct Header {
                    pub m_context: *mut ::std::os::raw::c_void,
                    pub m_buffer: root::aeron::concurrent::AtomicBuffer,
                    pub m_offset: root::aeron::util::index_t,
                    pub m_initialTermId: ::std::os::raw::c_int,
                    pub m_positionBitsToShift: ::std::os::raw::c_int,
                }
                #[test]
                fn bindgen_test_layout_Header() {
                    const UNINIT: ::std::mem::MaybeUninit<Header> =
                        ::std::mem::MaybeUninit::uninit();
                    let ptr = UNINIT.as_ptr();
                    assert_eq!(
                        ::std::mem::size_of::<Header>(),
                        40usize,
                        concat!("Size of: ", stringify!(Header))
                    );
                    assert_eq!(
                        ::std::mem::align_of::<Header>(),
                        8usize,
                        concat!("Alignment of ", stringify!(Header))
                    );
                    assert_eq!(
                        unsafe { ::std::ptr::addr_of!((*ptr).m_context) as usize - ptr as usize },
                        0usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(Header),
                            "::",
                            stringify!(m_context)
                        )
                    );
                    assert_eq!(
                        unsafe { ::std::ptr::addr_of!((*ptr).m_buffer) as usize - ptr as usize },
                        8usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(Header),
                            "::",
                            stringify!(m_buffer)
                        )
                    );
                    assert_eq!(
                        unsafe { ::std::ptr::addr_of!((*ptr).m_offset) as usize - ptr as usize },
                        24usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(Header),
                            "::",
                            stringify!(m_offset)
                        )
                    );
                    assert_eq!(
                        unsafe {
                            ::std::ptr::addr_of!((*ptr).m_initialTermId) as usize - ptr as usize
                        },
                        28usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(Header),
                            "::",
                            stringify!(m_initialTermId)
                        )
                    );
                    assert_eq!(
                        unsafe {
                            ::std::ptr::addr_of!((*ptr).m_positionBitsToShift) as usize
                                - ptr as usize
                        },
                        32usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(Header),
                            "::",
                            stringify!(m_positionBitsToShift)
                        )
                    );
                }
                extern "C" {
                    #[link_name = "\u{1}_ZNK5aeron10concurrent9logbuffer6Header13initialTermIdEv"]
                    pub fn Header_initialTermId(
                        this: *const root::aeron::concurrent::logbuffer::Header,
                    ) -> ::std::os::raw::c_int;
                }
                extern "C" {
                    #[link_name = "\u{1}_ZN5aeron10concurrent9logbuffer6Header13initialTermIdEi"]
                    pub fn Header_initialTermId1(
                        this: *mut root::aeron::concurrent::logbuffer::Header,
                        initialTermId: ::std::os::raw::c_int,
                    );
                }
                extern "C" {
                    #[link_name = "\u{1}_ZNK5aeron10concurrent9logbuffer6Header6offsetEv"]
                    pub fn Header_offset(
                        this: *const root::aeron::concurrent::logbuffer::Header,
                    ) -> root::aeron::util::index_t;
                }
                extern "C" {
                    #[link_name = "\u{1}_ZN5aeron10concurrent9logbuffer6Header6offsetEi"]
                    pub fn Header_offset1(
                        this: *mut root::aeron::concurrent::logbuffer::Header,
                        offset: root::aeron::util::index_t,
                    );
                }
                extern "C" {
                    #[link_name = "\u{1}_ZN5aeron10concurrent9logbuffer6Header6bufferEv"]
                    pub fn Header_buffer(
                        this: *mut root::aeron::concurrent::logbuffer::Header,
                    ) -> *mut root::aeron::concurrent::AtomicBuffer;
                }
                extern "C" {
                    #[link_name = "\u{1}_ZN5aeron10concurrent9logbuffer6Header6bufferERNS0_12AtomicBufferE"]
                    pub fn Header_buffer1(
                        this: *mut root::aeron::concurrent::logbuffer::Header,
                        buffer: *mut root::aeron::concurrent::AtomicBuffer,
                    );
                }
                extern "C" {
                    #[link_name = "\u{1}_ZNK5aeron10concurrent9logbuffer6Header11frameLengthEv"]
                    pub fn Header_frameLength(
                        this: *const root::aeron::concurrent::logbuffer::Header,
                    ) -> ::std::os::raw::c_int;
                }
                extern "C" {
                    #[link_name = "\u{1}_ZNK5aeron10concurrent9logbuffer6Header9sessionIdEv"]
                    pub fn Header_sessionId(
                        this: *const root::aeron::concurrent::logbuffer::Header,
                    ) -> ::std::os::raw::c_int;
                }
                extern "C" {
                    #[link_name = "\u{1}_ZNK5aeron10concurrent9logbuffer6Header8streamIdEv"]
                    pub fn Header_streamId(
                        this: *const root::aeron::concurrent::logbuffer::Header,
                    ) -> ::std::os::raw::c_int;
                }
                extern "C" {
                    #[link_name = "\u{1}_ZNK5aeron10concurrent9logbuffer6Header6termIdEv"]
                    pub fn Header_termId(
                        this: *const root::aeron::concurrent::logbuffer::Header,
                    ) -> ::std::os::raw::c_int;
                }
                extern "C" {
                    #[link_name = "\u{1}_ZNK5aeron10concurrent9logbuffer6Header10termOffsetEv"]
                    pub fn Header_termOffset(
                        this: *const root::aeron::concurrent::logbuffer::Header,
                    ) -> ::std::os::raw::c_int;
                }
                extern "C" {
                    #[link_name = "\u{1}_ZNK5aeron10concurrent9logbuffer6Header4typeEv"]
                    pub fn Header_type(
                        this: *const root::aeron::concurrent::logbuffer::Header,
                    ) -> ::std::os::raw::c_ushort;
                }
                extern "C" {
                    #[link_name = "\u{1}_ZNK5aeron10concurrent9logbuffer6Header5flagsEv"]
                    pub fn Header_flags(
                        this: *const root::aeron::concurrent::logbuffer::Header,
                    ) -> ::std::os::raw::c_uchar;
                }
                extern "C" {
                    #[link_name = "\u{1}_ZNK5aeron10concurrent9logbuffer6Header8positionEv"]
                    pub fn Header_position(
                        this: *const root::aeron::concurrent::logbuffer::Header,
                    ) -> ::std::os::raw::c_long;
                }
                extern "C" {
                    #[link_name = "\u{1}_ZNK5aeron10concurrent9logbuffer6Header19positionBitsToShiftEv"]
                    pub fn Header_positionBitsToShift(
                        this: *const root::aeron::concurrent::logbuffer::Header,
                    ) -> ::std::os::raw::c_int;
                }
                extern "C" {
                    #[link_name = "\u{1}_ZNK5aeron10concurrent9logbuffer6Header13reservedValueEv"]
                    pub fn Header_reservedValue(
                        this: *const root::aeron::concurrent::logbuffer::Header,
                    ) -> ::std::os::raw::c_long;
                }
                extern "C" {
                    #[link_name = "\u{1}_ZNK5aeron10concurrent9logbuffer6Header7contextEv"]
                    pub fn Header_context(
                        this: *const root::aeron::concurrent::logbuffer::Header,
                    ) -> *mut ::std::os::raw::c_void;
                }
                extern "C" {
                    #[link_name = "\u{1}_ZN5aeron10concurrent9logbuffer6HeaderC1EiiPv"]
                    pub fn Header_Header(
                        this: *mut root::aeron::concurrent::logbuffer::Header,
                        initialTermId: ::std::os::raw::c_int,
                        capacity: root::aeron::util::index_t,
                        context: *mut ::std::os::raw::c_void,
                    );
                }
                impl Header {
                    #[inline]
                    pub unsafe fn initialTermId(&self) -> ::std::os::raw::c_int {
                        Header_initialTermId(self)
                    }
                    #[inline]
                    pub unsafe fn initialTermId1(&mut self, initialTermId: ::std::os::raw::c_int) {
                        Header_initialTermId1(self, initialTermId)
                    }
                    #[inline]
                    pub unsafe fn offset(&self) -> root::aeron::util::index_t {
                        Header_offset(self)
                    }
                    #[inline]
                    pub unsafe fn offset1(&mut self, offset: root::aeron::util::index_t) {
                        Header_offset1(self, offset)
                    }
                    #[inline]
                    pub unsafe fn buffer(&mut self) -> *mut root::aeron::concurrent::AtomicBuffer {
                        Header_buffer(self)
                    }
                    #[inline]
                    pub unsafe fn buffer1(
                        &mut self,
                        buffer: *mut root::aeron::concurrent::AtomicBuffer,
                    ) {
                        Header_buffer1(self, buffer)
                    }
                    #[inline]
                    pub unsafe fn frameLength(&self) -> ::std::os::raw::c_int {
                        Header_frameLength(self)
                    }
                    #[inline]
                    pub unsafe fn sessionId(&self) -> ::std::os::raw::c_int {
                        Header_sessionId(self)
                    }
                    #[inline]
                    pub unsafe fn streamId(&self) -> ::std::os::raw::c_int {
                        Header_streamId(self)
                    }
                    #[inline]
                    pub unsafe fn termId(&self) -> ::std::os::raw::c_int {
                        Header_termId(self)
                    }
                    #[inline]
                    pub unsafe fn termOffset(&self) -> ::std::os::raw::c_int {
                        Header_termOffset(self)
                    }
                    #[inline]
                    pub unsafe fn type_(&self) -> ::std::os::raw::c_ushort {
                        Header_type(self)
                    }
                    #[inline]
                    pub unsafe fn flags(&self) -> ::std::os::raw::c_uchar {
                        Header_flags(self)
                    }
                    #[inline]
                    pub unsafe fn position(&self) -> ::std::os::raw::c_long {
                        Header_position(self)
                    }
                    #[inline]
                    pub unsafe fn positionBitsToShift(&self) -> ::std::os::raw::c_int {
                        Header_positionBitsToShift(self)
                    }
                    #[inline]
                    pub unsafe fn reservedValue(&self) -> ::std::os::raw::c_long {
                        Header_reservedValue(self)
                    }
                    #[inline]
                    pub unsafe fn context(&self) -> *mut ::std::os::raw::c_void {
                        Header_context(self)
                    }
                    #[inline]
                    pub unsafe fn new(
                        initialTermId: ::std::os::raw::c_int,
                        capacity: root::aeron::util::index_t,
                        context: *mut ::std::os::raw::c_void,
                    ) -> Self {
                        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                        Header_Header(__bindgen_tmp.as_mut_ptr(), initialTermId, capacity, context);
                        __bindgen_tmp.assume_init()
                    }
                }
                pub type fragment_handler_t = u8;
                pub mod TermReader {
                    #[allow(unused_imports)]
                    use self::super::super::super::super::super::root;
                    #[repr(C)]
                    #[derive(Copy, Clone)]
                    pub struct ReadOutcome {
                        pub offset: ::std::os::raw::c_int,
                        pub fragmentsRead: ::std::os::raw::c_int,
                    }
                    #[test]
                    fn bindgen_test_layout_ReadOutcome() {
                        const UNINIT: ::std::mem::MaybeUninit<ReadOutcome> =
                            ::std::mem::MaybeUninit::uninit();
                        let ptr = UNINIT.as_ptr();
                        assert_eq!(
                            ::std::mem::size_of::<ReadOutcome>(),
                            8usize,
                            concat!("Size of: ", stringify!(ReadOutcome))
                        );
                        assert_eq!(
                            ::std::mem::align_of::<ReadOutcome>(),
                            4usize,
                            concat!("Alignment of ", stringify!(ReadOutcome))
                        );
                        assert_eq!(
                            unsafe { ::std::ptr::addr_of!((*ptr).offset) as usize - ptr as usize },
                            0usize,
                            concat!(
                                "Offset of field: ",
                                stringify!(ReadOutcome),
                                "::",
                                stringify!(offset)
                            )
                        );
                        assert_eq!(
                            unsafe {
                                ::std::ptr::addr_of!((*ptr).fragmentsRead) as usize - ptr as usize
                            },
                            4usize,
                            concat!(
                                "Offset of field: ",
                                stringify!(ReadOutcome),
                                "::",
                                stringify!(fragmentsRead)
                            )
                        );
                    }
                }
                pub type block_handler_t = u8;
                pub mod TermBlockScanner {
                    #[allow(unused_imports)]
                    use self::super::super::super::super::super::root;
                    extern "C" {
                        #[link_name = "\u{1}_ZN5aeron10concurrent9logbuffer16TermBlockScanner4scanERKNS0_12AtomicBufferEii"]
                        pub fn scan(
                            termBuffer: *const root::aeron::concurrent::AtomicBuffer,
                            termOffset: ::std::os::raw::c_int,
                            limitOffset: ::std::os::raw::c_int,
                        ) -> ::std::os::raw::c_int;
                    }
                }
            }
            pub type on_counters_metadata_t = u8;
            #[repr(C)]
            #[derive(Copy, Clone)]
            pub struct CountersReader {
                pub m_metadataBuffer: root::aeron::concurrent::AtomicBuffer,
                pub m_valuesBuffer: root::aeron::concurrent::AtomicBuffer,
                pub m_maxCounterId: ::std::os::raw::c_int,
            }
            #[repr(C, packed(4))]
            #[derive(Copy, Clone)]
            pub struct CountersReader_CounterValueDefn {
                pub counterValue: ::std::os::raw::c_long,
                pub registrationId: ::std::os::raw::c_long,
                pub ownerId: ::std::os::raw::c_long,
                pub padding: [::std::os::raw::c_schar; 104usize],
            }
            #[test]
            fn bindgen_test_layout_CountersReader_CounterValueDefn() {
                const UNINIT: ::std::mem::MaybeUninit<CountersReader_CounterValueDefn> =
                    ::std::mem::MaybeUninit::uninit();
                let ptr = UNINIT.as_ptr();
                assert_eq!(
                    ::std::mem::size_of::<CountersReader_CounterValueDefn>(),
                    128usize,
                    concat!("Size of: ", stringify!(CountersReader_CounterValueDefn))
                );
                assert_eq!(
                    ::std::mem::align_of::<CountersReader_CounterValueDefn>(),
                    4usize,
                    concat!("Alignment of ", stringify!(CountersReader_CounterValueDefn))
                );
                assert_eq!(
                    unsafe { ::std::ptr::addr_of!((*ptr).counterValue) as usize - ptr as usize },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(CountersReader_CounterValueDefn),
                        "::",
                        stringify!(counterValue)
                    )
                );
                assert_eq!(
                    unsafe { ::std::ptr::addr_of!((*ptr).registrationId) as usize - ptr as usize },
                    8usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(CountersReader_CounterValueDefn),
                        "::",
                        stringify!(registrationId)
                    )
                );
                assert_eq!(
                    unsafe { ::std::ptr::addr_of!((*ptr).ownerId) as usize - ptr as usize },
                    16usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(CountersReader_CounterValueDefn),
                        "::",
                        stringify!(ownerId)
                    )
                );
                assert_eq!(
                    unsafe { ::std::ptr::addr_of!((*ptr).padding) as usize - ptr as usize },
                    24usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(CountersReader_CounterValueDefn),
                        "::",
                        stringify!(padding)
                    )
                );
            }
            #[repr(C, packed(4))]
            #[derive(Copy, Clone)]
            pub struct CountersReader_CounterMetaDataDefn {
                pub state: ::std::os::raw::c_int,
                pub typeId: ::std::os::raw::c_int,
                pub freeToReuseDeadline: ::std::os::raw::c_long,
                pub key: [::std::os::raw::c_schar; 112usize],
                pub labelLength: ::std::os::raw::c_int,
                pub label: [::std::os::raw::c_schar; 380usize],
            }
            #[test]
            fn bindgen_test_layout_CountersReader_CounterMetaDataDefn() {
                const UNINIT: ::std::mem::MaybeUninit<CountersReader_CounterMetaDataDefn> =
                    ::std::mem::MaybeUninit::uninit();
                let ptr = UNINIT.as_ptr();
                assert_eq!(
                    ::std::mem::size_of::<CountersReader_CounterMetaDataDefn>(),
                    512usize,
                    concat!("Size of: ", stringify!(CountersReader_CounterMetaDataDefn))
                );
                assert_eq!(
                    ::std::mem::align_of::<CountersReader_CounterMetaDataDefn>(),
                    4usize,
                    concat!(
                        "Alignment of ",
                        stringify!(CountersReader_CounterMetaDataDefn)
                    )
                );
                assert_eq!(
                    unsafe { ::std::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(CountersReader_CounterMetaDataDefn),
                        "::",
                        stringify!(state)
                    )
                );
                assert_eq!(
                    unsafe { ::std::ptr::addr_of!((*ptr).typeId) as usize - ptr as usize },
                    4usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(CountersReader_CounterMetaDataDefn),
                        "::",
                        stringify!(typeId)
                    )
                );
                assert_eq!(
                    unsafe {
                        ::std::ptr::addr_of!((*ptr).freeToReuseDeadline) as usize - ptr as usize
                    },
                    8usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(CountersReader_CounterMetaDataDefn),
                        "::",
                        stringify!(freeToReuseDeadline)
                    )
                );
                assert_eq!(
                    unsafe { ::std::ptr::addr_of!((*ptr).key) as usize - ptr as usize },
                    16usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(CountersReader_CounterMetaDataDefn),
                        "::",
                        stringify!(key)
                    )
                );
                assert_eq!(
                    unsafe { ::std::ptr::addr_of!((*ptr).labelLength) as usize - ptr as usize },
                    128usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(CountersReader_CounterMetaDataDefn),
                        "::",
                        stringify!(labelLength)
                    )
                );
                assert_eq!(
                    unsafe { ::std::ptr::addr_of!((*ptr).label) as usize - ptr as usize },
                    132usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(CountersReader_CounterMetaDataDefn),
                        "::",
                        stringify!(label)
                    )
                );
            }
            pub const CountersReader_NULL_COUNTER_ID: ::std::os::raw::c_int = -1;
            pub const CountersReader_RECORD_UNUSED: ::std::os::raw::c_int = 0;
            pub const CountersReader_RECORD_ALLOCATED: ::std::os::raw::c_int = 1;
            pub const CountersReader_RECORD_RECLAIMED: ::std::os::raw::c_int = -1;
            pub const CountersReader_DEFAULT_REGISTRATION_ID: ::std::os::raw::c_long = 0;
            pub const CountersReader_DEFAULT_OWNER_ID: ::std::os::raw::c_long = 0;
            pub const CountersReader_NOT_FREE_TO_REUSE: ::std::os::raw::c_long =
                9223372036854775807;
            extern "C" {
                #[link_name = "\u{1}_ZN5aeron10concurrent14CountersReader14COUNTER_LENGTHE"]
                pub static CountersReader_COUNTER_LENGTH: root::aeron::util::index_t;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN5aeron10concurrent14CountersReader22REGISTRATION_ID_OFFSETE"]
                pub static CountersReader_REGISTRATION_ID_OFFSET: root::aeron::util::index_t;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN5aeron10concurrent14CountersReader15OWNER_ID_OFFSETE"]
                pub static CountersReader_OWNER_ID_OFFSET: root::aeron::util::index_t;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN5aeron10concurrent14CountersReader15METADATA_LENGTHE"]
                pub static CountersReader_METADATA_LENGTH: root::aeron::util::index_t;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN5aeron10concurrent14CountersReader14TYPE_ID_OFFSETE"]
                pub static CountersReader_TYPE_ID_OFFSET: root::aeron::util::index_t;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN5aeron10concurrent14CountersReader30FREE_FOR_REUSE_DEADLINE_OFFSETE"]
                pub static CountersReader_FREE_FOR_REUSE_DEADLINE_OFFSET:
                    root::aeron::util::index_t;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN5aeron10concurrent14CountersReader10KEY_OFFSETE"]
                pub static CountersReader_KEY_OFFSET: root::aeron::util::index_t;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN5aeron10concurrent14CountersReader19LABEL_LENGTH_OFFSETE"]
                pub static CountersReader_LABEL_LENGTH_OFFSET: root::aeron::util::index_t;
            }
            pub const CountersReader_MAX_LABEL_LENGTH: ::std::os::raw::c_int = 380;
            pub const CountersReader_MAX_KEY_LENGTH: ::std::os::raw::c_int = 112;
            #[test]
            fn bindgen_test_layout_CountersReader() {
                const UNINIT: ::std::mem::MaybeUninit<CountersReader> =
                    ::std::mem::MaybeUninit::uninit();
                let ptr = UNINIT.as_ptr();
                assert_eq!(
                    ::std::mem::size_of::<CountersReader>(),
                    40usize,
                    concat!("Size of: ", stringify!(CountersReader))
                );
                assert_eq!(
                    ::std::mem::align_of::<CountersReader>(),
                    8usize,
                    concat!("Alignment of ", stringify!(CountersReader))
                );
                assert_eq!(
                    unsafe {
                        ::std::ptr::addr_of!((*ptr).m_metadataBuffer) as usize - ptr as usize
                    },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(CountersReader),
                        "::",
                        stringify!(m_metadataBuffer)
                    )
                );
                assert_eq!(
                    unsafe { ::std::ptr::addr_of!((*ptr).m_valuesBuffer) as usize - ptr as usize },
                    16usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(CountersReader),
                        "::",
                        stringify!(m_valuesBuffer)
                    )
                );
                assert_eq!(
                    unsafe { ::std::ptr::addr_of!((*ptr).m_maxCounterId) as usize - ptr as usize },
                    32usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(CountersReader),
                        "::",
                        stringify!(m_maxCounterId)
                    )
                );
            }
            extern "C" {
                #[link_name = "\u{1}_ZNK5aeron10concurrent14CountersReader20findByRegistrationIdEl"]
                pub fn CountersReader_findByRegistrationId(
                    this: *const root::aeron::concurrent::CountersReader,
                    registrationId: ::std::os::raw::c_long,
                ) -> ::std::os::raw::c_int;
            }
            extern "C" {
                #[link_name = "\u{1}_ZNK5aeron10concurrent14CountersReader29findByTypeIdAndRegistrationIdEil"]
                pub fn CountersReader_findByTypeIdAndRegistrationId(
                    this: *const root::aeron::concurrent::CountersReader,
                    typeId: ::std::os::raw::c_int,
                    registrationId: ::std::os::raw::c_long,
                ) -> ::std::os::raw::c_int;
            }
            extern "C" {
                #[link_name = "\u{1}_ZNK5aeron10concurrent14CountersReader12maxCounterIdEv"]
                pub fn CountersReader_maxCounterId(
                    this: *const root::aeron::concurrent::CountersReader,
                ) -> ::std::os::raw::c_int;
            }
            extern "C" {
                #[link_name = "\u{1}_ZNK5aeron10concurrent14CountersReader15getCounterValueEi"]
                pub fn CountersReader_getCounterValue(
                    this: *const root::aeron::concurrent::CountersReader,
                    id: ::std::os::raw::c_int,
                ) -> ::std::os::raw::c_long;
            }
            extern "C" {
                #[link_name = "\u{1}_ZNK5aeron10concurrent14CountersReader24getCounterRegistrationIdEi"]
                pub fn CountersReader_getCounterRegistrationId(
                    this: *const root::aeron::concurrent::CountersReader,
                    id: ::std::os::raw::c_int,
                ) -> ::std::os::raw::c_long;
            }
            extern "C" {
                #[link_name = "\u{1}_ZNK5aeron10concurrent14CountersReader17getCounterOwnerIdEi"]
                pub fn CountersReader_getCounterOwnerId(
                    this: *const root::aeron::concurrent::CountersReader,
                    id: ::std::os::raw::c_int,
                ) -> ::std::os::raw::c_long;
            }
            extern "C" {
                #[link_name = "\u{1}_ZNK5aeron10concurrent14CountersReader15getCounterStateEi"]
                pub fn CountersReader_getCounterState(
                    this: *const root::aeron::concurrent::CountersReader,
                    id: ::std::os::raw::c_int,
                ) -> ::std::os::raw::c_int;
            }
            extern "C" {
                #[link_name = "\u{1}_ZNK5aeron10concurrent14CountersReader16getCounterTypeIdEi"]
                pub fn CountersReader_getCounterTypeId(
                    this: *const root::aeron::concurrent::CountersReader,
                    id: ::std::os::raw::c_int,
                ) -> ::std::os::raw::c_int;
            }
            extern "C" {
                #[link_name = "\u{1}_ZNK5aeron10concurrent14CountersReader23getFreeForReuseDeadlineEi"]
                pub fn CountersReader_getFreeForReuseDeadline(
                    this: *const root::aeron::concurrent::CountersReader,
                    id: ::std::os::raw::c_int,
                ) -> ::std::os::raw::c_long;
            }
            extern "C" {
                #[link_name = "\u{1}_ZNK5aeron10concurrent14CountersReader15getCounterLabelB5cxx11Ei"]
                pub fn CountersReader_getCounterLabel(
                    this: *const root::aeron::concurrent::CountersReader,
                    id: ::std::os::raw::c_int,
                ) -> root::std::string;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN5aeron10concurrent14CountersReader13counterOffsetEi"]
                pub fn CountersReader_counterOffset(
                    counterId: ::std::os::raw::c_int,
                ) -> root::aeron::util::index_t;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN5aeron10concurrent14CountersReader14metadataOffsetEi"]
                pub fn CountersReader_metadataOffset(
                    counterId: ::std::os::raw::c_int,
                ) -> root::aeron::util::index_t;
            }
            extern "C" {
                #[link_name = "\u{1}_ZNK5aeron10concurrent14CountersReader12valuesBufferEv"]
                pub fn CountersReader_valuesBuffer(
                    this: *const root::aeron::concurrent::CountersReader,
                ) -> root::aeron::concurrent::AtomicBuffer;
            }
            extern "C" {
                #[link_name = "\u{1}_ZNK5aeron10concurrent14CountersReader14metaDataBufferEv"]
                pub fn CountersReader_metaDataBuffer(
                    this: *const root::aeron::concurrent::CountersReader,
                ) -> root::aeron::concurrent::AtomicBuffer;
            }
            extern "C" {
                #[link_name = "\u{1}_ZNK5aeron10concurrent14CountersReader17validateCounterIdEi"]
                pub fn CountersReader_validateCounterId(
                    this: *const root::aeron::concurrent::CountersReader,
                    counterId: ::std::os::raw::c_int,
                );
            }
            extern "C" {
                #[link_name = "\u{1}_ZN5aeron10concurrent14CountersReaderC1ERKNS0_12AtomicBufferES4_"]
                pub fn CountersReader_CountersReader(
                    this: *mut root::aeron::concurrent::CountersReader,
                    metadataBuffer: *const root::aeron::concurrent::AtomicBuffer,
                    valuesBuffer: *const root::aeron::concurrent::AtomicBuffer,
                );
            }
            impl CountersReader {
                #[inline]
                pub unsafe fn findByRegistrationId(
                    &self,
                    registrationId: ::std::os::raw::c_long,
                ) -> ::std::os::raw::c_int {
                    CountersReader_findByRegistrationId(self, registrationId)
                }
                #[inline]
                pub unsafe fn findByTypeIdAndRegistrationId(
                    &self,
                    typeId: ::std::os::raw::c_int,
                    registrationId: ::std::os::raw::c_long,
                ) -> ::std::os::raw::c_int {
                    CountersReader_findByTypeIdAndRegistrationId(self, typeId, registrationId)
                }
                #[inline]
                pub unsafe fn maxCounterId(&self) -> ::std::os::raw::c_int {
                    CountersReader_maxCounterId(self)
                }
                #[inline]
                pub unsafe fn getCounterValue(
                    &self,
                    id: ::std::os::raw::c_int,
                ) -> ::std::os::raw::c_long {
                    CountersReader_getCounterValue(self, id)
                }
                #[inline]
                pub unsafe fn getCounterRegistrationId(
                    &self,
                    id: ::std::os::raw::c_int,
                ) -> ::std::os::raw::c_long {
                    CountersReader_getCounterRegistrationId(self, id)
                }
                #[inline]
                pub unsafe fn getCounterOwnerId(
                    &self,
                    id: ::std::os::raw::c_int,
                ) -> ::std::os::raw::c_long {
                    CountersReader_getCounterOwnerId(self, id)
                }
                #[inline]
                pub unsafe fn getCounterState(
                    &self,
                    id: ::std::os::raw::c_int,
                ) -> ::std::os::raw::c_int {
                    CountersReader_getCounterState(self, id)
                }
                #[inline]
                pub unsafe fn getCounterTypeId(
                    &self,
                    id: ::std::os::raw::c_int,
                ) -> ::std::os::raw::c_int {
                    CountersReader_getCounterTypeId(self, id)
                }
                #[inline]
                pub unsafe fn getFreeForReuseDeadline(
                    &self,
                    id: ::std::os::raw::c_int,
                ) -> ::std::os::raw::c_long {
                    CountersReader_getFreeForReuseDeadline(self, id)
                }
                #[inline]
                pub unsafe fn getCounterLabel(
                    &self,
                    id: ::std::os::raw::c_int,
                ) -> root::std::string {
                    CountersReader_getCounterLabel(self, id)
                }
                #[inline]
                pub unsafe fn counterOffset(
                    counterId: ::std::os::raw::c_int,
                ) -> root::aeron::util::index_t {
                    CountersReader_counterOffset(counterId)
                }
                #[inline]
                pub unsafe fn metadataOffset(
                    counterId: ::std::os::raw::c_int,
                ) -> root::aeron::util::index_t {
                    CountersReader_metadataOffset(counterId)
                }
                #[inline]
                pub unsafe fn valuesBuffer(&self) -> root::aeron::concurrent::AtomicBuffer {
                    CountersReader_valuesBuffer(self)
                }
                #[inline]
                pub unsafe fn metaDataBuffer(&self) -> root::aeron::concurrent::AtomicBuffer {
                    CountersReader_metaDataBuffer(self)
                }
                #[inline]
                pub unsafe fn validateCounterId(&self, counterId: ::std::os::raw::c_int) {
                    CountersReader_validateCounterId(self, counterId)
                }
                #[inline]
                pub unsafe fn new(
                    metadataBuffer: *const root::aeron::concurrent::AtomicBuffer,
                    valuesBuffer: *const root::aeron::concurrent::AtomicBuffer,
                ) -> Self {
                    let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                    CountersReader_CountersReader(
                        __bindgen_tmp.as_mut_ptr(),
                        metadataBuffer,
                        valuesBuffer,
                    );
                    __bindgen_tmp.assume_init()
                }
            }
            #[repr(C)]
            pub struct CountersManager {
                pub _base: root::aeron::concurrent::CountersReader,
                pub m_freeList: [u64; 10usize],
                pub m_clock: root::aeron::concurrent::CountersManager_clock_t,
                pub m_freeToReuseTimeoutMs: ::std::os::raw::c_long,
                pub m_highWaterMark: root::aeron::util::index_t,
            }
            pub type CountersManager_clock_t = [u64; 4usize];
            #[test]
            fn bindgen_test_layout_CountersManager() {
                const UNINIT: ::std::mem::MaybeUninit<CountersManager> =
                    ::std::mem::MaybeUninit::uninit();
                let ptr = UNINIT.as_ptr();
                assert_eq!(
                    ::std::mem::size_of::<CountersManager>(),
                    168usize,
                    concat!("Size of: ", stringify!(CountersManager))
                );
                assert_eq!(
                    ::std::mem::align_of::<CountersManager>(),
                    8usize,
                    concat!("Alignment of ", stringify!(CountersManager))
                );
                assert_eq!(
                    unsafe { ::std::ptr::addr_of!((*ptr).m_freeList) as usize - ptr as usize },
                    40usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(CountersManager),
                        "::",
                        stringify!(m_freeList)
                    )
                );
                assert_eq!(
                    unsafe { ::std::ptr::addr_of!((*ptr).m_clock) as usize - ptr as usize },
                    120usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(CountersManager),
                        "::",
                        stringify!(m_clock)
                    )
                );
                assert_eq!(
                    unsafe {
                        ::std::ptr::addr_of!((*ptr).m_freeToReuseTimeoutMs) as usize - ptr as usize
                    },
                    152usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(CountersManager),
                        "::",
                        stringify!(m_freeToReuseTimeoutMs)
                    )
                );
                assert_eq!(
                    unsafe { ::std::ptr::addr_of!((*ptr).m_highWaterMark) as usize - ptr as usize },
                    160usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(CountersManager),
                        "::",
                        stringify!(m_highWaterMark)
                    )
                );
            }
            extern "C" {
                #[link_name = "\u{1}_ZN5aeron10concurrent15CountersManager8allocateEiPKhmRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
                pub fn CountersManager_allocate(
                    this: *mut root::aeron::concurrent::CountersManager,
                    typeId: ::std::os::raw::c_int,
                    key: *mut ::std::os::raw::c_uchar,
                    keyLength: usize,
                    label: *const root::std::string,
                ) -> ::std::os::raw::c_int;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN5aeron10concurrent15CountersManager8allocateERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
                pub fn CountersManager_allocate1(
                    this: *mut root::aeron::concurrent::CountersManager,
                    label: *const root::std::string,
                ) -> ::std::os::raw::c_int;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN5aeron10concurrent15CountersManager4freeEi"]
                pub fn CountersManager_free(
                    this: *mut root::aeron::concurrent::CountersManager,
                    counterId: ::std::os::raw::c_int,
                );
            }
            extern "C" {
                #[link_name = "\u{1}_ZN5aeron10concurrent15CountersManager15setCounterValueEil"]
                pub fn CountersManager_setCounterValue(
                    this: *mut root::aeron::concurrent::CountersManager,
                    counterId: ::std::os::raw::c_int,
                    value: ::std::os::raw::c_long,
                );
            }
            extern "C" {
                #[link_name = "\u{1}_ZN5aeron10concurrent15CountersManager24setCounterRegistrationIdEil"]
                pub fn CountersManager_setCounterRegistrationId(
                    this: *mut root::aeron::concurrent::CountersManager,
                    counterId: ::std::os::raw::c_int,
                    registrationId: ::std::os::raw::c_long,
                );
            }
            extern "C" {
                #[link_name = "\u{1}_ZN5aeron10concurrent15CountersManager17setCounterOwnerIdEil"]
                pub fn CountersManager_setCounterOwnerId(
                    this: *mut root::aeron::concurrent::CountersManager,
                    counterId: ::std::os::raw::c_int,
                    ownerId: ::std::os::raw::c_long,
                );
            }
            extern "C" {
                #[link_name = "\u{1}_ZN5aeron10concurrent15CountersManagerC1ERKNS0_12AtomicBufferES4_"]
                pub fn CountersManager_CountersManager(
                    this: *mut root::aeron::concurrent::CountersManager,
                    metadataBuffer: *const root::aeron::concurrent::AtomicBuffer,
                    valuesBuffer: *const root::aeron::concurrent::AtomicBuffer,
                );
            }
            extern "C" {
                #[link_name = "\u{1}_ZN5aeron10concurrent15CountersManagerC1ERKNS0_12AtomicBufferES4_RKSt8functionIFxvEEl"]
                pub fn CountersManager_CountersManager1(
                    this: *mut root::aeron::concurrent::CountersManager,
                    metadataBuffer: *const root::aeron::concurrent::AtomicBuffer,
                    valuesBuffer: *const root::aeron::concurrent::AtomicBuffer,
                    clock: *const root::aeron::concurrent::CountersManager_clock_t,
                    freeToReuseTimeoutMs: ::std::os::raw::c_long,
                );
            }
            impl CountersManager {
                #[inline]
                pub unsafe fn allocate(
                    &mut self,
                    typeId: ::std::os::raw::c_int,
                    key: *mut ::std::os::raw::c_uchar,
                    keyLength: usize,
                    label: *const root::std::string,
                ) -> ::std::os::raw::c_int {
                    CountersManager_allocate(self, typeId, key, keyLength, label)
                }
                #[inline]
                pub unsafe fn allocate1(
                    &mut self,
                    label: *const root::std::string,
                ) -> ::std::os::raw::c_int {
                    CountersManager_allocate1(self, label)
                }
                #[inline]
                pub unsafe fn free(&mut self, counterId: ::std::os::raw::c_int) {
                    CountersManager_free(self, counterId)
                }
                #[inline]
                pub unsafe fn setCounterValue(
                    &mut self,
                    counterId: ::std::os::raw::c_int,
                    value: ::std::os::raw::c_long,
                ) {
                    CountersManager_setCounterValue(self, counterId, value)
                }
                #[inline]
                pub unsafe fn setCounterRegistrationId(
                    &mut self,
                    counterId: ::std::os::raw::c_int,
                    registrationId: ::std::os::raw::c_long,
                ) {
                    CountersManager_setCounterRegistrationId(self, counterId, registrationId)
                }
                #[inline]
                pub unsafe fn setCounterOwnerId(
                    &mut self,
                    counterId: ::std::os::raw::c_int,
                    ownerId: ::std::os::raw::c_long,
                ) {
                    CountersManager_setCounterOwnerId(self, counterId, ownerId)
                }
                #[inline]
                pub unsafe fn new(
                    metadataBuffer: *const root::aeron::concurrent::AtomicBuffer,
                    valuesBuffer: *const root::aeron::concurrent::AtomicBuffer,
                ) -> Self {
                    let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                    CountersManager_CountersManager(
                        __bindgen_tmp.as_mut_ptr(),
                        metadataBuffer,
                        valuesBuffer,
                    );
                    __bindgen_tmp.assume_init()
                }
                #[inline]
                pub unsafe fn new1(
                    metadataBuffer: *const root::aeron::concurrent::AtomicBuffer,
                    valuesBuffer: *const root::aeron::concurrent::AtomicBuffer,
                    clock: *const root::aeron::concurrent::CountersManager_clock_t,
                    freeToReuseTimeoutMs: ::std::os::raw::c_long,
                ) -> Self {
                    let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                    CountersManager_CountersManager1(
                        __bindgen_tmp.as_mut_ptr(),
                        metadataBuffer,
                        valuesBuffer,
                        clock,
                        freeToReuseTimeoutMs,
                    );
                    __bindgen_tmp.assume_init()
                }
            }
            pub mod status {
                #[allow(unused_imports)]
                use self::super::super::super::super::root;
                #[repr(C)]
                #[derive(Copy, Clone)]
                pub struct ReadablePosition<X> {
                    pub m_impl: X,
                    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<X>>,
                }
                #[repr(C)]
                #[derive(Copy, Clone)]
                pub struct Position<X> {
                    pub _base: root::aeron::concurrent::status::ReadablePosition<X>,
                    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<X>>,
                }
                #[repr(C)]
                #[derive(Copy, Clone)]
                pub struct UnsafeBufferPosition {
                    pub m_buffer: root::aeron::concurrent::AtomicBuffer,
                    pub m_id: ::std::os::raw::c_int,
                    pub m_offset: ::std::os::raw::c_int,
                }
                #[test]
                fn bindgen_test_layout_UnsafeBufferPosition() {
                    const UNINIT: ::std::mem::MaybeUninit<UnsafeBufferPosition> =
                        ::std::mem::MaybeUninit::uninit();
                    let ptr = UNINIT.as_ptr();
                    assert_eq!(
                        ::std::mem::size_of::<UnsafeBufferPosition>(),
                        24usize,
                        concat!("Size of: ", stringify!(UnsafeBufferPosition))
                    );
                    assert_eq!(
                        ::std::mem::align_of::<UnsafeBufferPosition>(),
                        8usize,
                        concat!("Alignment of ", stringify!(UnsafeBufferPosition))
                    );
                    assert_eq!(
                        unsafe { ::std::ptr::addr_of!((*ptr).m_buffer) as usize - ptr as usize },
                        0usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(UnsafeBufferPosition),
                            "::",
                            stringify!(m_buffer)
                        )
                    );
                    assert_eq!(
                        unsafe { ::std::ptr::addr_of!((*ptr).m_id) as usize - ptr as usize },
                        16usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(UnsafeBufferPosition),
                            "::",
                            stringify!(m_id)
                        )
                    );
                    assert_eq!(
                        unsafe { ::std::ptr::addr_of!((*ptr).m_offset) as usize - ptr as usize },
                        20usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(UnsafeBufferPosition),
                            "::",
                            stringify!(m_offset)
                        )
                    );
                }
                extern "C" {
                    #[link_name = "\u{1}_ZN5aeron10concurrent6status20UnsafeBufferPosition4wrapERKS2_"]
                    pub fn UnsafeBufferPosition_wrap(
                        this: *mut root::aeron::concurrent::status::UnsafeBufferPosition,
                        position: *const root::aeron::concurrent::status::UnsafeBufferPosition,
                    );
                }
                extern "C" {
                    #[link_name = "\u{1}_ZNK5aeron10concurrent6status20UnsafeBufferPosition2idEv"]
                    pub fn UnsafeBufferPosition_id(
                        this: *const root::aeron::concurrent::status::UnsafeBufferPosition,
                    ) -> ::std::os::raw::c_int;
                }
                extern "C" {
                    #[link_name = "\u{1}_ZNK5aeron10concurrent6status20UnsafeBufferPosition3getEv"]
                    pub fn UnsafeBufferPosition_get(
                        this: *const root::aeron::concurrent::status::UnsafeBufferPosition,
                    ) -> ::std::os::raw::c_long;
                }
                extern "C" {
                    #[link_name = "\u{1}_ZNK5aeron10concurrent6status20UnsafeBufferPosition11getVolatileEv"]
                    pub fn UnsafeBufferPosition_getVolatile(
                        this: *const root::aeron::concurrent::status::UnsafeBufferPosition,
                    ) -> ::std::os::raw::c_long;
                }
                extern "C" {
                    #[link_name = "\u{1}_ZN5aeron10concurrent6status20UnsafeBufferPosition3setEl"]
                    pub fn UnsafeBufferPosition_set(
                        this: *mut root::aeron::concurrent::status::UnsafeBufferPosition,
                        value: ::std::os::raw::c_long,
                    );
                }
                extern "C" {
                    #[link_name = "\u{1}_ZN5aeron10concurrent6status20UnsafeBufferPosition10setOrderedEl"]
                    pub fn UnsafeBufferPosition_setOrdered(
                        this: *mut root::aeron::concurrent::status::UnsafeBufferPosition,
                        value: ::std::os::raw::c_long,
                    );
                }
                extern "C" {
                    #[link_name = "\u{1}_ZN5aeron10concurrent6status20UnsafeBufferPosition5closeEv"]
                    pub fn UnsafeBufferPosition_close(
                        this: *mut root::aeron::concurrent::status::UnsafeBufferPosition,
                    );
                }
                extern "C" {
                    #[link_name = "\u{1}_ZN5aeron10concurrent6status20UnsafeBufferPositionC1ERNS0_12AtomicBufferEi"]
                    pub fn UnsafeBufferPosition_UnsafeBufferPosition(
                        this: *mut root::aeron::concurrent::status::UnsafeBufferPosition,
                        buffer: *mut root::aeron::concurrent::AtomicBuffer,
                        id: ::std::os::raw::c_int,
                    );
                }
                extern "C" {
                    #[link_name = "\u{1}_ZN5aeron10concurrent6status20UnsafeBufferPositionC1Ev"]
                    pub fn UnsafeBufferPosition_UnsafeBufferPosition1(
                        this: *mut root::aeron::concurrent::status::UnsafeBufferPosition,
                    );
                }
                impl UnsafeBufferPosition {
                    #[inline]
                    pub unsafe fn wrap(
                        &mut self,
                        position: *const root::aeron::concurrent::status::UnsafeBufferPosition,
                    ) {
                        UnsafeBufferPosition_wrap(self, position)
                    }
                    #[inline]
                    pub unsafe fn id(&self) -> ::std::os::raw::c_int {
                        UnsafeBufferPosition_id(self)
                    }
                    #[inline]
                    pub unsafe fn get(&self) -> ::std::os::raw::c_long {
                        UnsafeBufferPosition_get(self)
                    }
                    #[inline]
                    pub unsafe fn getVolatile(&self) -> ::std::os::raw::c_long {
                        UnsafeBufferPosition_getVolatile(self)
                    }
                    #[inline]
                    pub unsafe fn set(&mut self, value: ::std::os::raw::c_long) {
                        UnsafeBufferPosition_set(self, value)
                    }
                    #[inline]
                    pub unsafe fn setOrdered(&mut self, value: ::std::os::raw::c_long) {
                        UnsafeBufferPosition_setOrdered(self, value)
                    }
                    #[inline]
                    pub unsafe fn close(&mut self) {
                        UnsafeBufferPosition_close(self)
                    }
                    #[inline]
                    pub unsafe fn new(
                        buffer: *mut root::aeron::concurrent::AtomicBuffer,
                        id: ::std::os::raw::c_int,
                    ) -> Self {
                        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                        UnsafeBufferPosition_UnsafeBufferPosition(
                            __bindgen_tmp.as_mut_ptr(),
                            buffer,
                            id,
                        );
                        __bindgen_tmp.assume_init()
                    }
                    #[inline]
                    pub unsafe fn new1() -> Self {
                        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                        UnsafeBufferPosition_UnsafeBufferPosition1(__bindgen_tmp.as_mut_ptr());
                        __bindgen_tmp.assume_init()
                    }
                }
                #[repr(C)]
                #[derive(Copy, Clone)]
                pub struct StatusIndicatorReader {
                    pub m_staticBuffer: [u8; 8usize],
                    pub m_buffer: root::aeron::concurrent::AtomicBuffer,
                    pub m_id: ::std::os::raw::c_int,
                    pub m_offset: ::std::os::raw::c_int,
                }
                #[test]
                fn bindgen_test_layout_StatusIndicatorReader() {
                    const UNINIT: ::std::mem::MaybeUninit<StatusIndicatorReader> =
                        ::std::mem::MaybeUninit::uninit();
                    let ptr = UNINIT.as_ptr();
                    assert_eq!(
                        ::std::mem::size_of::<StatusIndicatorReader>(),
                        32usize,
                        concat!("Size of: ", stringify!(StatusIndicatorReader))
                    );
                    assert_eq!(
                        ::std::mem::align_of::<StatusIndicatorReader>(),
                        8usize,
                        concat!("Alignment of ", stringify!(StatusIndicatorReader))
                    );
                    assert_eq!(
                        unsafe {
                            ::std::ptr::addr_of!((*ptr).m_staticBuffer) as usize - ptr as usize
                        },
                        0usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(StatusIndicatorReader),
                            "::",
                            stringify!(m_staticBuffer)
                        )
                    );
                    assert_eq!(
                        unsafe { ::std::ptr::addr_of!((*ptr).m_buffer) as usize - ptr as usize },
                        8usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(StatusIndicatorReader),
                            "::",
                            stringify!(m_buffer)
                        )
                    );
                    assert_eq!(
                        unsafe { ::std::ptr::addr_of!((*ptr).m_id) as usize - ptr as usize },
                        24usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(StatusIndicatorReader),
                            "::",
                            stringify!(m_id)
                        )
                    );
                    assert_eq!(
                        unsafe { ::std::ptr::addr_of!((*ptr).m_offset) as usize - ptr as usize },
                        28usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(StatusIndicatorReader),
                            "::",
                            stringify!(m_offset)
                        )
                    );
                }
                extern "C" {
                    #[link_name = "\u{1}_ZNK5aeron10concurrent6status21StatusIndicatorReader2idEv"]
                    pub fn StatusIndicatorReader_id(
                        this: *const root::aeron::concurrent::status::StatusIndicatorReader,
                    ) -> ::std::os::raw::c_int;
                }
                extern "C" {
                    #[link_name = "\u{1}_ZNK5aeron10concurrent6status21StatusIndicatorReader11getVolatileEv"]
                    pub fn StatusIndicatorReader_getVolatile(
                        this: *const root::aeron::concurrent::status::StatusIndicatorReader,
                    ) -> ::std::os::raw::c_long;
                }
                extern "C" {
                    #[link_name = "\u{1}_ZN5aeron10concurrent6status21StatusIndicatorReaderC1ERNS0_12AtomicBufferEi"]
                    pub fn StatusIndicatorReader_StatusIndicatorReader(
                        this: *mut root::aeron::concurrent::status::StatusIndicatorReader,
                        buffer: *mut root::aeron::concurrent::AtomicBuffer,
                        id: ::std::os::raw::c_int,
                    );
                }
                extern "C" {
                    #[link_name = "\u{1}_ZN5aeron10concurrent6status21StatusIndicatorReaderC1ERKS2_"]
                    pub fn StatusIndicatorReader_StatusIndicatorReader1(
                        this: *mut root::aeron::concurrent::status::StatusIndicatorReader,
                        indicatorReader : * const root :: aeron :: concurrent :: status :: StatusIndicatorReader,
                    );
                }
                impl StatusIndicatorReader {
                    #[inline]
                    pub unsafe fn id(&self) -> ::std::os::raw::c_int {
                        StatusIndicatorReader_id(self)
                    }
                    #[inline]
                    pub unsafe fn getVolatile(&self) -> ::std::os::raw::c_long {
                        StatusIndicatorReader_getVolatile(self)
                    }
                    #[inline]
                    pub unsafe fn new(
                        buffer: *mut root::aeron::concurrent::AtomicBuffer,
                        id: ::std::os::raw::c_int,
                    ) -> Self {
                        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                        StatusIndicatorReader_StatusIndicatorReader(
                            __bindgen_tmp.as_mut_ptr(),
                            buffer,
                            id,
                        );
                        __bindgen_tmp.assume_init()
                    }
                    #[inline]
                    pub unsafe fn new1(
                        indicatorReader : * const root :: aeron :: concurrent :: status :: StatusIndicatorReader,
                    ) -> Self {
                        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                        StatusIndicatorReader_StatusIndicatorReader1(
                            __bindgen_tmp.as_mut_ptr(),
                            indicatorReader,
                        );
                        __bindgen_tmp.assume_init()
                    }
                }
            }
            #[repr(C)]
            pub struct AtomicArrayUpdater<E> {
                pub m_beginChange: u64,
                pub m_array: *mut E,
                pub m_length: usize,
                pub m_endChange: u64,
                pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<E>>,
            }
            #[repr(C)]
            pub struct AtomicCounter {
                pub m_buffer: root::aeron::concurrent::AtomicBuffer,
                pub m_counterId: ::std::os::raw::c_int,
                pub m_countersManager: [u64; 2usize],
                pub m_offset: root::aeron::util::index_t,
            }
            #[test]
            fn bindgen_test_layout_AtomicCounter() {
                const UNINIT: ::std::mem::MaybeUninit<AtomicCounter> =
                    ::std::mem::MaybeUninit::uninit();
                let ptr = UNINIT.as_ptr();
                assert_eq!(
                    ::std::mem::size_of::<AtomicCounter>(),
                    48usize,
                    concat!("Size of: ", stringify!(AtomicCounter))
                );
                assert_eq!(
                    ::std::mem::align_of::<AtomicCounter>(),
                    8usize,
                    concat!("Alignment of ", stringify!(AtomicCounter))
                );
                assert_eq!(
                    unsafe { ::std::ptr::addr_of!((*ptr).m_buffer) as usize - ptr as usize },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(AtomicCounter),
                        "::",
                        stringify!(m_buffer)
                    )
                );
                assert_eq!(
                    unsafe { ::std::ptr::addr_of!((*ptr).m_counterId) as usize - ptr as usize },
                    16usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(AtomicCounter),
                        "::",
                        stringify!(m_counterId)
                    )
                );
                assert_eq!(
                    unsafe {
                        ::std::ptr::addr_of!((*ptr).m_countersManager) as usize - ptr as usize
                    },
                    24usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(AtomicCounter),
                        "::",
                        stringify!(m_countersManager)
                    )
                );
                assert_eq!(
                    unsafe { ::std::ptr::addr_of!((*ptr).m_offset) as usize - ptr as usize },
                    40usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(AtomicCounter),
                        "::",
                        stringify!(m_offset)
                    )
                );
            }
            extern "C" {
                #[link_name = "\u{1}_ZNK5aeron10concurrent13AtomicCounter2idEv"]
                pub fn AtomicCounter_id(
                    this: *const root::aeron::concurrent::AtomicCounter,
                ) -> ::std::os::raw::c_int;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN5aeron10concurrent13AtomicCounter9incrementEv"]
                pub fn AtomicCounter_increment(this: *mut root::aeron::concurrent::AtomicCounter);
            }
            extern "C" {
                #[link_name = "\u{1}_ZN5aeron10concurrent13AtomicCounter16incrementOrderedEv"]
                pub fn AtomicCounter_incrementOrdered(
                    this: *mut root::aeron::concurrent::AtomicCounter,
                );
            }
            extern "C" {
                #[link_name = "\u{1}_ZN5aeron10concurrent13AtomicCounter3setEl"]
                pub fn AtomicCounter_set(
                    this: *mut root::aeron::concurrent::AtomicCounter,
                    value: ::std::os::raw::c_long,
                );
            }
            extern "C" {
                #[link_name = "\u{1}_ZN5aeron10concurrent13AtomicCounter10setOrderedEl"]
                pub fn AtomicCounter_setOrdered(
                    this: *mut root::aeron::concurrent::AtomicCounter,
                    value: ::std::os::raw::c_long,
                );
            }
            extern "C" {
                #[link_name = "\u{1}_ZN5aeron10concurrent13AtomicCounter7setWeakEl"]
                pub fn AtomicCounter_setWeak(
                    this: *mut root::aeron::concurrent::AtomicCounter,
                    value: ::std::os::raw::c_long,
                );
            }
            extern "C" {
                #[link_name = "\u{1}_ZN5aeron10concurrent13AtomicCounter9getAndAddEl"]
                pub fn AtomicCounter_getAndAdd(
                    this: *mut root::aeron::concurrent::AtomicCounter,
                    value: ::std::os::raw::c_long,
                ) -> ::std::os::raw::c_long;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN5aeron10concurrent13AtomicCounter16getAndAddOrderedEl"]
                pub fn AtomicCounter_getAndAddOrdered(
                    this: *mut root::aeron::concurrent::AtomicCounter,
                    increment: ::std::os::raw::c_long,
                ) -> ::std::os::raw::c_long;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN5aeron10concurrent13AtomicCounter9getAndSetEl"]
                pub fn AtomicCounter_getAndSet(
                    this: *mut root::aeron::concurrent::AtomicCounter,
                    value: ::std::os::raw::c_long,
                ) -> ::std::os::raw::c_long;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN5aeron10concurrent13AtomicCounter13compareAndSetEll"]
                pub fn AtomicCounter_compareAndSet(
                    this: *mut root::aeron::concurrent::AtomicCounter,
                    expectedValue: ::std::os::raw::c_long,
                    updateValue: ::std::os::raw::c_long,
                ) -> bool;
            }
            extern "C" {
                #[link_name = "\u{1}_ZNK5aeron10concurrent13AtomicCounter3getEv"]
                pub fn AtomicCounter_get(
                    this: *const root::aeron::concurrent::AtomicCounter,
                ) -> ::std::os::raw::c_long;
            }
            extern "C" {
                #[link_name = "\u{1}_ZNK5aeron10concurrent13AtomicCounter7getWeakEv"]
                pub fn AtomicCounter_getWeak(
                    this: *const root::aeron::concurrent::AtomicCounter,
                ) -> ::std::os::raw::c_long;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN5aeron10concurrent13AtomicCounterC1ERKNS0_12AtomicBufferEiSt10shared_ptrINS0_15CountersManagerEE"]
                pub fn AtomicCounter_AtomicCounter(
                    this: *mut root::aeron::concurrent::AtomicCounter,
                    buffer: *const root::aeron::concurrent::AtomicBuffer,
                    counterId: ::std::os::raw::c_int,
                    countersManager: [u64; 2usize],
                );
            }
            extern "C" {
                #[link_name = "\u{1}_ZN5aeron10concurrent13AtomicCounterC1ERKNS0_12AtomicBufferEi"]
                pub fn AtomicCounter_AtomicCounter1(
                    this: *mut root::aeron::concurrent::AtomicCounter,
                    buffer: *const root::aeron::concurrent::AtomicBuffer,
                    counterId: ::std::os::raw::c_int,
                );
            }
            extern "C" {
                #[link_name = "\u{1}_ZN5aeron10concurrent13AtomicCounterD1Ev"]
                pub fn AtomicCounter_AtomicCounter_destructor(
                    this: *mut root::aeron::concurrent::AtomicCounter,
                );
            }
            impl AtomicCounter {
                #[inline]
                pub unsafe fn id(&self) -> ::std::os::raw::c_int {
                    AtomicCounter_id(self)
                }
                #[inline]
                pub unsafe fn increment(&mut self) {
                    AtomicCounter_increment(self)
                }
                #[inline]
                pub unsafe fn incrementOrdered(&mut self) {
                    AtomicCounter_incrementOrdered(self)
                }
                #[inline]
                pub unsafe fn set(&mut self, value: ::std::os::raw::c_long) {
                    AtomicCounter_set(self, value)
                }
                #[inline]
                pub unsafe fn setOrdered(&mut self, value: ::std::os::raw::c_long) {
                    AtomicCounter_setOrdered(self, value)
                }
                #[inline]
                pub unsafe fn setWeak(&mut self, value: ::std::os::raw::c_long) {
                    AtomicCounter_setWeak(self, value)
                }
                #[inline]
                pub unsafe fn getAndAdd(
                    &mut self,
                    value: ::std::os::raw::c_long,
                ) -> ::std::os::raw::c_long {
                    AtomicCounter_getAndAdd(self, value)
                }
                #[inline]
                pub unsafe fn getAndAddOrdered(
                    &mut self,
                    increment: ::std::os::raw::c_long,
                ) -> ::std::os::raw::c_long {
                    AtomicCounter_getAndAddOrdered(self, increment)
                }
                #[inline]
                pub unsafe fn getAndSet(
                    &mut self,
                    value: ::std::os::raw::c_long,
                ) -> ::std::os::raw::c_long {
                    AtomicCounter_getAndSet(self, value)
                }
                #[inline]
                pub unsafe fn compareAndSet(
                    &mut self,
                    expectedValue: ::std::os::raw::c_long,
                    updateValue: ::std::os::raw::c_long,
                ) -> bool {
                    AtomicCounter_compareAndSet(self, expectedValue, updateValue)
                }
                #[inline]
                pub unsafe fn get(&self) -> ::std::os::raw::c_long {
                    AtomicCounter_get(self)
                }
                #[inline]
                pub unsafe fn getWeak(&self) -> ::std::os::raw::c_long {
                    AtomicCounter_getWeak(self)
                }
                #[inline]
                pub unsafe fn new(
                    buffer: *const root::aeron::concurrent::AtomicBuffer,
                    counterId: ::std::os::raw::c_int,
                    countersManager: [u64; 2usize],
                ) -> Self {
                    let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                    AtomicCounter_AtomicCounter(
                        __bindgen_tmp.as_mut_ptr(),
                        buffer,
                        counterId,
                        countersManager,
                    );
                    __bindgen_tmp.assume_init()
                }
                #[inline]
                pub unsafe fn new1(
                    buffer: *const root::aeron::concurrent::AtomicBuffer,
                    counterId: ::std::os::raw::c_int,
                ) -> Self {
                    let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                    AtomicCounter_AtomicCounter1(__bindgen_tmp.as_mut_ptr(), buffer, counterId);
                    __bindgen_tmp.assume_init()
                }
                #[inline]
                pub unsafe fn destruct(&mut self) {
                    AtomicCounter_AtomicCounter_destructor(self)
                }
            }
            pub mod ringbuffer {
                #[allow(unused_imports)]
                use self::super::super::super::super::root;
                pub type handler_t = [u64; 4usize];
                pub mod RingBufferDescriptor {
                    #[allow(unused_imports)]
                    use self::super::super::super::super::super::root;
                }
                pub mod RecordDescriptor {
                    #[allow(unused_imports)]
                    use self::super::super::super::super::super::root;
                }
                #[repr(C)]
                #[derive(Copy, Clone)]
                pub struct ManyToOneRingBuffer {
                    pub m_buffer: *mut root::aeron::concurrent::AtomicBuffer,
                    pub m_capacity: root::aeron::util::index_t,
                    pub m_maxMsgLength: root::aeron::util::index_t,
                    pub m_headPositionIndex: root::aeron::util::index_t,
                    pub m_headCachePositionIndex: root::aeron::util::index_t,
                    pub m_tailPositionIndex: root::aeron::util::index_t,
                    pub m_correlationIdCounterIndex: root::aeron::util::index_t,
                    pub m_consumerHeartbeatIndex: root::aeron::util::index_t,
                }
                extern "C" {
                    #[link_name = "\u{1}_ZN5aeron10concurrent10ringbuffer19ManyToOneRingBuffer21INSUFFICIENT_CAPACITYE"]
                    pub static ManyToOneRingBuffer_INSUFFICIENT_CAPACITY:
                        root::aeron::util::index_t;
                }
                #[test]
                fn bindgen_test_layout_ManyToOneRingBuffer() {
                    const UNINIT: ::std::mem::MaybeUninit<ManyToOneRingBuffer> =
                        ::std::mem::MaybeUninit::uninit();
                    let ptr = UNINIT.as_ptr();
                    assert_eq!(
                        ::std::mem::size_of::<ManyToOneRingBuffer>(),
                        40usize,
                        concat!("Size of: ", stringify!(ManyToOneRingBuffer))
                    );
                    assert_eq!(
                        ::std::mem::align_of::<ManyToOneRingBuffer>(),
                        8usize,
                        concat!("Alignment of ", stringify!(ManyToOneRingBuffer))
                    );
                    assert_eq!(
                        unsafe { ::std::ptr::addr_of!((*ptr).m_buffer) as usize - ptr as usize },
                        0usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(ManyToOneRingBuffer),
                            "::",
                            stringify!(m_buffer)
                        )
                    );
                    assert_eq!(
                        unsafe { ::std::ptr::addr_of!((*ptr).m_capacity) as usize - ptr as usize },
                        8usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(ManyToOneRingBuffer),
                            "::",
                            stringify!(m_capacity)
                        )
                    );
                    assert_eq!(
                        unsafe {
                            ::std::ptr::addr_of!((*ptr).m_maxMsgLength) as usize - ptr as usize
                        },
                        12usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(ManyToOneRingBuffer),
                            "::",
                            stringify!(m_maxMsgLength)
                        )
                    );
                    assert_eq!(
                        unsafe {
                            ::std::ptr::addr_of!((*ptr).m_headPositionIndex) as usize - ptr as usize
                        },
                        16usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(ManyToOneRingBuffer),
                            "::",
                            stringify!(m_headPositionIndex)
                        )
                    );
                    assert_eq!(
                        unsafe {
                            ::std::ptr::addr_of!((*ptr).m_headCachePositionIndex) as usize
                                - ptr as usize
                        },
                        20usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(ManyToOneRingBuffer),
                            "::",
                            stringify!(m_headCachePositionIndex)
                        )
                    );
                    assert_eq!(
                        unsafe {
                            ::std::ptr::addr_of!((*ptr).m_tailPositionIndex) as usize - ptr as usize
                        },
                        24usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(ManyToOneRingBuffer),
                            "::",
                            stringify!(m_tailPositionIndex)
                        )
                    );
                    assert_eq!(
                        unsafe {
                            ::std::ptr::addr_of!((*ptr).m_correlationIdCounterIndex) as usize
                                - ptr as usize
                        },
                        28usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(ManyToOneRingBuffer),
                            "::",
                            stringify!(m_correlationIdCounterIndex)
                        )
                    );
                    assert_eq!(
                        unsafe {
                            ::std::ptr::addr_of!((*ptr).m_consumerHeartbeatIndex) as usize
                                - ptr as usize
                        },
                        32usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(ManyToOneRingBuffer),
                            "::",
                            stringify!(m_consumerHeartbeatIndex)
                        )
                    );
                }
                extern "C" {
                    #[link_name = "\u{1}_ZNK5aeron10concurrent10ringbuffer19ManyToOneRingBuffer8capacityEv"]
                    pub fn ManyToOneRingBuffer_capacity(
                        this: *const root::aeron::concurrent::ringbuffer::ManyToOneRingBuffer,
                    ) -> root::aeron::util::index_t;
                }
                extern "C" {
                    #[link_name = "\u{1}_ZN5aeron10concurrent10ringbuffer19ManyToOneRingBuffer5writeEiRNS0_12AtomicBufferEii"]
                    pub fn ManyToOneRingBuffer_write(
                        this: *mut root::aeron::concurrent::ringbuffer::ManyToOneRingBuffer,
                        msgTypeId: ::std::os::raw::c_int,
                        srcBuffer: *mut root::aeron::concurrent::AtomicBuffer,
                        srcIndex: root::aeron::util::index_t,
                        length: root::aeron::util::index_t,
                    ) -> bool;
                }
                extern "C" {
                    #[link_name = "\u{1}_ZN5aeron10concurrent10ringbuffer19ManyToOneRingBuffer4readERKSt8functionIFviRNS0_12AtomicBufferEiiEEi"]
                    pub fn ManyToOneRingBuffer_read(
                        this: *mut root::aeron::concurrent::ringbuffer::ManyToOneRingBuffer,
                        handler: *const root::aeron::concurrent::ringbuffer::handler_t,
                        messageCountLimit: ::std::os::raw::c_int,
                    ) -> ::std::os::raw::c_int;
                }
                extern "C" {
                    #[link_name = "\u{1}_ZN5aeron10concurrent10ringbuffer19ManyToOneRingBuffer4readERKSt8functionIFviRNS0_12AtomicBufferEiiEE"]
                    pub fn ManyToOneRingBuffer_read1(
                        this: *mut root::aeron::concurrent::ringbuffer::ManyToOneRingBuffer,
                        handler: *const root::aeron::concurrent::ringbuffer::handler_t,
                    ) -> ::std::os::raw::c_int;
                }
                extern "C" {
                    #[link_name = "\u{1}_ZNK5aeron10concurrent10ringbuffer19ManyToOneRingBuffer12maxMsgLengthEv"]
                    pub fn ManyToOneRingBuffer_maxMsgLength(
                        this: *const root::aeron::concurrent::ringbuffer::ManyToOneRingBuffer,
                    ) -> root::aeron::util::index_t;
                }
                extern "C" {
                    #[link_name = "\u{1}_ZN5aeron10concurrent10ringbuffer19ManyToOneRingBuffer17nextCorrelationIdEv"]
                    pub fn ManyToOneRingBuffer_nextCorrelationId(
                        this: *mut root::aeron::concurrent::ringbuffer::ManyToOneRingBuffer,
                    ) -> ::std::os::raw::c_long;
                }
                extern "C" {
                    #[link_name = "\u{1}_ZN5aeron10concurrent10ringbuffer19ManyToOneRingBuffer21consumerHeartbeatTimeEl"]
                    pub fn ManyToOneRingBuffer_consumerHeartbeatTime(
                        this: *mut root::aeron::concurrent::ringbuffer::ManyToOneRingBuffer,
                        time: ::std::os::raw::c_long,
                    );
                }
                extern "C" {
                    #[link_name = "\u{1}_ZNK5aeron10concurrent10ringbuffer19ManyToOneRingBuffer21consumerHeartbeatTimeEv"]
                    pub fn ManyToOneRingBuffer_consumerHeartbeatTime1(
                        this: *const root::aeron::concurrent::ringbuffer::ManyToOneRingBuffer,
                    ) -> ::std::os::raw::c_long;
                }
                extern "C" {
                    #[link_name = "\u{1}_ZNK5aeron10concurrent10ringbuffer19ManyToOneRingBuffer16producerPositionEv"]
                    pub fn ManyToOneRingBuffer_producerPosition(
                        this: *const root::aeron::concurrent::ringbuffer::ManyToOneRingBuffer,
                    ) -> ::std::os::raw::c_long;
                }
                extern "C" {
                    #[link_name = "\u{1}_ZNK5aeron10concurrent10ringbuffer19ManyToOneRingBuffer16consumerPositionEv"]
                    pub fn ManyToOneRingBuffer_consumerPosition(
                        this: *const root::aeron::concurrent::ringbuffer::ManyToOneRingBuffer,
                    ) -> ::std::os::raw::c_long;
                }
                extern "C" {
                    #[link_name = "\u{1}_ZNK5aeron10concurrent10ringbuffer19ManyToOneRingBuffer4sizeEv"]
                    pub fn ManyToOneRingBuffer_size(
                        this: *const root::aeron::concurrent::ringbuffer::ManyToOneRingBuffer,
                    ) -> ::std::os::raw::c_int;
                }
                extern "C" {
                    #[link_name = "\u{1}_ZN5aeron10concurrent10ringbuffer19ManyToOneRingBuffer7unblockEv"]
                    pub fn ManyToOneRingBuffer_unblock(
                        this: *mut root::aeron::concurrent::ringbuffer::ManyToOneRingBuffer,
                    ) -> bool;
                }
                extern "C" {
                    #[link_name = "\u{1}_ZN5aeron10concurrent10ringbuffer19ManyToOneRingBufferC1ERNS0_12AtomicBufferE"]
                    pub fn ManyToOneRingBuffer_ManyToOneRingBuffer(
                        this: *mut root::aeron::concurrent::ringbuffer::ManyToOneRingBuffer,
                        buffer: *mut root::aeron::concurrent::AtomicBuffer,
                    );
                }
                impl ManyToOneRingBuffer {
                    #[inline]
                    pub unsafe fn capacity(&self) -> root::aeron::util::index_t {
                        ManyToOneRingBuffer_capacity(self)
                    }
                    #[inline]
                    pub unsafe fn write(
                        &mut self,
                        msgTypeId: ::std::os::raw::c_int,
                        srcBuffer: *mut root::aeron::concurrent::AtomicBuffer,
                        srcIndex: root::aeron::util::index_t,
                        length: root::aeron::util::index_t,
                    ) -> bool {
                        ManyToOneRingBuffer_write(self, msgTypeId, srcBuffer, srcIndex, length)
                    }
                    #[inline]
                    pub unsafe fn read(
                        &mut self,
                        handler: *const root::aeron::concurrent::ringbuffer::handler_t,
                        messageCountLimit: ::std::os::raw::c_int,
                    ) -> ::std::os::raw::c_int {
                        ManyToOneRingBuffer_read(self, handler, messageCountLimit)
                    }
                    #[inline]
                    pub unsafe fn read1(
                        &mut self,
                        handler: *const root::aeron::concurrent::ringbuffer::handler_t,
                    ) -> ::std::os::raw::c_int {
                        ManyToOneRingBuffer_read1(self, handler)
                    }
                    #[inline]
                    pub unsafe fn maxMsgLength(&self) -> root::aeron::util::index_t {
                        ManyToOneRingBuffer_maxMsgLength(self)
                    }
                    #[inline]
                    pub unsafe fn nextCorrelationId(&mut self) -> ::std::os::raw::c_long {
                        ManyToOneRingBuffer_nextCorrelationId(self)
                    }
                    #[inline]
                    pub unsafe fn consumerHeartbeatTime(&mut self, time: ::std::os::raw::c_long) {
                        ManyToOneRingBuffer_consumerHeartbeatTime(self, time)
                    }
                    #[inline]
                    pub unsafe fn consumerHeartbeatTime1(&self) -> ::std::os::raw::c_long {
                        ManyToOneRingBuffer_consumerHeartbeatTime1(self)
                    }
                    #[inline]
                    pub unsafe fn producerPosition(&self) -> ::std::os::raw::c_long {
                        ManyToOneRingBuffer_producerPosition(self)
                    }
                    #[inline]
                    pub unsafe fn consumerPosition(&self) -> ::std::os::raw::c_long {
                        ManyToOneRingBuffer_consumerPosition(self)
                    }
                    #[inline]
                    pub unsafe fn size(&self) -> ::std::os::raw::c_int {
                        ManyToOneRingBuffer_size(self)
                    }
                    #[inline]
                    pub unsafe fn unblock(&mut self) -> bool {
                        ManyToOneRingBuffer_unblock(self)
                    }
                    #[inline]
                    pub unsafe fn new(buffer: *mut root::aeron::concurrent::AtomicBuffer) -> Self {
                        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                        ManyToOneRingBuffer_ManyToOneRingBuffer(__bindgen_tmp.as_mut_ptr(), buffer);
                        __bindgen_tmp.assume_init()
                    }
                }
            }
            #[repr(C)]
            pub struct AgentRunner<Agent, IdleStrategy> {
                pub m_agent: *mut Agent,
                pub m_idleStrategy: *mut IdleStrategy,
                pub m_exceptionHandler: *mut root::aeron::util::exception_handler_t,
                pub m_isStarted: u8,
                pub m_isRunning: u8,
                pub m_isClosed: u8,
                pub m_thread: root::std::thread,
                pub m_name: root::std::string,
                pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<Agent>>,
                pub _phantom_1: ::std::marker::PhantomData<::std::cell::UnsafeCell<IdleStrategy>>,
            }
            pub mod broadcast {
                #[allow(unused_imports)]
                use self::super::super::super::super::root;
                pub mod BroadcastBufferDescriptor {
                    #[allow(unused_imports)]
                    use self::super::super::super::super::super::root;
                }
                pub mod RecordDescriptor {
                    #[allow(unused_imports)]
                    use self::super::super::super::super::super::root;
                }
                #[repr(C)]
                pub struct BroadcastReceiver {
                    pub m_buffer: *mut root::aeron::concurrent::AtomicBuffer,
                    pub m_capacity: root::aeron::util::index_t,
                    pub m_mask: root::aeron::util::index_t,
                    pub m_tailIntentCounterIndex: root::aeron::util::index_t,
                    pub m_tailCounterIndex: root::aeron::util::index_t,
                    pub m_latestCounterIndex: root::aeron::util::index_t,
                    pub m_recordOffset: root::aeron::util::index_t,
                    pub m_cursor: ::std::os::raw::c_long,
                    pub m_nextRecord: ::std::os::raw::c_long,
                    pub m_lappedCount: u64,
                }
                #[test]
                fn bindgen_test_layout_BroadcastReceiver() {
                    const UNINIT: ::std::mem::MaybeUninit<BroadcastReceiver> =
                        ::std::mem::MaybeUninit::uninit();
                    let ptr = UNINIT.as_ptr();
                    assert_eq!(
                        ::std::mem::size_of::<BroadcastReceiver>(),
                        56usize,
                        concat!("Size of: ", stringify!(BroadcastReceiver))
                    );
                    assert_eq!(
                        ::std::mem::align_of::<BroadcastReceiver>(),
                        8usize,
                        concat!("Alignment of ", stringify!(BroadcastReceiver))
                    );
                    assert_eq!(
                        unsafe { ::std::ptr::addr_of!((*ptr).m_buffer) as usize - ptr as usize },
                        0usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(BroadcastReceiver),
                            "::",
                            stringify!(m_buffer)
                        )
                    );
                    assert_eq!(
                        unsafe { ::std::ptr::addr_of!((*ptr).m_capacity) as usize - ptr as usize },
                        8usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(BroadcastReceiver),
                            "::",
                            stringify!(m_capacity)
                        )
                    );
                    assert_eq!(
                        unsafe { ::std::ptr::addr_of!((*ptr).m_mask) as usize - ptr as usize },
                        12usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(BroadcastReceiver),
                            "::",
                            stringify!(m_mask)
                        )
                    );
                    assert_eq!(
                        unsafe {
                            ::std::ptr::addr_of!((*ptr).m_tailIntentCounterIndex) as usize
                                - ptr as usize
                        },
                        16usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(BroadcastReceiver),
                            "::",
                            stringify!(m_tailIntentCounterIndex)
                        )
                    );
                    assert_eq!(
                        unsafe {
                            ::std::ptr::addr_of!((*ptr).m_tailCounterIndex) as usize - ptr as usize
                        },
                        20usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(BroadcastReceiver),
                            "::",
                            stringify!(m_tailCounterIndex)
                        )
                    );
                    assert_eq!(
                        unsafe {
                            ::std::ptr::addr_of!((*ptr).m_latestCounterIndex) as usize
                                - ptr as usize
                        },
                        24usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(BroadcastReceiver),
                            "::",
                            stringify!(m_latestCounterIndex)
                        )
                    );
                    assert_eq!(
                        unsafe {
                            ::std::ptr::addr_of!((*ptr).m_recordOffset) as usize - ptr as usize
                        },
                        28usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(BroadcastReceiver),
                            "::",
                            stringify!(m_recordOffset)
                        )
                    );
                    assert_eq!(
                        unsafe { ::std::ptr::addr_of!((*ptr).m_cursor) as usize - ptr as usize },
                        32usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(BroadcastReceiver),
                            "::",
                            stringify!(m_cursor)
                        )
                    );
                    assert_eq!(
                        unsafe {
                            ::std::ptr::addr_of!((*ptr).m_nextRecord) as usize - ptr as usize
                        },
                        40usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(BroadcastReceiver),
                            "::",
                            stringify!(m_nextRecord)
                        )
                    );
                    assert_eq!(
                        unsafe {
                            ::std::ptr::addr_of!((*ptr).m_lappedCount) as usize - ptr as usize
                        },
                        48usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(BroadcastReceiver),
                            "::",
                            stringify!(m_lappedCount)
                        )
                    );
                }
                extern "C" {
                    #[link_name = "\u{1}_ZNK5aeron10concurrent9broadcast17BroadcastReceiver8capacityEv"]
                    pub fn BroadcastReceiver_capacity(
                        this: *const root::aeron::concurrent::broadcast::BroadcastReceiver,
                    ) -> root::aeron::util::index_t;
                }
                extern "C" {
                    #[link_name = "\u{1}_ZNK5aeron10concurrent9broadcast17BroadcastReceiver11lappedCountEv"]
                    pub fn BroadcastReceiver_lappedCount(
                        this: *const root::aeron::concurrent::broadcast::BroadcastReceiver,
                    ) -> ::std::os::raw::c_long;
                }
                extern "C" {
                    #[link_name = "\u{1}_ZNK5aeron10concurrent9broadcast17BroadcastReceiver6typeIdEv"]
                    pub fn BroadcastReceiver_typeId(
                        this: *const root::aeron::concurrent::broadcast::BroadcastReceiver,
                    ) -> ::std::os::raw::c_int;
                }
                extern "C" {
                    #[link_name = "\u{1}_ZNK5aeron10concurrent9broadcast17BroadcastReceiver6offsetEv"]
                    pub fn BroadcastReceiver_offset(
                        this: *const root::aeron::concurrent::broadcast::BroadcastReceiver,
                    ) -> root::aeron::util::index_t;
                }
                extern "C" {
                    #[link_name = "\u{1}_ZNK5aeron10concurrent9broadcast17BroadcastReceiver6lengthEv"]
                    pub fn BroadcastReceiver_length(
                        this: *const root::aeron::concurrent::broadcast::BroadcastReceiver,
                    ) -> ::std::os::raw::c_int;
                }
                extern "C" {
                    #[link_name = "\u{1}_ZN5aeron10concurrent9broadcast17BroadcastReceiver6bufferEv"]
                    pub fn BroadcastReceiver_buffer(
                        this: *mut root::aeron::concurrent::broadcast::BroadcastReceiver,
                    ) -> *mut root::aeron::concurrent::AtomicBuffer;
                }
                extern "C" {
                    #[link_name = "\u{1}_ZN5aeron10concurrent9broadcast17BroadcastReceiver11receiveNextEv"]
                    pub fn BroadcastReceiver_receiveNext(
                        this: *mut root::aeron::concurrent::broadcast::BroadcastReceiver,
                    ) -> bool;
                }
                extern "C" {
                    #[link_name = "\u{1}_ZNK5aeron10concurrent9broadcast17BroadcastReceiver8validateEv"]
                    pub fn BroadcastReceiver_validate(
                        this: *const root::aeron::concurrent::broadcast::BroadcastReceiver,
                    ) -> bool;
                }
                extern "C" {
                    #[link_name = "\u{1}_ZN5aeron10concurrent9broadcast17BroadcastReceiverC1ERNS0_12AtomicBufferE"]
                    pub fn BroadcastReceiver_BroadcastReceiver(
                        this: *mut root::aeron::concurrent::broadcast::BroadcastReceiver,
                        buffer: *mut root::aeron::concurrent::AtomicBuffer,
                    );
                }
                impl BroadcastReceiver {
                    #[inline]
                    pub unsafe fn capacity(&self) -> root::aeron::util::index_t {
                        BroadcastReceiver_capacity(self)
                    }
                    #[inline]
                    pub unsafe fn lappedCount(&self) -> ::std::os::raw::c_long {
                        BroadcastReceiver_lappedCount(self)
                    }
                    #[inline]
                    pub unsafe fn typeId(&self) -> ::std::os::raw::c_int {
                        BroadcastReceiver_typeId(self)
                    }
                    #[inline]
                    pub unsafe fn offset(&self) -> root::aeron::util::index_t {
                        BroadcastReceiver_offset(self)
                    }
                    #[inline]
                    pub unsafe fn length(&self) -> ::std::os::raw::c_int {
                        BroadcastReceiver_length(self)
                    }
                    #[inline]
                    pub unsafe fn buffer(&mut self) -> *mut root::aeron::concurrent::AtomicBuffer {
                        BroadcastReceiver_buffer(self)
                    }
                    #[inline]
                    pub unsafe fn receiveNext(&mut self) -> bool {
                        BroadcastReceiver_receiveNext(self)
                    }
                    #[inline]
                    pub unsafe fn validate(&self) -> bool {
                        BroadcastReceiver_validate(self)
                    }
                    #[inline]
                    pub unsafe fn new(buffer: *mut root::aeron::concurrent::AtomicBuffer) -> Self {
                        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                        BroadcastReceiver_BroadcastReceiver(__bindgen_tmp.as_mut_ptr(), buffer);
                        __bindgen_tmp.assume_init()
                    }
                }
                pub type scratch_buffer_t = [u8; 4096usize];
                pub type handler_t = [u64; 4usize];
                #[repr(C)]
                #[repr(align(16))]
                pub struct CopyBroadcastReceiver {
                    pub m_scratch: root::aeron::concurrent::broadcast::scratch_buffer_t,
                    pub m_receiver: *mut root::aeron::concurrent::broadcast::BroadcastReceiver,
                    pub m_scratchBuffer: root::aeron::concurrent::AtomicBuffer,
                }
                #[test]
                fn bindgen_test_layout_CopyBroadcastReceiver() {
                    const UNINIT: ::std::mem::MaybeUninit<CopyBroadcastReceiver> =
                        ::std::mem::MaybeUninit::uninit();
                    let ptr = UNINIT.as_ptr();
                    assert_eq!(
                        ::std::mem::size_of::<CopyBroadcastReceiver>(),
                        4128usize,
                        concat!("Size of: ", stringify!(CopyBroadcastReceiver))
                    );
                    assert_eq!(
                        ::std::mem::align_of::<CopyBroadcastReceiver>(),
                        16usize,
                        concat!("Alignment of ", stringify!(CopyBroadcastReceiver))
                    );
                    assert_eq!(
                        unsafe { ::std::ptr::addr_of!((*ptr).m_scratch) as usize - ptr as usize },
                        0usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(CopyBroadcastReceiver),
                            "::",
                            stringify!(m_scratch)
                        )
                    );
                    assert_eq!(
                        unsafe { ::std::ptr::addr_of!((*ptr).m_receiver) as usize - ptr as usize },
                        4096usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(CopyBroadcastReceiver),
                            "::",
                            stringify!(m_receiver)
                        )
                    );
                    assert_eq!(
                        unsafe {
                            ::std::ptr::addr_of!((*ptr).m_scratchBuffer) as usize - ptr as usize
                        },
                        4104usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(CopyBroadcastReceiver),
                            "::",
                            stringify!(m_scratchBuffer)
                        )
                    );
                }
                extern "C" {
                    #[link_name = "\u{1}_ZN5aeron10concurrent9broadcast21CopyBroadcastReceiver7receiveERKSt8functionIFviRNS0_12AtomicBufferEiiEE"]
                    pub fn CopyBroadcastReceiver_receive(
                        this: *mut root::aeron::concurrent::broadcast::CopyBroadcastReceiver,
                        handler: *const root::aeron::concurrent::broadcast::handler_t,
                    ) -> ::std::os::raw::c_int;
                }
                extern "C" {
                    #[link_name = "\u{1}_ZN5aeron10concurrent9broadcast21CopyBroadcastReceiverC1ERNS1_17BroadcastReceiverE"]
                    pub fn CopyBroadcastReceiver_CopyBroadcastReceiver(
                        this: *mut root::aeron::concurrent::broadcast::CopyBroadcastReceiver,
                        receiver: *mut root::aeron::concurrent::broadcast::BroadcastReceiver,
                    );
                }
                impl CopyBroadcastReceiver {
                    #[inline]
                    pub unsafe fn receive(
                        &mut self,
                        handler: *const root::aeron::concurrent::broadcast::handler_t,
                    ) -> ::std::os::raw::c_int {
                        CopyBroadcastReceiver_receive(self, handler)
                    }
                    #[inline]
                    pub unsafe fn new(
                        receiver: *mut root::aeron::concurrent::broadcast::BroadcastReceiver,
                    ) -> Self {
                        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                        CopyBroadcastReceiver_CopyBroadcastReceiver(
                            __bindgen_tmp.as_mut_ptr(),
                            receiver,
                        );
                        __bindgen_tmp.assume_init()
                    }
                }
            }
            #[repr(C)]
            pub struct SleepingIdleStrategy {
                pub m_duration: u64,
            }
            #[test]
            fn bindgen_test_layout_SleepingIdleStrategy() {
                const UNINIT: ::std::mem::MaybeUninit<SleepingIdleStrategy> =
                    ::std::mem::MaybeUninit::uninit();
                let ptr = UNINIT.as_ptr();
                assert_eq!(
                    ::std::mem::size_of::<SleepingIdleStrategy>(),
                    8usize,
                    concat!("Size of: ", stringify!(SleepingIdleStrategy))
                );
                assert_eq!(
                    ::std::mem::align_of::<SleepingIdleStrategy>(),
                    8usize,
                    concat!("Alignment of ", stringify!(SleepingIdleStrategy))
                );
                assert_eq!(
                    unsafe { ::std::ptr::addr_of!((*ptr).m_duration) as usize - ptr as usize },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(SleepingIdleStrategy),
                        "::",
                        stringify!(m_duration)
                    )
                );
            }
            extern "C" {
                #[link_name = "\u{1}_ZN5aeron10concurrent20SleepingIdleStrategy4idleEi"]
                pub fn SleepingIdleStrategy_idle(
                    this: *mut root::aeron::concurrent::SleepingIdleStrategy,
                    workCount: ::std::os::raw::c_int,
                );
            }
            extern "C" {
                #[link_name = "\u{1}_ZN5aeron10concurrent20SleepingIdleStrategy5resetEv"]
                pub fn SleepingIdleStrategy_reset(
                    this: *mut root::aeron::concurrent::SleepingIdleStrategy,
                );
            }
            extern "C" {
                #[link_name = "\u{1}_ZN5aeron10concurrent20SleepingIdleStrategy4idleEv"]
                pub fn SleepingIdleStrategy_idle1(
                    this: *mut root::aeron::concurrent::SleepingIdleStrategy,
                );
            }
            extern "C" {
                #[link_name = "\u{1}_ZN5aeron10concurrent20SleepingIdleStrategyC1ENSt6chrono8durationIlSt5ratioILl1ELl1000EEEE"]
                pub fn SleepingIdleStrategy_SleepingIdleStrategy(
                    this: *mut root::aeron::concurrent::SleepingIdleStrategy,
                    duration: u64,
                );
            }
            impl SleepingIdleStrategy {
                #[inline]
                pub unsafe fn idle(&mut self, workCount: ::std::os::raw::c_int) {
                    SleepingIdleStrategy_idle(self, workCount)
                }
                #[inline]
                pub unsafe fn reset(&mut self) {
                    SleepingIdleStrategy_reset(self)
                }
                #[inline]
                pub unsafe fn idle1(&mut self) {
                    SleepingIdleStrategy_idle1(self)
                }
                #[inline]
                pub unsafe fn new(duration: u64) -> Self {
                    let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                    SleepingIdleStrategy_SleepingIdleStrategy(__bindgen_tmp.as_mut_ptr(), duration);
                    __bindgen_tmp.assume_init()
                }
            }
            #[repr(C)]
            #[derive(Copy, Clone)]
            pub struct AgentInvoker<Agent> {
                pub m_agent: *mut Agent,
                pub m_exceptionHandler: *mut root::aeron::util::exception_handler_t,
                pub m_isStarted: bool,
                pub m_isRunning: bool,
                pub m_isClosed: bool,
                pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<Agent>>,
            }
            #[repr(C)]
            pub struct BackoffIdleStrategy {
                pub m_prePad: [::std::os::raw::c_uchar; 64usize],
                pub m_maxSpins: ::std::os::raw::c_long,
                pub m_maxYields: ::std::os::raw::c_long,
                pub m_minParkPeriodNs: u64,
                pub m_maxParkPeriodNs: u64,
                pub m_spins: ::std::os::raw::c_long,
                pub m_yields: ::std::os::raw::c_long,
                pub m_parkPeriodNs: u64,
                pub m_state: ::std::os::raw::c_uchar,
                pub m_postPad: [::std::os::raw::c_uchar; 64usize],
            }
            #[test]
            fn bindgen_test_layout_BackoffIdleStrategy() {
                const UNINIT: ::std::mem::MaybeUninit<BackoffIdleStrategy> =
                    ::std::mem::MaybeUninit::uninit();
                let ptr = UNINIT.as_ptr();
                assert_eq!(
                    ::std::mem::size_of::<BackoffIdleStrategy>(),
                    192usize,
                    concat!("Size of: ", stringify!(BackoffIdleStrategy))
                );
                assert_eq!(
                    ::std::mem::align_of::<BackoffIdleStrategy>(),
                    8usize,
                    concat!("Alignment of ", stringify!(BackoffIdleStrategy))
                );
                assert_eq!(
                    unsafe { ::std::ptr::addr_of!((*ptr).m_prePad) as usize - ptr as usize },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(BackoffIdleStrategy),
                        "::",
                        stringify!(m_prePad)
                    )
                );
                assert_eq!(
                    unsafe { ::std::ptr::addr_of!((*ptr).m_maxSpins) as usize - ptr as usize },
                    64usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(BackoffIdleStrategy),
                        "::",
                        stringify!(m_maxSpins)
                    )
                );
                assert_eq!(
                    unsafe { ::std::ptr::addr_of!((*ptr).m_maxYields) as usize - ptr as usize },
                    72usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(BackoffIdleStrategy),
                        "::",
                        stringify!(m_maxYields)
                    )
                );
                assert_eq!(
                    unsafe {
                        ::std::ptr::addr_of!((*ptr).m_minParkPeriodNs) as usize - ptr as usize
                    },
                    80usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(BackoffIdleStrategy),
                        "::",
                        stringify!(m_minParkPeriodNs)
                    )
                );
                assert_eq!(
                    unsafe {
                        ::std::ptr::addr_of!((*ptr).m_maxParkPeriodNs) as usize - ptr as usize
                    },
                    88usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(BackoffIdleStrategy),
                        "::",
                        stringify!(m_maxParkPeriodNs)
                    )
                );
                assert_eq!(
                    unsafe { ::std::ptr::addr_of!((*ptr).m_spins) as usize - ptr as usize },
                    96usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(BackoffIdleStrategy),
                        "::",
                        stringify!(m_spins)
                    )
                );
                assert_eq!(
                    unsafe { ::std::ptr::addr_of!((*ptr).m_yields) as usize - ptr as usize },
                    104usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(BackoffIdleStrategy),
                        "::",
                        stringify!(m_yields)
                    )
                );
                assert_eq!(
                    unsafe { ::std::ptr::addr_of!((*ptr).m_parkPeriodNs) as usize - ptr as usize },
                    112usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(BackoffIdleStrategy),
                        "::",
                        stringify!(m_parkPeriodNs)
                    )
                );
                assert_eq!(
                    unsafe { ::std::ptr::addr_of!((*ptr).m_state) as usize - ptr as usize },
                    120usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(BackoffIdleStrategy),
                        "::",
                        stringify!(m_state)
                    )
                );
                assert_eq!(
                    unsafe { ::std::ptr::addr_of!((*ptr).m_postPad) as usize - ptr as usize },
                    121usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(BackoffIdleStrategy),
                        "::",
                        stringify!(m_postPad)
                    )
                );
            }
            extern "C" {
                #[link_name = "\u{1}_ZN5aeron10concurrent19BackoffIdleStrategy4idleEi"]
                pub fn BackoffIdleStrategy_idle(
                    this: *mut root::aeron::concurrent::BackoffIdleStrategy,
                    workCount: ::std::os::raw::c_int,
                );
            }
            extern "C" {
                #[link_name = "\u{1}_ZN5aeron10concurrent19BackoffIdleStrategy5resetEv"]
                pub fn BackoffIdleStrategy_reset(
                    this: *mut root::aeron::concurrent::BackoffIdleStrategy,
                );
            }
            extern "C" {
                #[link_name = "\u{1}_ZN5aeron10concurrent19BackoffIdleStrategy4idleEv"]
                pub fn BackoffIdleStrategy_idle1(
                    this: *mut root::aeron::concurrent::BackoffIdleStrategy,
                );
            }
            extern "C" {
                #[link_name = "\u{1}_ZN5aeron10concurrent19BackoffIdleStrategyC1EllNSt6chrono8durationIlSt5ratioILl1ELl1000000000EEEES6_"]
                pub fn BackoffIdleStrategy_BackoffIdleStrategy(
                    this: *mut root::aeron::concurrent::BackoffIdleStrategy,
                    maxSpins: ::std::os::raw::c_long,
                    maxYields: ::std::os::raw::c_long,
                    minParkPeriodNs: u64,
                    maxParkPeriodNs: u64,
                );
            }
            impl BackoffIdleStrategy {
                #[inline]
                pub unsafe fn idle(&mut self, workCount: ::std::os::raw::c_int) {
                    BackoffIdleStrategy_idle(self, workCount)
                }
                #[inline]
                pub unsafe fn reset(&mut self) {
                    BackoffIdleStrategy_reset(self)
                }
                #[inline]
                pub unsafe fn idle1(&mut self) {
                    BackoffIdleStrategy_idle1(self)
                }
                #[inline]
                pub unsafe fn new(
                    maxSpins: ::std::os::raw::c_long,
                    maxYields: ::std::os::raw::c_long,
                    minParkPeriodNs: u64,
                    maxParkPeriodNs: u64,
                ) -> Self {
                    let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                    BackoffIdleStrategy_BackoffIdleStrategy(
                        __bindgen_tmp.as_mut_ptr(),
                        maxSpins,
                        maxYields,
                        minParkPeriodNs,
                        maxParkPeriodNs,
                    );
                    __bindgen_tmp.assume_init()
                }
            }
            #[repr(C)]
            #[derive(Copy, Clone)]
            pub struct YieldingIdleStrategy {
                pub _address: u8,
            }
            #[test]
            fn bindgen_test_layout_YieldingIdleStrategy() {
                assert_eq!(
                    ::std::mem::size_of::<YieldingIdleStrategy>(),
                    1usize,
                    concat!("Size of: ", stringify!(YieldingIdleStrategy))
                );
                assert_eq!(
                    ::std::mem::align_of::<YieldingIdleStrategy>(),
                    1usize,
                    concat!("Alignment of ", stringify!(YieldingIdleStrategy))
                );
            }
            extern "C" {
                #[link_name = "\u{1}_ZN5aeron10concurrent20YieldingIdleStrategy4idleEi"]
                pub fn YieldingIdleStrategy_idle(
                    this: *mut root::aeron::concurrent::YieldingIdleStrategy,
                    workCount: ::std::os::raw::c_int,
                );
            }
            extern "C" {
                #[link_name = "\u{1}_ZN5aeron10concurrent20YieldingIdleStrategy5resetEv"]
                pub fn YieldingIdleStrategy_reset(
                    this: *mut root::aeron::concurrent::YieldingIdleStrategy,
                );
            }
            extern "C" {
                #[link_name = "\u{1}_ZN5aeron10concurrent20YieldingIdleStrategy4idleEv"]
                pub fn YieldingIdleStrategy_idle1(
                    this: *mut root::aeron::concurrent::YieldingIdleStrategy,
                );
            }
            extern "C" {
                #[link_name = "\u{1}_ZN5aeron10concurrent20YieldingIdleStrategyC1Ev"]
                pub fn YieldingIdleStrategy_YieldingIdleStrategy(
                    this: *mut root::aeron::concurrent::YieldingIdleStrategy,
                );
            }
            impl YieldingIdleStrategy {
                #[inline]
                pub unsafe fn idle(&mut self, workCount: ::std::os::raw::c_int) {
                    YieldingIdleStrategy_idle(self, workCount)
                }
                #[inline]
                pub unsafe fn reset(&mut self) {
                    YieldingIdleStrategy_reset(self)
                }
                #[inline]
                pub unsafe fn idle1(&mut self) {
                    YieldingIdleStrategy_idle1(self)
                }
                #[inline]
                pub unsafe fn new() -> Self {
                    let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                    YieldingIdleStrategy_YieldingIdleStrategy(__bindgen_tmp.as_mut_ptr());
                    __bindgen_tmp.assume_init()
                }
            }
        }
        #[repr(C)]
        pub struct LogBuffers {
            pub m_memoryMappedFiles: root::aeron::util::MemoryMappedFile_ptr_t,
            pub m_buffers: [root::aeron::concurrent::AtomicBuffer; 4usize],
        }
        #[test]
        fn bindgen_test_layout_LogBuffers() {
            const UNINIT: ::std::mem::MaybeUninit<LogBuffers> = ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<LogBuffers>(),
                80usize,
                concat!("Size of: ", stringify!(LogBuffers))
            );
            assert_eq!(
                ::std::mem::align_of::<LogBuffers>(),
                8usize,
                concat!("Alignment of ", stringify!(LogBuffers))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_memoryMappedFiles) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(LogBuffers),
                    "::",
                    stringify!(m_memoryMappedFiles)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_buffers) as usize - ptr as usize },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(LogBuffers),
                    "::",
                    stringify!(m_buffers)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5aeron10LogBuffers12atomicBufferEi"]
            pub fn LogBuffers_atomicBuffer(
                this: *mut root::aeron::LogBuffers,
                index: ::std::os::raw::c_int,
            ) -> *mut root::aeron::concurrent::AtomicBuffer;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5aeron10LogBuffersC1EPKcb"]
            pub fn LogBuffers_LogBuffers(
                this: *mut root::aeron::LogBuffers,
                filename: *const ::std::os::raw::c_char,
                preTouch: bool,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5aeron10LogBuffersC1EPhli"]
            pub fn LogBuffers_LogBuffers1(
                this: *mut root::aeron::LogBuffers,
                address: *mut ::std::os::raw::c_uchar,
                logLength: ::std::os::raw::c_long,
                termLength: ::std::os::raw::c_int,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5aeron10LogBuffersD1Ev"]
            pub fn LogBuffers_LogBuffers_destructor(this: *mut root::aeron::LogBuffers);
        }
        impl LogBuffers {
            #[inline]
            pub unsafe fn atomicBuffer(
                &mut self,
                index: ::std::os::raw::c_int,
            ) -> *mut root::aeron::concurrent::AtomicBuffer {
                LogBuffers_atomicBuffer(self, index)
            }
            #[inline]
            pub unsafe fn new(filename: *const ::std::os::raw::c_char, preTouch: bool) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                LogBuffers_LogBuffers(__bindgen_tmp.as_mut_ptr(), filename, preTouch);
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn new1(
                address: *mut ::std::os::raw::c_uchar,
                logLength: ::std::os::raw::c_long,
                termLength: ::std::os::raw::c_int,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                LogBuffers_LogBuffers1(__bindgen_tmp.as_mut_ptr(), address, logLength, termLength);
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn destruct(&mut self) {
                LogBuffers_LogBuffers_destructor(self)
            }
        }
        pub type on_reserved_value_supplier_t = [u64; 4usize];
        #[repr(C)]
        pub struct Publication {
            pub m_conductor: *mut root::aeron::ClientConductor,
            pub m_logMetaDataBuffer: *mut root::aeron::concurrent::AtomicBuffer,
            pub m_channel: root::std::string,
            pub m_registrationId: ::std::os::raw::c_long,
            pub m_originalRegistrationId: ::std::os::raw::c_long,
            pub m_maxPossiblePosition: ::std::os::raw::c_long,
            pub m_streamId: ::std::os::raw::c_int,
            pub m_sessionId: ::std::os::raw::c_int,
            pub m_initialTermId: ::std::os::raw::c_int,
            pub m_maxPayloadLength: ::std::os::raw::c_int,
            pub m_maxMessageLength: ::std::os::raw::c_int,
            pub m_positionBitsToShift: ::std::os::raw::c_int,
            pub m_publicationLimit: root::aeron::concurrent::status::ReadablePosition<
                root::aeron::concurrent::status::UnsafeBufferPosition,
            >,
            pub m_channelStatusId: ::std::os::raw::c_int,
            pub m_isClosed: u8,
            pub m_logBuffers: [u64; 2usize],
            pub m_headerWriter: root::aeron::concurrent::logbuffer::HeaderWriter,
        }
        #[test]
        fn bindgen_test_layout_Publication() {
            const UNINIT: ::std::mem::MaybeUninit<Publication> = ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<Publication>(),
                152usize,
                concat!("Size of: ", stringify!(Publication))
            );
            assert_eq!(
                ::std::mem::align_of::<Publication>(),
                8usize,
                concat!("Alignment of ", stringify!(Publication))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_conductor) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Publication),
                    "::",
                    stringify!(m_conductor)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_logMetaDataBuffer) as usize - ptr as usize },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Publication),
                    "::",
                    stringify!(m_logMetaDataBuffer)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_channel) as usize - ptr as usize },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Publication),
                    "::",
                    stringify!(m_channel)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_registrationId) as usize - ptr as usize },
                48usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Publication),
                    "::",
                    stringify!(m_registrationId)
                )
            );
            assert_eq!(
                unsafe {
                    ::std::ptr::addr_of!((*ptr).m_originalRegistrationId) as usize - ptr as usize
                },
                56usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Publication),
                    "::",
                    stringify!(m_originalRegistrationId)
                )
            );
            assert_eq!(
                unsafe {
                    ::std::ptr::addr_of!((*ptr).m_maxPossiblePosition) as usize - ptr as usize
                },
                64usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Publication),
                    "::",
                    stringify!(m_maxPossiblePosition)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_streamId) as usize - ptr as usize },
                72usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Publication),
                    "::",
                    stringify!(m_streamId)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_sessionId) as usize - ptr as usize },
                76usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Publication),
                    "::",
                    stringify!(m_sessionId)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_initialTermId) as usize - ptr as usize },
                80usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Publication),
                    "::",
                    stringify!(m_initialTermId)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_maxPayloadLength) as usize - ptr as usize },
                84usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Publication),
                    "::",
                    stringify!(m_maxPayloadLength)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_maxMessageLength) as usize - ptr as usize },
                88usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Publication),
                    "::",
                    stringify!(m_maxMessageLength)
                )
            );
            assert_eq!(
                unsafe {
                    ::std::ptr::addr_of!((*ptr).m_positionBitsToShift) as usize - ptr as usize
                },
                92usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Publication),
                    "::",
                    stringify!(m_positionBitsToShift)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_publicationLimit) as usize - ptr as usize },
                96usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Publication),
                    "::",
                    stringify!(m_publicationLimit)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_channelStatusId) as usize - ptr as usize },
                120usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Publication),
                    "::",
                    stringify!(m_channelStatusId)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_isClosed) as usize - ptr as usize },
                124usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Publication),
                    "::",
                    stringify!(m_isClosed)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_logBuffers) as usize - ptr as usize },
                128usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Publication),
                    "::",
                    stringify!(m_logBuffers)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_headerWriter) as usize - ptr as usize },
                144usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Publication),
                    "::",
                    stringify!(m_headerWriter)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZNK5aeron11Publication7channelB5cxx11Ev"]
            pub fn Publication_channel(
                this: *const root::aeron::Publication,
            ) -> *const root::std::string;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNK5aeron11Publication8streamIdEv"]
            pub fn Publication_streamId(
                this: *const root::aeron::Publication,
            ) -> ::std::os::raw::c_int;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNK5aeron11Publication9sessionIdEv"]
            pub fn Publication_sessionId(
                this: *const root::aeron::Publication,
            ) -> ::std::os::raw::c_int;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNK5aeron11Publication13initialTermIdEv"]
            pub fn Publication_initialTermId(
                this: *const root::aeron::Publication,
            ) -> ::std::os::raw::c_int;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNK5aeron11Publication22originalRegistrationIdEv"]
            pub fn Publication_originalRegistrationId(
                this: *const root::aeron::Publication,
            ) -> ::std::os::raw::c_long;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNK5aeron11Publication14registrationIdEv"]
            pub fn Publication_registrationId(
                this: *const root::aeron::Publication,
            ) -> ::std::os::raw::c_long;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNK5aeron11Publication10isOriginalEv"]
            pub fn Publication_isOriginal(this: *const root::aeron::Publication) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNK5aeron11Publication16maxMessageLengthEv"]
            pub fn Publication_maxMessageLength(
                this: *const root::aeron::Publication,
            ) -> root::aeron::util::index_t;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNK5aeron11Publication16maxPayloadLengthEv"]
            pub fn Publication_maxPayloadLength(
                this: *const root::aeron::Publication,
            ) -> root::aeron::util::index_t;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNK5aeron11Publication16termBufferLengthEv"]
            pub fn Publication_termBufferLength(
                this: *const root::aeron::Publication,
            ) -> ::std::os::raw::c_int;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNK5aeron11Publication19positionBitsToShiftEv"]
            pub fn Publication_positionBitsToShift(
                this: *const root::aeron::Publication,
            ) -> ::std::os::raw::c_int;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNK5aeron11Publication11isConnectedEv"]
            pub fn Publication_isConnected(this: *const root::aeron::Publication) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNK5aeron11Publication8isClosedEv"]
            pub fn Publication_isClosed(this: *const root::aeron::Publication) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNK5aeron11Publication19maxPossiblePositionEv"]
            pub fn Publication_maxPossiblePosition(
                this: *const root::aeron::Publication,
            ) -> ::std::os::raw::c_long;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNK5aeron11Publication8positionEv"]
            pub fn Publication_position(
                this: *const root::aeron::Publication,
            ) -> ::std::os::raw::c_long;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNK5aeron11Publication16publicationLimitEv"]
            pub fn Publication_publicationLimit(
                this: *const root::aeron::Publication,
            ) -> ::std::os::raw::c_long;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNK5aeron11Publication18publicationLimitIdEv"]
            pub fn Publication_publicationLimitId(
                this: *const root::aeron::Publication,
            ) -> ::std::os::raw::c_int;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNK5aeron11Publication15availableWindowEv"]
            pub fn Publication_availableWindow(
                this: *const root::aeron::Publication,
            ) -> ::std::os::raw::c_long;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNK5aeron11Publication15channelStatusIdEv"]
            pub fn Publication_channelStatusId(
                this: *const root::aeron::Publication,
            ) -> ::std::os::raw::c_int;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNK5aeron11Publication13channelStatusEv"]
            pub fn Publication_channelStatus(
                this: *const root::aeron::Publication,
            ) -> ::std::os::raw::c_long;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNK5aeron11Publication20localSocketAddressesB5cxx11Ev"]
            pub fn Publication_localSocketAddresses(this: *const root::aeron::Publication) -> u8;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5aeron11Publication5offerERKNS_10concurrent12AtomicBufferEiiRKSt8functionIFlRS2_iiEE"]
            pub fn Publication_offer(
                this: *mut root::aeron::Publication,
                buffer: *const root::aeron::concurrent::AtomicBuffer,
                offset: root::aeron::util::index_t,
                length: root::aeron::util::index_t,
                reservedValueSupplier: *const root::aeron::on_reserved_value_supplier_t,
            ) -> ::std::os::raw::c_long;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5aeron11Publication5offerERKNS_10concurrent12AtomicBufferEii"]
            pub fn Publication_offer1(
                this: *mut root::aeron::Publication,
                buffer: *const root::aeron::concurrent::AtomicBuffer,
                offset: root::aeron::util::index_t,
                length: root::aeron::util::index_t,
            ) -> ::std::os::raw::c_long;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5aeron11Publication5offerERKNS_10concurrent12AtomicBufferE"]
            pub fn Publication_offer2(
                this: *mut root::aeron::Publication,
                buffer: *const root::aeron::concurrent::AtomicBuffer,
            ) -> ::std::os::raw::c_long;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5aeron11Publication5offerEPKNS_10concurrent12AtomicBufferEmRKSt8functionIFlRS2_iiEE"]
            pub fn Publication_offer3(
                this: *mut root::aeron::Publication,
                buffers: *const root::aeron::concurrent::AtomicBuffer,
                length: usize,
                reservedValueSupplier: *const root::aeron::on_reserved_value_supplier_t,
            ) -> ::std::os::raw::c_long;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5aeron11Publication8tryClaimEiRNS_10concurrent9logbuffer11BufferClaimE"]
            pub fn Publication_tryClaim(
                this: *mut root::aeron::Publication,
                length: root::aeron::util::index_t,
                bufferClaim: *mut root::aeron::concurrent::logbuffer::BufferClaim,
            ) -> ::std::os::raw::c_long;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5aeron11Publication14addDestinationERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
            pub fn Publication_addDestination(
                this: *mut root::aeron::Publication,
                endpointChannel: *const root::std::string,
            ) -> ::std::os::raw::c_long;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5aeron11Publication17removeDestinationERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
            pub fn Publication_removeDestination(
                this: *mut root::aeron::Publication,
                endpointChannel: *const root::std::string,
            ) -> ::std::os::raw::c_long;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5aeron11Publication23findDestinationResponseEl"]
            pub fn Publication_findDestinationResponse(
                this: *mut root::aeron::Publication,
                correlationId: ::std::os::raw::c_long,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5aeron11Publication5closeEv"]
            pub fn Publication_close(this: *mut root::aeron::Publication);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5aeron11PublicationC1ERNS_15ClientConductorERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEElliiRNS_10concurrent6status20UnsafeBufferPositionEiSt10shared_ptrINS_10LogBuffersEE"]
            pub fn Publication_Publication(
                this: *mut root::aeron::Publication,
                conductor: *mut root::aeron::ClientConductor,
                channel: *const root::std::string,
                registrationId: ::std::os::raw::c_long,
                originalRegistrationId: ::std::os::raw::c_long,
                streamId: ::std::os::raw::c_int,
                sessionId: ::std::os::raw::c_int,
                publicationLimit: *mut root::aeron::concurrent::status::UnsafeBufferPosition,
                channelStatusId: ::std::os::raw::c_int,
                logBuffers: [u64; 2usize],
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5aeron11PublicationD1Ev"]
            pub fn Publication_Publication_destructor(this: *mut root::aeron::Publication);
        }
        impl Publication {
            #[inline]
            pub unsafe fn channel(&self) -> *const root::std::string {
                Publication_channel(self)
            }
            #[inline]
            pub unsafe fn streamId(&self) -> ::std::os::raw::c_int {
                Publication_streamId(self)
            }
            #[inline]
            pub unsafe fn sessionId(&self) -> ::std::os::raw::c_int {
                Publication_sessionId(self)
            }
            #[inline]
            pub unsafe fn initialTermId(&self) -> ::std::os::raw::c_int {
                Publication_initialTermId(self)
            }
            #[inline]
            pub unsafe fn originalRegistrationId(&self) -> ::std::os::raw::c_long {
                Publication_originalRegistrationId(self)
            }
            #[inline]
            pub unsafe fn registrationId(&self) -> ::std::os::raw::c_long {
                Publication_registrationId(self)
            }
            #[inline]
            pub unsafe fn isOriginal(&self) -> bool {
                Publication_isOriginal(self)
            }
            #[inline]
            pub unsafe fn maxMessageLength(&self) -> root::aeron::util::index_t {
                Publication_maxMessageLength(self)
            }
            #[inline]
            pub unsafe fn maxPayloadLength(&self) -> root::aeron::util::index_t {
                Publication_maxPayloadLength(self)
            }
            #[inline]
            pub unsafe fn termBufferLength(&self) -> ::std::os::raw::c_int {
                Publication_termBufferLength(self)
            }
            #[inline]
            pub unsafe fn positionBitsToShift(&self) -> ::std::os::raw::c_int {
                Publication_positionBitsToShift(self)
            }
            #[inline]
            pub unsafe fn isConnected(&self) -> bool {
                Publication_isConnected(self)
            }
            #[inline]
            pub unsafe fn isClosed(&self) -> bool {
                Publication_isClosed(self)
            }
            #[inline]
            pub unsafe fn maxPossiblePosition(&self) -> ::std::os::raw::c_long {
                Publication_maxPossiblePosition(self)
            }
            #[inline]
            pub unsafe fn position(&self) -> ::std::os::raw::c_long {
                Publication_position(self)
            }
            #[inline]
            pub unsafe fn publicationLimit(&self) -> ::std::os::raw::c_long {
                Publication_publicationLimit(self)
            }
            #[inline]
            pub unsafe fn publicationLimitId(&self) -> ::std::os::raw::c_int {
                Publication_publicationLimitId(self)
            }
            #[inline]
            pub unsafe fn availableWindow(&self) -> ::std::os::raw::c_long {
                Publication_availableWindow(self)
            }
            #[inline]
            pub unsafe fn channelStatusId(&self) -> ::std::os::raw::c_int {
                Publication_channelStatusId(self)
            }
            #[inline]
            pub unsafe fn channelStatus(&self) -> ::std::os::raw::c_long {
                Publication_channelStatus(self)
            }
            #[inline]
            pub unsafe fn localSocketAddresses(&self) -> u8 {
                Publication_localSocketAddresses(self)
            }
            #[inline]
            pub unsafe fn offer(
                &mut self,
                buffer: *const root::aeron::concurrent::AtomicBuffer,
                offset: root::aeron::util::index_t,
                length: root::aeron::util::index_t,
                reservedValueSupplier: *const root::aeron::on_reserved_value_supplier_t,
            ) -> ::std::os::raw::c_long {
                Publication_offer(self, buffer, offset, length, reservedValueSupplier)
            }
            #[inline]
            pub unsafe fn offer1(
                &mut self,
                buffer: *const root::aeron::concurrent::AtomicBuffer,
                offset: root::aeron::util::index_t,
                length: root::aeron::util::index_t,
            ) -> ::std::os::raw::c_long {
                Publication_offer1(self, buffer, offset, length)
            }
            #[inline]
            pub unsafe fn offer2(
                &mut self,
                buffer: *const root::aeron::concurrent::AtomicBuffer,
            ) -> ::std::os::raw::c_long {
                Publication_offer2(self, buffer)
            }
            #[inline]
            pub unsafe fn offer3(
                &mut self,
                buffers: *const root::aeron::concurrent::AtomicBuffer,
                length: usize,
                reservedValueSupplier: *const root::aeron::on_reserved_value_supplier_t,
            ) -> ::std::os::raw::c_long {
                Publication_offer3(self, buffers, length, reservedValueSupplier)
            }
            #[inline]
            pub unsafe fn tryClaim(
                &mut self,
                length: root::aeron::util::index_t,
                bufferClaim: *mut root::aeron::concurrent::logbuffer::BufferClaim,
            ) -> ::std::os::raw::c_long {
                Publication_tryClaim(self, length, bufferClaim)
            }
            #[inline]
            pub unsafe fn addDestination(
                &mut self,
                endpointChannel: *const root::std::string,
            ) -> ::std::os::raw::c_long {
                Publication_addDestination(self, endpointChannel)
            }
            #[inline]
            pub unsafe fn removeDestination(
                &mut self,
                endpointChannel: *const root::std::string,
            ) -> ::std::os::raw::c_long {
                Publication_removeDestination(self, endpointChannel)
            }
            #[inline]
            pub unsafe fn findDestinationResponse(
                &mut self,
                correlationId: ::std::os::raw::c_long,
            ) -> bool {
                Publication_findDestinationResponse(self, correlationId)
            }
            #[inline]
            pub unsafe fn close(&mut self) {
                Publication_close(self)
            }
            #[inline]
            pub unsafe fn new(
                conductor: *mut root::aeron::ClientConductor,
                channel: *const root::std::string,
                registrationId: ::std::os::raw::c_long,
                originalRegistrationId: ::std::os::raw::c_long,
                streamId: ::std::os::raw::c_int,
                sessionId: ::std::os::raw::c_int,
                publicationLimit: *mut root::aeron::concurrent::status::UnsafeBufferPosition,
                channelStatusId: ::std::os::raw::c_int,
                logBuffers: [u64; 2usize],
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                Publication_Publication(
                    __bindgen_tmp.as_mut_ptr(),
                    conductor,
                    channel,
                    registrationId,
                    originalRegistrationId,
                    streamId,
                    sessionId,
                    publicationLimit,
                    channelStatusId,
                    logBuffers,
                );
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn destruct(&mut self) {
                Publication_Publication_destructor(self)
            }
        }
        #[repr(C)]
        pub struct ExclusivePublication {
            pub m_conductor: *mut root::aeron::ClientConductor,
            pub m_logMetaDataBuffer: *mut root::aeron::concurrent::AtomicBuffer,
            pub m_channel: root::std::string,
            pub m_registrationId: ::std::os::raw::c_long,
            pub m_maxPossiblePosition: ::std::os::raw::c_long,
            pub m_streamId: ::std::os::raw::c_int,
            pub m_sessionId: ::std::os::raw::c_int,
            pub m_initialTermId: ::std::os::raw::c_int,
            pub m_maxPayloadLength: ::std::os::raw::c_int,
            pub m_maxMessageLength: ::std::os::raw::c_int,
            pub m_positionBitsToShift: ::std::os::raw::c_int,
            pub m_termOffset: ::std::os::raw::c_int,
            pub m_termId: ::std::os::raw::c_int,
            pub m_activePartitionIndex: ::std::os::raw::c_int,
            pub m_termBeginPosition: ::std::os::raw::c_long,
            pub m_publicationLimit: root::aeron::concurrent::status::ReadablePosition<
                root::aeron::concurrent::status::UnsafeBufferPosition,
            >,
            pub m_channelStatusId: ::std::os::raw::c_int,
            pub m_isClosed: u8,
            pub m_logBuffers: [u64; 2usize],
            pub m_headerWriter: root::aeron::concurrent::logbuffer::HeaderWriter,
        }
        #[test]
        fn bindgen_test_layout_ExclusivePublication() {
            const UNINIT: ::std::mem::MaybeUninit<ExclusivePublication> =
                ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<ExclusivePublication>(),
                168usize,
                concat!("Size of: ", stringify!(ExclusivePublication))
            );
            assert_eq!(
                ::std::mem::align_of::<ExclusivePublication>(),
                8usize,
                concat!("Alignment of ", stringify!(ExclusivePublication))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_conductor) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ExclusivePublication),
                    "::",
                    stringify!(m_conductor)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_logMetaDataBuffer) as usize - ptr as usize },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ExclusivePublication),
                    "::",
                    stringify!(m_logMetaDataBuffer)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_channel) as usize - ptr as usize },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ExclusivePublication),
                    "::",
                    stringify!(m_channel)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_registrationId) as usize - ptr as usize },
                48usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ExclusivePublication),
                    "::",
                    stringify!(m_registrationId)
                )
            );
            assert_eq!(
                unsafe {
                    ::std::ptr::addr_of!((*ptr).m_maxPossiblePosition) as usize - ptr as usize
                },
                56usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ExclusivePublication),
                    "::",
                    stringify!(m_maxPossiblePosition)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_streamId) as usize - ptr as usize },
                64usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ExclusivePublication),
                    "::",
                    stringify!(m_streamId)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_sessionId) as usize - ptr as usize },
                68usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ExclusivePublication),
                    "::",
                    stringify!(m_sessionId)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_initialTermId) as usize - ptr as usize },
                72usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ExclusivePublication),
                    "::",
                    stringify!(m_initialTermId)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_maxPayloadLength) as usize - ptr as usize },
                76usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ExclusivePublication),
                    "::",
                    stringify!(m_maxPayloadLength)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_maxMessageLength) as usize - ptr as usize },
                80usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ExclusivePublication),
                    "::",
                    stringify!(m_maxMessageLength)
                )
            );
            assert_eq!(
                unsafe {
                    ::std::ptr::addr_of!((*ptr).m_positionBitsToShift) as usize - ptr as usize
                },
                84usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ExclusivePublication),
                    "::",
                    stringify!(m_positionBitsToShift)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_termOffset) as usize - ptr as usize },
                88usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ExclusivePublication),
                    "::",
                    stringify!(m_termOffset)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_termId) as usize - ptr as usize },
                92usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ExclusivePublication),
                    "::",
                    stringify!(m_termId)
                )
            );
            assert_eq!(
                unsafe {
                    ::std::ptr::addr_of!((*ptr).m_activePartitionIndex) as usize - ptr as usize
                },
                96usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ExclusivePublication),
                    "::",
                    stringify!(m_activePartitionIndex)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_termBeginPosition) as usize - ptr as usize },
                104usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ExclusivePublication),
                    "::",
                    stringify!(m_termBeginPosition)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_publicationLimit) as usize - ptr as usize },
                112usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ExclusivePublication),
                    "::",
                    stringify!(m_publicationLimit)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_channelStatusId) as usize - ptr as usize },
                136usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ExclusivePublication),
                    "::",
                    stringify!(m_channelStatusId)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_isClosed) as usize - ptr as usize },
                140usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ExclusivePublication),
                    "::",
                    stringify!(m_isClosed)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_logBuffers) as usize - ptr as usize },
                144usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ExclusivePublication),
                    "::",
                    stringify!(m_logBuffers)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_headerWriter) as usize - ptr as usize },
                160usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ExclusivePublication),
                    "::",
                    stringify!(m_headerWriter)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZNK5aeron20ExclusivePublication7channelB5cxx11Ev"]
            pub fn ExclusivePublication_channel(
                this: *const root::aeron::ExclusivePublication,
            ) -> *const root::std::string;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNK5aeron20ExclusivePublication8streamIdEv"]
            pub fn ExclusivePublication_streamId(
                this: *const root::aeron::ExclusivePublication,
            ) -> ::std::os::raw::c_int;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNK5aeron20ExclusivePublication9sessionIdEv"]
            pub fn ExclusivePublication_sessionId(
                this: *const root::aeron::ExclusivePublication,
            ) -> ::std::os::raw::c_int;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNK5aeron20ExclusivePublication13initialTermIdEv"]
            pub fn ExclusivePublication_initialTermId(
                this: *const root::aeron::ExclusivePublication,
            ) -> ::std::os::raw::c_int;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNK5aeron20ExclusivePublication6termIdEv"]
            pub fn ExclusivePublication_termId(
                this: *const root::aeron::ExclusivePublication,
            ) -> ::std::os::raw::c_int;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNK5aeron20ExclusivePublication10termOffsetEv"]
            pub fn ExclusivePublication_termOffset(
                this: *const root::aeron::ExclusivePublication,
            ) -> ::std::os::raw::c_int;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNK5aeron20ExclusivePublication22originalRegistrationIdEv"]
            pub fn ExclusivePublication_originalRegistrationId(
                this: *const root::aeron::ExclusivePublication,
            ) -> ::std::os::raw::c_long;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNK5aeron20ExclusivePublication14registrationIdEv"]
            pub fn ExclusivePublication_registrationId(
                this: *const root::aeron::ExclusivePublication,
            ) -> ::std::os::raw::c_long;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5aeron20ExclusivePublication10isOriginalEv"]
            pub fn ExclusivePublication_isOriginal() -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNK5aeron20ExclusivePublication16maxMessageLengthEv"]
            pub fn ExclusivePublication_maxMessageLength(
                this: *const root::aeron::ExclusivePublication,
            ) -> root::aeron::util::index_t;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNK5aeron20ExclusivePublication16maxPayloadLengthEv"]
            pub fn ExclusivePublication_maxPayloadLength(
                this: *const root::aeron::ExclusivePublication,
            ) -> root::aeron::util::index_t;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNK5aeron20ExclusivePublication16termBufferLengthEv"]
            pub fn ExclusivePublication_termBufferLength(
                this: *const root::aeron::ExclusivePublication,
            ) -> ::std::os::raw::c_int;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNK5aeron20ExclusivePublication19positionBitsToShiftEv"]
            pub fn ExclusivePublication_positionBitsToShift(
                this: *const root::aeron::ExclusivePublication,
            ) -> ::std::os::raw::c_int;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNK5aeron20ExclusivePublication11isConnectedEv"]
            pub fn ExclusivePublication_isConnected(
                this: *const root::aeron::ExclusivePublication,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNK5aeron20ExclusivePublication8isClosedEv"]
            pub fn ExclusivePublication_isClosed(
                this: *const root::aeron::ExclusivePublication,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNK5aeron20ExclusivePublication19maxPossiblePositionEv"]
            pub fn ExclusivePublication_maxPossiblePosition(
                this: *const root::aeron::ExclusivePublication,
            ) -> ::std::os::raw::c_long;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNK5aeron20ExclusivePublication8positionEv"]
            pub fn ExclusivePublication_position(
                this: *const root::aeron::ExclusivePublication,
            ) -> ::std::os::raw::c_long;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNK5aeron20ExclusivePublication16publicationLimitEv"]
            pub fn ExclusivePublication_publicationLimit(
                this: *const root::aeron::ExclusivePublication,
            ) -> ::std::os::raw::c_long;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNK5aeron20ExclusivePublication18publicationLimitIdEv"]
            pub fn ExclusivePublication_publicationLimitId(
                this: *const root::aeron::ExclusivePublication,
            ) -> ::std::os::raw::c_int;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNK5aeron20ExclusivePublication15availableWindowEv"]
            pub fn ExclusivePublication_availableWindow(
                this: *const root::aeron::ExclusivePublication,
            ) -> ::std::os::raw::c_long;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNK5aeron20ExclusivePublication15channelStatusIdEv"]
            pub fn ExclusivePublication_channelStatusId(
                this: *const root::aeron::ExclusivePublication,
            ) -> ::std::os::raw::c_int;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNK5aeron20ExclusivePublication13channelStatusEv"]
            pub fn ExclusivePublication_channelStatus(
                this: *const root::aeron::ExclusivePublication,
            ) -> ::std::os::raw::c_long;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNK5aeron20ExclusivePublication20localSocketAddressesB5cxx11Ev"]
            pub fn ExclusivePublication_localSocketAddresses(
                this: *const root::aeron::ExclusivePublication,
            ) -> u8;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5aeron20ExclusivePublication5offerERKNS_10concurrent12AtomicBufferEiiRKSt8functionIFlRS2_iiEE"]
            pub fn ExclusivePublication_offer(
                this: *mut root::aeron::ExclusivePublication,
                buffer: *const root::aeron::concurrent::AtomicBuffer,
                offset: root::aeron::util::index_t,
                length: root::aeron::util::index_t,
                reservedValueSupplier: *const root::aeron::on_reserved_value_supplier_t,
            ) -> ::std::os::raw::c_long;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5aeron20ExclusivePublication5offerERKNS_10concurrent12AtomicBufferEii"]
            pub fn ExclusivePublication_offer1(
                this: *mut root::aeron::ExclusivePublication,
                buffer: *const root::aeron::concurrent::AtomicBuffer,
                offset: root::aeron::util::index_t,
                length: root::aeron::util::index_t,
            ) -> ::std::os::raw::c_long;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5aeron20ExclusivePublication5offerERKNS_10concurrent12AtomicBufferE"]
            pub fn ExclusivePublication_offer2(
                this: *mut root::aeron::ExclusivePublication,
                buffer: *const root::aeron::concurrent::AtomicBuffer,
            ) -> ::std::os::raw::c_long;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5aeron20ExclusivePublication5offerEPKNS_10concurrent12AtomicBufferEmRKSt8functionIFlRS2_iiEE"]
            pub fn ExclusivePublication_offer3(
                this: *mut root::aeron::ExclusivePublication,
                buffers: *const root::aeron::concurrent::AtomicBuffer,
                length: usize,
                reservedValueSupplier: *const root::aeron::on_reserved_value_supplier_t,
            ) -> ::std::os::raw::c_long;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5aeron20ExclusivePublication8tryClaimEiRNS_10concurrent9logbuffer11BufferClaimE"]
            pub fn ExclusivePublication_tryClaim(
                this: *mut root::aeron::ExclusivePublication,
                length: root::aeron::util::index_t,
                bufferClaim: *mut root::aeron::concurrent::logbuffer::BufferClaim,
            ) -> ::std::os::raw::c_long;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5aeron20ExclusivePublication14addDestinationERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
            pub fn ExclusivePublication_addDestination(
                this: *mut root::aeron::ExclusivePublication,
                endpointChannel: *const root::std::string,
            ) -> ::std::os::raw::c_long;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5aeron20ExclusivePublication17removeDestinationERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
            pub fn ExclusivePublication_removeDestination(
                this: *mut root::aeron::ExclusivePublication,
                endpointChannel: *const root::std::string,
            ) -> ::std::os::raw::c_long;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5aeron20ExclusivePublication23findDestinationResponseEl"]
            pub fn ExclusivePublication_findDestinationResponse(
                this: *mut root::aeron::ExclusivePublication,
                correlationId: ::std::os::raw::c_long,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5aeron20ExclusivePublication5closeEv"]
            pub fn ExclusivePublication_close(this: *mut root::aeron::ExclusivePublication);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5aeron20ExclusivePublicationC1ERNS_15ClientConductorERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEliiRNS_10concurrent6status20UnsafeBufferPositionEiSt10shared_ptrINS_10LogBuffersEE"]
            pub fn ExclusivePublication_ExclusivePublication(
                this: *mut root::aeron::ExclusivePublication,
                conductor: *mut root::aeron::ClientConductor,
                channel: *const root::std::string,
                registrationId: ::std::os::raw::c_long,
                streamId: ::std::os::raw::c_int,
                sessionId: ::std::os::raw::c_int,
                publicationLimit: *mut root::aeron::concurrent::status::UnsafeBufferPosition,
                channelStatusId: ::std::os::raw::c_int,
                logBuffers: [u64; 2usize],
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5aeron20ExclusivePublicationD1Ev"]
            pub fn ExclusivePublication_ExclusivePublication_destructor(
                this: *mut root::aeron::ExclusivePublication,
            );
        }
        impl ExclusivePublication {
            #[inline]
            pub unsafe fn channel(&self) -> *const root::std::string {
                ExclusivePublication_channel(self)
            }
            #[inline]
            pub unsafe fn streamId(&self) -> ::std::os::raw::c_int {
                ExclusivePublication_streamId(self)
            }
            #[inline]
            pub unsafe fn sessionId(&self) -> ::std::os::raw::c_int {
                ExclusivePublication_sessionId(self)
            }
            #[inline]
            pub unsafe fn initialTermId(&self) -> ::std::os::raw::c_int {
                ExclusivePublication_initialTermId(self)
            }
            #[inline]
            pub unsafe fn termId(&self) -> ::std::os::raw::c_int {
                ExclusivePublication_termId(self)
            }
            #[inline]
            pub unsafe fn termOffset(&self) -> ::std::os::raw::c_int {
                ExclusivePublication_termOffset(self)
            }
            #[inline]
            pub unsafe fn originalRegistrationId(&self) -> ::std::os::raw::c_long {
                ExclusivePublication_originalRegistrationId(self)
            }
            #[inline]
            pub unsafe fn registrationId(&self) -> ::std::os::raw::c_long {
                ExclusivePublication_registrationId(self)
            }
            #[inline]
            pub unsafe fn isOriginal() -> bool {
                ExclusivePublication_isOriginal()
            }
            #[inline]
            pub unsafe fn maxMessageLength(&self) -> root::aeron::util::index_t {
                ExclusivePublication_maxMessageLength(self)
            }
            #[inline]
            pub unsafe fn maxPayloadLength(&self) -> root::aeron::util::index_t {
                ExclusivePublication_maxPayloadLength(self)
            }
            #[inline]
            pub unsafe fn termBufferLength(&self) -> ::std::os::raw::c_int {
                ExclusivePublication_termBufferLength(self)
            }
            #[inline]
            pub unsafe fn positionBitsToShift(&self) -> ::std::os::raw::c_int {
                ExclusivePublication_positionBitsToShift(self)
            }
            #[inline]
            pub unsafe fn isConnected(&self) -> bool {
                ExclusivePublication_isConnected(self)
            }
            #[inline]
            pub unsafe fn isClosed(&self) -> bool {
                ExclusivePublication_isClosed(self)
            }
            #[inline]
            pub unsafe fn maxPossiblePosition(&self) -> ::std::os::raw::c_long {
                ExclusivePublication_maxPossiblePosition(self)
            }
            #[inline]
            pub unsafe fn position(&self) -> ::std::os::raw::c_long {
                ExclusivePublication_position(self)
            }
            #[inline]
            pub unsafe fn publicationLimit(&self) -> ::std::os::raw::c_long {
                ExclusivePublication_publicationLimit(self)
            }
            #[inline]
            pub unsafe fn publicationLimitId(&self) -> ::std::os::raw::c_int {
                ExclusivePublication_publicationLimitId(self)
            }
            #[inline]
            pub unsafe fn availableWindow(&self) -> ::std::os::raw::c_long {
                ExclusivePublication_availableWindow(self)
            }
            #[inline]
            pub unsafe fn channelStatusId(&self) -> ::std::os::raw::c_int {
                ExclusivePublication_channelStatusId(self)
            }
            #[inline]
            pub unsafe fn channelStatus(&self) -> ::std::os::raw::c_long {
                ExclusivePublication_channelStatus(self)
            }
            #[inline]
            pub unsafe fn localSocketAddresses(&self) -> u8 {
                ExclusivePublication_localSocketAddresses(self)
            }
            #[inline]
            pub unsafe fn offer(
                &mut self,
                buffer: *const root::aeron::concurrent::AtomicBuffer,
                offset: root::aeron::util::index_t,
                length: root::aeron::util::index_t,
                reservedValueSupplier: *const root::aeron::on_reserved_value_supplier_t,
            ) -> ::std::os::raw::c_long {
                ExclusivePublication_offer(self, buffer, offset, length, reservedValueSupplier)
            }
            #[inline]
            pub unsafe fn offer1(
                &mut self,
                buffer: *const root::aeron::concurrent::AtomicBuffer,
                offset: root::aeron::util::index_t,
                length: root::aeron::util::index_t,
            ) -> ::std::os::raw::c_long {
                ExclusivePublication_offer1(self, buffer, offset, length)
            }
            #[inline]
            pub unsafe fn offer2(
                &mut self,
                buffer: *const root::aeron::concurrent::AtomicBuffer,
            ) -> ::std::os::raw::c_long {
                ExclusivePublication_offer2(self, buffer)
            }
            #[inline]
            pub unsafe fn offer3(
                &mut self,
                buffers: *const root::aeron::concurrent::AtomicBuffer,
                length: usize,
                reservedValueSupplier: *const root::aeron::on_reserved_value_supplier_t,
            ) -> ::std::os::raw::c_long {
                ExclusivePublication_offer3(self, buffers, length, reservedValueSupplier)
            }
            #[inline]
            pub unsafe fn tryClaim(
                &mut self,
                length: root::aeron::util::index_t,
                bufferClaim: *mut root::aeron::concurrent::logbuffer::BufferClaim,
            ) -> ::std::os::raw::c_long {
                ExclusivePublication_tryClaim(self, length, bufferClaim)
            }
            #[inline]
            pub unsafe fn addDestination(
                &mut self,
                endpointChannel: *const root::std::string,
            ) -> ::std::os::raw::c_long {
                ExclusivePublication_addDestination(self, endpointChannel)
            }
            #[inline]
            pub unsafe fn removeDestination(
                &mut self,
                endpointChannel: *const root::std::string,
            ) -> ::std::os::raw::c_long {
                ExclusivePublication_removeDestination(self, endpointChannel)
            }
            #[inline]
            pub unsafe fn findDestinationResponse(
                &mut self,
                correlationId: ::std::os::raw::c_long,
            ) -> bool {
                ExclusivePublication_findDestinationResponse(self, correlationId)
            }
            #[inline]
            pub unsafe fn close(&mut self) {
                ExclusivePublication_close(self)
            }
            #[inline]
            pub unsafe fn new(
                conductor: *mut root::aeron::ClientConductor,
                channel: *const root::std::string,
                registrationId: ::std::os::raw::c_long,
                streamId: ::std::os::raw::c_int,
                sessionId: ::std::os::raw::c_int,
                publicationLimit: *mut root::aeron::concurrent::status::UnsafeBufferPosition,
                channelStatusId: ::std::os::raw::c_int,
                logBuffers: [u64; 2usize],
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                ExclusivePublication_ExclusivePublication(
                    __bindgen_tmp.as_mut_ptr(),
                    conductor,
                    channel,
                    registrationId,
                    streamId,
                    sessionId,
                    publicationLimit,
                    channelStatusId,
                    logBuffers,
                );
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn destruct(&mut self) {
                ExclusivePublication_ExclusivePublication_destructor(self)
            }
        }
        pub const ControlledPollAction_ABORT: root::aeron::ControlledPollAction = 1;
        pub const ControlledPollAction_BREAK: root::aeron::ControlledPollAction = 2;
        pub const ControlledPollAction_COMMIT: root::aeron::ControlledPollAction = 3;
        pub const ControlledPollAction_CONTINUE: root::aeron::ControlledPollAction = 4;
        pub type ControlledPollAction = ::std::os::raw::c_int;
        pub type controlled_poll_fragment_handler_t = [u64; 4usize];
        #[repr(C)]
        pub struct Image {
            pub m_sourceIdentity: root::std::string,
            pub m_logBuffers: [u64; 2usize],
            pub m_exceptionHandler: root::aeron::util::exception_handler_t,
            pub m_termBuffers: [u64; 6usize],
            pub m_subscriberPosition: root::aeron::concurrent::status::Position<
                root::aeron::concurrent::status::UnsafeBufferPosition,
            >,
            pub m_header: root::aeron::concurrent::logbuffer::Header,
            pub m_isClosed: u8,
            pub m_isEos: bool,
            pub m_termLengthMask: ::std::os::raw::c_int,
            pub m_positionBitsToShift: ::std::os::raw::c_int,
            pub m_sessionId: ::std::os::raw::c_int,
            pub m_joinPosition: ::std::os::raw::c_long,
            pub m_finalPosition: ::std::os::raw::c_long,
            pub m_subscriptionRegistrationId: ::std::os::raw::c_long,
            pub m_correlationId: ::std::os::raw::c_long,
        }
        pub type Image_list_t = [u64; 3usize];
        pub type Image_array_t = *mut [u64; 2usize];
        #[test]
        fn bindgen_test_layout_Image() {
            const UNINIT: ::std::mem::MaybeUninit<Image> = ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<Image>(),
                240usize,
                concat!("Size of: ", stringify!(Image))
            );
            assert_eq!(
                ::std::mem::align_of::<Image>(),
                8usize,
                concat!("Alignment of ", stringify!(Image))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_sourceIdentity) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Image),
                    "::",
                    stringify!(m_sourceIdentity)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_logBuffers) as usize - ptr as usize },
                32usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Image),
                    "::",
                    stringify!(m_logBuffers)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_exceptionHandler) as usize - ptr as usize },
                48usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Image),
                    "::",
                    stringify!(m_exceptionHandler)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_termBuffers) as usize - ptr as usize },
                80usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Image),
                    "::",
                    stringify!(m_termBuffers)
                )
            );
            assert_eq!(
                unsafe {
                    ::std::ptr::addr_of!((*ptr).m_subscriberPosition) as usize - ptr as usize
                },
                128usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Image),
                    "::",
                    stringify!(m_subscriberPosition)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_header) as usize - ptr as usize },
                152usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Image),
                    "::",
                    stringify!(m_header)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_isClosed) as usize - ptr as usize },
                192usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Image),
                    "::",
                    stringify!(m_isClosed)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_isEos) as usize - ptr as usize },
                193usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Image),
                    "::",
                    stringify!(m_isEos)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_termLengthMask) as usize - ptr as usize },
                196usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Image),
                    "::",
                    stringify!(m_termLengthMask)
                )
            );
            assert_eq!(
                unsafe {
                    ::std::ptr::addr_of!((*ptr).m_positionBitsToShift) as usize - ptr as usize
                },
                200usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Image),
                    "::",
                    stringify!(m_positionBitsToShift)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_sessionId) as usize - ptr as usize },
                204usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Image),
                    "::",
                    stringify!(m_sessionId)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_joinPosition) as usize - ptr as usize },
                208usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Image),
                    "::",
                    stringify!(m_joinPosition)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_finalPosition) as usize - ptr as usize },
                216usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Image),
                    "::",
                    stringify!(m_finalPosition)
                )
            );
            assert_eq!(
                unsafe {
                    ::std::ptr::addr_of!((*ptr).m_subscriptionRegistrationId) as usize
                        - ptr as usize
                },
                224usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Image),
                    "::",
                    stringify!(m_subscriptionRegistrationId)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_correlationId) as usize - ptr as usize },
                232usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Image),
                    "::",
                    stringify!(m_correlationId)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZNK5aeron5Image16termBufferLengthEv"]
            pub fn Image_termBufferLength(this: *const root::aeron::Image)
                -> ::std::os::raw::c_int;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNK5aeron5Image19positionBitsToShiftEv"]
            pub fn Image_positionBitsToShift(
                this: *const root::aeron::Image,
            ) -> ::std::os::raw::c_int;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNK5aeron5Image9sessionIdEv"]
            pub fn Image_sessionId(this: *const root::aeron::Image) -> ::std::os::raw::c_int;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNK5aeron5Image13correlationIdEv"]
            pub fn Image_correlationId(this: *const root::aeron::Image) -> ::std::os::raw::c_long;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNK5aeron5Image26subscriptionRegistrationIdEv"]
            pub fn Image_subscriptionRegistrationId(
                this: *const root::aeron::Image,
            ) -> ::std::os::raw::c_long;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNK5aeron5Image12joinPositionEv"]
            pub fn Image_joinPosition(this: *const root::aeron::Image) -> ::std::os::raw::c_long;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNK5aeron5Image13initialTermIdEv"]
            pub fn Image_initialTermId(this: *const root::aeron::Image) -> ::std::os::raw::c_int;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNK5aeron5Image14sourceIdentityB5cxx11Ev"]
            pub fn Image_sourceIdentity(this: *const root::aeron::Image) -> root::std::string;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNK5aeron5Image8isClosedEv"]
            pub fn Image_isClosed(this: *const root::aeron::Image) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNK5aeron5Image8positionEv"]
            pub fn Image_position(this: *const root::aeron::Image) -> ::std::os::raw::c_long;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNK5aeron5Image20subscriberPositionIdEv"]
            pub fn Image_subscriberPositionId(
                this: *const root::aeron::Image,
            ) -> ::std::os::raw::c_int;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5aeron5Image8positionEl"]
            pub fn Image_position1(
                this: *mut root::aeron::Image,
                newPosition: ::std::os::raw::c_long,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZNK5aeron5Image13isEndOfStreamEv"]
            pub fn Image_isEndOfStream(this: *const root::aeron::Image) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNK5aeron5Image20activeTransportCountEv"]
            pub fn Image_activeTransportCount(
                this: *const root::aeron::Image,
            ) -> ::std::os::raw::c_int;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5aeron5Image10logBuffersEv"]
            pub fn Image_logBuffers(this: *mut root::aeron::Image) -> [u64; 2usize];
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5aeron5Image5closeEv"]
            pub fn Image_close(this: *mut root::aeron::Image);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5aeron5ImageC1EillRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEERNS_10concurrent6status20UnsafeBufferPositionESt10shared_ptrINS_10LogBuffersEERKSt8functionIFvRKSt9exceptionEE"]
            pub fn Image_Image(
                this: *mut root::aeron::Image,
                sessionId: ::std::os::raw::c_int,
                correlationId: ::std::os::raw::c_long,
                subscriptionRegistrationId: ::std::os::raw::c_long,
                sourceIdentity: *const root::std::string,
                subscriberPosition: *mut root::aeron::concurrent::status::UnsafeBufferPosition,
                logBuffers: [u64; 2usize],
                exceptionHandler: *const root::aeron::util::exception_handler_t,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5aeron5ImageC1ERKS0_"]
            pub fn Image_Image1(this: *mut root::aeron::Image, image: *const root::aeron::Image);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5aeron5ImageC1EOS0_"]
            pub fn Image_Image2(this: *mut root::aeron::Image, image: *mut root::aeron::Image);
        }
        impl Image {
            #[inline]
            pub unsafe fn termBufferLength(&self) -> ::std::os::raw::c_int {
                Image_termBufferLength(self)
            }
            #[inline]
            pub unsafe fn positionBitsToShift(&self) -> ::std::os::raw::c_int {
                Image_positionBitsToShift(self)
            }
            #[inline]
            pub unsafe fn sessionId(&self) -> ::std::os::raw::c_int {
                Image_sessionId(self)
            }
            #[inline]
            pub unsafe fn correlationId(&self) -> ::std::os::raw::c_long {
                Image_correlationId(self)
            }
            #[inline]
            pub unsafe fn subscriptionRegistrationId(&self) -> ::std::os::raw::c_long {
                Image_subscriptionRegistrationId(self)
            }
            #[inline]
            pub unsafe fn joinPosition(&self) -> ::std::os::raw::c_long {
                Image_joinPosition(self)
            }
            #[inline]
            pub unsafe fn initialTermId(&self) -> ::std::os::raw::c_int {
                Image_initialTermId(self)
            }
            #[inline]
            pub unsafe fn sourceIdentity(&self) -> root::std::string {
                Image_sourceIdentity(self)
            }
            #[inline]
            pub unsafe fn isClosed(&self) -> bool {
                Image_isClosed(self)
            }
            #[inline]
            pub unsafe fn position(&self) -> ::std::os::raw::c_long {
                Image_position(self)
            }
            #[inline]
            pub unsafe fn subscriberPositionId(&self) -> ::std::os::raw::c_int {
                Image_subscriberPositionId(self)
            }
            #[inline]
            pub unsafe fn position1(&mut self, newPosition: ::std::os::raw::c_long) {
                Image_position1(self, newPosition)
            }
            #[inline]
            pub unsafe fn isEndOfStream(&self) -> bool {
                Image_isEndOfStream(self)
            }
            #[inline]
            pub unsafe fn activeTransportCount(&self) -> ::std::os::raw::c_int {
                Image_activeTransportCount(self)
            }
            #[inline]
            pub unsafe fn logBuffers(&mut self) -> [u64; 2usize] {
                Image_logBuffers(self)
            }
            #[inline]
            pub unsafe fn close(&mut self) {
                Image_close(self)
            }
            #[inline]
            pub unsafe fn new(
                sessionId: ::std::os::raw::c_int,
                correlationId: ::std::os::raw::c_long,
                subscriptionRegistrationId: ::std::os::raw::c_long,
                sourceIdentity: *const root::std::string,
                subscriberPosition: *mut root::aeron::concurrent::status::UnsafeBufferPosition,
                logBuffers: [u64; 2usize],
                exceptionHandler: *const root::aeron::util::exception_handler_t,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                Image_Image(
                    __bindgen_tmp.as_mut_ptr(),
                    sessionId,
                    correlationId,
                    subscriptionRegistrationId,
                    sourceIdentity,
                    subscriberPosition,
                    logBuffers,
                    exceptionHandler,
                );
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn new1(image: *const root::aeron::Image) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                Image_Image1(__bindgen_tmp.as_mut_ptr(), image);
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn new2(image: *mut root::aeron::Image) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                Image_Image2(__bindgen_tmp.as_mut_ptr(), image);
                __bindgen_tmp.assume_init()
            }
        }
        #[repr(C)]
        pub struct Subscription {
            pub m_conductor: *mut root::aeron::ClientConductor,
            pub m_channel: root::std::string,
            pub m_channelStatusId: ::std::os::raw::c_int,
            pub m_streamId: ::std::os::raw::c_int,
            pub m_registrationId: ::std::os::raw::c_long,
            pub m_isClosed: u8,
            pub m_imageArray: [u64; 4usize],
            pub m_paddingBefore: [::std::os::raw::c_char; 64usize],
            pub m_roundRobinIndex: usize,
            pub m_paddingAfter: [::std::os::raw::c_char; 64usize],
        }
        #[test]
        fn bindgen_test_layout_Subscription() {
            const UNINIT: ::std::mem::MaybeUninit<Subscription> = ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<Subscription>(),
                232usize,
                concat!("Size of: ", stringify!(Subscription))
            );
            assert_eq!(
                ::std::mem::align_of::<Subscription>(),
                8usize,
                concat!("Alignment of ", stringify!(Subscription))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_conductor) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Subscription),
                    "::",
                    stringify!(m_conductor)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_channel) as usize - ptr as usize },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Subscription),
                    "::",
                    stringify!(m_channel)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_channelStatusId) as usize - ptr as usize },
                40usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Subscription),
                    "::",
                    stringify!(m_channelStatusId)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_streamId) as usize - ptr as usize },
                44usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Subscription),
                    "::",
                    stringify!(m_streamId)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_registrationId) as usize - ptr as usize },
                48usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Subscription),
                    "::",
                    stringify!(m_registrationId)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_isClosed) as usize - ptr as usize },
                56usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Subscription),
                    "::",
                    stringify!(m_isClosed)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_imageArray) as usize - ptr as usize },
                64usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Subscription),
                    "::",
                    stringify!(m_imageArray)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_paddingBefore) as usize - ptr as usize },
                96usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Subscription),
                    "::",
                    stringify!(m_paddingBefore)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_roundRobinIndex) as usize - ptr as usize },
                160usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Subscription),
                    "::",
                    stringify!(m_roundRobinIndex)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_paddingAfter) as usize - ptr as usize },
                168usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Subscription),
                    "::",
                    stringify!(m_paddingAfter)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZNK5aeron12Subscription7channelB5cxx11Ev"]
            pub fn Subscription_channel(
                this: *const root::aeron::Subscription,
            ) -> *const root::std::string;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNK5aeron12Subscription8streamIdEv"]
            pub fn Subscription_streamId(
                this: *const root::aeron::Subscription,
            ) -> ::std::os::raw::c_int;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNK5aeron12Subscription14registrationIdEv"]
            pub fn Subscription_registrationId(
                this: *const root::aeron::Subscription,
            ) -> ::std::os::raw::c_long;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNK5aeron12Subscription15channelStatusIdEv"]
            pub fn Subscription_channelStatusId(
                this: *const root::aeron::Subscription,
            ) -> ::std::os::raw::c_int;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNK5aeron12Subscription13channelStatusEv"]
            pub fn Subscription_channelStatus(
                this: *const root::aeron::Subscription,
            ) -> ::std::os::raw::c_long;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNK5aeron12Subscription20localSocketAddressesB5cxx11Ev"]
            pub fn Subscription_localSocketAddresses(this: *const root::aeron::Subscription) -> u8;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNK5aeron12Subscription29tryResolveChannelEndpointPortB5cxx11Ev"]
            pub fn Subscription_tryResolveChannelEndpointPort(
                this: *const root::aeron::Subscription,
            ) -> root::std::string;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNK5aeron12Subscription16resolvedEndpointB5cxx11Ev"]
            pub fn Subscription_resolvedEndpoint(
                this: *const root::aeron::Subscription,
            ) -> root::std::string;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5aeron12Subscription14addDestinationERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
            pub fn Subscription_addDestination(
                this: *mut root::aeron::Subscription,
                endpointChannel: *const root::std::string,
            ) -> ::std::os::raw::c_long;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5aeron12Subscription17removeDestinationERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
            pub fn Subscription_removeDestination(
                this: *mut root::aeron::Subscription,
                endpointChannel: *const root::std::string,
            ) -> ::std::os::raw::c_long;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5aeron12Subscription23findDestinationResponseEl"]
            pub fn Subscription_findDestinationResponse(
                this: *mut root::aeron::Subscription,
                correlationId: ::std::os::raw::c_long,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNK5aeron12Subscription11isConnectedEv"]
            pub fn Subscription_isConnected(this: *const root::aeron::Subscription) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNK5aeron12Subscription10imageCountEv"]
            pub fn Subscription_imageCount(
                this: *const root::aeron::Subscription,
            ) -> ::std::os::raw::c_int;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNK5aeron12Subscription16imageBySessionIdEi"]
            pub fn Subscription_imageBySessionId(
                this: *const root::aeron::Subscription,
                sessionId: ::std::os::raw::c_int,
            ) -> [u64; 2usize];
        }
        extern "C" {
            #[link_name = "\u{1}_ZNK5aeron12Subscription12imageByIndexEm"]
            pub fn Subscription_imageByIndex(
                this: *const root::aeron::Subscription,
                index: usize,
            ) -> [u64; 2usize];
        }
        extern "C" {
            #[link_name = "\u{1}_ZNK5aeron12Subscription12imageAtIndexEm"]
            pub fn Subscription_imageAtIndex(
                this: *const root::aeron::Subscription,
                index: usize,
            ) -> *mut root::aeron::Image;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNK5aeron12Subscription6imagesEv"]
            pub fn Subscription_images(this: *const root::aeron::Subscription) -> [u64; 2usize];
        }
        extern "C" {
            #[link_name = "\u{1}_ZNK5aeron12Subscription15copyOfImageListEv"]
            pub fn Subscription_copyOfImageList(
                this: *const root::aeron::Subscription,
            ) -> [u64; 2usize];
        }
        extern "C" {
            #[link_name = "\u{1}_ZNK5aeron12Subscription8isClosedEv"]
            pub fn Subscription_isClosed(this: *const root::aeron::Subscription) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNK5aeron12Subscription8hasImageEl"]
            pub fn Subscription_hasImage(
                this: *const root::aeron::Subscription,
                correlationId: ::std::os::raw::c_long,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5aeron12Subscription8addImageESt10shared_ptrINS_5ImageEE"]
            pub fn Subscription_addImage(
                this: *mut root::aeron::Subscription,
                image: [u64; 2usize],
            ) -> root::aeron::Image_array_t;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5aeron12Subscription11removeImageEl"]
            pub fn Subscription_removeImage(
                this: *mut root::aeron::Subscription,
                correlationId: ::std::os::raw::c_long,
            ) -> [u64; 2usize];
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5aeron12Subscription20closeAndRemoveImagesEv"]
            pub fn Subscription_closeAndRemoveImages(
                this: *mut root::aeron::Subscription,
            ) -> [u64; 2usize];
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5aeron12SubscriptionC1ERNS_15ClientConductorElRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEii"]
            pub fn Subscription_Subscription(
                this: *mut root::aeron::Subscription,
                conductor: *mut root::aeron::ClientConductor,
                registrationId: ::std::os::raw::c_long,
                channel: *const root::std::string,
                streamId: ::std::os::raw::c_int,
                channelStatusId: ::std::os::raw::c_int,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5aeron12SubscriptionD1Ev"]
            pub fn Subscription_Subscription_destructor(this: *mut root::aeron::Subscription);
        }
        impl Subscription {
            #[inline]
            pub unsafe fn channel(&self) -> *const root::std::string {
                Subscription_channel(self)
            }
            #[inline]
            pub unsafe fn streamId(&self) -> ::std::os::raw::c_int {
                Subscription_streamId(self)
            }
            #[inline]
            pub unsafe fn registrationId(&self) -> ::std::os::raw::c_long {
                Subscription_registrationId(self)
            }
            #[inline]
            pub unsafe fn channelStatusId(&self) -> ::std::os::raw::c_int {
                Subscription_channelStatusId(self)
            }
            #[inline]
            pub unsafe fn channelStatus(&self) -> ::std::os::raw::c_long {
                Subscription_channelStatus(self)
            }
            #[inline]
            pub unsafe fn localSocketAddresses(&self) -> u8 {
                Subscription_localSocketAddresses(self)
            }
            #[inline]
            pub unsafe fn tryResolveChannelEndpointPort(&self) -> root::std::string {
                Subscription_tryResolveChannelEndpointPort(self)
            }
            #[inline]
            pub unsafe fn resolvedEndpoint(&self) -> root::std::string {
                Subscription_resolvedEndpoint(self)
            }
            #[inline]
            pub unsafe fn addDestination(
                &mut self,
                endpointChannel: *const root::std::string,
            ) -> ::std::os::raw::c_long {
                Subscription_addDestination(self, endpointChannel)
            }
            #[inline]
            pub unsafe fn removeDestination(
                &mut self,
                endpointChannel: *const root::std::string,
            ) -> ::std::os::raw::c_long {
                Subscription_removeDestination(self, endpointChannel)
            }
            #[inline]
            pub unsafe fn findDestinationResponse(
                &mut self,
                correlationId: ::std::os::raw::c_long,
            ) -> bool {
                Subscription_findDestinationResponse(self, correlationId)
            }
            #[inline]
            pub unsafe fn isConnected(&self) -> bool {
                Subscription_isConnected(self)
            }
            #[inline]
            pub unsafe fn imageCount(&self) -> ::std::os::raw::c_int {
                Subscription_imageCount(self)
            }
            #[inline]
            pub unsafe fn imageBySessionId(
                &self,
                sessionId: ::std::os::raw::c_int,
            ) -> [u64; 2usize] {
                Subscription_imageBySessionId(self, sessionId)
            }
            #[inline]
            pub unsafe fn imageByIndex(&self, index: usize) -> [u64; 2usize] {
                Subscription_imageByIndex(self, index)
            }
            #[inline]
            pub unsafe fn imageAtIndex(&self, index: usize) -> *mut root::aeron::Image {
                Subscription_imageAtIndex(self, index)
            }
            #[inline]
            pub unsafe fn images(&self) -> [u64; 2usize] {
                Subscription_images(self)
            }
            #[inline]
            pub unsafe fn copyOfImageList(&self) -> [u64; 2usize] {
                Subscription_copyOfImageList(self)
            }
            #[inline]
            pub unsafe fn isClosed(&self) -> bool {
                Subscription_isClosed(self)
            }
            #[inline]
            pub unsafe fn hasImage(&self, correlationId: ::std::os::raw::c_long) -> bool {
                Subscription_hasImage(self, correlationId)
            }
            #[inline]
            pub unsafe fn addImage(&mut self, image: [u64; 2usize]) -> root::aeron::Image_array_t {
                Subscription_addImage(self, image)
            }
            #[inline]
            pub unsafe fn removeImage(
                &mut self,
                correlationId: ::std::os::raw::c_long,
            ) -> [u64; 2usize] {
                Subscription_removeImage(self, correlationId)
            }
            #[inline]
            pub unsafe fn closeAndRemoveImages(&mut self) -> [u64; 2usize] {
                Subscription_closeAndRemoveImages(self)
            }
            #[inline]
            pub unsafe fn new(
                conductor: *mut root::aeron::ClientConductor,
                registrationId: ::std::os::raw::c_long,
                channel: *const root::std::string,
                streamId: ::std::os::raw::c_int,
                channelStatusId: ::std::os::raw::c_int,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                Subscription_Subscription(
                    __bindgen_tmp.as_mut_ptr(),
                    conductor,
                    registrationId,
                    channel,
                    streamId,
                    channelStatusId,
                );
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn destruct(&mut self) {
                Subscription_Subscription_destructor(self)
            }
        }
        #[repr(C)]
        pub struct Counter {
            pub _base: root::aeron::concurrent::AtomicCounter,
            pub m_clientConductor: *mut root::aeron::ClientConductor,
            pub m_registrationId: ::std::os::raw::c_long,
            pub m_isClosed: u8,
        }
        #[test]
        fn bindgen_test_layout_Counter() {
            const UNINIT: ::std::mem::MaybeUninit<Counter> = ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<Counter>(),
                72usize,
                concat!("Size of: ", stringify!(Counter))
            );
            assert_eq!(
                ::std::mem::align_of::<Counter>(),
                8usize,
                concat!("Alignment of ", stringify!(Counter))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_clientConductor) as usize - ptr as usize },
                48usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Counter),
                    "::",
                    stringify!(m_clientConductor)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_registrationId) as usize - ptr as usize },
                56usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Counter),
                    "::",
                    stringify!(m_registrationId)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_isClosed) as usize - ptr as usize },
                64usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Counter),
                    "::",
                    stringify!(m_isClosed)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZNK5aeron7Counter14registrationIdEv"]
            pub fn Counter_registrationId(
                this: *const root::aeron::Counter,
            ) -> ::std::os::raw::c_long;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNK5aeron7Counter5stateEv"]
            pub fn Counter_state(this: *const root::aeron::Counter) -> ::std::os::raw::c_int;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNK5aeron7Counter5labelB5cxx11Ev"]
            pub fn Counter_label(this: *const root::aeron::Counter) -> root::std::string;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNK5aeron7Counter8isClosedEv"]
            pub fn Counter_isClosed(this: *const root::aeron::Counter) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5aeron7Counter5closeEv"]
            pub fn Counter_close(this: *mut root::aeron::Counter);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5aeron7CounterC1EPNS_15ClientConductorERNS_10concurrent12AtomicBufferEli"]
            pub fn Counter_Counter(
                this: *mut root::aeron::Counter,
                clientConductor: *mut root::aeron::ClientConductor,
                buffer: *mut root::aeron::concurrent::AtomicBuffer,
                registrationId: ::std::os::raw::c_long,
                counterId: ::std::os::raw::c_int,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5aeron7CounterC1ERNS_10concurrent14CountersReaderEli"]
            pub fn Counter_Counter1(
                this: *mut root::aeron::Counter,
                countersReader: *mut root::aeron::concurrent::CountersReader,
                registrationId: ::std::os::raw::c_long,
                counterId: ::std::os::raw::c_int,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5aeron7CounterD1Ev"]
            pub fn Counter_Counter_destructor(this: *mut root::aeron::Counter);
        }
        impl Counter {
            #[inline]
            pub unsafe fn registrationId(&self) -> ::std::os::raw::c_long {
                Counter_registrationId(self)
            }
            #[inline]
            pub unsafe fn state(&self) -> ::std::os::raw::c_int {
                Counter_state(self)
            }
            #[inline]
            pub unsafe fn label(&self) -> root::std::string {
                Counter_label(self)
            }
            #[inline]
            pub unsafe fn isClosed(&self) -> bool {
                Counter_isClosed(self)
            }
            #[inline]
            pub unsafe fn close(&mut self) {
                Counter_close(self)
            }
            #[inline]
            pub unsafe fn new(
                clientConductor: *mut root::aeron::ClientConductor,
                buffer: *mut root::aeron::concurrent::AtomicBuffer,
                registrationId: ::std::os::raw::c_long,
                counterId: ::std::os::raw::c_int,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                Counter_Counter(
                    __bindgen_tmp.as_mut_ptr(),
                    clientConductor,
                    buffer,
                    registrationId,
                    counterId,
                );
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn new1(
                countersReader: *mut root::aeron::concurrent::CountersReader,
                registrationId: ::std::os::raw::c_long,
                counterId: ::std::os::raw::c_int,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                Counter_Counter1(
                    __bindgen_tmp.as_mut_ptr(),
                    countersReader,
                    registrationId,
                    counterId,
                );
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn destruct(&mut self) {
                Counter_Counter_destructor(self)
            }
        }
        pub mod command {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            #[repr(C)]
            #[derive(Copy, Clone)]
            pub struct Flyweight<struct_t> {
                pub m_struct: *mut struct_t,
                pub m_buffer: root::aeron::concurrent::AtomicBuffer,
                pub m_baseOffset: root::aeron::util::index_t,
                pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<struct_t>>,
            }
            #[repr(C, packed(4))]
            #[derive(Copy, Clone)]
            pub struct CorrelatedMessageDefn {
                pub clientId: ::std::os::raw::c_long,
                pub correlationId: ::std::os::raw::c_long,
            }
            #[test]
            fn bindgen_test_layout_CorrelatedMessageDefn() {
                const UNINIT: ::std::mem::MaybeUninit<CorrelatedMessageDefn> =
                    ::std::mem::MaybeUninit::uninit();
                let ptr = UNINIT.as_ptr();
                assert_eq!(
                    ::std::mem::size_of::<CorrelatedMessageDefn>(),
                    16usize,
                    concat!("Size of: ", stringify!(CorrelatedMessageDefn))
                );
                assert_eq!(
                    ::std::mem::align_of::<CorrelatedMessageDefn>(),
                    4usize,
                    concat!("Alignment of ", stringify!(CorrelatedMessageDefn))
                );
                assert_eq!(
                    unsafe { ::std::ptr::addr_of!((*ptr).clientId) as usize - ptr as usize },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(CorrelatedMessageDefn),
                        "::",
                        stringify!(clientId)
                    )
                );
                assert_eq!(
                    unsafe { ::std::ptr::addr_of!((*ptr).correlationId) as usize - ptr as usize },
                    8usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(CorrelatedMessageDefn),
                        "::",
                        stringify!(correlationId)
                    )
                );
            }
            #[repr(C)]
            #[derive(Copy, Clone)]
            pub struct CorrelatedMessageFlyweight {
                pub _base:
                    root::aeron::command::Flyweight<root::aeron::command::CorrelatedMessageDefn>,
            }
            #[test]
            fn bindgen_test_layout_CorrelatedMessageFlyweight() {
                assert_eq!(
                    ::std::mem::size_of::<CorrelatedMessageFlyweight>(),
                    32usize,
                    concat!("Size of: ", stringify!(CorrelatedMessageFlyweight))
                );
                assert_eq!(
                    ::std::mem::align_of::<CorrelatedMessageFlyweight>(),
                    8usize,
                    concat!("Alignment of ", stringify!(CorrelatedMessageFlyweight))
                );
            }
            extern "C" {
                #[link_name = "\u{1}_ZNK5aeron7command26CorrelatedMessageFlyweight13correlationIdEv"]
                pub fn CorrelatedMessageFlyweight_correlationId(
                    this: *const root::aeron::command::CorrelatedMessageFlyweight,
                ) -> ::std::os::raw::c_long;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN5aeron7command26CorrelatedMessageFlyweight13correlationIdEl"]
                pub fn CorrelatedMessageFlyweight_correlationId1(
                    this: *mut root::aeron::command::CorrelatedMessageFlyweight,
                    value: ::std::os::raw::c_long,
                ) -> *mut root::aeron::command::CorrelatedMessageFlyweight;
            }
            extern "C" {
                #[link_name = "\u{1}_ZNK5aeron7command26CorrelatedMessageFlyweight8clientIdEv"]
                pub fn CorrelatedMessageFlyweight_clientId(
                    this: *const root::aeron::command::CorrelatedMessageFlyweight,
                ) -> ::std::os::raw::c_long;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN5aeron7command26CorrelatedMessageFlyweight8clientIdEl"]
                pub fn CorrelatedMessageFlyweight_clientId1(
                    this: *mut root::aeron::command::CorrelatedMessageFlyweight,
                    value: ::std::os::raw::c_long,
                ) -> *mut root::aeron::command::CorrelatedMessageFlyweight;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN5aeron7command26CorrelatedMessageFlyweightC1ERNS_10concurrent12AtomicBufferEi"]
                pub fn CorrelatedMessageFlyweight_CorrelatedMessageFlyweight(
                    this: *mut root::aeron::command::CorrelatedMessageFlyweight,
                    buffer: *mut root::aeron::concurrent::AtomicBuffer,
                    offset: root::aeron::util::index_t,
                );
            }
            impl CorrelatedMessageFlyweight {
                #[inline]
                pub unsafe fn correlationId(&self) -> ::std::os::raw::c_long {
                    CorrelatedMessageFlyweight_correlationId(self)
                }
                #[inline]
                pub unsafe fn correlationId1(
                    &mut self,
                    value: ::std::os::raw::c_long,
                ) -> *mut root::aeron::command::CorrelatedMessageFlyweight {
                    CorrelatedMessageFlyweight_correlationId1(self, value)
                }
                #[inline]
                pub unsafe fn clientId(&self) -> ::std::os::raw::c_long {
                    CorrelatedMessageFlyweight_clientId(self)
                }
                #[inline]
                pub unsafe fn clientId1(
                    &mut self,
                    value: ::std::os::raw::c_long,
                ) -> *mut root::aeron::command::CorrelatedMessageFlyweight {
                    CorrelatedMessageFlyweight_clientId1(self, value)
                }
                #[inline]
                pub unsafe fn new(
                    buffer: *mut root::aeron::concurrent::AtomicBuffer,
                    offset: root::aeron::util::index_t,
                ) -> Self {
                    let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                    CorrelatedMessageFlyweight_CorrelatedMessageFlyweight(
                        __bindgen_tmp.as_mut_ptr(),
                        buffer,
                        offset,
                    );
                    __bindgen_tmp.assume_init()
                }
            }
            #[repr(C, packed(4))]
            #[derive(Copy, Clone)]
            pub struct PublicationBuffersReadyDefn {
                pub correlationId: ::std::os::raw::c_long,
                pub registrationId: ::std::os::raw::c_long,
                pub sessionId: ::std::os::raw::c_int,
                pub streamId: ::std::os::raw::c_int,
                pub positionLimitCounterId: ::std::os::raw::c_int,
                pub channelStatusIndicatorId: ::std::os::raw::c_int,
                pub logFileLength: ::std::os::raw::c_int,
                pub logFileData: [::std::os::raw::c_schar; 1usize],
            }
            #[test]
            fn bindgen_test_layout_PublicationBuffersReadyDefn() {
                const UNINIT: ::std::mem::MaybeUninit<PublicationBuffersReadyDefn> =
                    ::std::mem::MaybeUninit::uninit();
                let ptr = UNINIT.as_ptr();
                assert_eq!(
                    ::std::mem::size_of::<PublicationBuffersReadyDefn>(),
                    40usize,
                    concat!("Size of: ", stringify!(PublicationBuffersReadyDefn))
                );
                assert_eq!(
                    ::std::mem::align_of::<PublicationBuffersReadyDefn>(),
                    4usize,
                    concat!("Alignment of ", stringify!(PublicationBuffersReadyDefn))
                );
                assert_eq!(
                    unsafe { ::std::ptr::addr_of!((*ptr).correlationId) as usize - ptr as usize },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(PublicationBuffersReadyDefn),
                        "::",
                        stringify!(correlationId)
                    )
                );
                assert_eq!(
                    unsafe { ::std::ptr::addr_of!((*ptr).registrationId) as usize - ptr as usize },
                    8usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(PublicationBuffersReadyDefn),
                        "::",
                        stringify!(registrationId)
                    )
                );
                assert_eq!(
                    unsafe { ::std::ptr::addr_of!((*ptr).sessionId) as usize - ptr as usize },
                    16usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(PublicationBuffersReadyDefn),
                        "::",
                        stringify!(sessionId)
                    )
                );
                assert_eq!(
                    unsafe { ::std::ptr::addr_of!((*ptr).streamId) as usize - ptr as usize },
                    20usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(PublicationBuffersReadyDefn),
                        "::",
                        stringify!(streamId)
                    )
                );
                assert_eq!(
                    unsafe {
                        ::std::ptr::addr_of!((*ptr).positionLimitCounterId) as usize - ptr as usize
                    },
                    24usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(PublicationBuffersReadyDefn),
                        "::",
                        stringify!(positionLimitCounterId)
                    )
                );
                assert_eq!(
                    unsafe {
                        ::std::ptr::addr_of!((*ptr).channelStatusIndicatorId) as usize
                            - ptr as usize
                    },
                    28usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(PublicationBuffersReadyDefn),
                        "::",
                        stringify!(channelStatusIndicatorId)
                    )
                );
                assert_eq!(
                    unsafe { ::std::ptr::addr_of!((*ptr).logFileLength) as usize - ptr as usize },
                    32usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(PublicationBuffersReadyDefn),
                        "::",
                        stringify!(logFileLength)
                    )
                );
                assert_eq!(
                    unsafe { ::std::ptr::addr_of!((*ptr).logFileData) as usize - ptr as usize },
                    36usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(PublicationBuffersReadyDefn),
                        "::",
                        stringify!(logFileData)
                    )
                );
            }
            #[repr(C)]
            #[derive(Copy, Clone)]
            pub struct PublicationBuffersReadyFlyweight {
                pub _base: root::aeron::command::Flyweight<
                    root::aeron::command::PublicationBuffersReadyDefn,
                >,
            }
            #[test]
            fn bindgen_test_layout_PublicationBuffersReadyFlyweight() {
                assert_eq!(
                    ::std::mem::size_of::<PublicationBuffersReadyFlyweight>(),
                    32usize,
                    concat!("Size of: ", stringify!(PublicationBuffersReadyFlyweight))
                );
                assert_eq!(
                    ::std::mem::align_of::<PublicationBuffersReadyFlyweight>(),
                    8usize,
                    concat!(
                        "Alignment of ",
                        stringify!(PublicationBuffersReadyFlyweight)
                    )
                );
            }
            extern "C" {
                #[link_name = "\u{1}_ZNK5aeron7command32PublicationBuffersReadyFlyweight13correlationIdEv"]
                pub fn PublicationBuffersReadyFlyweight_correlationId(
                    this: *const root::aeron::command::PublicationBuffersReadyFlyweight,
                ) -> ::std::os::raw::c_long;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN5aeron7command32PublicationBuffersReadyFlyweight13correlationIdEl"]
                pub fn PublicationBuffersReadyFlyweight_correlationId1(
                    this: *mut root::aeron::command::PublicationBuffersReadyFlyweight,
                    value: ::std::os::raw::c_long,
                ) -> *mut root::aeron::command::PublicationBuffersReadyFlyweight;
            }
            extern "C" {
                #[link_name = "\u{1}_ZNK5aeron7command32PublicationBuffersReadyFlyweight14registrationIdEv"]
                pub fn PublicationBuffersReadyFlyweight_registrationId(
                    this: *const root::aeron::command::PublicationBuffersReadyFlyweight,
                ) -> ::std::os::raw::c_long;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN5aeron7command32PublicationBuffersReadyFlyweight14registrationIdEl"]
                pub fn PublicationBuffersReadyFlyweight_registrationId1(
                    this: *mut root::aeron::command::PublicationBuffersReadyFlyweight,
                    value: ::std::os::raw::c_long,
                ) -> *mut root::aeron::command::PublicationBuffersReadyFlyweight;
            }
            extern "C" {
                #[link_name = "\u{1}_ZNK5aeron7command32PublicationBuffersReadyFlyweight9sessionIdEv"]
                pub fn PublicationBuffersReadyFlyweight_sessionId(
                    this: *const root::aeron::command::PublicationBuffersReadyFlyweight,
                ) -> ::std::os::raw::c_int;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN5aeron7command32PublicationBuffersReadyFlyweight9sessionIdEi"]
                pub fn PublicationBuffersReadyFlyweight_sessionId1(
                    this: *mut root::aeron::command::PublicationBuffersReadyFlyweight,
                    value: ::std::os::raw::c_int,
                ) -> *mut root::aeron::command::PublicationBuffersReadyFlyweight;
            }
            extern "C" {
                #[link_name = "\u{1}_ZNK5aeron7command32PublicationBuffersReadyFlyweight8streamIdEv"]
                pub fn PublicationBuffersReadyFlyweight_streamId(
                    this: *const root::aeron::command::PublicationBuffersReadyFlyweight,
                ) -> ::std::os::raw::c_int;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN5aeron7command32PublicationBuffersReadyFlyweight8streamIdEi"]
                pub fn PublicationBuffersReadyFlyweight_streamId1(
                    this: *mut root::aeron::command::PublicationBuffersReadyFlyweight,
                    value: ::std::os::raw::c_int,
                ) -> *mut root::aeron::command::PublicationBuffersReadyFlyweight;
            }
            extern "C" {
                #[link_name = "\u{1}_ZNK5aeron7command32PublicationBuffersReadyFlyweight22positionLimitCounterIdEv"]
                pub fn PublicationBuffersReadyFlyweight_positionLimitCounterId(
                    this: *const root::aeron::command::PublicationBuffersReadyFlyweight,
                ) -> ::std::os::raw::c_int;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN5aeron7command32PublicationBuffersReadyFlyweight22positionLimitCounterIdEi"]
                pub fn PublicationBuffersReadyFlyweight_positionLimitCounterId1(
                    this: *mut root::aeron::command::PublicationBuffersReadyFlyweight,
                    value: ::std::os::raw::c_int,
                ) -> *mut root::aeron::command::PublicationBuffersReadyFlyweight;
            }
            extern "C" {
                #[link_name = "\u{1}_ZNK5aeron7command32PublicationBuffersReadyFlyweight24channelStatusIndicatorIdEv"]
                pub fn PublicationBuffersReadyFlyweight_channelStatusIndicatorId(
                    this: *const root::aeron::command::PublicationBuffersReadyFlyweight,
                ) -> ::std::os::raw::c_int;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN5aeron7command32PublicationBuffersReadyFlyweight24channelStatusIndicatorIdEi"]
                pub fn PublicationBuffersReadyFlyweight_channelStatusIndicatorId1(
                    this: *mut root::aeron::command::PublicationBuffersReadyFlyweight,
                    value: ::std::os::raw::c_int,
                ) -> *mut root::aeron::command::PublicationBuffersReadyFlyweight;
            }
            extern "C" {
                #[link_name = "\u{1}_ZNK5aeron7command32PublicationBuffersReadyFlyweight11logFileNameB5cxx11Ev"]
                pub fn PublicationBuffersReadyFlyweight_logFileName(
                    this: *const root::aeron::command::PublicationBuffersReadyFlyweight,
                ) -> root::std::string;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN5aeron7command32PublicationBuffersReadyFlyweight11logFileNameERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
                pub fn PublicationBuffersReadyFlyweight_logFileName1(
                    this: *mut root::aeron::command::PublicationBuffersReadyFlyweight,
                    value: *const root::std::string,
                ) -> *mut root::aeron::command::PublicationBuffersReadyFlyweight;
            }
            extern "C" {
                #[link_name = "\u{1}_ZNK5aeron7command32PublicationBuffersReadyFlyweight6lengthEv"]
                pub fn PublicationBuffersReadyFlyweight_length(
                    this: *const root::aeron::command::PublicationBuffersReadyFlyweight,
                ) -> root::aeron::util::index_t;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN5aeron7command32PublicationBuffersReadyFlyweightC1ERNS_10concurrent12AtomicBufferEi"]
                pub fn PublicationBuffersReadyFlyweight_PublicationBuffersReadyFlyweight(
                    this: *mut root::aeron::command::PublicationBuffersReadyFlyweight,
                    buffer: *mut root::aeron::concurrent::AtomicBuffer,
                    offset: root::aeron::util::index_t,
                );
            }
            impl PublicationBuffersReadyFlyweight {
                #[inline]
                pub unsafe fn correlationId(&self) -> ::std::os::raw::c_long {
                    PublicationBuffersReadyFlyweight_correlationId(self)
                }
                #[inline]
                pub unsafe fn correlationId1(
                    &mut self,
                    value: ::std::os::raw::c_long,
                ) -> *mut root::aeron::command::PublicationBuffersReadyFlyweight {
                    PublicationBuffersReadyFlyweight_correlationId1(self, value)
                }
                #[inline]
                pub unsafe fn registrationId(&self) -> ::std::os::raw::c_long {
                    PublicationBuffersReadyFlyweight_registrationId(self)
                }
                #[inline]
                pub unsafe fn registrationId1(
                    &mut self,
                    value: ::std::os::raw::c_long,
                ) -> *mut root::aeron::command::PublicationBuffersReadyFlyweight {
                    PublicationBuffersReadyFlyweight_registrationId1(self, value)
                }
                #[inline]
                pub unsafe fn sessionId(&self) -> ::std::os::raw::c_int {
                    PublicationBuffersReadyFlyweight_sessionId(self)
                }
                #[inline]
                pub unsafe fn sessionId1(
                    &mut self,
                    value: ::std::os::raw::c_int,
                ) -> *mut root::aeron::command::PublicationBuffersReadyFlyweight {
                    PublicationBuffersReadyFlyweight_sessionId1(self, value)
                }
                #[inline]
                pub unsafe fn streamId(&self) -> ::std::os::raw::c_int {
                    PublicationBuffersReadyFlyweight_streamId(self)
                }
                #[inline]
                pub unsafe fn streamId1(
                    &mut self,
                    value: ::std::os::raw::c_int,
                ) -> *mut root::aeron::command::PublicationBuffersReadyFlyweight {
                    PublicationBuffersReadyFlyweight_streamId1(self, value)
                }
                #[inline]
                pub unsafe fn positionLimitCounterId(&self) -> ::std::os::raw::c_int {
                    PublicationBuffersReadyFlyweight_positionLimitCounterId(self)
                }
                #[inline]
                pub unsafe fn positionLimitCounterId1(
                    &mut self,
                    value: ::std::os::raw::c_int,
                ) -> *mut root::aeron::command::PublicationBuffersReadyFlyweight {
                    PublicationBuffersReadyFlyweight_positionLimitCounterId1(self, value)
                }
                #[inline]
                pub unsafe fn channelStatusIndicatorId(&self) -> ::std::os::raw::c_int {
                    PublicationBuffersReadyFlyweight_channelStatusIndicatorId(self)
                }
                #[inline]
                pub unsafe fn channelStatusIndicatorId1(
                    &mut self,
                    value: ::std::os::raw::c_int,
                ) -> *mut root::aeron::command::PublicationBuffersReadyFlyweight {
                    PublicationBuffersReadyFlyweight_channelStatusIndicatorId1(self, value)
                }
                #[inline]
                pub unsafe fn logFileName(&self) -> root::std::string {
                    PublicationBuffersReadyFlyweight_logFileName(self)
                }
                #[inline]
                pub unsafe fn logFileName1(
                    &mut self,
                    value: *const root::std::string,
                ) -> *mut root::aeron::command::PublicationBuffersReadyFlyweight {
                    PublicationBuffersReadyFlyweight_logFileName1(self, value)
                }
                #[inline]
                pub unsafe fn length(&self) -> root::aeron::util::index_t {
                    PublicationBuffersReadyFlyweight_length(self)
                }
                #[inline]
                pub unsafe fn new(
                    buffer: *mut root::aeron::concurrent::AtomicBuffer,
                    offset: root::aeron::util::index_t,
                ) -> Self {
                    let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                    PublicationBuffersReadyFlyweight_PublicationBuffersReadyFlyweight(
                        __bindgen_tmp.as_mut_ptr(),
                        buffer,
                        offset,
                    );
                    __bindgen_tmp.assume_init()
                }
            }
            #[repr(C)]
            #[derive(Copy, Clone)]
            pub struct PublicationMessageDefn {
                pub correlatedMessage: root::aeron::command::CorrelatedMessageDefn,
                pub streamId: ::std::os::raw::c_int,
                pub channelLength: ::std::os::raw::c_int,
                pub channelData: [::std::os::raw::c_schar; 1usize],
            }
            #[test]
            fn bindgen_test_layout_PublicationMessageDefn() {
                const UNINIT: ::std::mem::MaybeUninit<PublicationMessageDefn> =
                    ::std::mem::MaybeUninit::uninit();
                let ptr = UNINIT.as_ptr();
                assert_eq!(
                    ::std::mem::size_of::<PublicationMessageDefn>(),
                    28usize,
                    concat!("Size of: ", stringify!(PublicationMessageDefn))
                );
                assert_eq!(
                    ::std::mem::align_of::<PublicationMessageDefn>(),
                    4usize,
                    concat!("Alignment of ", stringify!(PublicationMessageDefn))
                );
                assert_eq!(
                    unsafe {
                        ::std::ptr::addr_of!((*ptr).correlatedMessage) as usize - ptr as usize
                    },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(PublicationMessageDefn),
                        "::",
                        stringify!(correlatedMessage)
                    )
                );
                assert_eq!(
                    unsafe { ::std::ptr::addr_of!((*ptr).streamId) as usize - ptr as usize },
                    16usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(PublicationMessageDefn),
                        "::",
                        stringify!(streamId)
                    )
                );
                assert_eq!(
                    unsafe { ::std::ptr::addr_of!((*ptr).channelLength) as usize - ptr as usize },
                    20usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(PublicationMessageDefn),
                        "::",
                        stringify!(channelLength)
                    )
                );
                assert_eq!(
                    unsafe { ::std::ptr::addr_of!((*ptr).channelData) as usize - ptr as usize },
                    24usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(PublicationMessageDefn),
                        "::",
                        stringify!(channelData)
                    )
                );
            }
            #[repr(C)]
            #[derive(Copy, Clone)]
            pub struct PublicationMessageFlyweight {
                pub _base: root::aeron::command::CorrelatedMessageFlyweight,
                pub m_struct: *mut root::aeron::command::PublicationMessageDefn,
            }
            #[test]
            fn bindgen_test_layout_PublicationMessageFlyweight() {
                const UNINIT: ::std::mem::MaybeUninit<PublicationMessageFlyweight> =
                    ::std::mem::MaybeUninit::uninit();
                let ptr = UNINIT.as_ptr();
                assert_eq!(
                    ::std::mem::size_of::<PublicationMessageFlyweight>(),
                    40usize,
                    concat!("Size of: ", stringify!(PublicationMessageFlyweight))
                );
                assert_eq!(
                    ::std::mem::align_of::<PublicationMessageFlyweight>(),
                    8usize,
                    concat!("Alignment of ", stringify!(PublicationMessageFlyweight))
                );
                assert_eq!(
                    unsafe { ::std::ptr::addr_of!((*ptr).m_struct) as usize - ptr as usize },
                    32usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(PublicationMessageFlyweight),
                        "::",
                        stringify!(m_struct)
                    )
                );
            }
            extern "C" {
                #[link_name = "\u{1}_ZNK5aeron7command27PublicationMessageFlyweight8streamIdEv"]
                pub fn PublicationMessageFlyweight_streamId(
                    this: *const root::aeron::command::PublicationMessageFlyweight,
                ) -> ::std::os::raw::c_int;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN5aeron7command27PublicationMessageFlyweight8streamIdEi"]
                pub fn PublicationMessageFlyweight_streamId1(
                    this: *mut root::aeron::command::PublicationMessageFlyweight,
                    value: ::std::os::raw::c_int,
                ) -> *mut root::aeron::command::PublicationMessageFlyweight;
            }
            extern "C" {
                #[link_name = "\u{1}_ZNK5aeron7command27PublicationMessageFlyweight7channelB5cxx11Ev"]
                pub fn PublicationMessageFlyweight_channel(
                    this: *const root::aeron::command::PublicationMessageFlyweight,
                ) -> root::std::string;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN5aeron7command27PublicationMessageFlyweight7channelERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
                pub fn PublicationMessageFlyweight_channel1(
                    this: *mut root::aeron::command::PublicationMessageFlyweight,
                    value: *const root::std::string,
                ) -> *mut root::aeron::command::PublicationMessageFlyweight;
            }
            extern "C" {
                #[link_name = "\u{1}_ZNK5aeron7command27PublicationMessageFlyweight6lengthEv"]
                pub fn PublicationMessageFlyweight_length(
                    this: *const root::aeron::command::PublicationMessageFlyweight,
                ) -> root::aeron::util::index_t;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN5aeron7command27PublicationMessageFlyweightC1ERNS_10concurrent12AtomicBufferEi"]
                pub fn PublicationMessageFlyweight_PublicationMessageFlyweight(
                    this: *mut root::aeron::command::PublicationMessageFlyweight,
                    buffer: *mut root::aeron::concurrent::AtomicBuffer,
                    offset: root::aeron::util::index_t,
                );
            }
            impl PublicationMessageFlyweight {
                #[inline]
                pub unsafe fn streamId(&self) -> ::std::os::raw::c_int {
                    PublicationMessageFlyweight_streamId(self)
                }
                #[inline]
                pub unsafe fn streamId1(
                    &mut self,
                    value: ::std::os::raw::c_int,
                ) -> *mut root::aeron::command::PublicationMessageFlyweight {
                    PublicationMessageFlyweight_streamId1(self, value)
                }
                #[inline]
                pub unsafe fn channel(&self) -> root::std::string {
                    PublicationMessageFlyweight_channel(self)
                }
                #[inline]
                pub unsafe fn channel1(
                    &mut self,
                    value: *const root::std::string,
                ) -> *mut root::aeron::command::PublicationMessageFlyweight {
                    PublicationMessageFlyweight_channel1(self, value)
                }
                #[inline]
                pub unsafe fn length(&self) -> root::aeron::util::index_t {
                    PublicationMessageFlyweight_length(self)
                }
                #[inline]
                pub unsafe fn new(
                    buffer: *mut root::aeron::concurrent::AtomicBuffer,
                    offset: root::aeron::util::index_t,
                ) -> Self {
                    let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                    PublicationMessageFlyweight_PublicationMessageFlyweight(
                        __bindgen_tmp.as_mut_ptr(),
                        buffer,
                        offset,
                    );
                    __bindgen_tmp.assume_init()
                }
            }
            #[repr(C, packed(4))]
            #[derive(Copy, Clone)]
            pub struct RemoveMessageDefn {
                pub correlatedMessage: root::aeron::command::CorrelatedMessageDefn,
                pub registrationId: ::std::os::raw::c_long,
            }
            #[test]
            fn bindgen_test_layout_RemoveMessageDefn() {
                const UNINIT: ::std::mem::MaybeUninit<RemoveMessageDefn> =
                    ::std::mem::MaybeUninit::uninit();
                let ptr = UNINIT.as_ptr();
                assert_eq!(
                    ::std::mem::size_of::<RemoveMessageDefn>(),
                    24usize,
                    concat!("Size of: ", stringify!(RemoveMessageDefn))
                );
                assert_eq!(
                    ::std::mem::align_of::<RemoveMessageDefn>(),
                    4usize,
                    concat!("Alignment of ", stringify!(RemoveMessageDefn))
                );
                assert_eq!(
                    unsafe {
                        ::std::ptr::addr_of!((*ptr).correlatedMessage) as usize - ptr as usize
                    },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(RemoveMessageDefn),
                        "::",
                        stringify!(correlatedMessage)
                    )
                );
                assert_eq!(
                    unsafe { ::std::ptr::addr_of!((*ptr).registrationId) as usize - ptr as usize },
                    16usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(RemoveMessageDefn),
                        "::",
                        stringify!(registrationId)
                    )
                );
            }
            #[repr(C)]
            #[derive(Copy, Clone)]
            pub struct RemoveMessageFlyweight {
                pub _base: root::aeron::command::CorrelatedMessageFlyweight,
                pub m_struct: *mut root::aeron::command::RemoveMessageDefn,
            }
            #[test]
            fn bindgen_test_layout_RemoveMessageFlyweight() {
                const UNINIT: ::std::mem::MaybeUninit<RemoveMessageFlyweight> =
                    ::std::mem::MaybeUninit::uninit();
                let ptr = UNINIT.as_ptr();
                assert_eq!(
                    ::std::mem::size_of::<RemoveMessageFlyweight>(),
                    40usize,
                    concat!("Size of: ", stringify!(RemoveMessageFlyweight))
                );
                assert_eq!(
                    ::std::mem::align_of::<RemoveMessageFlyweight>(),
                    8usize,
                    concat!("Alignment of ", stringify!(RemoveMessageFlyweight))
                );
                assert_eq!(
                    unsafe { ::std::ptr::addr_of!((*ptr).m_struct) as usize - ptr as usize },
                    32usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(RemoveMessageFlyweight),
                        "::",
                        stringify!(m_struct)
                    )
                );
            }
            extern "C" {
                #[link_name = "\u{1}_ZNK5aeron7command22RemoveMessageFlyweight14registrationIdEv"]
                pub fn RemoveMessageFlyweight_registrationId(
                    this: *const root::aeron::command::RemoveMessageFlyweight,
                ) -> ::std::os::raw::c_long;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN5aeron7command22RemoveMessageFlyweight14registrationIdEl"]
                pub fn RemoveMessageFlyweight_registrationId1(
                    this: *mut root::aeron::command::RemoveMessageFlyweight,
                    value: ::std::os::raw::c_long,
                ) -> *mut root::aeron::command::CorrelatedMessageFlyweight;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN5aeron7command22RemoveMessageFlyweight6lengthEv"]
                pub fn RemoveMessageFlyweight_length() -> root::aeron::util::index_t;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN5aeron7command22RemoveMessageFlyweightC1ERNS_10concurrent12AtomicBufferEi"]
                pub fn RemoveMessageFlyweight_RemoveMessageFlyweight(
                    this: *mut root::aeron::command::RemoveMessageFlyweight,
                    buffer: *mut root::aeron::concurrent::AtomicBuffer,
                    offset: root::aeron::util::index_t,
                );
            }
            impl RemoveMessageFlyweight {
                #[inline]
                pub unsafe fn registrationId(&self) -> ::std::os::raw::c_long {
                    RemoveMessageFlyweight_registrationId(self)
                }
                #[inline]
                pub unsafe fn registrationId1(
                    &mut self,
                    value: ::std::os::raw::c_long,
                ) -> *mut root::aeron::command::CorrelatedMessageFlyweight {
                    RemoveMessageFlyweight_registrationId1(self, value)
                }
                #[inline]
                pub unsafe fn length() -> root::aeron::util::index_t {
                    RemoveMessageFlyweight_length()
                }
                #[inline]
                pub unsafe fn new(
                    buffer: *mut root::aeron::concurrent::AtomicBuffer,
                    offset: root::aeron::util::index_t,
                ) -> Self {
                    let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                    RemoveMessageFlyweight_RemoveMessageFlyweight(
                        __bindgen_tmp.as_mut_ptr(),
                        buffer,
                        offset,
                    );
                    __bindgen_tmp.assume_init()
                }
            }
            #[repr(C, packed(4))]
            #[derive(Copy, Clone)]
            pub struct SubscriptionMessageDefn {
                pub correlatedMessage: root::aeron::command::CorrelatedMessageDefn,
                pub registrationCorrelationId: ::std::os::raw::c_long,
                pub streamId: ::std::os::raw::c_int,
                pub channelLength: ::std::os::raw::c_int,
                pub channelData: [::std::os::raw::c_schar; 1usize],
            }
            #[test]
            fn bindgen_test_layout_SubscriptionMessageDefn() {
                const UNINIT: ::std::mem::MaybeUninit<SubscriptionMessageDefn> =
                    ::std::mem::MaybeUninit::uninit();
                let ptr = UNINIT.as_ptr();
                assert_eq!(
                    ::std::mem::size_of::<SubscriptionMessageDefn>(),
                    36usize,
                    concat!("Size of: ", stringify!(SubscriptionMessageDefn))
                );
                assert_eq!(
                    ::std::mem::align_of::<SubscriptionMessageDefn>(),
                    4usize,
                    concat!("Alignment of ", stringify!(SubscriptionMessageDefn))
                );
                assert_eq!(
                    unsafe {
                        ::std::ptr::addr_of!((*ptr).correlatedMessage) as usize - ptr as usize
                    },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(SubscriptionMessageDefn),
                        "::",
                        stringify!(correlatedMessage)
                    )
                );
                assert_eq!(
                    unsafe {
                        ::std::ptr::addr_of!((*ptr).registrationCorrelationId) as usize
                            - ptr as usize
                    },
                    16usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(SubscriptionMessageDefn),
                        "::",
                        stringify!(registrationCorrelationId)
                    )
                );
                assert_eq!(
                    unsafe { ::std::ptr::addr_of!((*ptr).streamId) as usize - ptr as usize },
                    24usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(SubscriptionMessageDefn),
                        "::",
                        stringify!(streamId)
                    )
                );
                assert_eq!(
                    unsafe { ::std::ptr::addr_of!((*ptr).channelLength) as usize - ptr as usize },
                    28usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(SubscriptionMessageDefn),
                        "::",
                        stringify!(channelLength)
                    )
                );
                assert_eq!(
                    unsafe { ::std::ptr::addr_of!((*ptr).channelData) as usize - ptr as usize },
                    32usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(SubscriptionMessageDefn),
                        "::",
                        stringify!(channelData)
                    )
                );
            }
            #[repr(C)]
            #[derive(Copy, Clone)]
            pub struct SubscriptionMessageFlyweight {
                pub _base: root::aeron::command::CorrelatedMessageFlyweight,
                pub m_struct: *mut root::aeron::command::SubscriptionMessageDefn,
            }
            #[test]
            fn bindgen_test_layout_SubscriptionMessageFlyweight() {
                const UNINIT: ::std::mem::MaybeUninit<SubscriptionMessageFlyweight> =
                    ::std::mem::MaybeUninit::uninit();
                let ptr = UNINIT.as_ptr();
                assert_eq!(
                    ::std::mem::size_of::<SubscriptionMessageFlyweight>(),
                    40usize,
                    concat!("Size of: ", stringify!(SubscriptionMessageFlyweight))
                );
                assert_eq!(
                    ::std::mem::align_of::<SubscriptionMessageFlyweight>(),
                    8usize,
                    concat!("Alignment of ", stringify!(SubscriptionMessageFlyweight))
                );
                assert_eq!(
                    unsafe { ::std::ptr::addr_of!((*ptr).m_struct) as usize - ptr as usize },
                    32usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(SubscriptionMessageFlyweight),
                        "::",
                        stringify!(m_struct)
                    )
                );
            }
            extern "C" {
                #[link_name = "\u{1}_ZNK5aeron7command28SubscriptionMessageFlyweight25registrationCorrelationIdEv"]
                pub fn SubscriptionMessageFlyweight_registrationCorrelationId(
                    this: *const root::aeron::command::SubscriptionMessageFlyweight,
                ) -> ::std::os::raw::c_long;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN5aeron7command28SubscriptionMessageFlyweight25registrationCorrelationIdEl"]
                pub fn SubscriptionMessageFlyweight_registrationCorrelationId1(
                    this: *mut root::aeron::command::SubscriptionMessageFlyweight,
                    value: ::std::os::raw::c_long,
                ) -> *mut root::aeron::command::SubscriptionMessageFlyweight;
            }
            extern "C" {
                #[link_name = "\u{1}_ZNK5aeron7command28SubscriptionMessageFlyweight8streamIdEv"]
                pub fn SubscriptionMessageFlyweight_streamId(
                    this: *const root::aeron::command::SubscriptionMessageFlyweight,
                ) -> ::std::os::raw::c_int;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN5aeron7command28SubscriptionMessageFlyweight8streamIdEi"]
                pub fn SubscriptionMessageFlyweight_streamId1(
                    this: *mut root::aeron::command::SubscriptionMessageFlyweight,
                    value: ::std::os::raw::c_int,
                ) -> *mut root::aeron::command::SubscriptionMessageFlyweight;
            }
            extern "C" {
                #[link_name = "\u{1}_ZNK5aeron7command28SubscriptionMessageFlyweight7channelB5cxx11Ev"]
                pub fn SubscriptionMessageFlyweight_channel(
                    this: *const root::aeron::command::SubscriptionMessageFlyweight,
                ) -> root::std::string;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN5aeron7command28SubscriptionMessageFlyweight7channelERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
                pub fn SubscriptionMessageFlyweight_channel1(
                    this: *mut root::aeron::command::SubscriptionMessageFlyweight,
                    value: *const root::std::string,
                ) -> *mut root::aeron::command::SubscriptionMessageFlyweight;
            }
            extern "C" {
                #[link_name = "\u{1}_ZNK5aeron7command28SubscriptionMessageFlyweight6lengthEv"]
                pub fn SubscriptionMessageFlyweight_length(
                    this: *const root::aeron::command::SubscriptionMessageFlyweight,
                ) -> root::aeron::util::index_t;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN5aeron7command28SubscriptionMessageFlyweightC1ERNS_10concurrent12AtomicBufferEi"]
                pub fn SubscriptionMessageFlyweight_SubscriptionMessageFlyweight(
                    this: *mut root::aeron::command::SubscriptionMessageFlyweight,
                    buffer: *mut root::aeron::concurrent::AtomicBuffer,
                    offset: root::aeron::util::index_t,
                );
            }
            impl SubscriptionMessageFlyweight {
                #[inline]
                pub unsafe fn registrationCorrelationId(&self) -> ::std::os::raw::c_long {
                    SubscriptionMessageFlyweight_registrationCorrelationId(self)
                }
                #[inline]
                pub unsafe fn registrationCorrelationId1(
                    &mut self,
                    value: ::std::os::raw::c_long,
                ) -> *mut root::aeron::command::SubscriptionMessageFlyweight {
                    SubscriptionMessageFlyweight_registrationCorrelationId1(self, value)
                }
                #[inline]
                pub unsafe fn streamId(&self) -> ::std::os::raw::c_int {
                    SubscriptionMessageFlyweight_streamId(self)
                }
                #[inline]
                pub unsafe fn streamId1(
                    &mut self,
                    value: ::std::os::raw::c_int,
                ) -> *mut root::aeron::command::SubscriptionMessageFlyweight {
                    SubscriptionMessageFlyweight_streamId1(self, value)
                }
                #[inline]
                pub unsafe fn channel(&self) -> root::std::string {
                    SubscriptionMessageFlyweight_channel(self)
                }
                #[inline]
                pub unsafe fn channel1(
                    &mut self,
                    value: *const root::std::string,
                ) -> *mut root::aeron::command::SubscriptionMessageFlyweight {
                    SubscriptionMessageFlyweight_channel1(self, value)
                }
                #[inline]
                pub unsafe fn length(&self) -> root::aeron::util::index_t {
                    SubscriptionMessageFlyweight_length(self)
                }
                #[inline]
                pub unsafe fn new(
                    buffer: *mut root::aeron::concurrent::AtomicBuffer,
                    offset: root::aeron::util::index_t,
                ) -> Self {
                    let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                    SubscriptionMessageFlyweight_SubscriptionMessageFlyweight(
                        __bindgen_tmp.as_mut_ptr(),
                        buffer,
                        offset,
                    );
                    __bindgen_tmp.assume_init()
                }
            }
            #[repr(C, packed(4))]
            #[derive(Copy, Clone)]
            pub struct DestinationMessageDefn {
                pub correlatedMessage: root::aeron::command::CorrelatedMessageDefn,
                pub registrationId: ::std::os::raw::c_long,
                pub channelLength: ::std::os::raw::c_int,
                pub channelData: [::std::os::raw::c_schar; 1usize],
            }
            #[test]
            fn bindgen_test_layout_DestinationMessageDefn() {
                const UNINIT: ::std::mem::MaybeUninit<DestinationMessageDefn> =
                    ::std::mem::MaybeUninit::uninit();
                let ptr = UNINIT.as_ptr();
                assert_eq!(
                    ::std::mem::size_of::<DestinationMessageDefn>(),
                    32usize,
                    concat!("Size of: ", stringify!(DestinationMessageDefn))
                );
                assert_eq!(
                    ::std::mem::align_of::<DestinationMessageDefn>(),
                    4usize,
                    concat!("Alignment of ", stringify!(DestinationMessageDefn))
                );
                assert_eq!(
                    unsafe {
                        ::std::ptr::addr_of!((*ptr).correlatedMessage) as usize - ptr as usize
                    },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(DestinationMessageDefn),
                        "::",
                        stringify!(correlatedMessage)
                    )
                );
                assert_eq!(
                    unsafe { ::std::ptr::addr_of!((*ptr).registrationId) as usize - ptr as usize },
                    16usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(DestinationMessageDefn),
                        "::",
                        stringify!(registrationId)
                    )
                );
                assert_eq!(
                    unsafe { ::std::ptr::addr_of!((*ptr).channelLength) as usize - ptr as usize },
                    24usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(DestinationMessageDefn),
                        "::",
                        stringify!(channelLength)
                    )
                );
                assert_eq!(
                    unsafe { ::std::ptr::addr_of!((*ptr).channelData) as usize - ptr as usize },
                    28usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(DestinationMessageDefn),
                        "::",
                        stringify!(channelData)
                    )
                );
            }
            #[repr(C)]
            #[derive(Copy, Clone)]
            pub struct DestinationMessageFlyweight {
                pub _base: root::aeron::command::CorrelatedMessageFlyweight,
                pub m_struct: *mut root::aeron::command::DestinationMessageDefn,
            }
            #[test]
            fn bindgen_test_layout_DestinationMessageFlyweight() {
                const UNINIT: ::std::mem::MaybeUninit<DestinationMessageFlyweight> =
                    ::std::mem::MaybeUninit::uninit();
                let ptr = UNINIT.as_ptr();
                assert_eq!(
                    ::std::mem::size_of::<DestinationMessageFlyweight>(),
                    40usize,
                    concat!("Size of: ", stringify!(DestinationMessageFlyweight))
                );
                assert_eq!(
                    ::std::mem::align_of::<DestinationMessageFlyweight>(),
                    8usize,
                    concat!("Alignment of ", stringify!(DestinationMessageFlyweight))
                );
                assert_eq!(
                    unsafe { ::std::ptr::addr_of!((*ptr).m_struct) as usize - ptr as usize },
                    32usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(DestinationMessageFlyweight),
                        "::",
                        stringify!(m_struct)
                    )
                );
            }
            extern "C" {
                #[link_name = "\u{1}_ZNK5aeron7command27DestinationMessageFlyweight14registrationIdEv"]
                pub fn DestinationMessageFlyweight_registrationId(
                    this: *const root::aeron::command::DestinationMessageFlyweight,
                ) -> ::std::os::raw::c_long;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN5aeron7command27DestinationMessageFlyweight14registrationIdEl"]
                pub fn DestinationMessageFlyweight_registrationId1(
                    this: *mut root::aeron::command::DestinationMessageFlyweight,
                    value: ::std::os::raw::c_long,
                ) -> *mut root::aeron::command::DestinationMessageFlyweight;
            }
            extern "C" {
                #[link_name = "\u{1}_ZNK5aeron7command27DestinationMessageFlyweight7channelB5cxx11Ev"]
                pub fn DestinationMessageFlyweight_channel(
                    this: *const root::aeron::command::DestinationMessageFlyweight,
                ) -> root::std::string;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN5aeron7command27DestinationMessageFlyweight7channelERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
                pub fn DestinationMessageFlyweight_channel1(
                    this: *mut root::aeron::command::DestinationMessageFlyweight,
                    value: *const root::std::string,
                ) -> *mut root::aeron::command::DestinationMessageFlyweight;
            }
            extern "C" {
                #[link_name = "\u{1}_ZNK5aeron7command27DestinationMessageFlyweight6lengthEv"]
                pub fn DestinationMessageFlyweight_length(
                    this: *const root::aeron::command::DestinationMessageFlyweight,
                ) -> root::aeron::util::index_t;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN5aeron7command27DestinationMessageFlyweightC1ERNS_10concurrent12AtomicBufferEi"]
                pub fn DestinationMessageFlyweight_DestinationMessageFlyweight(
                    this: *mut root::aeron::command::DestinationMessageFlyweight,
                    buffer: *mut root::aeron::concurrent::AtomicBuffer,
                    offset: root::aeron::util::index_t,
                );
            }
            impl DestinationMessageFlyweight {
                #[inline]
                pub unsafe fn registrationId(&self) -> ::std::os::raw::c_long {
                    DestinationMessageFlyweight_registrationId(self)
                }
                #[inline]
                pub unsafe fn registrationId1(
                    &mut self,
                    value: ::std::os::raw::c_long,
                ) -> *mut root::aeron::command::DestinationMessageFlyweight {
                    DestinationMessageFlyweight_registrationId1(self, value)
                }
                #[inline]
                pub unsafe fn channel(&self) -> root::std::string {
                    DestinationMessageFlyweight_channel(self)
                }
                #[inline]
                pub unsafe fn channel1(
                    &mut self,
                    value: *const root::std::string,
                ) -> *mut root::aeron::command::DestinationMessageFlyweight {
                    DestinationMessageFlyweight_channel1(self, value)
                }
                #[inline]
                pub unsafe fn length(&self) -> root::aeron::util::index_t {
                    DestinationMessageFlyweight_length(self)
                }
                #[inline]
                pub unsafe fn new(
                    buffer: *mut root::aeron::concurrent::AtomicBuffer,
                    offset: root::aeron::util::index_t,
                ) -> Self {
                    let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                    DestinationMessageFlyweight_DestinationMessageFlyweight(
                        __bindgen_tmp.as_mut_ptr(),
                        buffer,
                        offset,
                    );
                    __bindgen_tmp.assume_init()
                }
            }
            #[repr(C)]
            #[derive(Copy, Clone)]
            pub struct CounterMessageDefn {
                pub correlatedMessage: root::aeron::command::CorrelatedMessageDefn,
                pub typeId: ::std::os::raw::c_int,
            }
            #[test]
            fn bindgen_test_layout_CounterMessageDefn() {
                const UNINIT: ::std::mem::MaybeUninit<CounterMessageDefn> =
                    ::std::mem::MaybeUninit::uninit();
                let ptr = UNINIT.as_ptr();
                assert_eq!(
                    ::std::mem::size_of::<CounterMessageDefn>(),
                    20usize,
                    concat!("Size of: ", stringify!(CounterMessageDefn))
                );
                assert_eq!(
                    ::std::mem::align_of::<CounterMessageDefn>(),
                    4usize,
                    concat!("Alignment of ", stringify!(CounterMessageDefn))
                );
                assert_eq!(
                    unsafe {
                        ::std::ptr::addr_of!((*ptr).correlatedMessage) as usize - ptr as usize
                    },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(CounterMessageDefn),
                        "::",
                        stringify!(correlatedMessage)
                    )
                );
                assert_eq!(
                    unsafe { ::std::ptr::addr_of!((*ptr).typeId) as usize - ptr as usize },
                    16usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(CounterMessageDefn),
                        "::",
                        stringify!(typeId)
                    )
                );
            }
            #[repr(C)]
            #[derive(Copy, Clone)]
            pub struct CounterMessageFlyweight {
                pub _base: root::aeron::command::CorrelatedMessageFlyweight,
                pub m_struct: *mut root::aeron::command::CounterMessageDefn,
            }
            #[test]
            fn bindgen_test_layout_CounterMessageFlyweight() {
                const UNINIT: ::std::mem::MaybeUninit<CounterMessageFlyweight> =
                    ::std::mem::MaybeUninit::uninit();
                let ptr = UNINIT.as_ptr();
                assert_eq!(
                    ::std::mem::size_of::<CounterMessageFlyweight>(),
                    40usize,
                    concat!("Size of: ", stringify!(CounterMessageFlyweight))
                );
                assert_eq!(
                    ::std::mem::align_of::<CounterMessageFlyweight>(),
                    8usize,
                    concat!("Alignment of ", stringify!(CounterMessageFlyweight))
                );
                assert_eq!(
                    unsafe { ::std::ptr::addr_of!((*ptr).m_struct) as usize - ptr as usize },
                    32usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(CounterMessageFlyweight),
                        "::",
                        stringify!(m_struct)
                    )
                );
            }
            extern "C" {
                #[link_name = "\u{1}_ZNK5aeron7command23CounterMessageFlyweight6typeIdEv"]
                pub fn CounterMessageFlyweight_typeId(
                    this: *const root::aeron::command::CounterMessageFlyweight,
                ) -> ::std::os::raw::c_int;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN5aeron7command23CounterMessageFlyweight6typeIdEi"]
                pub fn CounterMessageFlyweight_typeId1(
                    this: *mut root::aeron::command::CounterMessageFlyweight,
                    value: ::std::os::raw::c_int,
                ) -> *mut root::aeron::command::CounterMessageFlyweight;
            }
            extern "C" {
                #[link_name = "\u{1}_ZNK5aeron7command23CounterMessageFlyweight9keyBufferEv"]
                pub fn CounterMessageFlyweight_keyBuffer(
                    this: *const root::aeron::command::CounterMessageFlyweight,
                ) -> *mut ::std::os::raw::c_uchar;
            }
            extern "C" {
                #[link_name = "\u{1}_ZNK5aeron7command23CounterMessageFlyweight9keyLengthEv"]
                pub fn CounterMessageFlyweight_keyLength(
                    this: *const root::aeron::command::CounterMessageFlyweight,
                ) -> ::std::os::raw::c_int;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN5aeron7command23CounterMessageFlyweight9keyBufferEPKhm"]
                pub fn CounterMessageFlyweight_keyBuffer1(
                    this: *mut root::aeron::command::CounterMessageFlyweight,
                    key: *mut ::std::os::raw::c_uchar,
                    keyLength: usize,
                ) -> *mut root::aeron::command::CounterMessageFlyweight;
            }
            extern "C" {
                #[link_name = "\u{1}_ZNK5aeron7command23CounterMessageFlyweight11labelLengthEv"]
                pub fn CounterMessageFlyweight_labelLength(
                    this: *const root::aeron::command::CounterMessageFlyweight,
                ) -> ::std::os::raw::c_int;
            }
            extern "C" {
                #[link_name = "\u{1}_ZNK5aeron7command23CounterMessageFlyweight5labelB5cxx11Ev"]
                pub fn CounterMessageFlyweight_label(
                    this: *const root::aeron::command::CounterMessageFlyweight,
                ) -> root::std::string;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN5aeron7command23CounterMessageFlyweight5labelERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
                pub fn CounterMessageFlyweight_label1(
                    this: *mut root::aeron::command::CounterMessageFlyweight,
                    label: *const root::std::string,
                ) -> *mut root::aeron::command::CounterMessageFlyweight;
            }
            extern "C" {
                #[link_name = "\u{1}_ZNK5aeron7command23CounterMessageFlyweight6lengthEv"]
                pub fn CounterMessageFlyweight_length(
                    this: *const root::aeron::command::CounterMessageFlyweight,
                ) -> root::aeron::util::index_t;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN5aeron7command23CounterMessageFlyweightC1ERNS_10concurrent12AtomicBufferEi"]
                pub fn CounterMessageFlyweight_CounterMessageFlyweight(
                    this: *mut root::aeron::command::CounterMessageFlyweight,
                    buffer: *mut root::aeron::concurrent::AtomicBuffer,
                    offset: root::aeron::util::index_t,
                );
            }
            impl CounterMessageFlyweight {
                #[inline]
                pub unsafe fn typeId(&self) -> ::std::os::raw::c_int {
                    CounterMessageFlyweight_typeId(self)
                }
                #[inline]
                pub unsafe fn typeId1(
                    &mut self,
                    value: ::std::os::raw::c_int,
                ) -> *mut root::aeron::command::CounterMessageFlyweight {
                    CounterMessageFlyweight_typeId1(self, value)
                }
                #[inline]
                pub unsafe fn keyBuffer(&self) -> *mut ::std::os::raw::c_uchar {
                    CounterMessageFlyweight_keyBuffer(self)
                }
                #[inline]
                pub unsafe fn keyLength(&self) -> ::std::os::raw::c_int {
                    CounterMessageFlyweight_keyLength(self)
                }
                #[inline]
                pub unsafe fn keyBuffer1(
                    &mut self,
                    key: *mut ::std::os::raw::c_uchar,
                    keyLength: usize,
                ) -> *mut root::aeron::command::CounterMessageFlyweight {
                    CounterMessageFlyweight_keyBuffer1(self, key, keyLength)
                }
                #[inline]
                pub unsafe fn labelLength(&self) -> ::std::os::raw::c_int {
                    CounterMessageFlyweight_labelLength(self)
                }
                #[inline]
                pub unsafe fn label(&self) -> root::std::string {
                    CounterMessageFlyweight_label(self)
                }
                #[inline]
                pub unsafe fn label1(
                    &mut self,
                    label: *const root::std::string,
                ) -> *mut root::aeron::command::CounterMessageFlyweight {
                    CounterMessageFlyweight_label1(self, label)
                }
                #[inline]
                pub unsafe fn length(&self) -> root::aeron::util::index_t {
                    CounterMessageFlyweight_length(self)
                }
                #[inline]
                pub unsafe fn new(
                    buffer: *mut root::aeron::concurrent::AtomicBuffer,
                    offset: root::aeron::util::index_t,
                ) -> Self {
                    let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                    CounterMessageFlyweight_CounterMessageFlyweight(
                        __bindgen_tmp.as_mut_ptr(),
                        buffer,
                        offset,
                    );
                    __bindgen_tmp.assume_init()
                }
            }
            #[repr(C)]
            #[derive(Copy, Clone)]
            pub struct TerminateDriverDefn {
                pub correlatedMessage: root::aeron::command::CorrelatedMessageDefn,
                pub tokenLength: ::std::os::raw::c_int,
            }
            #[test]
            fn bindgen_test_layout_TerminateDriverDefn() {
                const UNINIT: ::std::mem::MaybeUninit<TerminateDriverDefn> =
                    ::std::mem::MaybeUninit::uninit();
                let ptr = UNINIT.as_ptr();
                assert_eq!(
                    ::std::mem::size_of::<TerminateDriverDefn>(),
                    20usize,
                    concat!("Size of: ", stringify!(TerminateDriverDefn))
                );
                assert_eq!(
                    ::std::mem::align_of::<TerminateDriverDefn>(),
                    4usize,
                    concat!("Alignment of ", stringify!(TerminateDriverDefn))
                );
                assert_eq!(
                    unsafe {
                        ::std::ptr::addr_of!((*ptr).correlatedMessage) as usize - ptr as usize
                    },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(TerminateDriverDefn),
                        "::",
                        stringify!(correlatedMessage)
                    )
                );
                assert_eq!(
                    unsafe { ::std::ptr::addr_of!((*ptr).tokenLength) as usize - ptr as usize },
                    16usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(TerminateDriverDefn),
                        "::",
                        stringify!(tokenLength)
                    )
                );
            }
            #[repr(C)]
            #[derive(Copy, Clone)]
            pub struct TerminateDriverFlyweight {
                pub _base: root::aeron::command::CorrelatedMessageFlyweight,
                pub m_struct: *mut root::aeron::command::TerminateDriverDefn,
            }
            #[test]
            fn bindgen_test_layout_TerminateDriverFlyweight() {
                const UNINIT: ::std::mem::MaybeUninit<TerminateDriverFlyweight> =
                    ::std::mem::MaybeUninit::uninit();
                let ptr = UNINIT.as_ptr();
                assert_eq!(
                    ::std::mem::size_of::<TerminateDriverFlyweight>(),
                    40usize,
                    concat!("Size of: ", stringify!(TerminateDriverFlyweight))
                );
                assert_eq!(
                    ::std::mem::align_of::<TerminateDriverFlyweight>(),
                    8usize,
                    concat!("Alignment of ", stringify!(TerminateDriverFlyweight))
                );
                assert_eq!(
                    unsafe { ::std::ptr::addr_of!((*ptr).m_struct) as usize - ptr as usize },
                    32usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(TerminateDriverFlyweight),
                        "::",
                        stringify!(m_struct)
                    )
                );
            }
            extern "C" {
                #[link_name = "\u{1}_ZNK5aeron7command24TerminateDriverFlyweight11tokenBufferEv"]
                pub fn TerminateDriverFlyweight_tokenBuffer(
                    this: *const root::aeron::command::TerminateDriverFlyweight,
                ) -> *mut ::std::os::raw::c_uchar;
            }
            extern "C" {
                #[link_name = "\u{1}_ZNK5aeron7command24TerminateDriverFlyweight11tokenLengthEv"]
                pub fn TerminateDriverFlyweight_tokenLength(
                    this: *const root::aeron::command::TerminateDriverFlyweight,
                ) -> ::std::os::raw::c_int;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN5aeron7command24TerminateDriverFlyweight11tokenBufferEPKhm"]
                pub fn TerminateDriverFlyweight_tokenBuffer1(
                    this: *mut root::aeron::command::TerminateDriverFlyweight,
                    tokenBuffer: *mut ::std::os::raw::c_uchar,
                    tokenLength: usize,
                ) -> *mut root::aeron::command::TerminateDriverFlyweight;
            }
            extern "C" {
                #[link_name = "\u{1}_ZNK5aeron7command24TerminateDriverFlyweight6lengthEv"]
                pub fn TerminateDriverFlyweight_length(
                    this: *const root::aeron::command::TerminateDriverFlyweight,
                ) -> root::aeron::util::index_t;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN5aeron7command24TerminateDriverFlyweightC1ERNS_10concurrent12AtomicBufferEi"]
                pub fn TerminateDriverFlyweight_TerminateDriverFlyweight(
                    this: *mut root::aeron::command::TerminateDriverFlyweight,
                    buffer: *mut root::aeron::concurrent::AtomicBuffer,
                    offset: root::aeron::util::index_t,
                );
            }
            impl TerminateDriverFlyweight {
                #[inline]
                pub unsafe fn tokenBuffer(&self) -> *mut ::std::os::raw::c_uchar {
                    TerminateDriverFlyweight_tokenBuffer(self)
                }
                #[inline]
                pub unsafe fn tokenLength(&self) -> ::std::os::raw::c_int {
                    TerminateDriverFlyweight_tokenLength(self)
                }
                #[inline]
                pub unsafe fn tokenBuffer1(
                    &mut self,
                    tokenBuffer: *mut ::std::os::raw::c_uchar,
                    tokenLength: usize,
                ) -> *mut root::aeron::command::TerminateDriverFlyweight {
                    TerminateDriverFlyweight_tokenBuffer1(self, tokenBuffer, tokenLength)
                }
                #[inline]
                pub unsafe fn length(&self) -> root::aeron::util::index_t {
                    TerminateDriverFlyweight_length(self)
                }
                #[inline]
                pub unsafe fn new(
                    buffer: *mut root::aeron::concurrent::AtomicBuffer,
                    offset: root::aeron::util::index_t,
                ) -> Self {
                    let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                    TerminateDriverFlyweight_TerminateDriverFlyweight(
                        __bindgen_tmp.as_mut_ptr(),
                        buffer,
                        offset,
                    );
                    __bindgen_tmp.assume_init()
                }
            }
            #[repr(C)]
            #[derive(Copy, Clone)]
            pub struct ControlProtocolEvents {
                pub _address: u8,
            }
            pub const ControlProtocolEvents_ADD_PUBLICATION: ::std::os::raw::c_int = 1;
            pub const ControlProtocolEvents_REMOVE_PUBLICATION: ::std::os::raw::c_int = 2;
            pub const ControlProtocolEvents_ADD_EXCLUSIVE_PUBLICATION: ::std::os::raw::c_int = 3;
            pub const ControlProtocolEvents_ADD_SUBSCRIPTION: ::std::os::raw::c_int = 4;
            pub const ControlProtocolEvents_REMOVE_SUBSCRIPTION: ::std::os::raw::c_int = 5;
            pub const ControlProtocolEvents_CLIENT_KEEPALIVE: ::std::os::raw::c_int = 6;
            pub const ControlProtocolEvents_ADD_DESTINATION: ::std::os::raw::c_int = 7;
            pub const ControlProtocolEvents_REMOVE_DESTINATION: ::std::os::raw::c_int = 8;
            pub const ControlProtocolEvents_ADD_COUNTER: ::std::os::raw::c_int = 9;
            pub const ControlProtocolEvents_REMOVE_COUNTER: ::std::os::raw::c_int = 10;
            pub const ControlProtocolEvents_CLIENT_CLOSE: ::std::os::raw::c_int = 11;
            pub const ControlProtocolEvents_ADD_RCV_DESTINATION: ::std::os::raw::c_int = 12;
            pub const ControlProtocolEvents_REMOVE_RCV_DESTINATION: ::std::os::raw::c_int = 13;
            pub const ControlProtocolEvents_TERMINATE_DRIVER: ::std::os::raw::c_int = 14;
            pub const ControlProtocolEvents_ON_ERROR: ::std::os::raw::c_int = 3841;
            pub const ControlProtocolEvents_ON_AVAILABLE_IMAGE: ::std::os::raw::c_int = 3842;
            pub const ControlProtocolEvents_ON_PUBLICATION_READY: ::std::os::raw::c_int = 3843;
            pub const ControlProtocolEvents_ON_OPERATION_SUCCESS: ::std::os::raw::c_int = 3844;
            pub const ControlProtocolEvents_ON_UNAVAILABLE_IMAGE: ::std::os::raw::c_int = 3845;
            pub const ControlProtocolEvents_ON_EXCLUSIVE_PUBLICATION_READY: ::std::os::raw::c_int =
                3846;
            pub const ControlProtocolEvents_ON_SUBSCRIPTION_READY: ::std::os::raw::c_int = 3847;
            pub const ControlProtocolEvents_ON_COUNTER_READY: ::std::os::raw::c_int = 3848;
            pub const ControlProtocolEvents_ON_UNAVAILABLE_COUNTER: ::std::os::raw::c_int = 3849;
            pub const ControlProtocolEvents_ON_CLIENT_TIMEOUT: ::std::os::raw::c_int = 3850;
            #[test]
            fn bindgen_test_layout_ControlProtocolEvents() {
                assert_eq!(
                    ::std::mem::size_of::<ControlProtocolEvents>(),
                    1usize,
                    concat!("Size of: ", stringify!(ControlProtocolEvents))
                );
                assert_eq!(
                    ::std::mem::align_of::<ControlProtocolEvents>(),
                    1usize,
                    concat!("Alignment of ", stringify!(ControlProtocolEvents))
                );
            }
            #[repr(C, packed(4))]
            #[derive(Copy, Clone)]
            pub struct ImageBuffersReadyDefn {
                pub correlationId: ::std::os::raw::c_long,
                pub sessionId: ::std::os::raw::c_int,
                pub streamId: ::std::os::raw::c_int,
                pub subscriptionRegistrationId: ::std::os::raw::c_long,
                pub subscriberPositionId: ::std::os::raw::c_int,
            }
            #[test]
            fn bindgen_test_layout_ImageBuffersReadyDefn() {
                const UNINIT: ::std::mem::MaybeUninit<ImageBuffersReadyDefn> =
                    ::std::mem::MaybeUninit::uninit();
                let ptr = UNINIT.as_ptr();
                assert_eq!(
                    ::std::mem::size_of::<ImageBuffersReadyDefn>(),
                    28usize,
                    concat!("Size of: ", stringify!(ImageBuffersReadyDefn))
                );
                assert_eq!(
                    ::std::mem::align_of::<ImageBuffersReadyDefn>(),
                    4usize,
                    concat!("Alignment of ", stringify!(ImageBuffersReadyDefn))
                );
                assert_eq!(
                    unsafe { ::std::ptr::addr_of!((*ptr).correlationId) as usize - ptr as usize },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(ImageBuffersReadyDefn),
                        "::",
                        stringify!(correlationId)
                    )
                );
                assert_eq!(
                    unsafe { ::std::ptr::addr_of!((*ptr).sessionId) as usize - ptr as usize },
                    8usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(ImageBuffersReadyDefn),
                        "::",
                        stringify!(sessionId)
                    )
                );
                assert_eq!(
                    unsafe { ::std::ptr::addr_of!((*ptr).streamId) as usize - ptr as usize },
                    12usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(ImageBuffersReadyDefn),
                        "::",
                        stringify!(streamId)
                    )
                );
                assert_eq!(
                    unsafe {
                        ::std::ptr::addr_of!((*ptr).subscriptionRegistrationId) as usize
                            - ptr as usize
                    },
                    16usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(ImageBuffersReadyDefn),
                        "::",
                        stringify!(subscriptionRegistrationId)
                    )
                );
                assert_eq!(
                    unsafe {
                        ::std::ptr::addr_of!((*ptr).subscriberPositionId) as usize - ptr as usize
                    },
                    24usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(ImageBuffersReadyDefn),
                        "::",
                        stringify!(subscriberPositionId)
                    )
                );
            }
            #[repr(C)]
            #[derive(Copy, Clone)]
            pub struct ImageBuffersReadyFlyweight {
                pub _base:
                    root::aeron::command::Flyweight<root::aeron::command::ImageBuffersReadyDefn>,
            }
            #[test]
            fn bindgen_test_layout_ImageBuffersReadyFlyweight() {
                assert_eq!(
                    ::std::mem::size_of::<ImageBuffersReadyFlyweight>(),
                    32usize,
                    concat!("Size of: ", stringify!(ImageBuffersReadyFlyweight))
                );
                assert_eq!(
                    ::std::mem::align_of::<ImageBuffersReadyFlyweight>(),
                    8usize,
                    concat!("Alignment of ", stringify!(ImageBuffersReadyFlyweight))
                );
            }
            extern "C" {
                #[link_name = "\u{1}_ZNK5aeron7command26ImageBuffersReadyFlyweight13correlationIdEv"]
                pub fn ImageBuffersReadyFlyweight_correlationId(
                    this: *const root::aeron::command::ImageBuffersReadyFlyweight,
                ) -> ::std::os::raw::c_long;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN5aeron7command26ImageBuffersReadyFlyweight13correlationIdEl"]
                pub fn ImageBuffersReadyFlyweight_correlationId1(
                    this: *mut root::aeron::command::ImageBuffersReadyFlyweight,
                    value: ::std::os::raw::c_long,
                ) -> *mut root::aeron::command::ImageBuffersReadyFlyweight;
            }
            extern "C" {
                #[link_name = "\u{1}_ZNK5aeron7command26ImageBuffersReadyFlyweight9sessionIdEv"]
                pub fn ImageBuffersReadyFlyweight_sessionId(
                    this: *const root::aeron::command::ImageBuffersReadyFlyweight,
                ) -> ::std::os::raw::c_int;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN5aeron7command26ImageBuffersReadyFlyweight9sessionIdEi"]
                pub fn ImageBuffersReadyFlyweight_sessionId1(
                    this: *mut root::aeron::command::ImageBuffersReadyFlyweight,
                    value: ::std::os::raw::c_int,
                ) -> *mut root::aeron::command::ImageBuffersReadyFlyweight;
            }
            extern "C" {
                #[link_name = "\u{1}_ZNK5aeron7command26ImageBuffersReadyFlyweight8streamIdEv"]
                pub fn ImageBuffersReadyFlyweight_streamId(
                    this: *const root::aeron::command::ImageBuffersReadyFlyweight,
                ) -> ::std::os::raw::c_int;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN5aeron7command26ImageBuffersReadyFlyweight8streamIdEi"]
                pub fn ImageBuffersReadyFlyweight_streamId1(
                    this: *mut root::aeron::command::ImageBuffersReadyFlyweight,
                    value: ::std::os::raw::c_int,
                ) -> *mut root::aeron::command::ImageBuffersReadyFlyweight;
            }
            extern "C" {
                #[link_name = "\u{1}_ZNK5aeron7command26ImageBuffersReadyFlyweight26subscriptionRegistrationIdEv"]
                pub fn ImageBuffersReadyFlyweight_subscriptionRegistrationId(
                    this: *const root::aeron::command::ImageBuffersReadyFlyweight,
                ) -> ::std::os::raw::c_long;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN5aeron7command26ImageBuffersReadyFlyweight24subscriberRegistrationIdEl"]
                pub fn ImageBuffersReadyFlyweight_subscriberRegistrationId(
                    this: *mut root::aeron::command::ImageBuffersReadyFlyweight,
                    value: ::std::os::raw::c_long,
                ) -> *mut root::aeron::command::ImageBuffersReadyFlyweight;
            }
            extern "C" {
                #[link_name = "\u{1}_ZNK5aeron7command26ImageBuffersReadyFlyweight20subscriberPositionIdEv"]
                pub fn ImageBuffersReadyFlyweight_subscriberPositionId(
                    this: *const root::aeron::command::ImageBuffersReadyFlyweight,
                ) -> ::std::os::raw::c_int;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN5aeron7command26ImageBuffersReadyFlyweight20subscriberPositionIdEi"]
                pub fn ImageBuffersReadyFlyweight_subscriberPositionId1(
                    this: *mut root::aeron::command::ImageBuffersReadyFlyweight,
                    value: ::std::os::raw::c_int,
                ) -> *mut root::aeron::command::ImageBuffersReadyFlyweight;
            }
            extern "C" {
                #[link_name = "\u{1}_ZNK5aeron7command26ImageBuffersReadyFlyweight11logFileNameB5cxx11Ev"]
                pub fn ImageBuffersReadyFlyweight_logFileName(
                    this: *const root::aeron::command::ImageBuffersReadyFlyweight,
                ) -> root::std::string;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN5aeron7command26ImageBuffersReadyFlyweight11logFileNameERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
                pub fn ImageBuffersReadyFlyweight_logFileName1(
                    this: *mut root::aeron::command::ImageBuffersReadyFlyweight,
                    value: *const root::std::string,
                ) -> *mut root::aeron::command::ImageBuffersReadyFlyweight;
            }
            extern "C" {
                #[link_name = "\u{1}_ZNK5aeron7command26ImageBuffersReadyFlyweight14sourceIdentityB5cxx11Ev"]
                pub fn ImageBuffersReadyFlyweight_sourceIdentity(
                    this: *const root::aeron::command::ImageBuffersReadyFlyweight,
                ) -> root::std::string;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN5aeron7command26ImageBuffersReadyFlyweight14sourceIdentityERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
                pub fn ImageBuffersReadyFlyweight_sourceIdentity1(
                    this: *mut root::aeron::command::ImageBuffersReadyFlyweight,
                    value: *const root::std::string,
                ) -> *mut root::aeron::command::ImageBuffersReadyFlyweight;
            }
            extern "C" {
                #[link_name = "\u{1}_ZNK5aeron7command26ImageBuffersReadyFlyweight6lengthEv"]
                pub fn ImageBuffersReadyFlyweight_length(
                    this: *const root::aeron::command::ImageBuffersReadyFlyweight,
                ) -> root::aeron::util::index_t;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN5aeron7command26ImageBuffersReadyFlyweightC1ERNS_10concurrent12AtomicBufferEi"]
                pub fn ImageBuffersReadyFlyweight_ImageBuffersReadyFlyweight(
                    this: *mut root::aeron::command::ImageBuffersReadyFlyweight,
                    buffer: *mut root::aeron::concurrent::AtomicBuffer,
                    offset: root::aeron::util::index_t,
                );
            }
            impl ImageBuffersReadyFlyweight {
                #[inline]
                pub unsafe fn correlationId(&self) -> ::std::os::raw::c_long {
                    ImageBuffersReadyFlyweight_correlationId(self)
                }
                #[inline]
                pub unsafe fn correlationId1(
                    &mut self,
                    value: ::std::os::raw::c_long,
                ) -> *mut root::aeron::command::ImageBuffersReadyFlyweight {
                    ImageBuffersReadyFlyweight_correlationId1(self, value)
                }
                #[inline]
                pub unsafe fn sessionId(&self) -> ::std::os::raw::c_int {
                    ImageBuffersReadyFlyweight_sessionId(self)
                }
                #[inline]
                pub unsafe fn sessionId1(
                    &mut self,
                    value: ::std::os::raw::c_int,
                ) -> *mut root::aeron::command::ImageBuffersReadyFlyweight {
                    ImageBuffersReadyFlyweight_sessionId1(self, value)
                }
                #[inline]
                pub unsafe fn streamId(&self) -> ::std::os::raw::c_int {
                    ImageBuffersReadyFlyweight_streamId(self)
                }
                #[inline]
                pub unsafe fn streamId1(
                    &mut self,
                    value: ::std::os::raw::c_int,
                ) -> *mut root::aeron::command::ImageBuffersReadyFlyweight {
                    ImageBuffersReadyFlyweight_streamId1(self, value)
                }
                #[inline]
                pub unsafe fn subscriptionRegistrationId(&self) -> ::std::os::raw::c_long {
                    ImageBuffersReadyFlyweight_subscriptionRegistrationId(self)
                }
                #[inline]
                pub unsafe fn subscriberRegistrationId(
                    &mut self,
                    value: ::std::os::raw::c_long,
                ) -> *mut root::aeron::command::ImageBuffersReadyFlyweight {
                    ImageBuffersReadyFlyweight_subscriberRegistrationId(self, value)
                }
                #[inline]
                pub unsafe fn subscriberPositionId(&self) -> ::std::os::raw::c_int {
                    ImageBuffersReadyFlyweight_subscriberPositionId(self)
                }
                #[inline]
                pub unsafe fn subscriberPositionId1(
                    &mut self,
                    value: ::std::os::raw::c_int,
                ) -> *mut root::aeron::command::ImageBuffersReadyFlyweight {
                    ImageBuffersReadyFlyweight_subscriberPositionId1(self, value)
                }
                #[inline]
                pub unsafe fn logFileName(&self) -> root::std::string {
                    ImageBuffersReadyFlyweight_logFileName(self)
                }
                #[inline]
                pub unsafe fn logFileName1(
                    &mut self,
                    value: *const root::std::string,
                ) -> *mut root::aeron::command::ImageBuffersReadyFlyweight {
                    ImageBuffersReadyFlyweight_logFileName1(self, value)
                }
                #[inline]
                pub unsafe fn sourceIdentity(&self) -> root::std::string {
                    ImageBuffersReadyFlyweight_sourceIdentity(self)
                }
                #[inline]
                pub unsafe fn sourceIdentity1(
                    &mut self,
                    value: *const root::std::string,
                ) -> *mut root::aeron::command::ImageBuffersReadyFlyweight {
                    ImageBuffersReadyFlyweight_sourceIdentity1(self, value)
                }
                #[inline]
                pub unsafe fn length(&self) -> root::aeron::util::index_t {
                    ImageBuffersReadyFlyweight_length(self)
                }
                #[inline]
                pub unsafe fn new(
                    buffer: *mut root::aeron::concurrent::AtomicBuffer,
                    offset: root::aeron::util::index_t,
                ) -> Self {
                    let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                    ImageBuffersReadyFlyweight_ImageBuffersReadyFlyweight(
                        __bindgen_tmp.as_mut_ptr(),
                        buffer,
                        offset,
                    );
                    __bindgen_tmp.assume_init()
                }
            }
            #[repr(C, packed(4))]
            #[derive(Copy, Clone)]
            pub struct ImageMessageDefn {
                pub correlationId: ::std::os::raw::c_long,
                pub subscriptionRegistrationId: ::std::os::raw::c_long,
                pub streamId: ::std::os::raw::c_int,
                pub channelLength: ::std::os::raw::c_int,
                pub channelData: [::std::os::raw::c_schar; 1usize],
            }
            #[test]
            fn bindgen_test_layout_ImageMessageDefn() {
                const UNINIT: ::std::mem::MaybeUninit<ImageMessageDefn> =
                    ::std::mem::MaybeUninit::uninit();
                let ptr = UNINIT.as_ptr();
                assert_eq!(
                    ::std::mem::size_of::<ImageMessageDefn>(),
                    28usize,
                    concat!("Size of: ", stringify!(ImageMessageDefn))
                );
                assert_eq!(
                    ::std::mem::align_of::<ImageMessageDefn>(),
                    4usize,
                    concat!("Alignment of ", stringify!(ImageMessageDefn))
                );
                assert_eq!(
                    unsafe { ::std::ptr::addr_of!((*ptr).correlationId) as usize - ptr as usize },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(ImageMessageDefn),
                        "::",
                        stringify!(correlationId)
                    )
                );
                assert_eq!(
                    unsafe {
                        ::std::ptr::addr_of!((*ptr).subscriptionRegistrationId) as usize
                            - ptr as usize
                    },
                    8usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(ImageMessageDefn),
                        "::",
                        stringify!(subscriptionRegistrationId)
                    )
                );
                assert_eq!(
                    unsafe { ::std::ptr::addr_of!((*ptr).streamId) as usize - ptr as usize },
                    16usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(ImageMessageDefn),
                        "::",
                        stringify!(streamId)
                    )
                );
                assert_eq!(
                    unsafe { ::std::ptr::addr_of!((*ptr).channelLength) as usize - ptr as usize },
                    20usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(ImageMessageDefn),
                        "::",
                        stringify!(channelLength)
                    )
                );
                assert_eq!(
                    unsafe { ::std::ptr::addr_of!((*ptr).channelData) as usize - ptr as usize },
                    24usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(ImageMessageDefn),
                        "::",
                        stringify!(channelData)
                    )
                );
            }
            #[repr(C)]
            #[derive(Copy, Clone)]
            pub struct ImageMessageFlyweight {
                pub _base: root::aeron::command::Flyweight<root::aeron::command::ImageMessageDefn>,
            }
            #[test]
            fn bindgen_test_layout_ImageMessageFlyweight() {
                assert_eq!(
                    ::std::mem::size_of::<ImageMessageFlyweight>(),
                    32usize,
                    concat!("Size of: ", stringify!(ImageMessageFlyweight))
                );
                assert_eq!(
                    ::std::mem::align_of::<ImageMessageFlyweight>(),
                    8usize,
                    concat!("Alignment of ", stringify!(ImageMessageFlyweight))
                );
            }
            extern "C" {
                #[link_name = "\u{1}_ZNK5aeron7command21ImageMessageFlyweight13correlationIdEv"]
                pub fn ImageMessageFlyweight_correlationId(
                    this: *const root::aeron::command::ImageMessageFlyweight,
                ) -> ::std::os::raw::c_long;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN5aeron7command21ImageMessageFlyweight13correlationIdEl"]
                pub fn ImageMessageFlyweight_correlationId1(
                    this: *mut root::aeron::command::ImageMessageFlyweight,
                    value: ::std::os::raw::c_long,
                ) -> *mut root::aeron::command::ImageMessageFlyweight;
            }
            extern "C" {
                #[link_name = "\u{1}_ZNK5aeron7command21ImageMessageFlyweight26subscriptionRegistrationIdEv"]
                pub fn ImageMessageFlyweight_subscriptionRegistrationId(
                    this: *const root::aeron::command::ImageMessageFlyweight,
                ) -> ::std::os::raw::c_long;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN5aeron7command21ImageMessageFlyweight26subscriptionRegistrationIdEl"]
                pub fn ImageMessageFlyweight_subscriptionRegistrationId1(
                    this: *mut root::aeron::command::ImageMessageFlyweight,
                    value: ::std::os::raw::c_long,
                ) -> *mut root::aeron::command::ImageMessageFlyweight;
            }
            extern "C" {
                #[link_name = "\u{1}_ZNK5aeron7command21ImageMessageFlyweight8streamIdEv"]
                pub fn ImageMessageFlyweight_streamId(
                    this: *const root::aeron::command::ImageMessageFlyweight,
                ) -> ::std::os::raw::c_int;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN5aeron7command21ImageMessageFlyweight8streamIdEi"]
                pub fn ImageMessageFlyweight_streamId1(
                    this: *mut root::aeron::command::ImageMessageFlyweight,
                    value: ::std::os::raw::c_int,
                ) -> *mut root::aeron::command::ImageMessageFlyweight;
            }
            extern "C" {
                #[link_name = "\u{1}_ZNK5aeron7command21ImageMessageFlyweight7channelB5cxx11Ev"]
                pub fn ImageMessageFlyweight_channel(
                    this: *const root::aeron::command::ImageMessageFlyweight,
                ) -> root::std::string;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN5aeron7command21ImageMessageFlyweight7channelERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
                pub fn ImageMessageFlyweight_channel1(
                    this: *mut root::aeron::command::ImageMessageFlyweight,
                    value: *const root::std::string,
                ) -> *mut root::aeron::command::ImageMessageFlyweight;
            }
            extern "C" {
                #[link_name = "\u{1}_ZNK5aeron7command21ImageMessageFlyweight6lengthEv"]
                pub fn ImageMessageFlyweight_length(
                    this: *const root::aeron::command::ImageMessageFlyweight,
                ) -> root::aeron::util::index_t;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN5aeron7command21ImageMessageFlyweightC1ERNS_10concurrent12AtomicBufferEi"]
                pub fn ImageMessageFlyweight_ImageMessageFlyweight(
                    this: *mut root::aeron::command::ImageMessageFlyweight,
                    buffer: *mut root::aeron::concurrent::AtomicBuffer,
                    offset: root::aeron::util::index_t,
                );
            }
            impl ImageMessageFlyweight {
                #[inline]
                pub unsafe fn correlationId(&self) -> ::std::os::raw::c_long {
                    ImageMessageFlyweight_correlationId(self)
                }
                #[inline]
                pub unsafe fn correlationId1(
                    &mut self,
                    value: ::std::os::raw::c_long,
                ) -> *mut root::aeron::command::ImageMessageFlyweight {
                    ImageMessageFlyweight_correlationId1(self, value)
                }
                #[inline]
                pub unsafe fn subscriptionRegistrationId(&self) -> ::std::os::raw::c_long {
                    ImageMessageFlyweight_subscriptionRegistrationId(self)
                }
                #[inline]
                pub unsafe fn subscriptionRegistrationId1(
                    &mut self,
                    value: ::std::os::raw::c_long,
                ) -> *mut root::aeron::command::ImageMessageFlyweight {
                    ImageMessageFlyweight_subscriptionRegistrationId1(self, value)
                }
                #[inline]
                pub unsafe fn streamId(&self) -> ::std::os::raw::c_int {
                    ImageMessageFlyweight_streamId(self)
                }
                #[inline]
                pub unsafe fn streamId1(
                    &mut self,
                    value: ::std::os::raw::c_int,
                ) -> *mut root::aeron::command::ImageMessageFlyweight {
                    ImageMessageFlyweight_streamId1(self, value)
                }
                #[inline]
                pub unsafe fn channel(&self) -> root::std::string {
                    ImageMessageFlyweight_channel(self)
                }
                #[inline]
                pub unsafe fn channel1(
                    &mut self,
                    value: *const root::std::string,
                ) -> *mut root::aeron::command::ImageMessageFlyweight {
                    ImageMessageFlyweight_channel1(self, value)
                }
                #[inline]
                pub unsafe fn length(&self) -> root::aeron::util::index_t {
                    ImageMessageFlyweight_length(self)
                }
                #[inline]
                pub unsafe fn new(
                    buffer: *mut root::aeron::concurrent::AtomicBuffer,
                    offset: root::aeron::util::index_t,
                ) -> Self {
                    let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                    ImageMessageFlyweight_ImageMessageFlyweight(
                        __bindgen_tmp.as_mut_ptr(),
                        buffer,
                        offset,
                    );
                    __bindgen_tmp.assume_init()
                }
            }
            #[repr(C, packed(4))]
            #[derive(Copy, Clone)]
            pub struct ErrorResponseDefn {
                pub offendingCommandCorrelationId: ::std::os::raw::c_long,
                pub errorCode: ::std::os::raw::c_int,
                pub errorMessageLength: ::std::os::raw::c_int,
                pub errorMessageData: [::std::os::raw::c_schar; 1usize],
            }
            #[test]
            fn bindgen_test_layout_ErrorResponseDefn() {
                const UNINIT: ::std::mem::MaybeUninit<ErrorResponseDefn> =
                    ::std::mem::MaybeUninit::uninit();
                let ptr = UNINIT.as_ptr();
                assert_eq!(
                    ::std::mem::size_of::<ErrorResponseDefn>(),
                    20usize,
                    concat!("Size of: ", stringify!(ErrorResponseDefn))
                );
                assert_eq!(
                    ::std::mem::align_of::<ErrorResponseDefn>(),
                    4usize,
                    concat!("Alignment of ", stringify!(ErrorResponseDefn))
                );
                assert_eq!(
                    unsafe {
                        ::std::ptr::addr_of!((*ptr).offendingCommandCorrelationId) as usize
                            - ptr as usize
                    },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(ErrorResponseDefn),
                        "::",
                        stringify!(offendingCommandCorrelationId)
                    )
                );
                assert_eq!(
                    unsafe { ::std::ptr::addr_of!((*ptr).errorCode) as usize - ptr as usize },
                    8usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(ErrorResponseDefn),
                        "::",
                        stringify!(errorCode)
                    )
                );
                assert_eq!(
                    unsafe {
                        ::std::ptr::addr_of!((*ptr).errorMessageLength) as usize - ptr as usize
                    },
                    12usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(ErrorResponseDefn),
                        "::",
                        stringify!(errorMessageLength)
                    )
                );
                assert_eq!(
                    unsafe {
                        ::std::ptr::addr_of!((*ptr).errorMessageData) as usize - ptr as usize
                    },
                    16usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(ErrorResponseDefn),
                        "::",
                        stringify!(errorMessageData)
                    )
                );
            }
            #[repr(C)]
            #[derive(Copy, Clone)]
            pub struct ErrorResponseFlyweight {
                pub _base: root::aeron::command::Flyweight<root::aeron::command::ErrorResponseDefn>,
            }
            #[test]
            fn bindgen_test_layout_ErrorResponseFlyweight() {
                assert_eq!(
                    ::std::mem::size_of::<ErrorResponseFlyweight>(),
                    32usize,
                    concat!("Size of: ", stringify!(ErrorResponseFlyweight))
                );
                assert_eq!(
                    ::std::mem::align_of::<ErrorResponseFlyweight>(),
                    8usize,
                    concat!("Alignment of ", stringify!(ErrorResponseFlyweight))
                );
            }
            extern "C" {
                #[link_name = "\u{1}_ZNK5aeron7command22ErrorResponseFlyweight29offendingCommandCorrelationIdEv"]
                pub fn ErrorResponseFlyweight_offendingCommandCorrelationId(
                    this: *const root::aeron::command::ErrorResponseFlyweight,
                ) -> ::std::os::raw::c_long;
            }
            extern "C" {
                #[link_name = "\u{1}_ZNK5aeron7command22ErrorResponseFlyweight9errorCodeEv"]
                pub fn ErrorResponseFlyweight_errorCode(
                    this: *const root::aeron::command::ErrorResponseFlyweight,
                ) -> ::std::os::raw::c_int;
            }
            extern "C" {
                #[link_name = "\u{1}_ZNK5aeron7command22ErrorResponseFlyweight12errorMessageB5cxx11Ev"]
                pub fn ErrorResponseFlyweight_errorMessage(
                    this: *const root::aeron::command::ErrorResponseFlyweight,
                ) -> root::std::string;
            }
            extern "C" {
                #[link_name = "\u{1}_ZNK5aeron7command22ErrorResponseFlyweight6lengthEv"]
                pub fn ErrorResponseFlyweight_length(
                    this: *const root::aeron::command::ErrorResponseFlyweight,
                ) -> root::aeron::util::index_t;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN5aeron7command22ErrorResponseFlyweightC1ERNS_10concurrent12AtomicBufferEi"]
                pub fn ErrorResponseFlyweight_ErrorResponseFlyweight(
                    this: *mut root::aeron::command::ErrorResponseFlyweight,
                    buffer: *mut root::aeron::concurrent::AtomicBuffer,
                    offset: root::aeron::util::index_t,
                );
            }
            impl ErrorResponseFlyweight {
                #[inline]
                pub unsafe fn offendingCommandCorrelationId(&self) -> ::std::os::raw::c_long {
                    ErrorResponseFlyweight_offendingCommandCorrelationId(self)
                }
                #[inline]
                pub unsafe fn errorCode(&self) -> ::std::os::raw::c_int {
                    ErrorResponseFlyweight_errorCode(self)
                }
                #[inline]
                pub unsafe fn errorMessage(&self) -> root::std::string {
                    ErrorResponseFlyweight_errorMessage(self)
                }
                #[inline]
                pub unsafe fn length(&self) -> root::aeron::util::index_t {
                    ErrorResponseFlyweight_length(self)
                }
                #[inline]
                pub unsafe fn new(
                    buffer: *mut root::aeron::concurrent::AtomicBuffer,
                    offset: root::aeron::util::index_t,
                ) -> Self {
                    let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                    ErrorResponseFlyweight_ErrorResponseFlyweight(
                        __bindgen_tmp.as_mut_ptr(),
                        buffer,
                        offset,
                    );
                    __bindgen_tmp.assume_init()
                }
            }
            #[repr(C, packed(4))]
            #[derive(Copy, Clone)]
            pub struct OperationSucceededDefn {
                pub correlationId: ::std::os::raw::c_long,
            }
            #[test]
            fn bindgen_test_layout_OperationSucceededDefn() {
                const UNINIT: ::std::mem::MaybeUninit<OperationSucceededDefn> =
                    ::std::mem::MaybeUninit::uninit();
                let ptr = UNINIT.as_ptr();
                assert_eq!(
                    ::std::mem::size_of::<OperationSucceededDefn>(),
                    8usize,
                    concat!("Size of: ", stringify!(OperationSucceededDefn))
                );
                assert_eq!(
                    ::std::mem::align_of::<OperationSucceededDefn>(),
                    4usize,
                    concat!("Alignment of ", stringify!(OperationSucceededDefn))
                );
                assert_eq!(
                    unsafe { ::std::ptr::addr_of!((*ptr).correlationId) as usize - ptr as usize },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(OperationSucceededDefn),
                        "::",
                        stringify!(correlationId)
                    )
                );
            }
            #[repr(C)]
            #[derive(Copy, Clone)]
            pub struct OperationSucceededFlyweight {
                pub _base:
                    root::aeron::command::Flyweight<root::aeron::command::OperationSucceededDefn>,
            }
            #[test]
            fn bindgen_test_layout_OperationSucceededFlyweight() {
                assert_eq!(
                    ::std::mem::size_of::<OperationSucceededFlyweight>(),
                    32usize,
                    concat!("Size of: ", stringify!(OperationSucceededFlyweight))
                );
                assert_eq!(
                    ::std::mem::align_of::<OperationSucceededFlyweight>(),
                    8usize,
                    concat!("Alignment of ", stringify!(OperationSucceededFlyweight))
                );
            }
            extern "C" {
                #[link_name = "\u{1}_ZNK5aeron7command27OperationSucceededFlyweight13correlationIdEv"]
                pub fn OperationSucceededFlyweight_correlationId(
                    this: *const root::aeron::command::OperationSucceededFlyweight,
                ) -> ::std::os::raw::c_long;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN5aeron7command27OperationSucceededFlyweight13correlationIdEl"]
                pub fn OperationSucceededFlyweight_correlationId1(
                    this: *mut root::aeron::command::OperationSucceededFlyweight,
                    value: ::std::os::raw::c_long,
                ) -> *mut root::aeron::command::OperationSucceededFlyweight;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN5aeron7command27OperationSucceededFlyweightC1ERNS_10concurrent12AtomicBufferEi"]
                pub fn OperationSucceededFlyweight_OperationSucceededFlyweight(
                    this: *mut root::aeron::command::OperationSucceededFlyweight,
                    buffer: *mut root::aeron::concurrent::AtomicBuffer,
                    offset: root::aeron::util::index_t,
                );
            }
            impl OperationSucceededFlyweight {
                #[inline]
                pub unsafe fn correlationId(&self) -> ::std::os::raw::c_long {
                    OperationSucceededFlyweight_correlationId(self)
                }
                #[inline]
                pub unsafe fn correlationId1(
                    &mut self,
                    value: ::std::os::raw::c_long,
                ) -> *mut root::aeron::command::OperationSucceededFlyweight {
                    OperationSucceededFlyweight_correlationId1(self, value)
                }
                #[inline]
                pub unsafe fn new(
                    buffer: *mut root::aeron::concurrent::AtomicBuffer,
                    offset: root::aeron::util::index_t,
                ) -> Self {
                    let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                    OperationSucceededFlyweight_OperationSucceededFlyweight(
                        __bindgen_tmp.as_mut_ptr(),
                        buffer,
                        offset,
                    );
                    __bindgen_tmp.assume_init()
                }
            }
            #[repr(C, packed(4))]
            #[derive(Copy, Clone)]
            pub struct SubscriptionReadyDefn {
                pub correlationId: ::std::os::raw::c_long,
                pub channelStatusIndicatorId: ::std::os::raw::c_int,
            }
            #[test]
            fn bindgen_test_layout_SubscriptionReadyDefn() {
                const UNINIT: ::std::mem::MaybeUninit<SubscriptionReadyDefn> =
                    ::std::mem::MaybeUninit::uninit();
                let ptr = UNINIT.as_ptr();
                assert_eq!(
                    ::std::mem::size_of::<SubscriptionReadyDefn>(),
                    12usize,
                    concat!("Size of: ", stringify!(SubscriptionReadyDefn))
                );
                assert_eq!(
                    ::std::mem::align_of::<SubscriptionReadyDefn>(),
                    4usize,
                    concat!("Alignment of ", stringify!(SubscriptionReadyDefn))
                );
                assert_eq!(
                    unsafe { ::std::ptr::addr_of!((*ptr).correlationId) as usize - ptr as usize },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(SubscriptionReadyDefn),
                        "::",
                        stringify!(correlationId)
                    )
                );
                assert_eq!(
                    unsafe {
                        ::std::ptr::addr_of!((*ptr).channelStatusIndicatorId) as usize
                            - ptr as usize
                    },
                    8usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(SubscriptionReadyDefn),
                        "::",
                        stringify!(channelStatusIndicatorId)
                    )
                );
            }
            #[repr(C)]
            #[derive(Copy, Clone)]
            pub struct SubscriptionReadyFlyweight {
                pub _base:
                    root::aeron::command::Flyweight<root::aeron::command::SubscriptionReadyDefn>,
            }
            #[test]
            fn bindgen_test_layout_SubscriptionReadyFlyweight() {
                assert_eq!(
                    ::std::mem::size_of::<SubscriptionReadyFlyweight>(),
                    32usize,
                    concat!("Size of: ", stringify!(SubscriptionReadyFlyweight))
                );
                assert_eq!(
                    ::std::mem::align_of::<SubscriptionReadyFlyweight>(),
                    8usize,
                    concat!("Alignment of ", stringify!(SubscriptionReadyFlyweight))
                );
            }
            extern "C" {
                #[link_name = "\u{1}_ZNK5aeron7command26SubscriptionReadyFlyweight13correlationIdEv"]
                pub fn SubscriptionReadyFlyweight_correlationId(
                    this: *const root::aeron::command::SubscriptionReadyFlyweight,
                ) -> ::std::os::raw::c_long;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN5aeron7command26SubscriptionReadyFlyweight13correlationIdEl"]
                pub fn SubscriptionReadyFlyweight_correlationId1(
                    this: *mut root::aeron::command::SubscriptionReadyFlyweight,
                    value: ::std::os::raw::c_long,
                ) -> *mut root::aeron::command::SubscriptionReadyFlyweight;
            }
            extern "C" {
                #[link_name = "\u{1}_ZNK5aeron7command26SubscriptionReadyFlyweight24channelStatusIndicatorIdEv"]
                pub fn SubscriptionReadyFlyweight_channelStatusIndicatorId(
                    this: *const root::aeron::command::SubscriptionReadyFlyweight,
                ) -> ::std::os::raw::c_int;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN5aeron7command26SubscriptionReadyFlyweight24channelStatusIndicatorIdEi"]
                pub fn SubscriptionReadyFlyweight_channelStatusIndicatorId1(
                    this: *mut root::aeron::command::SubscriptionReadyFlyweight,
                    value: ::std::os::raw::c_int,
                ) -> *mut root::aeron::command::SubscriptionReadyFlyweight;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN5aeron7command26SubscriptionReadyFlyweightC1ERNS_10concurrent12AtomicBufferEi"]
                pub fn SubscriptionReadyFlyweight_SubscriptionReadyFlyweight(
                    this: *mut root::aeron::command::SubscriptionReadyFlyweight,
                    buffer: *mut root::aeron::concurrent::AtomicBuffer,
                    offset: root::aeron::util::index_t,
                );
            }
            impl SubscriptionReadyFlyweight {
                #[inline]
                pub unsafe fn correlationId(&self) -> ::std::os::raw::c_long {
                    SubscriptionReadyFlyweight_correlationId(self)
                }
                #[inline]
                pub unsafe fn correlationId1(
                    &mut self,
                    value: ::std::os::raw::c_long,
                ) -> *mut root::aeron::command::SubscriptionReadyFlyweight {
                    SubscriptionReadyFlyweight_correlationId1(self, value)
                }
                #[inline]
                pub unsafe fn channelStatusIndicatorId(&self) -> ::std::os::raw::c_int {
                    SubscriptionReadyFlyweight_channelStatusIndicatorId(self)
                }
                #[inline]
                pub unsafe fn channelStatusIndicatorId1(
                    &mut self,
                    value: ::std::os::raw::c_int,
                ) -> *mut root::aeron::command::SubscriptionReadyFlyweight {
                    SubscriptionReadyFlyweight_channelStatusIndicatorId1(self, value)
                }
                #[inline]
                pub unsafe fn new(
                    buffer: *mut root::aeron::concurrent::AtomicBuffer,
                    offset: root::aeron::util::index_t,
                ) -> Self {
                    let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                    SubscriptionReadyFlyweight_SubscriptionReadyFlyweight(
                        __bindgen_tmp.as_mut_ptr(),
                        buffer,
                        offset,
                    );
                    __bindgen_tmp.assume_init()
                }
            }
            #[repr(C, packed(4))]
            #[derive(Copy, Clone)]
            pub struct CounterUpdateDefn {
                pub correlationId: ::std::os::raw::c_long,
                pub counterId: ::std::os::raw::c_int,
            }
            #[test]
            fn bindgen_test_layout_CounterUpdateDefn() {
                const UNINIT: ::std::mem::MaybeUninit<CounterUpdateDefn> =
                    ::std::mem::MaybeUninit::uninit();
                let ptr = UNINIT.as_ptr();
                assert_eq!(
                    ::std::mem::size_of::<CounterUpdateDefn>(),
                    12usize,
                    concat!("Size of: ", stringify!(CounterUpdateDefn))
                );
                assert_eq!(
                    ::std::mem::align_of::<CounterUpdateDefn>(),
                    4usize,
                    concat!("Alignment of ", stringify!(CounterUpdateDefn))
                );
                assert_eq!(
                    unsafe { ::std::ptr::addr_of!((*ptr).correlationId) as usize - ptr as usize },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(CounterUpdateDefn),
                        "::",
                        stringify!(correlationId)
                    )
                );
                assert_eq!(
                    unsafe { ::std::ptr::addr_of!((*ptr).counterId) as usize - ptr as usize },
                    8usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(CounterUpdateDefn),
                        "::",
                        stringify!(counterId)
                    )
                );
            }
            #[repr(C)]
            #[derive(Copy, Clone)]
            pub struct CounterUpdateFlyweight {
                pub _base: root::aeron::command::Flyweight<root::aeron::command::CounterUpdateDefn>,
            }
            #[test]
            fn bindgen_test_layout_CounterUpdateFlyweight() {
                assert_eq!(
                    ::std::mem::size_of::<CounterUpdateFlyweight>(),
                    32usize,
                    concat!("Size of: ", stringify!(CounterUpdateFlyweight))
                );
                assert_eq!(
                    ::std::mem::align_of::<CounterUpdateFlyweight>(),
                    8usize,
                    concat!("Alignment of ", stringify!(CounterUpdateFlyweight))
                );
            }
            extern "C" {
                #[link_name = "\u{1}_ZNK5aeron7command22CounterUpdateFlyweight13correlationIdEv"]
                pub fn CounterUpdateFlyweight_correlationId(
                    this: *const root::aeron::command::CounterUpdateFlyweight,
                ) -> ::std::os::raw::c_long;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN5aeron7command22CounterUpdateFlyweight13correlationIdEl"]
                pub fn CounterUpdateFlyweight_correlationId1(
                    this: *mut root::aeron::command::CounterUpdateFlyweight,
                    value: ::std::os::raw::c_long,
                ) -> *mut root::aeron::command::CounterUpdateFlyweight;
            }
            extern "C" {
                #[link_name = "\u{1}_ZNK5aeron7command22CounterUpdateFlyweight9counterIdEv"]
                pub fn CounterUpdateFlyweight_counterId(
                    this: *const root::aeron::command::CounterUpdateFlyweight,
                ) -> ::std::os::raw::c_int;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN5aeron7command22CounterUpdateFlyweight9counterIdEi"]
                pub fn CounterUpdateFlyweight_counterId1(
                    this: *mut root::aeron::command::CounterUpdateFlyweight,
                    value: ::std::os::raw::c_int,
                ) -> *mut root::aeron::command::CounterUpdateFlyweight;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN5aeron7command22CounterUpdateFlyweightC1ERNS_10concurrent12AtomicBufferEi"]
                pub fn CounterUpdateFlyweight_CounterUpdateFlyweight(
                    this: *mut root::aeron::command::CounterUpdateFlyweight,
                    buffer: *mut root::aeron::concurrent::AtomicBuffer,
                    offset: root::aeron::util::index_t,
                );
            }
            impl CounterUpdateFlyweight {
                #[inline]
                pub unsafe fn correlationId(&self) -> ::std::os::raw::c_long {
                    CounterUpdateFlyweight_correlationId(self)
                }
                #[inline]
                pub unsafe fn correlationId1(
                    &mut self,
                    value: ::std::os::raw::c_long,
                ) -> *mut root::aeron::command::CounterUpdateFlyweight {
                    CounterUpdateFlyweight_correlationId1(self, value)
                }
                #[inline]
                pub unsafe fn counterId(&self) -> ::std::os::raw::c_int {
                    CounterUpdateFlyweight_counterId(self)
                }
                #[inline]
                pub unsafe fn counterId1(
                    &mut self,
                    value: ::std::os::raw::c_int,
                ) -> *mut root::aeron::command::CounterUpdateFlyweight {
                    CounterUpdateFlyweight_counterId1(self, value)
                }
                #[inline]
                pub unsafe fn new(
                    buffer: *mut root::aeron::concurrent::AtomicBuffer,
                    offset: root::aeron::util::index_t,
                ) -> Self {
                    let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                    CounterUpdateFlyweight_CounterUpdateFlyweight(
                        __bindgen_tmp.as_mut_ptr(),
                        buffer,
                        offset,
                    );
                    __bindgen_tmp.assume_init()
                }
            }
            #[repr(C, packed(4))]
            #[derive(Copy, Clone)]
            pub struct ClientTimeoutDefn {
                pub clientId: ::std::os::raw::c_long,
            }
            #[test]
            fn bindgen_test_layout_ClientTimeoutDefn() {
                const UNINIT: ::std::mem::MaybeUninit<ClientTimeoutDefn> =
                    ::std::mem::MaybeUninit::uninit();
                let ptr = UNINIT.as_ptr();
                assert_eq!(
                    ::std::mem::size_of::<ClientTimeoutDefn>(),
                    8usize,
                    concat!("Size of: ", stringify!(ClientTimeoutDefn))
                );
                assert_eq!(
                    ::std::mem::align_of::<ClientTimeoutDefn>(),
                    4usize,
                    concat!("Alignment of ", stringify!(ClientTimeoutDefn))
                );
                assert_eq!(
                    unsafe { ::std::ptr::addr_of!((*ptr).clientId) as usize - ptr as usize },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(ClientTimeoutDefn),
                        "::",
                        stringify!(clientId)
                    )
                );
            }
            #[repr(C)]
            #[derive(Copy, Clone)]
            pub struct ClientTimeoutFlyweight {
                pub _base: root::aeron::command::Flyweight<root::aeron::command::ClientTimeoutDefn>,
            }
            #[test]
            fn bindgen_test_layout_ClientTimeoutFlyweight() {
                assert_eq!(
                    ::std::mem::size_of::<ClientTimeoutFlyweight>(),
                    32usize,
                    concat!("Size of: ", stringify!(ClientTimeoutFlyweight))
                );
                assert_eq!(
                    ::std::mem::align_of::<ClientTimeoutFlyweight>(),
                    8usize,
                    concat!("Alignment of ", stringify!(ClientTimeoutFlyweight))
                );
            }
            extern "C" {
                #[link_name = "\u{1}_ZNK5aeron7command22ClientTimeoutFlyweight8clientIdEv"]
                pub fn ClientTimeoutFlyweight_clientId(
                    this: *const root::aeron::command::ClientTimeoutFlyweight,
                ) -> ::std::os::raw::c_long;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN5aeron7command22ClientTimeoutFlyweight8clientIdEl"]
                pub fn ClientTimeoutFlyweight_clientId1(
                    this: *mut root::aeron::command::ClientTimeoutFlyweight,
                    value: ::std::os::raw::c_long,
                ) -> *mut root::aeron::command::ClientTimeoutFlyweight;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN5aeron7command22ClientTimeoutFlyweightC1ERNS_10concurrent12AtomicBufferEi"]
                pub fn ClientTimeoutFlyweight_ClientTimeoutFlyweight(
                    this: *mut root::aeron::command::ClientTimeoutFlyweight,
                    buffer: *mut root::aeron::concurrent::AtomicBuffer,
                    offset: root::aeron::util::index_t,
                );
            }
            impl ClientTimeoutFlyweight {
                #[inline]
                pub unsafe fn clientId(&self) -> ::std::os::raw::c_long {
                    ClientTimeoutFlyweight_clientId(self)
                }
                #[inline]
                pub unsafe fn clientId1(
                    &mut self,
                    value: ::std::os::raw::c_long,
                ) -> *mut root::aeron::command::ClientTimeoutFlyweight {
                    ClientTimeoutFlyweight_clientId1(self, value)
                }
                #[inline]
                pub unsafe fn new(
                    buffer: *mut root::aeron::concurrent::AtomicBuffer,
                    offset: root::aeron::util::index_t,
                ) -> Self {
                    let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                    ClientTimeoutFlyweight_ClientTimeoutFlyweight(
                        __bindgen_tmp.as_mut_ptr(),
                        buffer,
                        offset,
                    );
                    __bindgen_tmp.assume_init()
                }
            }
        }
        #[repr(C)]
        #[derive(Copy, Clone)]
        pub struct DriverProxy {
            pub m_toDriverCommandBuffer:
                *mut root::aeron::concurrent::ringbuffer::ManyToOneRingBuffer,
            pub m_clientId: ::std::os::raw::c_long,
        }
        pub type DriverProxy_driver_proxy_command_buffer_t = [u8; 4096usize];
        #[test]
        fn bindgen_test_layout_DriverProxy() {
            const UNINIT: ::std::mem::MaybeUninit<DriverProxy> = ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<DriverProxy>(),
                16usize,
                concat!("Size of: ", stringify!(DriverProxy))
            );
            assert_eq!(
                ::std::mem::align_of::<DriverProxy>(),
                8usize,
                concat!("Alignment of ", stringify!(DriverProxy))
            );
            assert_eq!(
                unsafe {
                    ::std::ptr::addr_of!((*ptr).m_toDriverCommandBuffer) as usize - ptr as usize
                },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(DriverProxy),
                    "::",
                    stringify!(m_toDriverCommandBuffer)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_clientId) as usize - ptr as usize },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(DriverProxy),
                    "::",
                    stringify!(m_clientId)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5aeron11DriverProxy25timeOfLastDriverKeepaliveEv"]
            pub fn DriverProxy_timeOfLastDriverKeepalive(
                this: *mut root::aeron::DriverProxy,
            ) -> ::std::os::raw::c_long;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5aeron11DriverProxy17nextCorrelationIdEv"]
            pub fn DriverProxy_nextCorrelationId(
                this: *mut root::aeron::DriverProxy,
            ) -> ::std::os::raw::c_long;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNK5aeron11DriverProxy8clientIdEv"]
            pub fn DriverProxy_clientId(
                this: *const root::aeron::DriverProxy,
            ) -> ::std::os::raw::c_long;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5aeron11DriverProxy14addPublicationERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEi"]
            pub fn DriverProxy_addPublication(
                this: *mut root::aeron::DriverProxy,
                channel: *const root::std::string,
                streamId: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_long;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5aeron11DriverProxy23addExclusivePublicationERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEi"]
            pub fn DriverProxy_addExclusivePublication(
                this: *mut root::aeron::DriverProxy,
                channel: *const root::std::string,
                streamId: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_long;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5aeron11DriverProxy17removePublicationEl"]
            pub fn DriverProxy_removePublication(
                this: *mut root::aeron::DriverProxy,
                registrationId: ::std::os::raw::c_long,
            ) -> ::std::os::raw::c_long;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5aeron11DriverProxy15addSubscriptionERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEi"]
            pub fn DriverProxy_addSubscription(
                this: *mut root::aeron::DriverProxy,
                channel: *const root::std::string,
                streamId: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_long;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5aeron11DriverProxy18removeSubscriptionEl"]
            pub fn DriverProxy_removeSubscription(
                this: *mut root::aeron::DriverProxy,
                registrationId: ::std::os::raw::c_long,
            ) -> ::std::os::raw::c_long;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5aeron11DriverProxy14addDestinationElRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
            pub fn DriverProxy_addDestination(
                this: *mut root::aeron::DriverProxy,
                publicationRegistrationId: ::std::os::raw::c_long,
                channel: *const root::std::string,
            ) -> ::std::os::raw::c_long;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5aeron11DriverProxy17removeDestinationElRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
            pub fn DriverProxy_removeDestination(
                this: *mut root::aeron::DriverProxy,
                publicationRegistrationId: ::std::os::raw::c_long,
                channel: *const root::std::string,
            ) -> ::std::os::raw::c_long;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5aeron11DriverProxy17addRcvDestinationElRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
            pub fn DriverProxy_addRcvDestination(
                this: *mut root::aeron::DriverProxy,
                subscriptionRegistrationId: ::std::os::raw::c_long,
                channel: *const root::std::string,
            ) -> ::std::os::raw::c_long;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5aeron11DriverProxy20removeRcvDestinationElRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
            pub fn DriverProxy_removeRcvDestination(
                this: *mut root::aeron::DriverProxy,
                subscriptionRegistrationId: ::std::os::raw::c_long,
                channel: *const root::std::string,
            ) -> ::std::os::raw::c_long;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5aeron11DriverProxy10addCounterEiPKhmRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
            pub fn DriverProxy_addCounter(
                this: *mut root::aeron::DriverProxy,
                typeId: ::std::os::raw::c_int,
                key: *mut ::std::os::raw::c_uchar,
                keyLength: usize,
                label: *const root::std::string,
            ) -> ::std::os::raw::c_long;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5aeron11DriverProxy13removeCounterEl"]
            pub fn DriverProxy_removeCounter(
                this: *mut root::aeron::DriverProxy,
                registrationId: ::std::os::raw::c_long,
            ) -> ::std::os::raw::c_long;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5aeron11DriverProxy11clientCloseEv"]
            pub fn DriverProxy_clientClose(
                this: *mut root::aeron::DriverProxy,
            ) -> ::std::os::raw::c_long;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5aeron11DriverProxy15terminateDriverEPKhm"]
            pub fn DriverProxy_terminateDriver(
                this: *mut root::aeron::DriverProxy,
                tokenBuffer: *mut ::std::os::raw::c_uchar,
                tokenLength: usize,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5aeron11DriverProxyC1ERNS_10concurrent10ringbuffer19ManyToOneRingBufferE"]
            pub fn DriverProxy_DriverProxy(
                this: *mut root::aeron::DriverProxy,
                toDriverCommandBuffer : * mut root :: aeron :: concurrent :: ringbuffer :: ManyToOneRingBuffer,
            );
        }
        impl DriverProxy {
            #[inline]
            pub unsafe fn timeOfLastDriverKeepalive(&mut self) -> ::std::os::raw::c_long {
                DriverProxy_timeOfLastDriverKeepalive(self)
            }
            #[inline]
            pub unsafe fn nextCorrelationId(&mut self) -> ::std::os::raw::c_long {
                DriverProxy_nextCorrelationId(self)
            }
            #[inline]
            pub unsafe fn clientId(&self) -> ::std::os::raw::c_long {
                DriverProxy_clientId(self)
            }
            #[inline]
            pub unsafe fn addPublication(
                &mut self,
                channel: *const root::std::string,
                streamId: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_long {
                DriverProxy_addPublication(self, channel, streamId)
            }
            #[inline]
            pub unsafe fn addExclusivePublication(
                &mut self,
                channel: *const root::std::string,
                streamId: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_long {
                DriverProxy_addExclusivePublication(self, channel, streamId)
            }
            #[inline]
            pub unsafe fn removePublication(
                &mut self,
                registrationId: ::std::os::raw::c_long,
            ) -> ::std::os::raw::c_long {
                DriverProxy_removePublication(self, registrationId)
            }
            #[inline]
            pub unsafe fn addSubscription(
                &mut self,
                channel: *const root::std::string,
                streamId: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_long {
                DriverProxy_addSubscription(self, channel, streamId)
            }
            #[inline]
            pub unsafe fn removeSubscription(
                &mut self,
                registrationId: ::std::os::raw::c_long,
            ) -> ::std::os::raw::c_long {
                DriverProxy_removeSubscription(self, registrationId)
            }
            #[inline]
            pub unsafe fn addDestination(
                &mut self,
                publicationRegistrationId: ::std::os::raw::c_long,
                channel: *const root::std::string,
            ) -> ::std::os::raw::c_long {
                DriverProxy_addDestination(self, publicationRegistrationId, channel)
            }
            #[inline]
            pub unsafe fn removeDestination(
                &mut self,
                publicationRegistrationId: ::std::os::raw::c_long,
                channel: *const root::std::string,
            ) -> ::std::os::raw::c_long {
                DriverProxy_removeDestination(self, publicationRegistrationId, channel)
            }
            #[inline]
            pub unsafe fn addRcvDestination(
                &mut self,
                subscriptionRegistrationId: ::std::os::raw::c_long,
                channel: *const root::std::string,
            ) -> ::std::os::raw::c_long {
                DriverProxy_addRcvDestination(self, subscriptionRegistrationId, channel)
            }
            #[inline]
            pub unsafe fn removeRcvDestination(
                &mut self,
                subscriptionRegistrationId: ::std::os::raw::c_long,
                channel: *const root::std::string,
            ) -> ::std::os::raw::c_long {
                DriverProxy_removeRcvDestination(self, subscriptionRegistrationId, channel)
            }
            #[inline]
            pub unsafe fn addCounter(
                &mut self,
                typeId: ::std::os::raw::c_int,
                key: *mut ::std::os::raw::c_uchar,
                keyLength: usize,
                label: *const root::std::string,
            ) -> ::std::os::raw::c_long {
                DriverProxy_addCounter(self, typeId, key, keyLength, label)
            }
            #[inline]
            pub unsafe fn removeCounter(
                &mut self,
                registrationId: ::std::os::raw::c_long,
            ) -> ::std::os::raw::c_long {
                DriverProxy_removeCounter(self, registrationId)
            }
            #[inline]
            pub unsafe fn clientClose(&mut self) -> ::std::os::raw::c_long {
                DriverProxy_clientClose(self)
            }
            #[inline]
            pub unsafe fn terminateDriver(
                &mut self,
                tokenBuffer: *mut ::std::os::raw::c_uchar,
                tokenLength: usize,
            ) {
                DriverProxy_terminateDriver(self, tokenBuffer, tokenLength)
            }
            #[inline]
            pub unsafe fn new(
                toDriverCommandBuffer : * mut root :: aeron :: concurrent :: ringbuffer :: ManyToOneRingBuffer,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                DriverProxy_DriverProxy(__bindgen_tmp.as_mut_ptr(), toDriverCommandBuffer);
                __bindgen_tmp.assume_init()
            }
        }
        pub mod CncFileDescriptor {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            #[repr(C, packed(4))]
            #[derive(Copy, Clone)]
            pub struct MetaDataDefn {
                pub cncVersion: ::std::os::raw::c_int,
                pub toDriverBufferLength: ::std::os::raw::c_int,
                pub toClientsBufferLength: ::std::os::raw::c_int,
                pub counterMetadataBufferLength: ::std::os::raw::c_int,
                pub counterValuesBufferLength: ::std::os::raw::c_int,
                pub errorLogBufferLength: ::std::os::raw::c_int,
                pub clientLivenessTimeout: ::std::os::raw::c_long,
                pub startTimestamp: ::std::os::raw::c_long,
                pub pid: ::std::os::raw::c_long,
            }
            #[test]
            fn bindgen_test_layout_MetaDataDefn() {
                const UNINIT: ::std::mem::MaybeUninit<MetaDataDefn> =
                    ::std::mem::MaybeUninit::uninit();
                let ptr = UNINIT.as_ptr();
                assert_eq!(
                    ::std::mem::size_of::<MetaDataDefn>(),
                    48usize,
                    concat!("Size of: ", stringify!(MetaDataDefn))
                );
                assert_eq!(
                    ::std::mem::align_of::<MetaDataDefn>(),
                    4usize,
                    concat!("Alignment of ", stringify!(MetaDataDefn))
                );
                assert_eq!(
                    unsafe { ::std::ptr::addr_of!((*ptr).cncVersion) as usize - ptr as usize },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(MetaDataDefn),
                        "::",
                        stringify!(cncVersion)
                    )
                );
                assert_eq!(
                    unsafe {
                        ::std::ptr::addr_of!((*ptr).toDriverBufferLength) as usize - ptr as usize
                    },
                    4usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(MetaDataDefn),
                        "::",
                        stringify!(toDriverBufferLength)
                    )
                );
                assert_eq!(
                    unsafe {
                        ::std::ptr::addr_of!((*ptr).toClientsBufferLength) as usize - ptr as usize
                    },
                    8usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(MetaDataDefn),
                        "::",
                        stringify!(toClientsBufferLength)
                    )
                );
                assert_eq!(
                    unsafe {
                        ::std::ptr::addr_of!((*ptr).counterMetadataBufferLength) as usize
                            - ptr as usize
                    },
                    12usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(MetaDataDefn),
                        "::",
                        stringify!(counterMetadataBufferLength)
                    )
                );
                assert_eq!(
                    unsafe {
                        ::std::ptr::addr_of!((*ptr).counterValuesBufferLength) as usize
                            - ptr as usize
                    },
                    16usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(MetaDataDefn),
                        "::",
                        stringify!(counterValuesBufferLength)
                    )
                );
                assert_eq!(
                    unsafe {
                        ::std::ptr::addr_of!((*ptr).errorLogBufferLength) as usize - ptr as usize
                    },
                    20usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(MetaDataDefn),
                        "::",
                        stringify!(errorLogBufferLength)
                    )
                );
                assert_eq!(
                    unsafe {
                        ::std::ptr::addr_of!((*ptr).clientLivenessTimeout) as usize - ptr as usize
                    },
                    24usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(MetaDataDefn),
                        "::",
                        stringify!(clientLivenessTimeout)
                    )
                );
                assert_eq!(
                    unsafe { ::std::ptr::addr_of!((*ptr).startTimestamp) as usize - ptr as usize },
                    32usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(MetaDataDefn),
                        "::",
                        stringify!(startTimestamp)
                    )
                );
                assert_eq!(
                    unsafe { ::std::ptr::addr_of!((*ptr).pid) as usize - ptr as usize },
                    40usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(MetaDataDefn),
                        "::",
                        stringify!(pid)
                    )
                );
            }
        }
        pub type on_available_image_t = [u64; 4usize];
        pub type on_unavailable_image_t = [u64; 4usize];
        pub type on_new_publication_t = [u64; 4usize];
        pub type on_new_subscription_t = [u64; 4usize];
        pub type on_available_counter_t = [u64; 4usize];
        pub type on_unavailable_counter_t = [u64; 4usize];
        pub type on_close_client_t = [u64; 4usize];
        extern "C" {
            #[link_name = "\u{1}_ZN5aeron19defaultErrorHandlerERKSt9exception"]
            pub fn defaultErrorHandler(exception: *const root::std::exception);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5aeron30defaultOnNewPublicationHandlerERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEiil"]
            pub fn defaultOnNewPublicationHandler(
                arg1: *const root::std::string,
                arg2: ::std::os::raw::c_int,
                arg3: ::std::os::raw::c_int,
                arg4: ::std::os::raw::c_long,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5aeron30defaultOnAvailableImageHandlerERNS_5ImageE"]
            pub fn defaultOnAvailableImageHandler(arg1: *mut root::aeron::Image);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5aeron31defaultOnNewSubscriptionHandlerERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEil"]
            pub fn defaultOnNewSubscriptionHandler(
                arg1: *const root::std::string,
                arg2: ::std::os::raw::c_int,
                arg3: ::std::os::raw::c_long,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5aeron32defaultOnUnavailableImageHandlerERNS_5ImageE"]
            pub fn defaultOnUnavailableImageHandler(arg1: *mut root::aeron::Image);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5aeron32defaultOnAvailableCounterHandlerERNS_10concurrent14CountersReaderEli"]
            pub fn defaultOnAvailableCounterHandler(
                arg1: *mut root::aeron::concurrent::CountersReader,
                arg2: ::std::os::raw::c_long,
                arg3: ::std::os::raw::c_int,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5aeron34defaultOnUnavailableCounterHandlerERNS_10concurrent14CountersReaderEli"]
            pub fn defaultOnUnavailableCounterHandler(
                arg1: *mut root::aeron::concurrent::CountersReader,
                arg2: ::std::os::raw::c_long,
                arg3: ::std::os::raw::c_int,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5aeron27defaultOnCloseClientHandlerEv"]
            pub fn defaultOnCloseClientHandler();
        }
        #[repr(C)]
        #[derive(Copy, Clone)]
        pub struct Context {
            pub m_dirName: root::std::string,
            pub m_exceptionHandler: root::aeron::util::exception_handler_t,
            pub m_onNewPublicationHandler: root::aeron::on_new_publication_t,
            pub m_onNewExclusivePublicationHandler: root::aeron::on_new_publication_t,
            pub m_onNewSubscriptionHandler: root::aeron::on_new_subscription_t,
            pub m_onAvailableImageHandler: root::aeron::on_available_image_t,
            pub m_onUnavailableImageHandler: root::aeron::on_unavailable_image_t,
            pub m_onAvailableCounterHandler: root::aeron::on_available_counter_t,
            pub m_onUnavailableCounterHandler: root::aeron::on_unavailable_counter_t,
            pub m_onCloseClientHandler: root::aeron::on_close_client_t,
            pub m_mediaDriverTimeout: ::std::os::raw::c_long,
            pub m_resourceLingerTimeout: ::std::os::raw::c_long,
            pub m_useConductorAgentInvoker: bool,
            pub m_isOnNewExclusivePublicationHandlerSet: bool,
            pub m_preTouchMappedMemory: bool,
        }
        #[test]
        fn bindgen_test_layout_Context() {
            const UNINIT: ::std::mem::MaybeUninit<Context> = ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<Context>(),
                344usize,
                concat!("Size of: ", stringify!(Context))
            );
            assert_eq!(
                ::std::mem::align_of::<Context>(),
                8usize,
                concat!("Alignment of ", stringify!(Context))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_dirName) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Context),
                    "::",
                    stringify!(m_dirName)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_exceptionHandler) as usize - ptr as usize },
                32usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Context),
                    "::",
                    stringify!(m_exceptionHandler)
                )
            );
            assert_eq!(
                unsafe {
                    ::std::ptr::addr_of!((*ptr).m_onNewPublicationHandler) as usize - ptr as usize
                },
                64usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Context),
                    "::",
                    stringify!(m_onNewPublicationHandler)
                )
            );
            assert_eq!(
                unsafe {
                    ::std::ptr::addr_of!((*ptr).m_onNewExclusivePublicationHandler) as usize
                        - ptr as usize
                },
                96usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Context),
                    "::",
                    stringify!(m_onNewExclusivePublicationHandler)
                )
            );
            assert_eq!(
                unsafe {
                    ::std::ptr::addr_of!((*ptr).m_onNewSubscriptionHandler) as usize - ptr as usize
                },
                128usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Context),
                    "::",
                    stringify!(m_onNewSubscriptionHandler)
                )
            );
            assert_eq!(
                unsafe {
                    ::std::ptr::addr_of!((*ptr).m_onAvailableImageHandler) as usize - ptr as usize
                },
                160usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Context),
                    "::",
                    stringify!(m_onAvailableImageHandler)
                )
            );
            assert_eq!(
                unsafe {
                    ::std::ptr::addr_of!((*ptr).m_onUnavailableImageHandler) as usize - ptr as usize
                },
                192usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Context),
                    "::",
                    stringify!(m_onUnavailableImageHandler)
                )
            );
            assert_eq!(
                unsafe {
                    ::std::ptr::addr_of!((*ptr).m_onAvailableCounterHandler) as usize - ptr as usize
                },
                224usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Context),
                    "::",
                    stringify!(m_onAvailableCounterHandler)
                )
            );
            assert_eq!(
                unsafe {
                    ::std::ptr::addr_of!((*ptr).m_onUnavailableCounterHandler) as usize
                        - ptr as usize
                },
                256usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Context),
                    "::",
                    stringify!(m_onUnavailableCounterHandler)
                )
            );
            assert_eq!(
                unsafe {
                    ::std::ptr::addr_of!((*ptr).m_onCloseClientHandler) as usize - ptr as usize
                },
                288usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Context),
                    "::",
                    stringify!(m_onCloseClientHandler)
                )
            );
            assert_eq!(
                unsafe {
                    ::std::ptr::addr_of!((*ptr).m_mediaDriverTimeout) as usize - ptr as usize
                },
                320usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Context),
                    "::",
                    stringify!(m_mediaDriverTimeout)
                )
            );
            assert_eq!(
                unsafe {
                    ::std::ptr::addr_of!((*ptr).m_resourceLingerTimeout) as usize - ptr as usize
                },
                328usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Context),
                    "::",
                    stringify!(m_resourceLingerTimeout)
                )
            );
            assert_eq!(
                unsafe {
                    ::std::ptr::addr_of!((*ptr).m_useConductorAgentInvoker) as usize - ptr as usize
                },
                336usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Context),
                    "::",
                    stringify!(m_useConductorAgentInvoker)
                )
            );
            assert_eq!(
                unsafe {
                    ::std::ptr::addr_of!((*ptr).m_isOnNewExclusivePublicationHandlerSet) as usize
                        - ptr as usize
                },
                337usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Context),
                    "::",
                    stringify!(m_isOnNewExclusivePublicationHandlerSet)
                )
            );
            assert_eq!(
                unsafe {
                    ::std::ptr::addr_of!((*ptr).m_preTouchMappedMemory) as usize - ptr as usize
                },
                338usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Context),
                    "::",
                    stringify!(m_preTouchMappedMemory)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5aeron7Context8concludeEv"]
            pub fn Context_conclude(this: *mut root::aeron::Context) -> *mut root::aeron::Context;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5aeron7Context8aeronDirERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
            pub fn Context_aeronDir(
                this: *mut root::aeron::Context,
                directory: *const root::std::string,
            ) -> *mut root::aeron::Context;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNK5aeron7Context11cncFileNameB5cxx11Ev"]
            pub fn Context_cncFileName(this: *const root::aeron::Context) -> root::std::string;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5aeron7Context12errorHandlerERKSt8functionIFvRKSt9exceptionEE"]
            pub fn Context_errorHandler(
                this: *mut root::aeron::Context,
                handler: *const root::aeron::util::exception_handler_t,
            ) -> *mut root::aeron::Context;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5aeron7Context21newPublicationHandlerERKSt8functionIFvRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEiilEE"]
            pub fn Context_newPublicationHandler(
                this: *mut root::aeron::Context,
                handler: *const root::aeron::on_new_publication_t,
            ) -> *mut root::aeron::Context;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5aeron7Context30newExclusivePublicationHandlerERKSt8functionIFvRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEiilEE"]
            pub fn Context_newExclusivePublicationHandler(
                this: *mut root::aeron::Context,
                handler: *const root::aeron::on_new_publication_t,
            ) -> *mut root::aeron::Context;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5aeron7Context22newSubscriptionHandlerERKSt8functionIFvRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEilEE"]
            pub fn Context_newSubscriptionHandler(
                this: *mut root::aeron::Context,
                handler: *const root::aeron::on_new_subscription_t,
            ) -> *mut root::aeron::Context;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5aeron7Context21availableImageHandlerERKSt8functionIFvRNS_5ImageEEE"]
            pub fn Context_availableImageHandler(
                this: *mut root::aeron::Context,
                handler: *const root::aeron::on_available_image_t,
            ) -> *mut root::aeron::Context;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5aeron7Context23unavailableImageHandlerERKSt8functionIFvRNS_5ImageEEE"]
            pub fn Context_unavailableImageHandler(
                this: *mut root::aeron::Context,
                handler: *const root::aeron::on_unavailable_image_t,
            ) -> *mut root::aeron::Context;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5aeron7Context23availableCounterHandlerERKSt8functionIFvRNS_10concurrent14CountersReaderEliEE"]
            pub fn Context_availableCounterHandler(
                this: *mut root::aeron::Context,
                handler: *const root::aeron::on_available_counter_t,
            ) -> *mut root::aeron::Context;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5aeron7Context25unavailableCounterHandlerERKSt8functionIFvRNS_10concurrent14CountersReaderEliEE"]
            pub fn Context_unavailableCounterHandler(
                this: *mut root::aeron::Context,
                handler: *const root::aeron::on_unavailable_counter_t,
            ) -> *mut root::aeron::Context;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5aeron7Context18closeClientHandlerERKSt8functionIFvvEE"]
            pub fn Context_closeClientHandler(
                this: *mut root::aeron::Context,
                handler: *const root::aeron::on_close_client_t,
            ) -> *mut root::aeron::Context;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5aeron7Context18mediaDriverTimeoutEl"]
            pub fn Context_mediaDriverTimeout(
                this: *mut root::aeron::Context,
                value: ::std::os::raw::c_long,
            ) -> *mut root::aeron::Context;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNK5aeron7Context18mediaDriverTimeoutEv"]
            pub fn Context_mediaDriverTimeout1(
                this: *const root::aeron::Context,
            ) -> ::std::os::raw::c_long;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5aeron7Context21resourceLingerTimeoutEl"]
            pub fn Context_resourceLingerTimeout(
                this: *mut root::aeron::Context,
                value: ::std::os::raw::c_long,
            ) -> *mut root::aeron::Context;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5aeron7Context24useConductorAgentInvokerEb"]
            pub fn Context_useConductorAgentInvoker(
                this: *mut root::aeron::Context,
                useConductorAgentInvoker: bool,
            ) -> *mut root::aeron::Context;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5aeron7Context20preTouchMappedMemoryEb"]
            pub fn Context_preTouchMappedMemory(
                this: *mut root::aeron::Context,
                preTouchMappedMemory: bool,
            ) -> *mut root::aeron::Context;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5aeron7Context24requestDriverTerminationERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEPKhm"]
            pub fn Context_requestDriverTermination(
                directory: *const root::std::string,
                tokenBuffer: *mut ::std::os::raw::c_uchar,
                tokenLength: usize,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5aeron7Context16defaultAeronPathB5cxx11Ev"]
            pub fn Context_defaultAeronPath() -> root::std::string;
        }
        impl Context {
            #[inline]
            pub unsafe fn conclude(&mut self) -> *mut root::aeron::Context {
                Context_conclude(self)
            }
            #[inline]
            pub unsafe fn aeronDir(
                &mut self,
                directory: *const root::std::string,
            ) -> *mut root::aeron::Context {
                Context_aeronDir(self, directory)
            }
            #[inline]
            pub unsafe fn cncFileName(&self) -> root::std::string {
                Context_cncFileName(self)
            }
            #[inline]
            pub unsafe fn errorHandler(
                &mut self,
                handler: *const root::aeron::util::exception_handler_t,
            ) -> *mut root::aeron::Context {
                Context_errorHandler(self, handler)
            }
            #[inline]
            pub unsafe fn newPublicationHandler(
                &mut self,
                handler: *const root::aeron::on_new_publication_t,
            ) -> *mut root::aeron::Context {
                Context_newPublicationHandler(self, handler)
            }
            #[inline]
            pub unsafe fn newExclusivePublicationHandler(
                &mut self,
                handler: *const root::aeron::on_new_publication_t,
            ) -> *mut root::aeron::Context {
                Context_newExclusivePublicationHandler(self, handler)
            }
            #[inline]
            pub unsafe fn newSubscriptionHandler(
                &mut self,
                handler: *const root::aeron::on_new_subscription_t,
            ) -> *mut root::aeron::Context {
                Context_newSubscriptionHandler(self, handler)
            }
            #[inline]
            pub unsafe fn availableImageHandler(
                &mut self,
                handler: *const root::aeron::on_available_image_t,
            ) -> *mut root::aeron::Context {
                Context_availableImageHandler(self, handler)
            }
            #[inline]
            pub unsafe fn unavailableImageHandler(
                &mut self,
                handler: *const root::aeron::on_unavailable_image_t,
            ) -> *mut root::aeron::Context {
                Context_unavailableImageHandler(self, handler)
            }
            #[inline]
            pub unsafe fn availableCounterHandler(
                &mut self,
                handler: *const root::aeron::on_available_counter_t,
            ) -> *mut root::aeron::Context {
                Context_availableCounterHandler(self, handler)
            }
            #[inline]
            pub unsafe fn unavailableCounterHandler(
                &mut self,
                handler: *const root::aeron::on_unavailable_counter_t,
            ) -> *mut root::aeron::Context {
                Context_unavailableCounterHandler(self, handler)
            }
            #[inline]
            pub unsafe fn closeClientHandler(
                &mut self,
                handler: *const root::aeron::on_close_client_t,
            ) -> *mut root::aeron::Context {
                Context_closeClientHandler(self, handler)
            }
            #[inline]
            pub unsafe fn mediaDriverTimeout(
                &mut self,
                value: ::std::os::raw::c_long,
            ) -> *mut root::aeron::Context {
                Context_mediaDriverTimeout(self, value)
            }
            #[inline]
            pub unsafe fn mediaDriverTimeout1(&self) -> ::std::os::raw::c_long {
                Context_mediaDriverTimeout1(self)
            }
            #[inline]
            pub unsafe fn resourceLingerTimeout(
                &mut self,
                value: ::std::os::raw::c_long,
            ) -> *mut root::aeron::Context {
                Context_resourceLingerTimeout(self, value)
            }
            #[inline]
            pub unsafe fn useConductorAgentInvoker(
                &mut self,
                useConductorAgentInvoker: bool,
            ) -> *mut root::aeron::Context {
                Context_useConductorAgentInvoker(self, useConductorAgentInvoker)
            }
            #[inline]
            pub unsafe fn preTouchMappedMemory(
                &mut self,
                preTouchMappedMemory: bool,
            ) -> *mut root::aeron::Context {
                Context_preTouchMappedMemory(self, preTouchMappedMemory)
            }
            #[inline]
            pub unsafe fn requestDriverTermination(
                directory: *const root::std::string,
                tokenBuffer: *mut ::std::os::raw::c_uchar,
                tokenLength: usize,
            ) -> bool {
                Context_requestDriverTermination(directory, tokenBuffer, tokenLength)
            }
            #[inline]
            pub unsafe fn defaultAeronPath() -> root::std::string {
                Context_defaultAeronPath()
            }
        }
        #[repr(C)]
        #[derive(Copy, Clone)]
        pub struct DriverListenerAdapter<DriverListener> {
            pub m_broadcastReceiver: *mut root::aeron::concurrent::broadcast::CopyBroadcastReceiver,
            pub m_driverListener: *mut DriverListener,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<DriverListener>>,
        }
        pub mod HeartbeatTimestamp {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            #[repr(C, packed(4))]
            #[derive(Copy, Clone)]
            pub struct HeartbeatTimestampKeyDefn {
                pub registrationId: ::std::os::raw::c_long,
            }
            #[test]
            fn bindgen_test_layout_HeartbeatTimestampKeyDefn() {
                const UNINIT: ::std::mem::MaybeUninit<HeartbeatTimestampKeyDefn> =
                    ::std::mem::MaybeUninit::uninit();
                let ptr = UNINIT.as_ptr();
                assert_eq!(
                    ::std::mem::size_of::<HeartbeatTimestampKeyDefn>(),
                    8usize,
                    concat!("Size of: ", stringify!(HeartbeatTimestampKeyDefn))
                );
                assert_eq!(
                    ::std::mem::align_of::<HeartbeatTimestampKeyDefn>(),
                    4usize,
                    concat!("Alignment of ", stringify!(HeartbeatTimestampKeyDefn))
                );
                assert_eq!(
                    unsafe { ::std::ptr::addr_of!((*ptr).registrationId) as usize - ptr as usize },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(HeartbeatTimestampKeyDefn),
                        "::",
                        stringify!(registrationId)
                    )
                );
            }
        }
        pub type epoch_clock_t = [u64; 4usize];
        pub type nano_clock_t = [u64; 4usize];
        #[repr(C)]
        pub struct ClientConductor {
            pub m_publicationByRegistrationId: [u64; 7usize],
            pub m_exclusivePublicationByRegistrationId: [u64; 7usize],
            pub m_subscriptionByRegistrationId: [u64; 7usize],
            pub m_counterByRegistrationId: [u64; 7usize],
            pub m_destinationStateByCorrelationId: [u64; 7usize],
            pub m_logBuffersByRegistrationId: [u64; 7usize],
            pub m_lingeringImageLists: [u64; 3usize],
            pub m_driverProxy: *mut root::aeron::DriverProxy,
            pub m_driverListenerAdapter:
                root::aeron::DriverListenerAdapter<root::aeron::ClientConductor>,
            pub m_countersReader: root::aeron::concurrent::CountersReader,
            pub m_counterValuesBuffer: *mut root::aeron::concurrent::AtomicBuffer,
            pub m_onNewPublicationHandler: root::aeron::on_new_publication_t,
            pub m_onNewExclusivePublicationHandler: root::aeron::on_new_publication_t,
            pub m_onNewSubscriptionHandler: root::aeron::on_new_subscription_t,
            pub m_errorHandler: root::aeron::util::exception_handler_t,
            pub m_onAvailableCounterHandlers: [u64; 3usize],
            pub m_onUnavailableCounterHandlers: [u64; 3usize],
            pub m_onCloseClientHandlers: [u64; 3usize],
            pub m_epochClock: root::aeron::epoch_clock_t,
            pub m_driverTimeoutMs: ::std::os::raw::c_long,
            pub m_resourceLingerTimeoutMs: ::std::os::raw::c_long,
            pub m_interServiceTimeoutMs: ::std::os::raw::c_long,
            pub m_preTouchMappedMemory: bool,
            pub m_isInCallback: bool,
            pub m_driverActive: u8,
            pub m_isClosed: u8,
            pub m_adminLock: root::std::recursive_mutex,
            pub m_heartbeatTimestamp: u64,
            pub m_timeOfLastDoWorkMs: ::std::os::raw::c_longlong,
            pub m_timeOfLastKeepaliveMs: ::std::os::raw::c_longlong,
            pub m_timeOfLastCheckManagedResourcesMs: ::std::os::raw::c_longlong,
            pub m_padding: [::std::os::raw::c_char; 64usize],
        }
        pub const ClientConductor_RegistrationStatus_AWAITING_MEDIA_DRIVER:
            root::aeron::ClientConductor_RegistrationStatus = 0;
        pub const ClientConductor_RegistrationStatus_REGISTERED_MEDIA_DRIVER:
            root::aeron::ClientConductor_RegistrationStatus = 1;
        pub const ClientConductor_RegistrationStatus_ERRORED_MEDIA_DRIVER:
            root::aeron::ClientConductor_RegistrationStatus = 2;
        pub type ClientConductor_RegistrationStatus = ::std::os::raw::c_schar;
        #[repr(C)]
        pub struct ClientConductor_PublicationStateDefn {
            pub m_errorMessage: root::std::string,
            pub m_buffers: [u64; 2usize],
            pub m_publication: [u64; 2usize],
            pub m_channel: root::std::string,
            pub m_registrationId: ::std::os::raw::c_long,
            pub m_originalRegistrationId: ::std::os::raw::c_long,
            pub m_timeOfRegistrationMs: ::std::os::raw::c_longlong,
            pub m_streamId: ::std::os::raw::c_int,
            pub m_sessionId: ::std::os::raw::c_int,
            pub m_publicationLimitCounterId: ::std::os::raw::c_int,
            pub m_channelStatusId: ::std::os::raw::c_int,
            pub m_errorCode: ::std::os::raw::c_int,
            pub m_status: root::aeron::ClientConductor_RegistrationStatus,
        }
        #[test]
        fn bindgen_test_layout_ClientConductor_PublicationStateDefn() {
            const UNINIT: ::std::mem::MaybeUninit<ClientConductor_PublicationStateDefn> =
                ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<ClientConductor_PublicationStateDefn>(),
                144usize,
                concat!(
                    "Size of: ",
                    stringify!(ClientConductor_PublicationStateDefn)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<ClientConductor_PublicationStateDefn>(),
                8usize,
                concat!(
                    "Alignment of ",
                    stringify!(ClientConductor_PublicationStateDefn)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_errorMessage) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ClientConductor_PublicationStateDefn),
                    "::",
                    stringify!(m_errorMessage)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_buffers) as usize - ptr as usize },
                32usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ClientConductor_PublicationStateDefn),
                    "::",
                    stringify!(m_buffers)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_publication) as usize - ptr as usize },
                48usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ClientConductor_PublicationStateDefn),
                    "::",
                    stringify!(m_publication)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_channel) as usize - ptr as usize },
                64usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ClientConductor_PublicationStateDefn),
                    "::",
                    stringify!(m_channel)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_registrationId) as usize - ptr as usize },
                96usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ClientConductor_PublicationStateDefn),
                    "::",
                    stringify!(m_registrationId)
                )
            );
            assert_eq!(
                unsafe {
                    ::std::ptr::addr_of!((*ptr).m_originalRegistrationId) as usize - ptr as usize
                },
                104usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ClientConductor_PublicationStateDefn),
                    "::",
                    stringify!(m_originalRegistrationId)
                )
            );
            assert_eq!(
                unsafe {
                    ::std::ptr::addr_of!((*ptr).m_timeOfRegistrationMs) as usize - ptr as usize
                },
                112usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ClientConductor_PublicationStateDefn),
                    "::",
                    stringify!(m_timeOfRegistrationMs)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_streamId) as usize - ptr as usize },
                120usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ClientConductor_PublicationStateDefn),
                    "::",
                    stringify!(m_streamId)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_sessionId) as usize - ptr as usize },
                124usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ClientConductor_PublicationStateDefn),
                    "::",
                    stringify!(m_sessionId)
                )
            );
            assert_eq!(
                unsafe {
                    ::std::ptr::addr_of!((*ptr).m_publicationLimitCounterId) as usize - ptr as usize
                },
                128usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ClientConductor_PublicationStateDefn),
                    "::",
                    stringify!(m_publicationLimitCounterId)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_channelStatusId) as usize - ptr as usize },
                132usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ClientConductor_PublicationStateDefn),
                    "::",
                    stringify!(m_channelStatusId)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_errorCode) as usize - ptr as usize },
                136usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ClientConductor_PublicationStateDefn),
                    "::",
                    stringify!(m_errorCode)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_status) as usize - ptr as usize },
                140usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ClientConductor_PublicationStateDefn),
                    "::",
                    stringify!(m_status)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5aeron15ClientConductor20PublicationStateDefnC1ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEElix"]
            pub fn ClientConductor_PublicationStateDefn_PublicationStateDefn(
                this: *mut root::aeron::ClientConductor_PublicationStateDefn,
                channel: *const root::std::string,
                registrationId: ::std::os::raw::c_long,
                streamId: ::std::os::raw::c_int,
                nowMs: ::std::os::raw::c_longlong,
            );
        }
        impl ClientConductor_PublicationStateDefn {
            #[inline]
            pub unsafe fn new(
                channel: *const root::std::string,
                registrationId: ::std::os::raw::c_long,
                streamId: ::std::os::raw::c_int,
                nowMs: ::std::os::raw::c_longlong,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                ClientConductor_PublicationStateDefn_PublicationStateDefn(
                    __bindgen_tmp.as_mut_ptr(),
                    channel,
                    registrationId,
                    streamId,
                    nowMs,
                );
                __bindgen_tmp.assume_init()
            }
        }
        #[repr(C)]
        pub struct ClientConductor_ExclusivePublicationStateDefn {
            pub m_errorMessage: root::std::string,
            pub m_buffers: [u64; 2usize],
            pub m_publication: [u64; 2usize],
            pub m_channel: root::std::string,
            pub m_registrationId: ::std::os::raw::c_long,
            pub m_timeOfRegistrationMs: ::std::os::raw::c_longlong,
            pub m_streamId: ::std::os::raw::c_int,
            pub m_sessionId: ::std::os::raw::c_int,
            pub m_publicationLimitCounterId: ::std::os::raw::c_int,
            pub m_channelStatusId: ::std::os::raw::c_int,
            pub m_errorCode: ::std::os::raw::c_int,
            pub m_status: root::aeron::ClientConductor_RegistrationStatus,
        }
        #[test]
        fn bindgen_test_layout_ClientConductor_ExclusivePublicationStateDefn() {
            const UNINIT: ::std::mem::MaybeUninit<ClientConductor_ExclusivePublicationStateDefn> =
                ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<ClientConductor_ExclusivePublicationStateDefn>(),
                136usize,
                concat!(
                    "Size of: ",
                    stringify!(ClientConductor_ExclusivePublicationStateDefn)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<ClientConductor_ExclusivePublicationStateDefn>(),
                8usize,
                concat!(
                    "Alignment of ",
                    stringify!(ClientConductor_ExclusivePublicationStateDefn)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_errorMessage) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ClientConductor_ExclusivePublicationStateDefn),
                    "::",
                    stringify!(m_errorMessage)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_buffers) as usize - ptr as usize },
                32usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ClientConductor_ExclusivePublicationStateDefn),
                    "::",
                    stringify!(m_buffers)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_publication) as usize - ptr as usize },
                48usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ClientConductor_ExclusivePublicationStateDefn),
                    "::",
                    stringify!(m_publication)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_channel) as usize - ptr as usize },
                64usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ClientConductor_ExclusivePublicationStateDefn),
                    "::",
                    stringify!(m_channel)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_registrationId) as usize - ptr as usize },
                96usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ClientConductor_ExclusivePublicationStateDefn),
                    "::",
                    stringify!(m_registrationId)
                )
            );
            assert_eq!(
                unsafe {
                    ::std::ptr::addr_of!((*ptr).m_timeOfRegistrationMs) as usize - ptr as usize
                },
                104usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ClientConductor_ExclusivePublicationStateDefn),
                    "::",
                    stringify!(m_timeOfRegistrationMs)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_streamId) as usize - ptr as usize },
                112usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ClientConductor_ExclusivePublicationStateDefn),
                    "::",
                    stringify!(m_streamId)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_sessionId) as usize - ptr as usize },
                116usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ClientConductor_ExclusivePublicationStateDefn),
                    "::",
                    stringify!(m_sessionId)
                )
            );
            assert_eq!(
                unsafe {
                    ::std::ptr::addr_of!((*ptr).m_publicationLimitCounterId) as usize - ptr as usize
                },
                120usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ClientConductor_ExclusivePublicationStateDefn),
                    "::",
                    stringify!(m_publicationLimitCounterId)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_channelStatusId) as usize - ptr as usize },
                124usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ClientConductor_ExclusivePublicationStateDefn),
                    "::",
                    stringify!(m_channelStatusId)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_errorCode) as usize - ptr as usize },
                128usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ClientConductor_ExclusivePublicationStateDefn),
                    "::",
                    stringify!(m_errorCode)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_status) as usize - ptr as usize },
                132usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ClientConductor_ExclusivePublicationStateDefn),
                    "::",
                    stringify!(m_status)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5aeron15ClientConductor29ExclusivePublicationStateDefnC1ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEElix"]
            pub fn ClientConductor_ExclusivePublicationStateDefn_ExclusivePublicationStateDefn(
                this: *mut root::aeron::ClientConductor_ExclusivePublicationStateDefn,
                channel: *const root::std::string,
                registrationId: ::std::os::raw::c_long,
                streamId: ::std::os::raw::c_int,
                nowMs: ::std::os::raw::c_longlong,
            );
        }
        impl ClientConductor_ExclusivePublicationStateDefn {
            #[inline]
            pub unsafe fn new(
                channel: *const root::std::string,
                registrationId: ::std::os::raw::c_long,
                streamId: ::std::os::raw::c_int,
                nowMs: ::std::os::raw::c_longlong,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                ClientConductor_ExclusivePublicationStateDefn_ExclusivePublicationStateDefn(
                    __bindgen_tmp.as_mut_ptr(),
                    channel,
                    registrationId,
                    streamId,
                    nowMs,
                );
                __bindgen_tmp.assume_init()
            }
        }
        #[repr(C)]
        pub struct ClientConductor_SubscriptionStateDefn {
            pub m_errorMessage: root::std::string,
            pub m_subscriptionCache: [u64; 2usize],
            pub m_subscription: [u64; 2usize],
            pub m_onAvailableImageHandler: root::aeron::on_available_image_t,
            pub m_onUnavailableImageHandler: root::aeron::on_unavailable_image_t,
            pub m_channel: root::std::string,
            pub m_registrationId: ::std::os::raw::c_long,
            pub m_timeOfRegistrationMs: ::std::os::raw::c_longlong,
            pub m_streamId: ::std::os::raw::c_int,
            pub m_errorCode: ::std::os::raw::c_int,
            pub m_status: root::aeron::ClientConductor_RegistrationStatus,
        }
        #[test]
        fn bindgen_test_layout_ClientConductor_SubscriptionStateDefn() {
            const UNINIT: ::std::mem::MaybeUninit<ClientConductor_SubscriptionStateDefn> =
                ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<ClientConductor_SubscriptionStateDefn>(),
                192usize,
                concat!(
                    "Size of: ",
                    stringify!(ClientConductor_SubscriptionStateDefn)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<ClientConductor_SubscriptionStateDefn>(),
                8usize,
                concat!(
                    "Alignment of ",
                    stringify!(ClientConductor_SubscriptionStateDefn)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_errorMessage) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ClientConductor_SubscriptionStateDefn),
                    "::",
                    stringify!(m_errorMessage)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_subscriptionCache) as usize - ptr as usize },
                32usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ClientConductor_SubscriptionStateDefn),
                    "::",
                    stringify!(m_subscriptionCache)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_subscription) as usize - ptr as usize },
                48usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ClientConductor_SubscriptionStateDefn),
                    "::",
                    stringify!(m_subscription)
                )
            );
            assert_eq!(
                unsafe {
                    ::std::ptr::addr_of!((*ptr).m_onAvailableImageHandler) as usize - ptr as usize
                },
                64usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ClientConductor_SubscriptionStateDefn),
                    "::",
                    stringify!(m_onAvailableImageHandler)
                )
            );
            assert_eq!(
                unsafe {
                    ::std::ptr::addr_of!((*ptr).m_onUnavailableImageHandler) as usize - ptr as usize
                },
                96usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ClientConductor_SubscriptionStateDefn),
                    "::",
                    stringify!(m_onUnavailableImageHandler)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_channel) as usize - ptr as usize },
                128usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ClientConductor_SubscriptionStateDefn),
                    "::",
                    stringify!(m_channel)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_registrationId) as usize - ptr as usize },
                160usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ClientConductor_SubscriptionStateDefn),
                    "::",
                    stringify!(m_registrationId)
                )
            );
            assert_eq!(
                unsafe {
                    ::std::ptr::addr_of!((*ptr).m_timeOfRegistrationMs) as usize - ptr as usize
                },
                168usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ClientConductor_SubscriptionStateDefn),
                    "::",
                    stringify!(m_timeOfRegistrationMs)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_streamId) as usize - ptr as usize },
                176usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ClientConductor_SubscriptionStateDefn),
                    "::",
                    stringify!(m_streamId)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_errorCode) as usize - ptr as usize },
                180usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ClientConductor_SubscriptionStateDefn),
                    "::",
                    stringify!(m_errorCode)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_status) as usize - ptr as usize },
                184usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ClientConductor_SubscriptionStateDefn),
                    "::",
                    stringify!(m_status)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5aeron15ClientConductor21SubscriptionStateDefnC1ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEElixRKSt8functionIFvRNS_5ImageEEESG_"]
            pub fn ClientConductor_SubscriptionStateDefn_SubscriptionStateDefn(
                this: *mut root::aeron::ClientConductor_SubscriptionStateDefn,
                channel: *const root::std::string,
                registrationId: ::std::os::raw::c_long,
                streamId: ::std::os::raw::c_int,
                nowMs: ::std::os::raw::c_longlong,
                onAvailableImageHandler: *const root::aeron::on_available_image_t,
                onUnavailableImageHandler: *const root::aeron::on_unavailable_image_t,
            );
        }
        impl ClientConductor_SubscriptionStateDefn {
            #[inline]
            pub unsafe fn new(
                channel: *const root::std::string,
                registrationId: ::std::os::raw::c_long,
                streamId: ::std::os::raw::c_int,
                nowMs: ::std::os::raw::c_longlong,
                onAvailableImageHandler: *const root::aeron::on_available_image_t,
                onUnavailableImageHandler: *const root::aeron::on_unavailable_image_t,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                ClientConductor_SubscriptionStateDefn_SubscriptionStateDefn(
                    __bindgen_tmp.as_mut_ptr(),
                    channel,
                    registrationId,
                    streamId,
                    nowMs,
                    onAvailableImageHandler,
                    onUnavailableImageHandler,
                );
                __bindgen_tmp.assume_init()
            }
        }
        #[repr(C)]
        pub struct ClientConductor_CounterStateDefn {
            pub m_errorMessage: root::std::string,
            pub m_counterCache: [u64; 2usize],
            pub m_counter: [u64; 2usize],
            pub m_registrationId: ::std::os::raw::c_long,
            pub m_timeOfRegistrationMs: ::std::os::raw::c_longlong,
            pub m_counterId: ::std::os::raw::c_int,
            pub m_status: root::aeron::ClientConductor_RegistrationStatus,
            pub m_errorCode: ::std::os::raw::c_int,
        }
        #[test]
        fn bindgen_test_layout_ClientConductor_CounterStateDefn() {
            const UNINIT: ::std::mem::MaybeUninit<ClientConductor_CounterStateDefn> =
                ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<ClientConductor_CounterStateDefn>(),
                96usize,
                concat!("Size of: ", stringify!(ClientConductor_CounterStateDefn))
            );
            assert_eq!(
                ::std::mem::align_of::<ClientConductor_CounterStateDefn>(),
                8usize,
                concat!(
                    "Alignment of ",
                    stringify!(ClientConductor_CounterStateDefn)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_errorMessage) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ClientConductor_CounterStateDefn),
                    "::",
                    stringify!(m_errorMessage)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_counterCache) as usize - ptr as usize },
                32usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ClientConductor_CounterStateDefn),
                    "::",
                    stringify!(m_counterCache)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_counter) as usize - ptr as usize },
                48usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ClientConductor_CounterStateDefn),
                    "::",
                    stringify!(m_counter)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_registrationId) as usize - ptr as usize },
                64usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ClientConductor_CounterStateDefn),
                    "::",
                    stringify!(m_registrationId)
                )
            );
            assert_eq!(
                unsafe {
                    ::std::ptr::addr_of!((*ptr).m_timeOfRegistrationMs) as usize - ptr as usize
                },
                72usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ClientConductor_CounterStateDefn),
                    "::",
                    stringify!(m_timeOfRegistrationMs)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_counterId) as usize - ptr as usize },
                80usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ClientConductor_CounterStateDefn),
                    "::",
                    stringify!(m_counterId)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_status) as usize - ptr as usize },
                84usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ClientConductor_CounterStateDefn),
                    "::",
                    stringify!(m_status)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_errorCode) as usize - ptr as usize },
                88usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ClientConductor_CounterStateDefn),
                    "::",
                    stringify!(m_errorCode)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5aeron15ClientConductor16CounterStateDefnC1Elx"]
            pub fn ClientConductor_CounterStateDefn_CounterStateDefn(
                this: *mut root::aeron::ClientConductor_CounterStateDefn,
                registrationId: ::std::os::raw::c_long,
                nowMs: ::std::os::raw::c_longlong,
            );
        }
        impl ClientConductor_CounterStateDefn {
            #[inline]
            pub unsafe fn new(
                registrationId: ::std::os::raw::c_long,
                nowMs: ::std::os::raw::c_longlong,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                ClientConductor_CounterStateDefn_CounterStateDefn(
                    __bindgen_tmp.as_mut_ptr(),
                    registrationId,
                    nowMs,
                );
                __bindgen_tmp.assume_init()
            }
        }
        #[repr(C)]
        #[derive(Copy, Clone)]
        pub struct ClientConductor_ImageListLingerDefn {
            pub m_imageArray: root::aeron::Image_array_t,
            pub m_timeOfLastStateChangeMs: ::std::os::raw::c_longlong,
        }
        #[test]
        fn bindgen_test_layout_ClientConductor_ImageListLingerDefn() {
            const UNINIT: ::std::mem::MaybeUninit<ClientConductor_ImageListLingerDefn> =
                ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<ClientConductor_ImageListLingerDefn>(),
                16usize,
                concat!("Size of: ", stringify!(ClientConductor_ImageListLingerDefn))
            );
            assert_eq!(
                ::std::mem::align_of::<ClientConductor_ImageListLingerDefn>(),
                8usize,
                concat!(
                    "Alignment of ",
                    stringify!(ClientConductor_ImageListLingerDefn)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_imageArray) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ClientConductor_ImageListLingerDefn),
                    "::",
                    stringify!(m_imageArray)
                )
            );
            assert_eq!(
                unsafe {
                    ::std::ptr::addr_of!((*ptr).m_timeOfLastStateChangeMs) as usize - ptr as usize
                },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ClientConductor_ImageListLingerDefn),
                    "::",
                    stringify!(m_timeOfLastStateChangeMs)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5aeron15ClientConductor19ImageListLingerDefnC1ExPSt10shared_ptrINS_5ImageEE"]
            pub fn ClientConductor_ImageListLingerDefn_ImageListLingerDefn(
                this: *mut root::aeron::ClientConductor_ImageListLingerDefn,
                nowMs: ::std::os::raw::c_longlong,
                imageArray: root::aeron::Image_array_t,
            );
        }
        impl ClientConductor_ImageListLingerDefn {
            #[inline]
            pub unsafe fn new(
                nowMs: ::std::os::raw::c_longlong,
                imageArray: root::aeron::Image_array_t,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                ClientConductor_ImageListLingerDefn_ImageListLingerDefn(
                    __bindgen_tmp.as_mut_ptr(),
                    nowMs,
                    imageArray,
                );
                __bindgen_tmp.assume_init()
            }
        }
        #[repr(C)]
        pub struct ClientConductor_LogBuffersDefn {
            pub m_logBuffers: [u64; 2usize],
            pub m_timeOfLastStateChangeMs: ::std::os::raw::c_longlong,
        }
        #[test]
        fn bindgen_test_layout_ClientConductor_LogBuffersDefn() {
            const UNINIT: ::std::mem::MaybeUninit<ClientConductor_LogBuffersDefn> =
                ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<ClientConductor_LogBuffersDefn>(),
                24usize,
                concat!("Size of: ", stringify!(ClientConductor_LogBuffersDefn))
            );
            assert_eq!(
                ::std::mem::align_of::<ClientConductor_LogBuffersDefn>(),
                8usize,
                concat!("Alignment of ", stringify!(ClientConductor_LogBuffersDefn))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_logBuffers) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ClientConductor_LogBuffersDefn),
                    "::",
                    stringify!(m_logBuffers)
                )
            );
            assert_eq!(
                unsafe {
                    ::std::ptr::addr_of!((*ptr).m_timeOfLastStateChangeMs) as usize - ptr as usize
                },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ClientConductor_LogBuffersDefn),
                    "::",
                    stringify!(m_timeOfLastStateChangeMs)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5aeron15ClientConductor14LogBuffersDefnC1ESt10shared_ptrINS_10LogBuffersEE"]
            pub fn ClientConductor_LogBuffersDefn_LogBuffersDefn(
                this: *mut root::aeron::ClientConductor_LogBuffersDefn,
                buffers: [u64; 2usize],
            );
        }
        impl ClientConductor_LogBuffersDefn {
            #[inline]
            pub unsafe fn new(buffers: [u64; 2usize]) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                ClientConductor_LogBuffersDefn_LogBuffersDefn(__bindgen_tmp.as_mut_ptr(), buffers);
                __bindgen_tmp.assume_init()
            }
        }
        #[repr(C)]
        #[derive(Copy, Clone)]
        pub struct ClientConductor_DestinationStateDefn {
            pub m_errorMessage: root::std::string,
            pub m_correlationId: ::std::os::raw::c_long,
            pub m_registrationId: ::std::os::raw::c_long,
            pub m_timeOfRegistrationMs: ::std::os::raw::c_longlong,
            pub m_errorCode: ::std::os::raw::c_int,
            pub m_status: root::aeron::ClientConductor_RegistrationStatus,
        }
        #[test]
        fn bindgen_test_layout_ClientConductor_DestinationStateDefn() {
            const UNINIT: ::std::mem::MaybeUninit<ClientConductor_DestinationStateDefn> =
                ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<ClientConductor_DestinationStateDefn>(),
                64usize,
                concat!(
                    "Size of: ",
                    stringify!(ClientConductor_DestinationStateDefn)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<ClientConductor_DestinationStateDefn>(),
                8usize,
                concat!(
                    "Alignment of ",
                    stringify!(ClientConductor_DestinationStateDefn)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_errorMessage) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ClientConductor_DestinationStateDefn),
                    "::",
                    stringify!(m_errorMessage)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_correlationId) as usize - ptr as usize },
                32usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ClientConductor_DestinationStateDefn),
                    "::",
                    stringify!(m_correlationId)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_registrationId) as usize - ptr as usize },
                40usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ClientConductor_DestinationStateDefn),
                    "::",
                    stringify!(m_registrationId)
                )
            );
            assert_eq!(
                unsafe {
                    ::std::ptr::addr_of!((*ptr).m_timeOfRegistrationMs) as usize - ptr as usize
                },
                48usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ClientConductor_DestinationStateDefn),
                    "::",
                    stringify!(m_timeOfRegistrationMs)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_errorCode) as usize - ptr as usize },
                56usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ClientConductor_DestinationStateDefn),
                    "::",
                    stringify!(m_errorCode)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_status) as usize - ptr as usize },
                60usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ClientConductor_DestinationStateDefn),
                    "::",
                    stringify!(m_status)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5aeron15ClientConductor20DestinationStateDefnC1Ellx"]
            pub fn ClientConductor_DestinationStateDefn_DestinationStateDefn(
                this: *mut root::aeron::ClientConductor_DestinationStateDefn,
                correlationId: ::std::os::raw::c_long,
                registrationId: ::std::os::raw::c_long,
                nowMs: ::std::os::raw::c_longlong,
            );
        }
        impl ClientConductor_DestinationStateDefn {
            #[inline]
            pub unsafe fn new(
                correlationId: ::std::os::raw::c_long,
                registrationId: ::std::os::raw::c_long,
                nowMs: ::std::os::raw::c_longlong,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                ClientConductor_DestinationStateDefn_DestinationStateDefn(
                    __bindgen_tmp.as_mut_ptr(),
                    correlationId,
                    registrationId,
                    nowMs,
                );
                __bindgen_tmp.assume_init()
            }
        }
        #[test]
        fn bindgen_test_layout_ClientConductor() {
            const UNINIT: ::std::mem::MaybeUninit<ClientConductor> =
                ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<ClientConductor>(),
                832usize,
                concat!("Size of: ", stringify!(ClientConductor))
            );
            assert_eq!(
                ::std::mem::align_of::<ClientConductor>(),
                8usize,
                concat!("Alignment of ", stringify!(ClientConductor))
            );
            assert_eq!(
                unsafe {
                    ::std::ptr::addr_of!((*ptr).m_publicationByRegistrationId) as usize
                        - ptr as usize
                },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ClientConductor),
                    "::",
                    stringify!(m_publicationByRegistrationId)
                )
            );
            assert_eq!(
                unsafe {
                    ::std::ptr::addr_of!((*ptr).m_exclusivePublicationByRegistrationId) as usize
                        - ptr as usize
                },
                56usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ClientConductor),
                    "::",
                    stringify!(m_exclusivePublicationByRegistrationId)
                )
            );
            assert_eq!(
                unsafe {
                    ::std::ptr::addr_of!((*ptr).m_subscriptionByRegistrationId) as usize
                        - ptr as usize
                },
                112usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ClientConductor),
                    "::",
                    stringify!(m_subscriptionByRegistrationId)
                )
            );
            assert_eq!(
                unsafe {
                    ::std::ptr::addr_of!((*ptr).m_counterByRegistrationId) as usize - ptr as usize
                },
                168usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ClientConductor),
                    "::",
                    stringify!(m_counterByRegistrationId)
                )
            );
            assert_eq!(
                unsafe {
                    ::std::ptr::addr_of!((*ptr).m_destinationStateByCorrelationId) as usize
                        - ptr as usize
                },
                224usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ClientConductor),
                    "::",
                    stringify!(m_destinationStateByCorrelationId)
                )
            );
            assert_eq!(
                unsafe {
                    ::std::ptr::addr_of!((*ptr).m_logBuffersByRegistrationId) as usize
                        - ptr as usize
                },
                280usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ClientConductor),
                    "::",
                    stringify!(m_logBuffersByRegistrationId)
                )
            );
            assert_eq!(
                unsafe {
                    ::std::ptr::addr_of!((*ptr).m_lingeringImageLists) as usize - ptr as usize
                },
                336usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ClientConductor),
                    "::",
                    stringify!(m_lingeringImageLists)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_driverProxy) as usize - ptr as usize },
                360usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ClientConductor),
                    "::",
                    stringify!(m_driverProxy)
                )
            );
            assert_eq!(
                unsafe {
                    ::std::ptr::addr_of!((*ptr).m_driverListenerAdapter) as usize - ptr as usize
                },
                368usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ClientConductor),
                    "::",
                    stringify!(m_driverListenerAdapter)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_countersReader) as usize - ptr as usize },
                384usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ClientConductor),
                    "::",
                    stringify!(m_countersReader)
                )
            );
            assert_eq!(
                unsafe {
                    ::std::ptr::addr_of!((*ptr).m_counterValuesBuffer) as usize - ptr as usize
                },
                424usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ClientConductor),
                    "::",
                    stringify!(m_counterValuesBuffer)
                )
            );
            assert_eq!(
                unsafe {
                    ::std::ptr::addr_of!((*ptr).m_onNewPublicationHandler) as usize - ptr as usize
                },
                432usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ClientConductor),
                    "::",
                    stringify!(m_onNewPublicationHandler)
                )
            );
            assert_eq!(
                unsafe {
                    ::std::ptr::addr_of!((*ptr).m_onNewExclusivePublicationHandler) as usize
                        - ptr as usize
                },
                464usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ClientConductor),
                    "::",
                    stringify!(m_onNewExclusivePublicationHandler)
                )
            );
            assert_eq!(
                unsafe {
                    ::std::ptr::addr_of!((*ptr).m_onNewSubscriptionHandler) as usize - ptr as usize
                },
                496usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ClientConductor),
                    "::",
                    stringify!(m_onNewSubscriptionHandler)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_errorHandler) as usize - ptr as usize },
                528usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ClientConductor),
                    "::",
                    stringify!(m_errorHandler)
                )
            );
            assert_eq!(
                unsafe {
                    ::std::ptr::addr_of!((*ptr).m_onAvailableCounterHandlers) as usize
                        - ptr as usize
                },
                560usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ClientConductor),
                    "::",
                    stringify!(m_onAvailableCounterHandlers)
                )
            );
            assert_eq!(
                unsafe {
                    ::std::ptr::addr_of!((*ptr).m_onUnavailableCounterHandlers) as usize
                        - ptr as usize
                },
                584usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ClientConductor),
                    "::",
                    stringify!(m_onUnavailableCounterHandlers)
                )
            );
            assert_eq!(
                unsafe {
                    ::std::ptr::addr_of!((*ptr).m_onCloseClientHandlers) as usize - ptr as usize
                },
                608usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ClientConductor),
                    "::",
                    stringify!(m_onCloseClientHandlers)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_epochClock) as usize - ptr as usize },
                632usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ClientConductor),
                    "::",
                    stringify!(m_epochClock)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_driverTimeoutMs) as usize - ptr as usize },
                664usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ClientConductor),
                    "::",
                    stringify!(m_driverTimeoutMs)
                )
            );
            assert_eq!(
                unsafe {
                    ::std::ptr::addr_of!((*ptr).m_resourceLingerTimeoutMs) as usize - ptr as usize
                },
                672usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ClientConductor),
                    "::",
                    stringify!(m_resourceLingerTimeoutMs)
                )
            );
            assert_eq!(
                unsafe {
                    ::std::ptr::addr_of!((*ptr).m_interServiceTimeoutMs) as usize - ptr as usize
                },
                680usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ClientConductor),
                    "::",
                    stringify!(m_interServiceTimeoutMs)
                )
            );
            assert_eq!(
                unsafe {
                    ::std::ptr::addr_of!((*ptr).m_preTouchMappedMemory) as usize - ptr as usize
                },
                688usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ClientConductor),
                    "::",
                    stringify!(m_preTouchMappedMemory)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_isInCallback) as usize - ptr as usize },
                689usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ClientConductor),
                    "::",
                    stringify!(m_isInCallback)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_driverActive) as usize - ptr as usize },
                690usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ClientConductor),
                    "::",
                    stringify!(m_driverActive)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_isClosed) as usize - ptr as usize },
                691usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ClientConductor),
                    "::",
                    stringify!(m_isClosed)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_adminLock) as usize - ptr as usize },
                696usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ClientConductor),
                    "::",
                    stringify!(m_adminLock)
                )
            );
            assert_eq!(
                unsafe {
                    ::std::ptr::addr_of!((*ptr).m_heartbeatTimestamp) as usize - ptr as usize
                },
                736usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ClientConductor),
                    "::",
                    stringify!(m_heartbeatTimestamp)
                )
            );
            assert_eq!(
                unsafe {
                    ::std::ptr::addr_of!((*ptr).m_timeOfLastDoWorkMs) as usize - ptr as usize
                },
                744usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ClientConductor),
                    "::",
                    stringify!(m_timeOfLastDoWorkMs)
                )
            );
            assert_eq!(
                unsafe {
                    ::std::ptr::addr_of!((*ptr).m_timeOfLastKeepaliveMs) as usize - ptr as usize
                },
                752usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ClientConductor),
                    "::",
                    stringify!(m_timeOfLastKeepaliveMs)
                )
            );
            assert_eq!(
                unsafe {
                    ::std::ptr::addr_of!((*ptr).m_timeOfLastCheckManagedResourcesMs) as usize
                        - ptr as usize
                },
                760usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ClientConductor),
                    "::",
                    stringify!(m_timeOfLastCheckManagedResourcesMs)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_padding) as usize - ptr as usize },
                768usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ClientConductor),
                    "::",
                    stringify!(m_padding)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5aeron15ClientConductor7onStartEv"]
            pub fn ClientConductor_onStart(this: *mut root::aeron::ClientConductor);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5aeron15ClientConductor6doWorkEv"]
            pub fn ClientConductor_doWork(
                this: *mut root::aeron::ClientConductor,
            ) -> ::std::os::raw::c_int;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5aeron15ClientConductor7onCloseEv"]
            pub fn ClientConductor_onClose(this: *mut root::aeron::ClientConductor);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5aeron15ClientConductor14addPublicationERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEi"]
            pub fn ClientConductor_addPublication(
                this: *mut root::aeron::ClientConductor,
                channel: *const root::std::string,
                streamId: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_long;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5aeron15ClientConductor15findPublicationEl"]
            pub fn ClientConductor_findPublication(
                this: *mut root::aeron::ClientConductor,
                registrationId: ::std::os::raw::c_long,
            ) -> [u64; 2usize];
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5aeron15ClientConductor18releasePublicationEl"]
            pub fn ClientConductor_releasePublication(
                this: *mut root::aeron::ClientConductor,
                registrationId: ::std::os::raw::c_long,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5aeron15ClientConductor23addExclusivePublicationERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEi"]
            pub fn ClientConductor_addExclusivePublication(
                this: *mut root::aeron::ClientConductor,
                channel: *const root::std::string,
                streamId: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_long;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5aeron15ClientConductor24findExclusivePublicationEl"]
            pub fn ClientConductor_findExclusivePublication(
                this: *mut root::aeron::ClientConductor,
                registrationId: ::std::os::raw::c_long,
            ) -> [u64; 2usize];
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5aeron15ClientConductor27releaseExclusivePublicationEl"]
            pub fn ClientConductor_releaseExclusivePublication(
                this: *mut root::aeron::ClientConductor,
                registrationId: ::std::os::raw::c_long,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5aeron15ClientConductor15addSubscriptionERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEiRKSt8functionIFvRNS_5ImageEEESF_"]
            pub fn ClientConductor_addSubscription(
                this: *mut root::aeron::ClientConductor,
                channel: *const root::std::string,
                streamId: ::std::os::raw::c_int,
                onAvailableImageHandler: *const root::aeron::on_available_image_t,
                onUnavailableImageHandler: *const root::aeron::on_unavailable_image_t,
            ) -> ::std::os::raw::c_long;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5aeron15ClientConductor16findSubscriptionEl"]
            pub fn ClientConductor_findSubscription(
                this: *mut root::aeron::ClientConductor,
                registrationId: ::std::os::raw::c_long,
            ) -> [u64; 2usize];
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5aeron15ClientConductor19releaseSubscriptionElPSt10shared_ptrINS_5ImageEEm"]
            pub fn ClientConductor_releaseSubscription(
                this: *mut root::aeron::ClientConductor,
                registrationId: ::std::os::raw::c_long,
                imageArray: root::aeron::Image_array_t,
                length: usize,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5aeron15ClientConductor10addCounterEiPKhmRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
            pub fn ClientConductor_addCounter(
                this: *mut root::aeron::ClientConductor,
                typeId: ::std::os::raw::c_int,
                keyBuffer: *mut ::std::os::raw::c_uchar,
                keyLength: usize,
                label: *const root::std::string,
            ) -> ::std::os::raw::c_long;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5aeron15ClientConductor11findCounterEl"]
            pub fn ClientConductor_findCounter(
                this: *mut root::aeron::ClientConductor,
                registrationId: ::std::os::raw::c_long,
            ) -> [u64; 2usize];
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5aeron15ClientConductor14releaseCounterEl"]
            pub fn ClientConductor_releaseCounter(
                this: *mut root::aeron::ClientConductor,
                registrationId: ::std::os::raw::c_long,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5aeron15ClientConductor23findDestinationResponseEl"]
            pub fn ClientConductor_findDestinationResponse(
                this: *mut root::aeron::ClientConductor,
                correlationId: ::std::os::raw::c_long,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5aeron15ClientConductor16onNewPublicationElliiiiRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
            pub fn ClientConductor_onNewPublication(
                this: *mut root::aeron::ClientConductor,
                registrationId: ::std::os::raw::c_long,
                originalRegistrationId: ::std::os::raw::c_long,
                streamId: ::std::os::raw::c_int,
                sessionId: ::std::os::raw::c_int,
                publicationLimitCounterId: ::std::os::raw::c_int,
                channelStatusIndicatorId: ::std::os::raw::c_int,
                logFilename: *const root::std::string,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5aeron15ClientConductor25onNewExclusivePublicationElliiiiRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
            pub fn ClientConductor_onNewExclusivePublication(
                this: *mut root::aeron::ClientConductor,
                registrationId: ::std::os::raw::c_long,
                originalRegistrationId: ::std::os::raw::c_long,
                streamId: ::std::os::raw::c_int,
                sessionId: ::std::os::raw::c_int,
                publicationLimitCounterId: ::std::os::raw::c_int,
                channelStatusIndicatorId: ::std::os::raw::c_int,
                logFilename: *const root::std::string,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5aeron15ClientConductor19onSubscriptionReadyEli"]
            pub fn ClientConductor_onSubscriptionReady(
                this: *mut root::aeron::ClientConductor,
                registrationId: ::std::os::raw::c_long,
                channelStatusId: ::std::os::raw::c_int,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5aeron15ClientConductor18onOperationSuccessEl"]
            pub fn ClientConductor_onOperationSuccess(
                this: *mut root::aeron::ClientConductor,
                correlationId: ::std::os::raw::c_long,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5aeron15ClientConductor30onChannelEndpointErrorResponseEiRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
            pub fn ClientConductor_onChannelEndpointErrorResponse(
                this: *mut root::aeron::ClientConductor,
                channelStatusId: ::std::os::raw::c_int,
                errorMessage: *const root::std::string,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5aeron15ClientConductor15onErrorResponseEliRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
            pub fn ClientConductor_onErrorResponse(
                this: *mut root::aeron::ClientConductor,
                offendingCommandCorrelationId: ::std::os::raw::c_long,
                errorCode: ::std::os::raw::c_int,
                errorMessage: *const root::std::string,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5aeron15ClientConductor16onAvailableImageEliilRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEES8_"]
            pub fn ClientConductor_onAvailableImage(
                this: *mut root::aeron::ClientConductor,
                correlationId: ::std::os::raw::c_long,
                sessionId: ::std::os::raw::c_int,
                subscriberPositionId: ::std::os::raw::c_int,
                subscriptionRegistrationId: ::std::os::raw::c_long,
                logFilename: *const root::std::string,
                sourceIdentity: *const root::std::string,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5aeron15ClientConductor18onUnavailableImageEll"]
            pub fn ClientConductor_onUnavailableImage(
                this: *mut root::aeron::ClientConductor,
                correlationId: ::std::os::raw::c_long,
                subscriptionRegistrationId: ::std::os::raw::c_long,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5aeron15ClientConductor18onAvailableCounterEli"]
            pub fn ClientConductor_onAvailableCounter(
                this: *mut root::aeron::ClientConductor,
                registrationId: ::std::os::raw::c_long,
                counterId: ::std::os::raw::c_int,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5aeron15ClientConductor20onUnavailableCounterEli"]
            pub fn ClientConductor_onUnavailableCounter(
                this: *mut root::aeron::ClientConductor,
                registrationId: ::std::os::raw::c_long,
                counterId: ::std::os::raw::c_int,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5aeron15ClientConductor15onClientTimeoutEl"]
            pub fn ClientConductor_onClientTimeout(
                this: *mut root::aeron::ClientConductor,
                clientId: ::std::os::raw::c_long,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5aeron15ClientConductor17closeAllResourcesEx"]
            pub fn ClientConductor_closeAllResources(
                this: *mut root::aeron::ClientConductor,
                nowMs: ::std::os::raw::c_longlong,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5aeron15ClientConductor14addDestinationElRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
            pub fn ClientConductor_addDestination(
                this: *mut root::aeron::ClientConductor,
                publicationRegistrationId: ::std::os::raw::c_long,
                endpointChannel: *const root::std::string,
            ) -> ::std::os::raw::c_long;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5aeron15ClientConductor17removeDestinationElRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
            pub fn ClientConductor_removeDestination(
                this: *mut root::aeron::ClientConductor,
                publicationRegistrationId: ::std::os::raw::c_long,
                endpointChannel: *const root::std::string,
            ) -> ::std::os::raw::c_long;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5aeron15ClientConductor17addRcvDestinationElRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
            pub fn ClientConductor_addRcvDestination(
                this: *mut root::aeron::ClientConductor,
                subscriptionRegistrationId: ::std::os::raw::c_long,
                endpointChannel: *const root::std::string,
            ) -> ::std::os::raw::c_long;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5aeron15ClientConductor20removeRcvDestinationElRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
            pub fn ClientConductor_removeRcvDestination(
                this: *mut root::aeron::ClientConductor,
                subscriptionRegistrationId: ::std::os::raw::c_long,
                endpointChannel: *const root::std::string,
            ) -> ::std::os::raw::c_long;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5aeron15ClientConductor26addAvailableCounterHandlerERKSt8functionIFvRNS_10concurrent14CountersReaderEliEE"]
            pub fn ClientConductor_addAvailableCounterHandler(
                this: *mut root::aeron::ClientConductor,
                handler: *const root::aeron::on_available_counter_t,
            ) -> ::std::os::raw::c_long;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5aeron15ClientConductor29removeAvailableCounterHandlerERKSt8functionIFvRNS_10concurrent14CountersReaderEliEE"]
            pub fn ClientConductor_removeAvailableCounterHandler(
                this: *mut root::aeron::ClientConductor,
                handler: *const root::aeron::on_available_counter_t,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5aeron15ClientConductor29removeAvailableCounterHandlerEl"]
            pub fn ClientConductor_removeAvailableCounterHandler1(
                this: *mut root::aeron::ClientConductor,
                registrationId: ::std::os::raw::c_long,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5aeron15ClientConductor28addUnavailableCounterHandlerERKSt8functionIFvRNS_10concurrent14CountersReaderEliEE"]
            pub fn ClientConductor_addUnavailableCounterHandler(
                this: *mut root::aeron::ClientConductor,
                handler: *const root::aeron::on_unavailable_counter_t,
            ) -> ::std::os::raw::c_long;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5aeron15ClientConductor31removeUnavailableCounterHandlerERKSt8functionIFvRNS_10concurrent14CountersReaderEliEE"]
            pub fn ClientConductor_removeUnavailableCounterHandler(
                this: *mut root::aeron::ClientConductor,
                handler: *const root::aeron::on_unavailable_counter_t,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5aeron15ClientConductor31removeUnavailableCounterHandlerEl"]
            pub fn ClientConductor_removeUnavailableCounterHandler1(
                this: *mut root::aeron::ClientConductor,
                registrationId: ::std::os::raw::c_long,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5aeron15ClientConductor21addCloseClientHandlerERKSt8functionIFvvEE"]
            pub fn ClientConductor_addCloseClientHandler(
                this: *mut root::aeron::ClientConductor,
                handler: *const root::aeron::on_close_client_t,
            ) -> ::std::os::raw::c_long;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5aeron15ClientConductor24removeCloseClientHandlerERKSt8functionIFvvEE"]
            pub fn ClientConductor_removeCloseClientHandler(
                this: *mut root::aeron::ClientConductor,
                handler: *const root::aeron::on_close_client_t,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5aeron15ClientConductor24removeCloseClientHandlerEl"]
            pub fn ClientConductor_removeCloseClientHandler1(
                this: *mut root::aeron::ClientConductor,
                registrationId: ::std::os::raw::c_long,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5aeron15ClientConductor14countersReaderEv"]
            pub fn ClientConductor_countersReader(
                this: *mut root::aeron::ClientConductor,
            ) -> *mut root::aeron::concurrent::CountersReader;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNK5aeron15ClientConductor13channelStatusEi"]
            pub fn ClientConductor_channelStatus(
                this: *const root::aeron::ClientConductor,
                counterId: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_long;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNK5aeron15ClientConductor8isClosedEv"]
            pub fn ClientConductor_isClosed(this: *const root::aeron::ClientConductor) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNK5aeron15ClientConductor10ensureOpenEv"]
            pub fn ClientConductor_ensureOpen(this: *const root::aeron::ClientConductor);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5aeron15ClientConductorC1ESt8functionIFxvEERNS_11DriverProxyERNS_10concurrent9broadcast21CopyBroadcastReceiverERNS6_12AtomicBufferESB_RKS1_IFvRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEiilEESN_RKS1_IFvSJ_ilEERKS1_IFvRKSt9exceptionEERKS1_IFvRNS6_14CountersReaderEliEES14_RKS1_IFvvEEllxb"]
            pub fn ClientConductor_ClientConductor(
                this: *mut root::aeron::ClientConductor,
                epochClock: root::aeron::epoch_clock_t,
                driverProxy: *mut root::aeron::DriverProxy,
                broadcastReceiver: *mut root::aeron::concurrent::broadcast::CopyBroadcastReceiver,
                counterMetadataBuffer: *mut root::aeron::concurrent::AtomicBuffer,
                counterValuesBuffer: *mut root::aeron::concurrent::AtomicBuffer,
                newPublicationHandler: *const root::aeron::on_new_publication_t,
                newExclusivePublicationHandler: *const root::aeron::on_new_publication_t,
                newSubscriptionHandler: *const root::aeron::on_new_subscription_t,
                errorHandler: *const root::aeron::util::exception_handler_t,
                availableCounterHandler: *const root::aeron::on_available_counter_t,
                unavailableCounterHandler: *const root::aeron::on_unavailable_counter_t,
                onCloseClientHandler: *const root::aeron::on_close_client_t,
                driverTimeoutMs: ::std::os::raw::c_long,
                resourceLingerTimeoutMs: ::std::os::raw::c_long,
                interServiceTimeoutNs: ::std::os::raw::c_longlong,
                preTouchMappedMemory: bool,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5aeron15ClientConductorD1Ev"]
            pub fn ClientConductor_ClientConductor_destructor(
                this: *mut root::aeron::ClientConductor,
            );
        }
        impl ClientConductor {
            #[inline]
            pub unsafe fn onStart(&mut self) {
                ClientConductor_onStart(self)
            }
            #[inline]
            pub unsafe fn doWork(&mut self) -> ::std::os::raw::c_int {
                ClientConductor_doWork(self)
            }
            #[inline]
            pub unsafe fn onClose(&mut self) {
                ClientConductor_onClose(self)
            }
            #[inline]
            pub unsafe fn addPublication(
                &mut self,
                channel: *const root::std::string,
                streamId: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_long {
                ClientConductor_addPublication(self, channel, streamId)
            }
            #[inline]
            pub unsafe fn findPublication(
                &mut self,
                registrationId: ::std::os::raw::c_long,
            ) -> [u64; 2usize] {
                ClientConductor_findPublication(self, registrationId)
            }
            #[inline]
            pub unsafe fn releasePublication(&mut self, registrationId: ::std::os::raw::c_long) {
                ClientConductor_releasePublication(self, registrationId)
            }
            #[inline]
            pub unsafe fn addExclusivePublication(
                &mut self,
                channel: *const root::std::string,
                streamId: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_long {
                ClientConductor_addExclusivePublication(self, channel, streamId)
            }
            #[inline]
            pub unsafe fn findExclusivePublication(
                &mut self,
                registrationId: ::std::os::raw::c_long,
            ) -> [u64; 2usize] {
                ClientConductor_findExclusivePublication(self, registrationId)
            }
            #[inline]
            pub unsafe fn releaseExclusivePublication(
                &mut self,
                registrationId: ::std::os::raw::c_long,
            ) {
                ClientConductor_releaseExclusivePublication(self, registrationId)
            }
            #[inline]
            pub unsafe fn addSubscription(
                &mut self,
                channel: *const root::std::string,
                streamId: ::std::os::raw::c_int,
                onAvailableImageHandler: *const root::aeron::on_available_image_t,
                onUnavailableImageHandler: *const root::aeron::on_unavailable_image_t,
            ) -> ::std::os::raw::c_long {
                ClientConductor_addSubscription(
                    self,
                    channel,
                    streamId,
                    onAvailableImageHandler,
                    onUnavailableImageHandler,
                )
            }
            #[inline]
            pub unsafe fn findSubscription(
                &mut self,
                registrationId: ::std::os::raw::c_long,
            ) -> [u64; 2usize] {
                ClientConductor_findSubscription(self, registrationId)
            }
            #[inline]
            pub unsafe fn releaseSubscription(
                &mut self,
                registrationId: ::std::os::raw::c_long,
                imageArray: root::aeron::Image_array_t,
                length: usize,
            ) {
                ClientConductor_releaseSubscription(self, registrationId, imageArray, length)
            }
            #[inline]
            pub unsafe fn addCounter(
                &mut self,
                typeId: ::std::os::raw::c_int,
                keyBuffer: *mut ::std::os::raw::c_uchar,
                keyLength: usize,
                label: *const root::std::string,
            ) -> ::std::os::raw::c_long {
                ClientConductor_addCounter(self, typeId, keyBuffer, keyLength, label)
            }
            #[inline]
            pub unsafe fn findCounter(
                &mut self,
                registrationId: ::std::os::raw::c_long,
            ) -> [u64; 2usize] {
                ClientConductor_findCounter(self, registrationId)
            }
            #[inline]
            pub unsafe fn releaseCounter(&mut self, registrationId: ::std::os::raw::c_long) {
                ClientConductor_releaseCounter(self, registrationId)
            }
            #[inline]
            pub unsafe fn findDestinationResponse(
                &mut self,
                correlationId: ::std::os::raw::c_long,
            ) -> bool {
                ClientConductor_findDestinationResponse(self, correlationId)
            }
            #[inline]
            pub unsafe fn onNewPublication(
                &mut self,
                registrationId: ::std::os::raw::c_long,
                originalRegistrationId: ::std::os::raw::c_long,
                streamId: ::std::os::raw::c_int,
                sessionId: ::std::os::raw::c_int,
                publicationLimitCounterId: ::std::os::raw::c_int,
                channelStatusIndicatorId: ::std::os::raw::c_int,
                logFilename: *const root::std::string,
            ) {
                ClientConductor_onNewPublication(
                    self,
                    registrationId,
                    originalRegistrationId,
                    streamId,
                    sessionId,
                    publicationLimitCounterId,
                    channelStatusIndicatorId,
                    logFilename,
                )
            }
            #[inline]
            pub unsafe fn onNewExclusivePublication(
                &mut self,
                registrationId: ::std::os::raw::c_long,
                originalRegistrationId: ::std::os::raw::c_long,
                streamId: ::std::os::raw::c_int,
                sessionId: ::std::os::raw::c_int,
                publicationLimitCounterId: ::std::os::raw::c_int,
                channelStatusIndicatorId: ::std::os::raw::c_int,
                logFilename: *const root::std::string,
            ) {
                ClientConductor_onNewExclusivePublication(
                    self,
                    registrationId,
                    originalRegistrationId,
                    streamId,
                    sessionId,
                    publicationLimitCounterId,
                    channelStatusIndicatorId,
                    logFilename,
                )
            }
            #[inline]
            pub unsafe fn onSubscriptionReady(
                &mut self,
                registrationId: ::std::os::raw::c_long,
                channelStatusId: ::std::os::raw::c_int,
            ) {
                ClientConductor_onSubscriptionReady(self, registrationId, channelStatusId)
            }
            #[inline]
            pub unsafe fn onOperationSuccess(&mut self, correlationId: ::std::os::raw::c_long) {
                ClientConductor_onOperationSuccess(self, correlationId)
            }
            #[inline]
            pub unsafe fn onChannelEndpointErrorResponse(
                &mut self,
                channelStatusId: ::std::os::raw::c_int,
                errorMessage: *const root::std::string,
            ) {
                ClientConductor_onChannelEndpointErrorResponse(self, channelStatusId, errorMessage)
            }
            #[inline]
            pub unsafe fn onErrorResponse(
                &mut self,
                offendingCommandCorrelationId: ::std::os::raw::c_long,
                errorCode: ::std::os::raw::c_int,
                errorMessage: *const root::std::string,
            ) {
                ClientConductor_onErrorResponse(
                    self,
                    offendingCommandCorrelationId,
                    errorCode,
                    errorMessage,
                )
            }
            #[inline]
            pub unsafe fn onAvailableImage(
                &mut self,
                correlationId: ::std::os::raw::c_long,
                sessionId: ::std::os::raw::c_int,
                subscriberPositionId: ::std::os::raw::c_int,
                subscriptionRegistrationId: ::std::os::raw::c_long,
                logFilename: *const root::std::string,
                sourceIdentity: *const root::std::string,
            ) {
                ClientConductor_onAvailableImage(
                    self,
                    correlationId,
                    sessionId,
                    subscriberPositionId,
                    subscriptionRegistrationId,
                    logFilename,
                    sourceIdentity,
                )
            }
            #[inline]
            pub unsafe fn onUnavailableImage(
                &mut self,
                correlationId: ::std::os::raw::c_long,
                subscriptionRegistrationId: ::std::os::raw::c_long,
            ) {
                ClientConductor_onUnavailableImage(self, correlationId, subscriptionRegistrationId)
            }
            #[inline]
            pub unsafe fn onAvailableCounter(
                &mut self,
                registrationId: ::std::os::raw::c_long,
                counterId: ::std::os::raw::c_int,
            ) {
                ClientConductor_onAvailableCounter(self, registrationId, counterId)
            }
            #[inline]
            pub unsafe fn onUnavailableCounter(
                &mut self,
                registrationId: ::std::os::raw::c_long,
                counterId: ::std::os::raw::c_int,
            ) {
                ClientConductor_onUnavailableCounter(self, registrationId, counterId)
            }
            #[inline]
            pub unsafe fn onClientTimeout(&mut self, clientId: ::std::os::raw::c_long) {
                ClientConductor_onClientTimeout(self, clientId)
            }
            #[inline]
            pub unsafe fn closeAllResources(&mut self, nowMs: ::std::os::raw::c_longlong) {
                ClientConductor_closeAllResources(self, nowMs)
            }
            #[inline]
            pub unsafe fn addDestination(
                &mut self,
                publicationRegistrationId: ::std::os::raw::c_long,
                endpointChannel: *const root::std::string,
            ) -> ::std::os::raw::c_long {
                ClientConductor_addDestination(self, publicationRegistrationId, endpointChannel)
            }
            #[inline]
            pub unsafe fn removeDestination(
                &mut self,
                publicationRegistrationId: ::std::os::raw::c_long,
                endpointChannel: *const root::std::string,
            ) -> ::std::os::raw::c_long {
                ClientConductor_removeDestination(self, publicationRegistrationId, endpointChannel)
            }
            #[inline]
            pub unsafe fn addRcvDestination(
                &mut self,
                subscriptionRegistrationId: ::std::os::raw::c_long,
                endpointChannel: *const root::std::string,
            ) -> ::std::os::raw::c_long {
                ClientConductor_addRcvDestination(self, subscriptionRegistrationId, endpointChannel)
            }
            #[inline]
            pub unsafe fn removeRcvDestination(
                &mut self,
                subscriptionRegistrationId: ::std::os::raw::c_long,
                endpointChannel: *const root::std::string,
            ) -> ::std::os::raw::c_long {
                ClientConductor_removeRcvDestination(
                    self,
                    subscriptionRegistrationId,
                    endpointChannel,
                )
            }
            #[inline]
            pub unsafe fn addAvailableCounterHandler(
                &mut self,
                handler: *const root::aeron::on_available_counter_t,
            ) -> ::std::os::raw::c_long {
                ClientConductor_addAvailableCounterHandler(self, handler)
            }
            #[inline]
            pub unsafe fn removeAvailableCounterHandler(
                &mut self,
                handler: *const root::aeron::on_available_counter_t,
            ) {
                ClientConductor_removeAvailableCounterHandler(self, handler)
            }
            #[inline]
            pub unsafe fn removeAvailableCounterHandler1(
                &mut self,
                registrationId: ::std::os::raw::c_long,
            ) {
                ClientConductor_removeAvailableCounterHandler1(self, registrationId)
            }
            #[inline]
            pub unsafe fn addUnavailableCounterHandler(
                &mut self,
                handler: *const root::aeron::on_unavailable_counter_t,
            ) -> ::std::os::raw::c_long {
                ClientConductor_addUnavailableCounterHandler(self, handler)
            }
            #[inline]
            pub unsafe fn removeUnavailableCounterHandler(
                &mut self,
                handler: *const root::aeron::on_unavailable_counter_t,
            ) {
                ClientConductor_removeUnavailableCounterHandler(self, handler)
            }
            #[inline]
            pub unsafe fn removeUnavailableCounterHandler1(
                &mut self,
                registrationId: ::std::os::raw::c_long,
            ) {
                ClientConductor_removeUnavailableCounterHandler1(self, registrationId)
            }
            #[inline]
            pub unsafe fn addCloseClientHandler(
                &mut self,
                handler: *const root::aeron::on_close_client_t,
            ) -> ::std::os::raw::c_long {
                ClientConductor_addCloseClientHandler(self, handler)
            }
            #[inline]
            pub unsafe fn removeCloseClientHandler(
                &mut self,
                handler: *const root::aeron::on_close_client_t,
            ) {
                ClientConductor_removeCloseClientHandler(self, handler)
            }
            #[inline]
            pub unsafe fn removeCloseClientHandler1(
                &mut self,
                registrationId: ::std::os::raw::c_long,
            ) {
                ClientConductor_removeCloseClientHandler1(self, registrationId)
            }
            #[inline]
            pub unsafe fn countersReader(
                &mut self,
            ) -> *mut root::aeron::concurrent::CountersReader {
                ClientConductor_countersReader(self)
            }
            #[inline]
            pub unsafe fn channelStatus(
                &self,
                counterId: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_long {
                ClientConductor_channelStatus(self, counterId)
            }
            #[inline]
            pub unsafe fn isClosed(&self) -> bool {
                ClientConductor_isClosed(self)
            }
            #[inline]
            pub unsafe fn ensureOpen(&self) {
                ClientConductor_ensureOpen(self)
            }
            #[inline]
            pub unsafe fn new(
                epochClock: root::aeron::epoch_clock_t,
                driverProxy: *mut root::aeron::DriverProxy,
                broadcastReceiver: *mut root::aeron::concurrent::broadcast::CopyBroadcastReceiver,
                counterMetadataBuffer: *mut root::aeron::concurrent::AtomicBuffer,
                counterValuesBuffer: *mut root::aeron::concurrent::AtomicBuffer,
                newPublicationHandler: *const root::aeron::on_new_publication_t,
                newExclusivePublicationHandler: *const root::aeron::on_new_publication_t,
                newSubscriptionHandler: *const root::aeron::on_new_subscription_t,
                errorHandler: *const root::aeron::util::exception_handler_t,
                availableCounterHandler: *const root::aeron::on_available_counter_t,
                unavailableCounterHandler: *const root::aeron::on_unavailable_counter_t,
                onCloseClientHandler: *const root::aeron::on_close_client_t,
                driverTimeoutMs: ::std::os::raw::c_long,
                resourceLingerTimeoutMs: ::std::os::raw::c_long,
                interServiceTimeoutNs: ::std::os::raw::c_longlong,
                preTouchMappedMemory: bool,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                ClientConductor_ClientConductor(
                    __bindgen_tmp.as_mut_ptr(),
                    epochClock,
                    driverProxy,
                    broadcastReceiver,
                    counterMetadataBuffer,
                    counterValuesBuffer,
                    newPublicationHandler,
                    newExclusivePublicationHandler,
                    newSubscriptionHandler,
                    errorHandler,
                    availableCounterHandler,
                    unavailableCounterHandler,
                    onCloseClientHandler,
                    driverTimeoutMs,
                    resourceLingerTimeoutMs,
                    interServiceTimeoutNs,
                    preTouchMappedMemory,
                );
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn destruct(&mut self) {
                ClientConductor_ClientConductor_destructor(self)
            }
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5aeron17currentTimeMillisEv"]
            pub fn currentTimeMillis() -> ::std::os::raw::c_longlong;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5aeron15systemNanoClockEv"]
            pub fn systemNanoClock() -> ::std::os::raw::c_longlong;
        }
        #[repr(C)]
        #[repr(align(16))]
        pub struct Aeron {
            pub m_context: root::aeron::Context,
            pub m_cncBuffer: root::aeron::util::MemoryMappedFile_ptr_t,
            pub m_toDriverAtomicBuffer: root::aeron::concurrent::AtomicBuffer,
            pub m_toClientsAtomicBuffer: root::aeron::concurrent::AtomicBuffer,
            pub m_countersMetadataBuffer: root::aeron::concurrent::AtomicBuffer,
            pub m_countersValueBuffer: root::aeron::concurrent::AtomicBuffer,
            pub m_toDriverRingBuffer: root::aeron::concurrent::ringbuffer::ManyToOneRingBuffer,
            pub m_driverProxy: root::aeron::DriverProxy,
            pub m_toClientsBroadcastReceiver: root::aeron::concurrent::broadcast::BroadcastReceiver,
            pub __bindgen_padding_0: u64,
            pub m_toClientsCopyReceiver: root::aeron::concurrent::broadcast::CopyBroadcastReceiver,
            pub m_conductor: root::aeron::ClientConductor,
            pub m_idleStrategy: root::aeron::concurrent::SleepingIdleStrategy,
            pub m_conductorRunner: root::aeron::concurrent::AgentRunner<
                root::aeron::ClientConductor,
                root::aeron::concurrent::SleepingIdleStrategy,
            >,
            pub m_conductorInvoker:
                root::aeron::concurrent::AgentInvoker<root::aeron::ClientConductor>,
        }
        #[test]
        fn bindgen_test_layout_Aeron() {
            const UNINIT: ::std::mem::MaybeUninit<Aeron> = ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<Aeron>(),
                5616usize,
                concat!("Size of: ", stringify!(Aeron))
            );
            assert_eq!(
                ::std::mem::align_of::<Aeron>(),
                16usize,
                concat!("Alignment of ", stringify!(Aeron))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_context) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Aeron),
                    "::",
                    stringify!(m_context)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_cncBuffer) as usize - ptr as usize },
                344usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Aeron),
                    "::",
                    stringify!(m_cncBuffer)
                )
            );
            assert_eq!(
                unsafe {
                    ::std::ptr::addr_of!((*ptr).m_toDriverAtomicBuffer) as usize - ptr as usize
                },
                360usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Aeron),
                    "::",
                    stringify!(m_toDriverAtomicBuffer)
                )
            );
            assert_eq!(
                unsafe {
                    ::std::ptr::addr_of!((*ptr).m_toClientsAtomicBuffer) as usize - ptr as usize
                },
                376usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Aeron),
                    "::",
                    stringify!(m_toClientsAtomicBuffer)
                )
            );
            assert_eq!(
                unsafe {
                    ::std::ptr::addr_of!((*ptr).m_countersMetadataBuffer) as usize - ptr as usize
                },
                392usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Aeron),
                    "::",
                    stringify!(m_countersMetadataBuffer)
                )
            );
            assert_eq!(
                unsafe {
                    ::std::ptr::addr_of!((*ptr).m_countersValueBuffer) as usize - ptr as usize
                },
                408usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Aeron),
                    "::",
                    stringify!(m_countersValueBuffer)
                )
            );
            assert_eq!(
                unsafe {
                    ::std::ptr::addr_of!((*ptr).m_toDriverRingBuffer) as usize - ptr as usize
                },
                424usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Aeron),
                    "::",
                    stringify!(m_toDriverRingBuffer)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_driverProxy) as usize - ptr as usize },
                464usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Aeron),
                    "::",
                    stringify!(m_driverProxy)
                )
            );
            assert_eq!(
                unsafe {
                    ::std::ptr::addr_of!((*ptr).m_toClientsBroadcastReceiver) as usize
                        - ptr as usize
                },
                480usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Aeron),
                    "::",
                    stringify!(m_toClientsBroadcastReceiver)
                )
            );
            assert_eq!(
                unsafe {
                    ::std::ptr::addr_of!((*ptr).m_toClientsCopyReceiver) as usize - ptr as usize
                },
                544usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Aeron),
                    "::",
                    stringify!(m_toClientsCopyReceiver)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_conductor) as usize - ptr as usize },
                4672usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Aeron),
                    "::",
                    stringify!(m_conductor)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_idleStrategy) as usize - ptr as usize },
                5504usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Aeron),
                    "::",
                    stringify!(m_idleStrategy)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_conductorRunner) as usize - ptr as usize },
                5512usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Aeron),
                    "::",
                    stringify!(m_conductorRunner)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_conductorInvoker) as usize - ptr as usize },
                5584usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Aeron),
                    "::",
                    stringify!(m_conductorInvoker)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5aeron5Aeron8isClosedEv"]
            pub fn Aeron_isClosed(this: *mut root::aeron::Aeron) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5aeron5Aeron7connectERNS_7ContextE"]
            pub fn Aeron_connect(context: *mut root::aeron::Context) -> [u64; 2usize];
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5aeron5Aeron7connectEv"]
            pub fn Aeron_connect1() -> [u64; 2usize];
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5aeron5Aeron14addPublicationERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEi"]
            pub fn Aeron_addPublication(
                this: *mut root::aeron::Aeron,
                channel: *const root::std::string,
                streamId: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_long;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5aeron5Aeron15findPublicationEl"]
            pub fn Aeron_findPublication(
                this: *mut root::aeron::Aeron,
                registrationId: ::std::os::raw::c_long,
            ) -> [u64; 2usize];
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5aeron5Aeron23addExclusivePublicationERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEi"]
            pub fn Aeron_addExclusivePublication(
                this: *mut root::aeron::Aeron,
                channel: *const root::std::string,
                streamId: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_long;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5aeron5Aeron24findExclusivePublicationEl"]
            pub fn Aeron_findExclusivePublication(
                this: *mut root::aeron::Aeron,
                registrationId: ::std::os::raw::c_long,
            ) -> [u64; 2usize];
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5aeron5Aeron15addSubscriptionERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEi"]
            pub fn Aeron_addSubscription(
                this: *mut root::aeron::Aeron,
                channel: *const root::std::string,
                streamId: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_long;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5aeron5Aeron15addSubscriptionERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEiRKSt8functionIFvRNS_5ImageEEESF_"]
            pub fn Aeron_addSubscription1(
                this: *mut root::aeron::Aeron,
                channel: *const root::std::string,
                streamId: ::std::os::raw::c_int,
                onAvailableImageHandler: *const root::aeron::on_available_image_t,
                onUnavailableImageHandler: *const root::aeron::on_unavailable_image_t,
            ) -> ::std::os::raw::c_long;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5aeron5Aeron16findSubscriptionEl"]
            pub fn Aeron_findSubscription(
                this: *mut root::aeron::Aeron,
                registrationId: ::std::os::raw::c_long,
            ) -> [u64; 2usize];
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5aeron5Aeron17nextCorrelationIdEv"]
            pub fn Aeron_nextCorrelationId(this: *mut root::aeron::Aeron)
                -> ::std::os::raw::c_long;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5aeron5Aeron10addCounterEiPKhmRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
            pub fn Aeron_addCounter(
                this: *mut root::aeron::Aeron,
                typeId: ::std::os::raw::c_int,
                keyBuffer: *mut ::std::os::raw::c_uchar,
                keyLength: usize,
                label: *const root::std::string,
            ) -> ::std::os::raw::c_long;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5aeron5Aeron11findCounterEl"]
            pub fn Aeron_findCounter(
                this: *mut root::aeron::Aeron,
                registrationId: ::std::os::raw::c_long,
            ) -> [u64; 2usize];
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5aeron5Aeron26addAvailableCounterHandlerERKSt8functionIFvRNS_10concurrent14CountersReaderEliEE"]
            pub fn Aeron_addAvailableCounterHandler(
                this: *mut root::aeron::Aeron,
                handler: *const root::aeron::on_available_counter_t,
            ) -> ::std::os::raw::c_long;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5aeron5Aeron29removeAvailableCounterHandlerERKSt8functionIFvRNS_10concurrent14CountersReaderEliEE"]
            pub fn Aeron_removeAvailableCounterHandler(
                this: *mut root::aeron::Aeron,
                handler: *const root::aeron::on_available_counter_t,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5aeron5Aeron29removeAvailableCounterHandlerEl"]
            pub fn Aeron_removeAvailableCounterHandler1(
                this: *mut root::aeron::Aeron,
                registrationId: ::std::os::raw::c_long,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5aeron5Aeron28addUnavailableCounterHandlerERKSt8functionIFvRNS_10concurrent14CountersReaderEliEE"]
            pub fn Aeron_addUnavailableCounterHandler(
                this: *mut root::aeron::Aeron,
                handler: *const root::aeron::on_unavailable_counter_t,
            ) -> ::std::os::raw::c_long;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5aeron5Aeron31removeUnavailableCounterHandlerERKSt8functionIFvRNS_10concurrent14CountersReaderEliEE"]
            pub fn Aeron_removeUnavailableCounterHandler(
                this: *mut root::aeron::Aeron,
                handler: *const root::aeron::on_unavailable_counter_t,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5aeron5Aeron31removeUnavailableCounterHandlerEl"]
            pub fn Aeron_removeUnavailableCounterHandler1(
                this: *mut root::aeron::Aeron,
                registrationId: ::std::os::raw::c_long,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5aeron5Aeron21addCloseClientHandlerERKSt8functionIFvvEE"]
            pub fn Aeron_addCloseClientHandler(
                this: *mut root::aeron::Aeron,
                handler: *const root::aeron::on_close_client_t,
            ) -> ::std::os::raw::c_long;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5aeron5Aeron24removeCloseClientHandlerERKSt8functionIFvvEE"]
            pub fn Aeron_removeCloseClientHandler(
                this: *mut root::aeron::Aeron,
                handler: *const root::aeron::on_close_client_t,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5aeron5Aeron24removeCloseClientHandlerEl"]
            pub fn Aeron_removeCloseClientHandler1(
                this: *mut root::aeron::Aeron,
                registrationId: ::std::os::raw::c_long,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5aeron5Aeron21conductorAgentInvokerEv"]
            pub fn Aeron_conductorAgentInvoker(
                this: *mut root::aeron::Aeron,
            ) -> *mut root::aeron::concurrent::AgentInvoker<root::aeron::ClientConductor>;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNK5aeron5Aeron16usesAgentInvokerEv"]
            pub fn Aeron_usesAgentInvoker(this: *const root::aeron::Aeron) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5aeron5Aeron14countersReaderEv"]
            pub fn Aeron_countersReader(
                this: *mut root::aeron::Aeron,
            ) -> *mut root::aeron::concurrent::CountersReader;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNK5aeron5Aeron8clientIdEv"]
            pub fn Aeron_clientId(this: *const root::aeron::Aeron) -> ::std::os::raw::c_long;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5aeron5Aeron7contextEv"]
            pub fn Aeron_context(this: *mut root::aeron::Aeron) -> *mut root::aeron::Context;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNK5aeron5Aeron7contextEv"]
            pub fn Aeron_context1(this: *const root::aeron::Aeron) -> *const root::aeron::Context;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5aeron5Aeron7versionB5cxx11Ev"]
            pub fn Aeron_version() -> root::std::string;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5aeron5AeronC1ERNS_7ContextE"]
            pub fn Aeron_Aeron(this: *mut root::aeron::Aeron, context: *mut root::aeron::Context);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5aeron5AeronD1Ev"]
            pub fn Aeron_Aeron_destructor(this: *mut root::aeron::Aeron);
        }
        impl Aeron {
            #[inline]
            pub unsafe fn isClosed(&mut self) -> bool {
                Aeron_isClosed(self)
            }
            #[inline]
            pub unsafe fn connect(context: *mut root::aeron::Context) -> [u64; 2usize] {
                Aeron_connect(context)
            }
            #[inline]
            pub unsafe fn connect1() -> [u64; 2usize] {
                Aeron_connect1()
            }
            #[inline]
            pub unsafe fn addPublication(
                &mut self,
                channel: *const root::std::string,
                streamId: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_long {
                Aeron_addPublication(self, channel, streamId)
            }
            #[inline]
            pub unsafe fn findPublication(
                &mut self,
                registrationId: ::std::os::raw::c_long,
            ) -> [u64; 2usize] {
                Aeron_findPublication(self, registrationId)
            }
            #[inline]
            pub unsafe fn addExclusivePublication(
                &mut self,
                channel: *const root::std::string,
                streamId: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_long {
                Aeron_addExclusivePublication(self, channel, streamId)
            }
            #[inline]
            pub unsafe fn findExclusivePublication(
                &mut self,
                registrationId: ::std::os::raw::c_long,
            ) -> [u64; 2usize] {
                Aeron_findExclusivePublication(self, registrationId)
            }
            #[inline]
            pub unsafe fn addSubscription(
                &mut self,
                channel: *const root::std::string,
                streamId: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_long {
                Aeron_addSubscription(self, channel, streamId)
            }
            #[inline]
            pub unsafe fn addSubscription1(
                &mut self,
                channel: *const root::std::string,
                streamId: ::std::os::raw::c_int,
                onAvailableImageHandler: *const root::aeron::on_available_image_t,
                onUnavailableImageHandler: *const root::aeron::on_unavailable_image_t,
            ) -> ::std::os::raw::c_long {
                Aeron_addSubscription1(
                    self,
                    channel,
                    streamId,
                    onAvailableImageHandler,
                    onUnavailableImageHandler,
                )
            }
            #[inline]
            pub unsafe fn findSubscription(
                &mut self,
                registrationId: ::std::os::raw::c_long,
            ) -> [u64; 2usize] {
                Aeron_findSubscription(self, registrationId)
            }
            #[inline]
            pub unsafe fn nextCorrelationId(&mut self) -> ::std::os::raw::c_long {
                Aeron_nextCorrelationId(self)
            }
            #[inline]
            pub unsafe fn addCounter(
                &mut self,
                typeId: ::std::os::raw::c_int,
                keyBuffer: *mut ::std::os::raw::c_uchar,
                keyLength: usize,
                label: *const root::std::string,
            ) -> ::std::os::raw::c_long {
                Aeron_addCounter(self, typeId, keyBuffer, keyLength, label)
            }
            #[inline]
            pub unsafe fn findCounter(
                &mut self,
                registrationId: ::std::os::raw::c_long,
            ) -> [u64; 2usize] {
                Aeron_findCounter(self, registrationId)
            }
            #[inline]
            pub unsafe fn addAvailableCounterHandler(
                &mut self,
                handler: *const root::aeron::on_available_counter_t,
            ) -> ::std::os::raw::c_long {
                Aeron_addAvailableCounterHandler(self, handler)
            }
            #[inline]
            pub unsafe fn removeAvailableCounterHandler(
                &mut self,
                handler: *const root::aeron::on_available_counter_t,
            ) {
                Aeron_removeAvailableCounterHandler(self, handler)
            }
            #[inline]
            pub unsafe fn removeAvailableCounterHandler1(
                &mut self,
                registrationId: ::std::os::raw::c_long,
            ) {
                Aeron_removeAvailableCounterHandler1(self, registrationId)
            }
            #[inline]
            pub unsafe fn addUnavailableCounterHandler(
                &mut self,
                handler: *const root::aeron::on_unavailable_counter_t,
            ) -> ::std::os::raw::c_long {
                Aeron_addUnavailableCounterHandler(self, handler)
            }
            #[inline]
            pub unsafe fn removeUnavailableCounterHandler(
                &mut self,
                handler: *const root::aeron::on_unavailable_counter_t,
            ) {
                Aeron_removeUnavailableCounterHandler(self, handler)
            }
            #[inline]
            pub unsafe fn removeUnavailableCounterHandler1(
                &mut self,
                registrationId: ::std::os::raw::c_long,
            ) {
                Aeron_removeUnavailableCounterHandler1(self, registrationId)
            }
            #[inline]
            pub unsafe fn addCloseClientHandler(
                &mut self,
                handler: *const root::aeron::on_close_client_t,
            ) -> ::std::os::raw::c_long {
                Aeron_addCloseClientHandler(self, handler)
            }
            #[inline]
            pub unsafe fn removeCloseClientHandler(
                &mut self,
                handler: *const root::aeron::on_close_client_t,
            ) {
                Aeron_removeCloseClientHandler(self, handler)
            }
            #[inline]
            pub unsafe fn removeCloseClientHandler1(
                &mut self,
                registrationId: ::std::os::raw::c_long,
            ) {
                Aeron_removeCloseClientHandler1(self, registrationId)
            }
            #[inline]
            pub unsafe fn conductorAgentInvoker(
                &mut self,
            ) -> *mut root::aeron::concurrent::AgentInvoker<root::aeron::ClientConductor>
            {
                Aeron_conductorAgentInvoker(self)
            }
            #[inline]
            pub unsafe fn usesAgentInvoker(&self) -> bool {
                Aeron_usesAgentInvoker(self)
            }
            #[inline]
            pub unsafe fn countersReader(
                &mut self,
            ) -> *mut root::aeron::concurrent::CountersReader {
                Aeron_countersReader(self)
            }
            #[inline]
            pub unsafe fn clientId(&self) -> ::std::os::raw::c_long {
                Aeron_clientId(self)
            }
            #[inline]
            pub unsafe fn context(&mut self) -> *mut root::aeron::Context {
                Aeron_context(self)
            }
            #[inline]
            pub unsafe fn context1(&self) -> *const root::aeron::Context {
                Aeron_context1(self)
            }
            #[inline]
            pub unsafe fn version() -> root::std::string {
                Aeron_version()
            }
            #[inline]
            pub unsafe fn new(context: *mut root::aeron::Context) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                Aeron_Aeron(__bindgen_tmp.as_mut_ptr(), context);
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn destruct(&mut self) {
                Aeron_Aeron_destructor(self)
            }
        }
        #[repr(C)]
        pub struct ChannelUri {
            pub m_prefix: root::std::string,
            pub m_media: root::std::string,
            pub m_params: u64,
        }
        pub const ChannelUri_State_MEDIA: root::aeron::ChannelUri_State = 0;
        pub const ChannelUri_State_PARAMS_KEY: root::aeron::ChannelUri_State = 1;
        pub const ChannelUri_State_PARAMS_VALUE: root::aeron::ChannelUri_State = 2;
        pub type ChannelUri_State = ::std::os::raw::c_int;
        #[test]
        fn bindgen_test_layout_ChannelUri() {
            const UNINIT: ::std::mem::MaybeUninit<ChannelUri> = ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<ChannelUri>(),
                72usize,
                concat!("Size of: ", stringify!(ChannelUri))
            );
            assert_eq!(
                ::std::mem::align_of::<ChannelUri>(),
                8usize,
                concat!("Alignment of ", stringify!(ChannelUri))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_prefix) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ChannelUri),
                    "::",
                    stringify!(m_prefix)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_media) as usize - ptr as usize },
                32usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ChannelUri),
                    "::",
                    stringify!(m_media)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_params) as usize - ptr as usize },
                64usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ChannelUri),
                    "::",
                    stringify!(m_params)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5aeron10ChannelUri6prefixB5cxx11Ev"]
            pub fn ChannelUri_prefix(this: *mut root::aeron::ChannelUri) -> root::std::string;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5aeron10ChannelUri6prefixERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
            pub fn ChannelUri_prefix1(
                this: *mut root::aeron::ChannelUri,
                prefix: *const root::std::string,
            ) -> *mut root::aeron::ChannelUri;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5aeron10ChannelUri5mediaB5cxx11Ev"]
            pub fn ChannelUri_media(this: *mut root::aeron::ChannelUri) -> root::std::string;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5aeron10ChannelUri5mediaERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
            pub fn ChannelUri_media1(
                this: *mut root::aeron::ChannelUri,
                media: *const root::std::string,
            ) -> *mut root::aeron::ChannelUri;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5aeron10ChannelUri6schemeB5cxx11Ev"]
            pub fn ChannelUri_scheme(this: *mut root::aeron::ChannelUri) -> root::std::string;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5aeron10ChannelUri3getERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
            pub fn ChannelUri_get(
                this: *mut root::aeron::ChannelUri,
                key: *const root::std::string,
            ) -> root::std::string;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5aeron10ChannelUri3getERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEES8_"]
            pub fn ChannelUri_get1(
                this: *mut root::aeron::ChannelUri,
                key: *const root::std::string,
                defaultValue: *const root::std::string,
            ) -> root::std::string;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5aeron10ChannelUri3putERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEES8_"]
            pub fn ChannelUri_put(
                this: *mut root::aeron::ChannelUri,
                key: *const root::std::string,
                value: *const root::std::string,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5aeron10ChannelUri6removeERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
            pub fn ChannelUri_remove(
                this: *mut root::aeron::ChannelUri,
                key: *const root::std::string,
            ) -> root::std::string;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5aeron10ChannelUri11containsKeyERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
            pub fn ChannelUri_containsKey(
                this: *mut root::aeron::ChannelUri,
                key: *const root::std::string,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5aeron10ChannelUri8toStringB5cxx11Ev"]
            pub fn ChannelUri_toString(this: *mut root::aeron::ChannelUri) -> root::std::string;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5aeron10ChannelUri5parseERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
            pub fn ChannelUri_parse(uri: *const root::std::string) -> [u64; 2usize];
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5aeron10ChannelUri12addSessionIdERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEi"]
            pub fn ChannelUri_addSessionId(
                channel: *const root::std::string,
                sessionId: ::std::os::raw::c_int,
            ) -> root::std::string;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5aeron10ChannelUriC1ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEES8_St10unique_ptrISt13unordered_mapIS6_S6_St4hashIS6_ESt8equal_toIS6_ESaISt4pairIS7_S6_EEESt14default_deleteISI_EE"]
            pub fn ChannelUri_ChannelUri(
                this: *mut root::aeron::ChannelUri,
                prefix: *const root::std::string,
                media: *const root::std::string,
                params: u64,
            );
        }
        impl ChannelUri {
            #[inline]
            pub unsafe fn prefix(&mut self) -> root::std::string {
                ChannelUri_prefix(self)
            }
            #[inline]
            pub unsafe fn prefix1(
                &mut self,
                prefix: *const root::std::string,
            ) -> *mut root::aeron::ChannelUri {
                ChannelUri_prefix1(self, prefix)
            }
            #[inline]
            pub unsafe fn media(&mut self) -> root::std::string {
                ChannelUri_media(self)
            }
            #[inline]
            pub unsafe fn media1(&mut self, media: *const root::std::string) -> *mut root::aeron::ChannelUri {
                ChannelUri_media1(self, media)
            }
            #[inline]
            pub unsafe fn scheme(&mut self) -> root::std::string {
                ChannelUri_scheme(self)
            }
            #[inline]
            pub unsafe fn get(&mut self, key: *const root::std::string) -> root::std::string {
                ChannelUri_get(self, key)
            }
            #[inline]
            pub unsafe fn get1(
                &mut self,
                key: *const root::std::string,
                defaultValue: *const root::std::string,
            ) -> root::std::string {
                ChannelUri_get1(self, key, defaultValue)
            }
            #[inline]
            pub unsafe fn put(
                &mut self,
                key: *const root::std::string,
                value: *const root::std::string,
            ) {
                ChannelUri_put(self, key, value)
            }
            #[inline]
            pub unsafe fn remove(&mut self, key: *const root::std::string) -> root::std::string {
                ChannelUri_remove(self, key)
            }
            #[inline]
            pub unsafe fn containsKey(&mut self, key: *const root::std::string) -> bool {
                ChannelUri_containsKey(self, key)
            }
            #[inline]
            pub unsafe fn toString(&mut self) -> root::std::string {
                ChannelUri_toString(self)
            }
            #[inline]
            pub unsafe fn parse(uri: *const root::std::string) -> [u64; 2usize] {
                ChannelUri_parse(uri)
            }
            #[inline]
            pub unsafe fn addSessionId(
                channel: *const root::std::string,
                sessionId: ::std::os::raw::c_int,
            ) -> root::std::string {
                ChannelUri_addSessionId(channel, sessionId)
            }
            #[inline]
            pub unsafe fn new(
                prefix: *const root::std::string,
                media: *const root::std::string,
                params: u64,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                ChannelUri_ChannelUri(__bindgen_tmp.as_mut_ptr(), prefix, media, params);
                __bindgen_tmp.assume_init()
            }
        }
        pub mod archive {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            pub mod client {
                #[allow(unused_imports)]
                use self::super::super::super::super::root;
                #[doc = " Callback to return encoded credentials.\n\n @return encoded credentials to send on connect request."]
                pub type credentials_encoded_credentials_supplier_t = [u64; 4usize];
                extern "C" {
                    #[link_name = "\u{1}_ZN5aeron7archive6client36defaultCredentialsEncodedCredentialsEv"]
                    pub fn defaultCredentialsEncodedCredentials() -> [u64; 2usize];
                }
                #[doc = " Callback to return encoded credentials given specific encoded challenge\n\n @param encodedChallenge to use to generate the encoded credentials.\n @return encoded credentials to send in challenge response."]
                pub type credentials_challenge_supplier_t = [u64; 4usize];
                extern "C" {
                    #[link_name = "\u{1}_ZN5aeron7archive6client29defaultCredentialsOnChallengeESt4pairIPKcjE"]
                    pub fn defaultCredentialsOnChallenge(
                        encodedChallenge: [u64; 2usize],
                    ) -> [u64; 2usize];
                }
                #[doc = " Callback to return encoded credentials so they may be reused or freed.\n\n @param encodedCredentials to re-use or free."]
                pub type credentials_free_t = [u64; 4usize];
                extern "C" {
                    #[link_name = "\u{1}_ZN5aeron7archive6client24defaultCredentialsOnFreeESt4pairIPKcjE"]
                    pub fn defaultCredentialsOnFree(credentials: [u64; 2usize]);
                }
                #[doc = " Structure to hold credential callbacks."]
                #[repr(C)]
                #[derive(Copy, Clone)]
                pub struct CredentialsSupplier {
                    pub m_encodedCredentials:
                        root::aeron::archive::client::credentials_encoded_credentials_supplier_t,
                    pub m_onChallenge:
                        root::aeron::archive::client::credentials_challenge_supplier_t,
                    pub m_onFree: root::aeron::archive::client::credentials_free_t,
                }
                #[test]
                fn bindgen_test_layout_CredentialsSupplier() {
                    const UNINIT: ::std::mem::MaybeUninit<CredentialsSupplier> =
                        ::std::mem::MaybeUninit::uninit();
                    let ptr = UNINIT.as_ptr();
                    assert_eq!(
                        ::std::mem::size_of::<CredentialsSupplier>(),
                        96usize,
                        concat!("Size of: ", stringify!(CredentialsSupplier))
                    );
                    assert_eq!(
                        ::std::mem::align_of::<CredentialsSupplier>(),
                        8usize,
                        concat!("Alignment of ", stringify!(CredentialsSupplier))
                    );
                    assert_eq!(
                        unsafe {
                            ::std::ptr::addr_of!((*ptr).m_encodedCredentials) as usize
                                - ptr as usize
                        },
                        0usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(CredentialsSupplier),
                            "::",
                            stringify!(m_encodedCredentials)
                        )
                    );
                    assert_eq!(
                        unsafe {
                            ::std::ptr::addr_of!((*ptr).m_onChallenge) as usize - ptr as usize
                        },
                        32usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(CredentialsSupplier),
                            "::",
                            stringify!(m_onChallenge)
                        )
                    );
                    assert_eq!(
                        unsafe { ::std::ptr::addr_of!((*ptr).m_onFree) as usize - ptr as usize },
                        64usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(CredentialsSupplier),
                            "::",
                            stringify!(m_onFree)
                        )
                    );
                }
                extern "C" {
                    #[link_name = "\u{1}_ZN5aeron7archive6client19CredentialsSupplierC1ESt8functionIFSt4pairIPKcjEvEES3_IFS7_S7_EES3_IFvS7_EE"]
                    pub fn CredentialsSupplier_CredentialsSupplier(
                        this: *mut root::aeron::archive::client::CredentialsSupplier,
                        encodedCredentials : root :: aeron :: archive :: client :: credentials_encoded_credentials_supplier_t,
                        onChallenge: root::aeron::archive::client::credentials_challenge_supplier_t,
                        onFree: root::aeron::archive::client::credentials_free_t,
                    );
                }
                impl CredentialsSupplier {
                    #[inline]
                    pub unsafe fn new(
                        encodedCredentials : root :: aeron :: archive :: client :: credentials_encoded_credentials_supplier_t,
                        onChallenge: root::aeron::archive::client::credentials_challenge_supplier_t,
                        onFree: root::aeron::archive::client::credentials_free_t,
                    ) -> Self {
                        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                        CredentialsSupplier_CredentialsSupplier(
                            __bindgen_tmp.as_mut_ptr(),
                            encodedCredentials,
                            onChallenge,
                            onFree,
                        );
                        __bindgen_tmp.assume_init()
                    }
                }
                #[doc = " Callback to allow execution of a delegating invoker to be run."]
                pub type delegating_invoker_t = [u64; 4usize];
                extern "C" {
                    #[link_name = "\u{1}_ZN5aeron7archive6client24defaultDelegatingInvokerEv"]
                    pub fn defaultDelegatingInvoker(
                    ) -> root::aeron::archive::client::delegating_invoker_t;
                }
                #[doc = " A signal has been received from the Archive indicating an operation on a recording.\n\n The raw code representing the recording operation can be converted using methods on the RecordingSignal enum\n generated for the SBE coded.\n\n @param controlSessionId    of the originating session.\n @param recordingId         of the recording which transitioned.\n @param subscriptionId      of the subscription which captured the recording.\n @param position            of the recording at the time of transition.\n @param recordingSignalCode raw code representing the operation the recording has undertaken."]
                pub type on_recording_signal_t = [u64; 4usize];
                extern "C" {
                    #[doc = " Default function for consuming recording signals which is an no-op.\n\n @return function for consuming recording signals which is an no-op."]
                    #[link_name = "\u{1}_ZN5aeron7archive6client30defaultRecordingSignalConsumerEv"]
                    pub fn defaultRecordingSignalConsumer(
                    ) -> root::aeron::archive::client::on_recording_signal_t;
                }
                pub mod Configuration {
                    #[allow(unused_imports)]
                    use self::super::super::super::super::super::root;
                }
                #[doc = " Specialised configuration options for communicating with an Aeron Archive.\n <p>\n The context will be copied after a successful\n AeronArchive#connect(Context) or AeronArchive::asyncConnect(Context)."]
                #[repr(C)]
                pub struct Context {
                    pub m_aeron: [u64; 2usize],
                    pub m_aeronDirectoryName: root::std::string,
                    pub m_messageTimeoutNs: ::std::os::raw::c_longlong,
                    pub m_controlResponseChannel: root::std::string,
                    pub m_controlResponseStreamId: ::std::os::raw::c_int,
                    pub m_controlRequestChannel: root::std::string,
                    pub m_controlRequestStreamId: ::std::os::raw::c_int,
                    pub m_recordingEventsChannel: root::std::string,
                    pub m_recordingEventsStreamId: ::std::os::raw::c_int,
                    pub m_controlTermBufferSparse: bool,
                    pub m_controlTermBufferLength: ::std::os::raw::c_int,
                    pub m_controlMtuLength: ::std::os::raw::c_int,
                    pub m_ownsAeronClient: bool,
                    pub m_errorHandler: root::aeron::util::exception_handler_t,
                    pub m_onRecordingSignal: root::aeron::archive::client::on_recording_signal_t,
                    pub m_credentialsSupplier: root::aeron::archive::client::CredentialsSupplier,
                    pub m_delegating_invoker: root::aeron::archive::client::delegating_invoker_t,
                }
                #[test]
                fn bindgen_test_layout_Context() {
                    const UNINIT: ::std::mem::MaybeUninit<Context> =
                        ::std::mem::MaybeUninit::uninit();
                    let ptr = UNINIT.as_ptr();
                    assert_eq!(
                        ::std::mem::size_of::<Context>(),
                        384usize,
                        concat!("Size of: ", stringify!(Context))
                    );
                    assert_eq!(
                        ::std::mem::align_of::<Context>(),
                        8usize,
                        concat!("Alignment of ", stringify!(Context))
                    );
                    assert_eq!(
                        unsafe { ::std::ptr::addr_of!((*ptr).m_aeron) as usize - ptr as usize },
                        0usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(Context),
                            "::",
                            stringify!(m_aeron)
                        )
                    );
                    assert_eq!(
                        unsafe {
                            ::std::ptr::addr_of!((*ptr).m_aeronDirectoryName) as usize
                                - ptr as usize
                        },
                        16usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(Context),
                            "::",
                            stringify!(m_aeronDirectoryName)
                        )
                    );
                    assert_eq!(
                        unsafe {
                            ::std::ptr::addr_of!((*ptr).m_messageTimeoutNs) as usize - ptr as usize
                        },
                        48usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(Context),
                            "::",
                            stringify!(m_messageTimeoutNs)
                        )
                    );
                    assert_eq!(
                        unsafe {
                            ::std::ptr::addr_of!((*ptr).m_controlResponseChannel) as usize
                                - ptr as usize
                        },
                        56usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(Context),
                            "::",
                            stringify!(m_controlResponseChannel)
                        )
                    );
                    assert_eq!(
                        unsafe {
                            ::std::ptr::addr_of!((*ptr).m_controlResponseStreamId) as usize
                                - ptr as usize
                        },
                        88usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(Context),
                            "::",
                            stringify!(m_controlResponseStreamId)
                        )
                    );
                    assert_eq!(
                        unsafe {
                            ::std::ptr::addr_of!((*ptr).m_controlRequestChannel) as usize
                                - ptr as usize
                        },
                        96usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(Context),
                            "::",
                            stringify!(m_controlRequestChannel)
                        )
                    );
                    assert_eq!(
                        unsafe {
                            ::std::ptr::addr_of!((*ptr).m_controlRequestStreamId) as usize
                                - ptr as usize
                        },
                        128usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(Context),
                            "::",
                            stringify!(m_controlRequestStreamId)
                        )
                    );
                    assert_eq!(
                        unsafe {
                            ::std::ptr::addr_of!((*ptr).m_recordingEventsChannel) as usize
                                - ptr as usize
                        },
                        136usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(Context),
                            "::",
                            stringify!(m_recordingEventsChannel)
                        )
                    );
                    assert_eq!(
                        unsafe {
                            ::std::ptr::addr_of!((*ptr).m_recordingEventsStreamId) as usize
                                - ptr as usize
                        },
                        168usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(Context),
                            "::",
                            stringify!(m_recordingEventsStreamId)
                        )
                    );
                    assert_eq!(
                        unsafe {
                            ::std::ptr::addr_of!((*ptr).m_controlTermBufferSparse) as usize
                                - ptr as usize
                        },
                        172usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(Context),
                            "::",
                            stringify!(m_controlTermBufferSparse)
                        )
                    );
                    assert_eq!(
                        unsafe {
                            ::std::ptr::addr_of!((*ptr).m_controlTermBufferLength) as usize
                                - ptr as usize
                        },
                        176usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(Context),
                            "::",
                            stringify!(m_controlTermBufferLength)
                        )
                    );
                    assert_eq!(
                        unsafe {
                            ::std::ptr::addr_of!((*ptr).m_controlMtuLength) as usize - ptr as usize
                        },
                        180usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(Context),
                            "::",
                            stringify!(m_controlMtuLength)
                        )
                    );
                    assert_eq!(
                        unsafe {
                            ::std::ptr::addr_of!((*ptr).m_ownsAeronClient) as usize - ptr as usize
                        },
                        184usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(Context),
                            "::",
                            stringify!(m_ownsAeronClient)
                        )
                    );
                    assert_eq!(
                        unsafe {
                            ::std::ptr::addr_of!((*ptr).m_errorHandler) as usize - ptr as usize
                        },
                        192usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(Context),
                            "::",
                            stringify!(m_errorHandler)
                        )
                    );
                    assert_eq!(
                        unsafe {
                            ::std::ptr::addr_of!((*ptr).m_onRecordingSignal) as usize - ptr as usize
                        },
                        224usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(Context),
                            "::",
                            stringify!(m_onRecordingSignal)
                        )
                    );
                    assert_eq!(
                        unsafe {
                            ::std::ptr::addr_of!((*ptr).m_credentialsSupplier) as usize
                                - ptr as usize
                        },
                        256usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(Context),
                            "::",
                            stringify!(m_credentialsSupplier)
                        )
                    );
                    assert_eq!(
                        unsafe {
                            ::std::ptr::addr_of!((*ptr).m_delegating_invoker) as usize
                                - ptr as usize
                        },
                        352usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(Context),
                            "::",
                            stringify!(m_delegating_invoker)
                        )
                    );
                }
                extern "C" {
                    #[doc = " Conclude configuration by setting up defaults when specifics are not provided."]
                    #[link_name = "\u{1}_ZN5aeron7archive6client7Context8concludeEv"]
                    pub fn Context_conclude(this: *mut root::aeron::archive::client::Context);
                }
                extern "C" {
                    #[doc = " Aeron client for communicating with the local Media Driver.\n <p>\n If not provided then a default will be established during #conclude by calling\n Aeron#connect.\n\n @return client for communicating with the local Media Driver."]
                    #[link_name = "\u{1}_ZN5aeron7archive6client7Context5aeronEv"]
                    pub fn Context_aeron(
                        this: *mut root::aeron::archive::client::Context,
                    ) -> [u64; 2usize];
                }
                extern "C" {
                    #[doc = " Aeron client for communicating with the local Media Driver.\n <p>\n This client will be closed when the AeronArchive goes out of scope if\n #ownsAeronClient is true.\n\n @param aeron client for communicating with the local Media Driver.\n @return this for a fluent API.\n @see Aeron#connect()"]
                    #[link_name = "\u{1}_ZN5aeron7archive6client7Context5aeronESt10shared_ptrINS_5AeronEE"]
                    pub fn Context_aeron1(
                        this: *mut root::aeron::archive::client::Context,
                        aeron: [u64; 2usize],
                    ) -> *mut root::aeron::archive::client::Context;
                }
                extern "C" {
                    #[doc = " The message timeout in nanoseconds to wait for sending or receiving a message.\n\n @return the message timeout in nanoseconds to wait for sending or receiving a message.\n @see MESSAGE_TIMEOUT_NS_DEFAULT"]
                    #[link_name = "\u{1}_ZNK5aeron7archive6client7Context16messageTimeoutNsEv"]
                    pub fn Context_messageTimeoutNs(
                        this: *const root::aeron::archive::client::Context,
                    ) -> ::std::os::raw::c_longlong;
                }
                extern "C" {
                    #[doc = " Set the message timeout in nanoseconds to wait for sending or receiving a message.\n\n @param messageTimeoutNs to wait for sending or receiving a message.\n @return this for a fluent API.\n @see MESSAGE_TIMEOUT_NS_DEFAULT"]
                    #[link_name = "\u{1}_ZN5aeron7archive6client7Context16messageTimeoutNsEx"]
                    pub fn Context_messageTimeoutNs1(
                        this: *mut root::aeron::archive::client::Context,
                        timeoutNs: ::std::os::raw::c_longlong,
                    ) -> *mut root::aeron::archive::client::Context;
                }
                extern "C" {
                    #[doc = " Get the channel URI on which the recording events publication will publish.\n\n @return the channel URI on which the recording events publication will publish."]
                    #[link_name = "\u{1}_ZNK5aeron7archive6client7Context22recordingEventsChannelB5cxx11Ev"]
                    pub fn Context_recordingEventsChannel(
                        this: *const root::aeron::archive::client::Context,
                    ) -> root::std::string;
                }
                extern "C" {
                    #[doc = " Set the channel URI on which the recording events publication will publish.\n <p>\n To support dynamic subscribers then this can be set to multicast or MDC (Multi-Destination-Cast) if\n multicast cannot be supported for on the available the network infrastructure.\n\n @param recordingEventsChannel channel URI on which the recording events publication will publish.\n @return this for a fluent API.\n @see RECORDING_EVENTS_CHANNEL_DEFAULT"]
                    #[link_name = "\u{1}_ZN5aeron7archive6client7Context22recordingEventsChannelERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
                    pub fn Context_recordingEventsChannel1(
                        this: *mut root::aeron::archive::client::Context,
                        recordingEventsChannel: *const root::std::string,
                    ) -> *mut root::aeron::archive::client::Context;
                }
                extern "C" {
                    #[doc = " Get the stream id on which the recording events publication will publish.\n\n @return the stream id on which the recording events publication will publish."]
                    #[link_name = "\u{1}_ZNK5aeron7archive6client7Context23recordingEventsStreamIdEv"]
                    pub fn Context_recordingEventsStreamId(
                        this: *const root::aeron::archive::client::Context,
                    ) -> ::std::os::raw::c_int;
                }
                extern "C" {
                    #[doc = " Set the stream id on which the recording events publication will publish.\n\n @param recordingEventsStreamId stream id on which the recording events publication will publish.\n @return this for a fluent API."]
                    #[link_name = "\u{1}_ZN5aeron7archive6client7Context23recordingEventsStreamIdEi"]
                    pub fn Context_recordingEventsStreamId1(
                        this: *mut root::aeron::archive::client::Context,
                        recordingEventsStreamId: ::std::os::raw::c_int,
                    ) -> *mut root::aeron::archive::client::Context;
                }
                extern "C" {
                    #[doc = " Get the channel parameter for the control response channel.\n\n @return the channel parameter for the control response channel."]
                    #[link_name = "\u{1}_ZNK5aeron7archive6client7Context22controlResponseChannelB5cxx11Ev"]
                    pub fn Context_controlResponseChannel(
                        this: *const root::aeron::archive::client::Context,
                    ) -> root::std::string;
                }
                extern "C" {
                    #[doc = " Set the channel parameter for the control response channel.\n\n @param channel parameter for the control response channel.\n @return this for a fluent API."]
                    #[link_name = "\u{1}_ZN5aeron7archive6client7Context22controlResponseChannelERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
                    pub fn Context_controlResponseChannel1(
                        this: *mut root::aeron::archive::client::Context,
                        channel: *const root::std::string,
                    ) -> *mut root::aeron::archive::client::Context;
                }
                extern "C" {
                    #[doc = " Get the stream id for the control response channel.\n\n @return the stream id for the control response channel."]
                    #[link_name = "\u{1}_ZNK5aeron7archive6client7Context23controlResponseStreamIdEv"]
                    pub fn Context_controlResponseStreamId(
                        this: *const root::aeron::archive::client::Context,
                    ) -> ::std::os::raw::c_int;
                }
                extern "C" {
                    #[doc = " Set the stream id for the control response channel.\n\n @param streamId for the control response channel.\n @return this for a fluent API"]
                    #[link_name = "\u{1}_ZN5aeron7archive6client7Context23controlResponseStreamIdEi"]
                    pub fn Context_controlResponseStreamId1(
                        this: *mut root::aeron::archive::client::Context,
                        streamId: ::std::os::raw::c_int,
                    ) -> *mut root::aeron::archive::client::Context;
                }
                extern "C" {
                    #[doc = " Get the channel parameter for the control request channel.\n\n @return the channel parameter for the control request channel."]
                    #[link_name = "\u{1}_ZNK5aeron7archive6client7Context21controlRequestChannelB5cxx11Ev"]
                    pub fn Context_controlRequestChannel(
                        this: *const root::aeron::archive::client::Context,
                    ) -> root::std::string;
                }
                extern "C" {
                    #[doc = " Set the channel parameter for the control request channel.\n\n @param channel parameter for the control request channel.\n @return this for a fluent API."]
                    #[link_name = "\u{1}_ZN5aeron7archive6client7Context21controlRequestChannelERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
                    pub fn Context_controlRequestChannel1(
                        this: *mut root::aeron::archive::client::Context,
                        channel: *const root::std::string,
                    ) -> *mut root::aeron::archive::client::Context;
                }
                extern "C" {
                    #[doc = " Get the stream id for the control request channel.\n\n @return the stream id for the control request channel."]
                    #[link_name = "\u{1}_ZNK5aeron7archive6client7Context22controlRequestStreamIdEv"]
                    pub fn Context_controlRequestStreamId(
                        this: *const root::aeron::archive::client::Context,
                    ) -> ::std::os::raw::c_int;
                }
                extern "C" {
                    #[doc = " Set the stream id for the control request channel.\n\n @param streamId for the control request channel.\n @return this for a fluent API"]
                    #[link_name = "\u{1}_ZN5aeron7archive6client7Context22controlRequestStreamIdEi"]
                    pub fn Context_controlRequestStreamId1(
                        this: *mut root::aeron::archive::client::Context,
                        streamId: ::std::os::raw::c_int,
                    ) -> *mut root::aeron::archive::client::Context;
                }
                extern "C" {
                    #[doc = " Should the control streams use sparse file term buffers.\n\n @return true if the control stream should use sparse file term buffers."]
                    #[link_name = "\u{1}_ZNK5aeron7archive6client7Context23controlTermBufferSparseEv"]
                    pub fn Context_controlTermBufferSparse(
                        this: *const root::aeron::archive::client::Context,
                    ) -> bool;
                }
                extern "C" {
                    #[doc = " Should the control streams use sparse file term buffers.\n\n @param controlTermBufferSparse for the control stream.\n @return this for a fluent API."]
                    #[link_name = "\u{1}_ZN5aeron7archive6client7Context23controlTermBufferSparseEb"]
                    pub fn Context_controlTermBufferSparse1(
                        this: *mut root::aeron::archive::client::Context,
                        controlTermBufferSparse: bool,
                    ) -> *mut root::aeron::archive::client::Context;
                }
                extern "C" {
                    #[doc = " Get the term buffer length for the control streams.\n\n @return the term buffer length for the control streams."]
                    #[link_name = "\u{1}_ZNK5aeron7archive6client7Context23controlTermBufferLengthEv"]
                    pub fn Context_controlTermBufferLength(
                        this: *const root::aeron::archive::client::Context,
                    ) -> ::std::os::raw::c_int;
                }
                extern "C" {
                    #[doc = " Set the term buffer length for the control streams.\n\n @param controlTermBufferLength for the control streams.\n @return this for a fluent API."]
                    #[link_name = "\u{1}_ZN5aeron7archive6client7Context23controlTermBufferLengthEi"]
                    pub fn Context_controlTermBufferLength1(
                        this: *mut root::aeron::archive::client::Context,
                        controlTermBufferLength: ::std::os::raw::c_int,
                    ) -> *mut root::aeron::archive::client::Context;
                }
                extern "C" {
                    #[doc = " Get the MTU length for the control streams.\n\n @return the MTU length for the control streams."]
                    #[link_name = "\u{1}_ZNK5aeron7archive6client7Context16controlMtuLengthEv"]
                    pub fn Context_controlMtuLength(
                        this: *const root::aeron::archive::client::Context,
                    ) -> ::std::os::raw::c_int;
                }
                extern "C" {
                    #[doc = " Set the MTU length for the control streams.\n\n @param controlMtuLength for the control streams.\n @return this for a fluent API."]
                    #[link_name = "\u{1}_ZN5aeron7archive6client7Context16controlMtuLengthEi"]
                    pub fn Context_controlMtuLength1(
                        this: *mut root::aeron::archive::client::Context,
                        controlMtuLength: ::std::os::raw::c_int,
                    ) -> *mut root::aeron::archive::client::Context;
                }
                extern "C" {
                    #[doc = " Get the top level Aeron directory used for communication between the Aeron client and Media Driver.\n\n @return The top level Aeron directory."]
                    #[link_name = "\u{1}_ZNK5aeron7archive6client7Context18aeronDirectoryNameB5cxx11Ev"]
                    pub fn Context_aeronDirectoryName(
                        this: *const root::aeron::archive::client::Context,
                    ) -> root::std::string;
                }
                extern "C" {
                    #[doc = " Set the top level Aeron directory used for communication between the Aeron client and Media Driver.\n\n @param aeronDirectoryName the top level Aeron directory.\n @return this for a fluent API."]
                    #[link_name = "\u{1}_ZN5aeron7archive6client7Context18aeronDirectoryNameERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
                    pub fn Context_aeronDirectoryName1(
                        this: *mut root::aeron::archive::client::Context,
                        aeronDirectoryName: *const root::std::string,
                    ) -> *mut root::aeron::archive::client::Context;
                }
                extern "C" {
                    #[doc = " Does this context own the Aeron client and thus takes responsibility for closing it?\n\n @return does this context own the Aeron client and thus takes responsibility for closing it?"]
                    #[link_name = "\u{1}_ZNK5aeron7archive6client7Context15ownsAeronClientEv"]
                    pub fn Context_ownsAeronClient(
                        this: *const root::aeron::archive::client::Context,
                    ) -> bool;
                }
                extern "C" {
                    #[doc = " Does this context own the Aeron client and thus takes responsibility for closing it?\n\n @param ownsAeronClient does this context own the Aeron client?\n @return this for a fluent API."]
                    #[link_name = "\u{1}_ZN5aeron7archive6client7Context15ownsAeronClientEb"]
                    pub fn Context_ownsAeronClient1(
                        this: *mut root::aeron::archive::client::Context,
                        ownsAeronClient: bool,
                    ) -> *mut root::aeron::archive::client::Context;
                }
                extern "C" {
                    #[doc = " Get the error handler that will be called for asynchronous errors.\n\n @return the error handler that will be called for asynchronous errors."]
                    #[link_name = "\u{1}_ZNK5aeron7archive6client7Context12errorHandlerEv"]
                    pub fn Context_errorHandler(
                        this: *const root::aeron::archive::client::Context,
                    ) -> root::aeron::util::exception_handler_t;
                }
                extern "C" {
                    #[doc = " Handle errors returned asynchronously from the archive for a control session.\n\n @param errorHandler method to handle objects of type std::exception.\n @return this for a fluent API."]
                    #[link_name = "\u{1}_ZN5aeron7archive6client7Context12errorHandlerERKSt8functionIFvRKSt9exceptionEE"]
                    pub fn Context_errorHandler1(
                        this: *mut root::aeron::archive::client::Context,
                        errorHandler: *const root::aeron::util::exception_handler_t,
                    ) -> *mut root::aeron::archive::client::Context;
                }
                extern "C" {
                    #[doc = " Get the consumer to which recording signals are dispatched when polling for control responses.\n\n @return the consumer to which recording signals are dispatched when polling for control responses."]
                    #[link_name = "\u{1}_ZNK5aeron7archive6client7Context23recordingSignalConsumerEv"]
                    pub fn Context_recordingSignalConsumer(
                        this: *const root::aeron::archive::client::Context,
                    ) -> root::aeron::archive::client::on_recording_signal_t;
                }
                extern "C" {
                    #[doc = " Set the consumer to which recording signals are dispatched when polling for control responses.\n\n @param recordingSignalConsumer to which recording signals are dispatched when polling for control responses.\n @return this for a fluent API."]
                    #[link_name = "\u{1}_ZN5aeron7archive6client7Context23recordingSignalConsumerERKSt8functionIFvlllliEE"]
                    pub fn Context_recordingSignalConsumer1(
                        this: *mut root::aeron::archive::client::Context,
                        recordingSignalConsumer : * const root :: aeron :: archive :: client :: on_recording_signal_t,
                    ) -> *mut root::aeron::archive::client::Context;
                }
                extern "C" {
                    #[doc = " Get the credential supplier that will be called for generating encoded credentials.\n\n @return the credential supplier that will be called for generating encoded credentials."]
                    #[link_name = "\u{1}_ZN5aeron7archive6client7Context19credentialsSupplierEv"]
                    pub fn Context_credentialsSupplier(
                        this: *mut root::aeron::archive::client::Context,
                    ) -> *mut root::aeron::archive::client::CredentialsSupplier;
                }
                extern "C" {
                    #[doc = " Set the CredentialSupplier functions to be called as connect requests are handled.\n\n @param supplier that holds functions to be called.\n @return this for a fluent API."]
                    #[link_name = "\u{1}_ZN5aeron7archive6client7Context19credentialsSupplierERKNS1_19CredentialsSupplierE"]
                    pub fn Context_credentialsSupplier1(
                        this: *mut root::aeron::archive::client::Context,
                        supplier: *const root::aeron::archive::client::CredentialsSupplier,
                    ) -> *mut root::aeron::archive::client::Context;
                }
                extern "C" {
                    #[doc = " Get the function to be invoked in addition to any invoker used by the Aeron instance.\n\n @return the function that is used."]
                    #[link_name = "\u{1}_ZN5aeron7archive6client7Context17delegatingInvokerEv"]
                    pub fn Context_delegatingInvoker(
                        this: *mut root::aeron::archive::client::Context,
                    ) -> *mut root::aeron::archive::client::delegating_invoker_t;
                }
                extern "C" {
                    #[doc = " Set the function to be invoked in addition to any invoker used by the Aeron instance.\n\n Useful for when running on a low thread count scenario.\n\n @param delegatingInvokerFunc to be invoked while awaiting a response in the client.\n @return this for a fluent API."]
                    #[link_name = "\u{1}_ZN5aeron7archive6client7Context17delegatingInvokerERKSt8functionIFvvEE"]
                    pub fn Context_delegatingInvoker1(
                        this: *mut root::aeron::archive::client::Context,
                        delegatingInvokerFunc : * const root :: aeron :: archive :: client :: delegating_invoker_t,
                    ) -> *mut root::aeron::archive::client::Context;
                }
                impl Context {
                    #[inline]
                    pub unsafe fn conclude(&mut self) {
                        Context_conclude(self)
                    }
                    #[inline]
                    pub unsafe fn aeron(&mut self) -> [u64; 2usize] {
                        Context_aeron(self)
                    }
                    #[inline]
                    pub unsafe fn aeron1(&mut self, aeron: [u64; 2usize]) -> *mut root::aeron::archive::client::Context {
                        Context_aeron1(self, aeron)
                    }
                    #[inline]
                    pub unsafe fn messageTimeoutNs(&self) -> ::std::os::raw::c_longlong {
                        Context_messageTimeoutNs(self)
                    }
                    #[inline]
                    pub unsafe fn messageTimeoutNs1(
                        &mut self,
                        timeoutNs: ::std::os::raw::c_longlong,
                    ) -> *mut root::aeron::archive::client::Context {
                        Context_messageTimeoutNs1(self, timeoutNs)
                    }
                    #[inline]
                    pub unsafe fn recordingEventsChannel(&self) -> root::std::string {
                        Context_recordingEventsChannel(self)
                    }
                    #[inline]
                    pub unsafe fn recordingEventsChannel1(
                        &mut self,
                        recordingEventsChannel: *const root::std::string,
                    ) -> *mut root::aeron::archive::client::Context {
                        Context_recordingEventsChannel1(self, recordingEventsChannel)
                    }
                    #[inline]
                    pub unsafe fn recordingEventsStreamId(&self) -> ::std::os::raw::c_int {
                        Context_recordingEventsStreamId(self)
                    }
                    #[inline]
                    pub unsafe fn recordingEventsStreamId1(
                        &mut self,
                        recordingEventsStreamId: ::std::os::raw::c_int,
                    ) -> *mut root::aeron::archive::client::Context {
                        Context_recordingEventsStreamId1(self, recordingEventsStreamId)
                    }
                    #[inline]
                    pub unsafe fn controlResponseChannel(&self) -> root::std::string {
                        Context_controlResponseChannel(self)
                    }
                    #[inline]
                    pub unsafe fn controlResponseChannel1(
                        &mut self,
                        channel: *const root::std::string,
                    ) -> *mut root::aeron::archive::client::Context {
                        Context_controlResponseChannel1(self, channel)
                    }
                    #[inline]
                    pub unsafe fn controlResponseStreamId(&self) -> ::std::os::raw::c_int {
                        Context_controlResponseStreamId(self)
                    }
                    #[inline]
                    pub unsafe fn controlResponseStreamId1(
                        &mut self,
                        streamId: ::std::os::raw::c_int,
                    ) -> *mut root::aeron::archive::client::Context {
                        Context_controlResponseStreamId1(self, streamId)
                    }
                    #[inline]
                    pub unsafe fn controlRequestChannel(&self) -> root::std::string {
                        Context_controlRequestChannel(self)
                    }
                    #[inline]
                    pub unsafe fn controlRequestChannel1(
                        &mut self,
                        channel: *const root::std::string,
                    ) -> *mut root::aeron::archive::client::Context {
                        Context_controlRequestChannel1(self, channel)
                    }
                    #[inline]
                    pub unsafe fn controlRequestStreamId(&self) -> ::std::os::raw::c_int {
                        Context_controlRequestStreamId(self)
                    }
                    #[inline]
                    pub unsafe fn controlRequestStreamId1(
                        &mut self,
                        streamId: ::std::os::raw::c_int,
                    ) -> *mut root::aeron::archive::client::Context {
                        Context_controlRequestStreamId1(self, streamId)
                    }
                    #[inline]
                    pub unsafe fn controlTermBufferSparse(&self) -> bool {
                        Context_controlTermBufferSparse(self)
                    }
                    #[inline]
                    pub unsafe fn controlTermBufferSparse1(
                        &mut self,
                        controlTermBufferSparse: bool,
                    ) -> *mut root::aeron::archive::client::Context {
                        Context_controlTermBufferSparse1(self, controlTermBufferSparse)
                    }
                    #[inline]
                    pub unsafe fn controlTermBufferLength(&self) -> ::std::os::raw::c_int {
                        Context_controlTermBufferLength(self)
                    }
                    #[inline]
                    pub unsafe fn controlTermBufferLength1(
                        &mut self,
                        controlTermBufferLength: ::std::os::raw::c_int,
                    ) -> *mut root::aeron::archive::client::Context {
                        Context_controlTermBufferLength1(self, controlTermBufferLength)
                    }
                    #[inline]
                    pub unsafe fn controlMtuLength(&self) -> ::std::os::raw::c_int {
                        Context_controlMtuLength(self)
                    }
                    #[inline]
                    pub unsafe fn controlMtuLength1(
                        &mut self,
                        controlMtuLength: ::std::os::raw::c_int,
                    ) -> *mut root::aeron::archive::client::Context {
                        Context_controlMtuLength1(self, controlMtuLength)
                    }
                    #[inline]
                    pub unsafe fn aeronDirectoryName(&self) -> root::std::string {
                        Context_aeronDirectoryName(self)
                    }
                    #[inline]
                    pub unsafe fn aeronDirectoryName1(
                        &mut self,
                        aeronDirectoryName: *const root::std::string,
                    ) -> *mut root::aeron::archive::client::Context {
                        Context_aeronDirectoryName1(self, aeronDirectoryName)
                    }
                    #[inline]
                    pub unsafe fn ownsAeronClient(&self) -> bool {
                        Context_ownsAeronClient(self)
                    }
                    #[inline]
                    pub unsafe fn ownsAeronClient1(
                        &mut self,
                        ownsAeronClient: bool,
                    ) -> *mut root::aeron::archive::client::Context {
                        Context_ownsAeronClient1(self, ownsAeronClient)
                    }
                    #[inline]
                    pub unsafe fn errorHandler(&self) -> root::aeron::util::exception_handler_t {
                        Context_errorHandler(self)
                    }
                    #[inline]
                    pub unsafe fn errorHandler1(
                        &mut self,
                        errorHandler: *const root::aeron::util::exception_handler_t,
                    ) -> *mut root::aeron::archive::client::Context {
                        Context_errorHandler1(self, errorHandler)
                    }
                    #[inline]
                    pub unsafe fn recordingSignalConsumer(
                        &self,
                    ) -> root::aeron::archive::client::on_recording_signal_t {
                        Context_recordingSignalConsumer(self)
                    }
                    #[inline]
                    pub unsafe fn recordingSignalConsumer1(
                        &mut self,
                        recordingSignalConsumer : * const root :: aeron :: archive :: client :: on_recording_signal_t,
                    ) -> *mut root::aeron::archive::client::Context {
                        Context_recordingSignalConsumer1(self, recordingSignalConsumer)
                    }
                    #[inline]
                    pub unsafe fn credentialsSupplier(
                        &mut self,
                    ) -> *mut root::aeron::archive::client::CredentialsSupplier
                    {
                        Context_credentialsSupplier(self)
                    }
                    #[inline]
                    pub unsafe fn credentialsSupplier1(
                        &mut self,
                        supplier: *const root::aeron::archive::client::CredentialsSupplier,
                    ) -> *mut root::aeron::archive::client::Context {
                        Context_credentialsSupplier1(self, supplier)
                    }
                    #[inline]
                    pub unsafe fn delegatingInvoker(
                        &mut self,
                    ) -> *mut root::aeron::archive::client::delegating_invoker_t
                    {
                        Context_delegatingInvoker(self)
                    }
                    #[inline]
                    pub unsafe fn delegatingInvoker1(
                        &mut self,
                        delegatingInvokerFunc : * const root :: aeron :: archive :: client :: delegating_invoker_t,
                    ) -> *mut root::aeron::archive::client::Context {
                        Context_delegatingInvoker1(self, delegatingInvokerFunc)
                    }
                }
                #[doc = " Exception raised when communicating with the AeronArchive."]
                #[repr(C)]
                pub struct ArchiveException {
                    pub _base: root::aeron::util::SourcedException,
                    pub m_errorCode: ::std::os::raw::c_int,
                    pub m_correlationId: ::std::os::raw::c_long,
                }
                #[test]
                fn bindgen_test_layout_ArchiveException() {
                    const UNINIT: ::std::mem::MaybeUninit<ArchiveException> =
                        ::std::mem::MaybeUninit::uninit();
                    let ptr = UNINIT.as_ptr();
                    assert_eq!(
                        ::std::mem::size_of::<ArchiveException>(),
                        96usize,
                        concat!("Size of: ", stringify!(ArchiveException))
                    );
                    assert_eq!(
                        ::std::mem::align_of::<ArchiveException>(),
                        8usize,
                        concat!("Alignment of ", stringify!(ArchiveException))
                    );
                    assert_eq!(
                        unsafe { ::std::ptr::addr_of!((*ptr).m_errorCode) as usize - ptr as usize },
                        80usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(ArchiveException),
                            "::",
                            stringify!(m_errorCode)
                        )
                    );
                    assert_eq!(
                        unsafe {
                            ::std::ptr::addr_of!((*ptr).m_correlationId) as usize - ptr as usize
                        },
                        88usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(ArchiveException),
                            "::",
                            stringify!(m_correlationId)
                        )
                    );
                }
                extern "C" {
                    #[doc = " Error code providing more detail into what went wrong.\n\n @return code providing more detail into what went wrong."]
                    #[link_name = "\u{1}_ZNK5aeron7archive6client16ArchiveException9errorCodeEv"]
                    pub fn ArchiveException_errorCode(
                        this: *const root::aeron::archive::client::ArchiveException,
                    ) -> ::std::os::raw::c_int;
                }
                extern "C" {
                    #[doc = " Correlation id of request that triggered the exception.\n\n @return correlation id of request that triggered the exception."]
                    #[link_name = "\u{1}_ZNK5aeron7archive6client16ArchiveException13correlationIdEv"]
                    pub fn ArchiveException_correlationId(
                        this: *const root::aeron::archive::client::ArchiveException,
                    ) -> ::std::os::raw::c_long;
                }
                extern "C" {
                    #[link_name = "\u{1}_ZN5aeron7archive6client16ArchiveExceptionC1ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESA_SA_i"]
                    pub fn ArchiveException_ArchiveException(
                        this: *mut root::aeron::archive::client::ArchiveException,
                        what: *const root::std::string,
                        function: *const root::std::string,
                        file: *const root::std::string,
                        line: ::std::os::raw::c_int,
                    );
                }
                extern "C" {
                    #[link_name = "\u{1}_ZN5aeron7archive6client16ArchiveExceptionC1EiRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESA_SA_i"]
                    pub fn ArchiveException_ArchiveException1(
                        this: *mut root::aeron::archive::client::ArchiveException,
                        errorCode: ::std::os::raw::c_int,
                        what: *const root::std::string,
                        function: *const root::std::string,
                        file: *const root::std::string,
                        line: ::std::os::raw::c_int,
                    );
                }
                extern "C" {
                    #[link_name = "\u{1}_ZN5aeron7archive6client16ArchiveExceptionC1EilRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESA_SA_i"]
                    pub fn ArchiveException_ArchiveException2(
                        this: *mut root::aeron::archive::client::ArchiveException,
                        errorCode: ::std::os::raw::c_int,
                        correlationId: ::std::os::raw::c_long,
                        what: *const root::std::string,
                        function: *const root::std::string,
                        file: *const root::std::string,
                        line: ::std::os::raw::c_int,
                    );
                }
                impl ArchiveException {
                    #[inline]
                    pub unsafe fn errorCode(&self) -> ::std::os::raw::c_int {
                        ArchiveException_errorCode(self)
                    }
                    #[inline]
                    pub unsafe fn correlationId(&self) -> ::std::os::raw::c_long {
                        ArchiveException_correlationId(self)
                    }
                    #[inline]
                    pub unsafe fn new(
                        what: *const root::std::string,
                        function: *const root::std::string,
                        file: *const root::std::string,
                        line: ::std::os::raw::c_int,
                    ) -> Self {
                        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                        ArchiveException_ArchiveException(
                            __bindgen_tmp.as_mut_ptr(),
                            what,
                            function,
                            file,
                            line,
                        );
                        __bindgen_tmp.assume_init()
                    }
                    #[inline]
                    pub unsafe fn new1(
                        errorCode: ::std::os::raw::c_int,
                        what: *const root::std::string,
                        function: *const root::std::string,
                        file: *const root::std::string,
                        line: ::std::os::raw::c_int,
                    ) -> Self {
                        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                        ArchiveException_ArchiveException1(
                            __bindgen_tmp.as_mut_ptr(),
                            errorCode,
                            what,
                            function,
                            file,
                            line,
                        );
                        __bindgen_tmp.assume_init()
                    }
                    #[inline]
                    pub unsafe fn new2(
                        errorCode: ::std::os::raw::c_int,
                        correlationId: ::std::os::raw::c_long,
                        what: *const root::std::string,
                        function: *const root::std::string,
                        file: *const root::std::string,
                        line: ::std::os::raw::c_int,
                    ) -> Self {
                        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                        ArchiveException_ArchiveException2(
                            __bindgen_tmp.as_mut_ptr(),
                            errorCode,
                            correlationId,
                            what,
                            function,
                            file,
                            line,
                        );
                        __bindgen_tmp.assume_init()
                    }
                }
                #[doc = " Contains the optional parameters that can be passed to a Replication Request. Controls the behaviour of the\n replication including tagging, stop position, extending destination recordings, live merging, and setting the\n maximum length of the file I/O operations."]
                #[repr(C)]
                #[derive(Copy, Clone)]
                pub struct ReplicationParams {
                    pub m_stopPosition: ::std::os::raw::c_long,
                    pub m_dstRecordingId: ::std::os::raw::c_long,
                    pub m_liveDestination: root::std::string,
                    pub m_replicationChannel: root::std::string,
                    pub m_channelTagId: ::std::os::raw::c_long,
                    pub m_subscriptionTagId: ::std::os::raw::c_long,
                    pub m_fileIoMaxLength: ::std::os::raw::c_int,
                    pub m_replicationSessionId: ::std::os::raw::c_int,
                    pub m_encodedCredentials: [u64; 2usize],
                }
                #[test]
                fn bindgen_test_layout_ReplicationParams() {
                    const UNINIT: ::std::mem::MaybeUninit<ReplicationParams> =
                        ::std::mem::MaybeUninit::uninit();
                    let ptr = UNINIT.as_ptr();
                    assert_eq!(
                        ::std::mem::size_of::<ReplicationParams>(),
                        120usize,
                        concat!("Size of: ", stringify!(ReplicationParams))
                    );
                    assert_eq!(
                        ::std::mem::align_of::<ReplicationParams>(),
                        8usize,
                        concat!("Alignment of ", stringify!(ReplicationParams))
                    );
                    assert_eq!(
                        unsafe {
                            ::std::ptr::addr_of!((*ptr).m_stopPosition) as usize - ptr as usize
                        },
                        0usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(ReplicationParams),
                            "::",
                            stringify!(m_stopPosition)
                        )
                    );
                    assert_eq!(
                        unsafe {
                            ::std::ptr::addr_of!((*ptr).m_dstRecordingId) as usize - ptr as usize
                        },
                        8usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(ReplicationParams),
                            "::",
                            stringify!(m_dstRecordingId)
                        )
                    );
                    assert_eq!(
                        unsafe {
                            ::std::ptr::addr_of!((*ptr).m_liveDestination) as usize - ptr as usize
                        },
                        16usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(ReplicationParams),
                            "::",
                            stringify!(m_liveDestination)
                        )
                    );
                    assert_eq!(
                        unsafe {
                            ::std::ptr::addr_of!((*ptr).m_replicationChannel) as usize
                                - ptr as usize
                        },
                        48usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(ReplicationParams),
                            "::",
                            stringify!(m_replicationChannel)
                        )
                    );
                    assert_eq!(
                        unsafe {
                            ::std::ptr::addr_of!((*ptr).m_channelTagId) as usize - ptr as usize
                        },
                        80usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(ReplicationParams),
                            "::",
                            stringify!(m_channelTagId)
                        )
                    );
                    assert_eq!(
                        unsafe {
                            ::std::ptr::addr_of!((*ptr).m_subscriptionTagId) as usize - ptr as usize
                        },
                        88usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(ReplicationParams),
                            "::",
                            stringify!(m_subscriptionTagId)
                        )
                    );
                    assert_eq!(
                        unsafe {
                            ::std::ptr::addr_of!((*ptr).m_fileIoMaxLength) as usize - ptr as usize
                        },
                        96usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(ReplicationParams),
                            "::",
                            stringify!(m_fileIoMaxLength)
                        )
                    );
                    assert_eq!(
                        unsafe {
                            ::std::ptr::addr_of!((*ptr).m_replicationSessionId) as usize
                                - ptr as usize
                        },
                        100usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(ReplicationParams),
                            "::",
                            stringify!(m_replicationSessionId)
                        )
                    );
                    assert_eq!(
                        unsafe {
                            ::std::ptr::addr_of!((*ptr).m_encodedCredentials) as usize
                                - ptr as usize
                        },
                        104usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(ReplicationParams),
                            "::",
                            stringify!(m_encodedCredentials)
                        )
                    );
                }
                extern "C" {
                    #[doc = " The stop position for this replication request.\n @return stop position"]
                    #[link_name = "\u{1}_ZNK5aeron7archive6client17ReplicationParams12stopPositionEv"]
                    pub fn ReplicationParams_stopPosition(
                        this: *const root::aeron::archive::client::ReplicationParams,
                    ) -> ::std::os::raw::c_long;
                }
                extern "C" {
                    #[doc = " Set the stop position for replication, default is aeron::NULL_POSITION, which will continuously replicate.\n\n @param stopPosition position to stop the replication at.\n @return this for a fluent API"]
                    #[link_name = "\u{1}_ZN5aeron7archive6client17ReplicationParams12stopPositionEl"]
                    pub fn ReplicationParams_stopPosition1(
                        this: *mut root::aeron::archive::client::ReplicationParams,
                        stopPosition: ::std::os::raw::c_long,
                    ) -> *mut root::aeron::archive::client::ReplicationParams;
                }
                extern "C" {
                    #[doc = " Destination recording id to extend.\n\n @return destination recording id."]
                    #[link_name = "\u{1}_ZNK5aeron7archive6client17ReplicationParams14dstRecordingIdEv"]
                    pub fn ReplicationParams_dstRecordingId(
                        this: *const root::aeron::archive::client::ReplicationParams,
                    ) -> i64;
                }
                extern "C" {
                    #[doc = " The recording in the local archive to extend. Default is aeron::NULL_VALUE which will trigger the creation\n of a new recording in the destination archive.\n\n @param dstRecordingId destination recording to extend.\n @return this for a fluent API."]
                    #[link_name = "\u{1}_ZN5aeron7archive6client17ReplicationParams14dstRecordingIdEl"]
                    pub fn ReplicationParams_dstRecordingId1(
                        this: *mut root::aeron::archive::client::ReplicationParams,
                        dstRecordingId: i64,
                    ) -> *mut root::aeron::archive::client::ReplicationParams;
                }
                extern "C" {
                    #[doc = " Gets the destination for the live stream merge.\n\n @return destination for live stream merge."]
                    #[link_name = "\u{1}_ZNK5aeron7archive6client17ReplicationParams15liveDestinationB5cxx11Ev"]
                    pub fn ReplicationParams_liveDestination(
                        this: *const root::aeron::archive::client::ReplicationParams,
                    ) -> *const root::std::string;
                }
                extern "C" {
                    #[doc = " Destination for the live stream if merge is required. Default is empty string for no merge.\n\n @param liveChannel for the live stream merge\n @return this for a fluent API."]
                    #[link_name = "\u{1}_ZN5aeron7archive6client17ReplicationParams15liveDestinationERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
                    pub fn ReplicationParams_liveDestination1(
                        this: *mut root::aeron::archive::client::ReplicationParams,
                        liveDestination: *const root::std::string,
                    ) -> *mut root::aeron::archive::client::ReplicationParams;
                }
                extern "C" {
                    #[doc = " Channel to use for replicating the recording, empty string will mean that the default channel is used.\n @return channel to replicate the recording."]
                    #[link_name = "\u{1}_ZNK5aeron7archive6client17ReplicationParams18replicationChannelB5cxx11Ev"]
                    pub fn ReplicationParams_replicationChannel(
                        this: *const root::aeron::archive::client::ReplicationParams,
                    ) -> *const root::std::string;
                }
                extern "C" {
                    #[doc = " Channel use to replicate the recording. Default is empty string which will use the context's default replication\n channel\n\n @param replicationChannel to use for replicating the recording.\n @return this for a fluent API."]
                    #[link_name = "\u{1}_ZN5aeron7archive6client17ReplicationParams18replicationChannelERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
                    pub fn ReplicationParams_replicationChannel1(
                        this: *mut root::aeron::archive::client::ReplicationParams,
                        replicationChannel: *const root::std::string,
                    ) -> *mut root::aeron::archive::client::ReplicationParams;
                }
                extern "C" {
                    #[doc = " Gets channel tag id for the archive subscription.\n\n @return channel tag id."]
                    #[link_name = "\u{1}_ZNK5aeron7archive6client17ReplicationParams12channelTagIdEv"]
                    pub fn ReplicationParams_channelTagId(
                        this: *const root::aeron::archive::client::ReplicationParams,
                    ) -> i64;
                }
                extern "C" {
                    #[doc = " The channel used by the archive's subscription for replication will have the supplied channel tag applied to it.\n The default value for channelTagId is aeron::NULL_VALUE\n\n @param channelTagId tag to apply to the archive's subscription.\n @return this for a fluent API"]
                    #[link_name = "\u{1}_ZN5aeron7archive6client17ReplicationParams12channelTagIdEl"]
                    pub fn ReplicationParams_channelTagId1(
                        this: *mut root::aeron::archive::client::ReplicationParams,
                        channelTagId: i64,
                    ) -> *mut root::aeron::archive::client::ReplicationParams;
                }
                extern "C" {
                    #[doc = " Gets subscription tag id for the archive subscription.\n\n  @return subscription tag id."]
                    #[link_name = "\u{1}_ZNK5aeron7archive6client17ReplicationParams17subscriptionTagIdEv"]
                    pub fn ReplicationParams_subscriptionTagId(
                        this: *const root::aeron::archive::client::ReplicationParams,
                    ) -> i64;
                }
                extern "C" {
                    #[doc = " The channel used by the archive's subscription for replication will have the supplied subscription tag applied to\n it. The default value for subscriptionTagId is aeron::NULL_VALUE\n\n @param subscriptionTagId tag to apply to the archive's subscription.\n @return this for a fluent API"]
                    #[link_name = "\u{1}_ZN5aeron7archive6client17ReplicationParams17subscriptionTagIdEl"]
                    pub fn ReplicationParams_subscriptionTagId1(
                        this: *mut root::aeron::archive::client::ReplicationParams,
                        subscriptionTagId: i64,
                    ) -> *mut root::aeron::archive::client::ReplicationParams;
                }
                extern "C" {
                    #[doc = " Gets the maximum length for file IO operations in the replay. Defaults to {@link Aeron#NULL_VALUE} if not\n set, which will trigger the use of the Archive.Context default.\n\n @return maximum length of a file I/O operation."]
                    #[link_name = "\u{1}_ZNK5aeron7archive6client17ReplicationParams15fileIoMaxLengthEv"]
                    pub fn ReplicationParams_fileIoMaxLength(
                        this: *const root::aeron::archive::client::ReplicationParams,
                    ) -> i32;
                }
                extern "C" {
                    #[doc = " The maximum size of a file operation when reading from the archive to execute the replication. Will use the value\n defined in the context otherwise. This can be used reduce the size of file IO operations to lower the\n priority of some replays. Setting it to a value larger than the context value will have no affect.\n\n @param fileIoMaxLength maximum length of a file I/O operation.\n @return this for a fluent API"]
                    #[link_name = "\u{1}_ZN5aeron7archive6client17ReplicationParams15fileIoMaxLengthEi"]
                    pub fn ReplicationParams_fileIoMaxLength1(
                        this: *mut root::aeron::archive::client::ReplicationParams,
                        fileIoMaxLength: i32,
                    ) -> *mut root::aeron::archive::client::ReplicationParams;
                }
                extern "C" {
                    #[doc = " Sets the session-id to be used for the replicated file instead of the session id from the source archive. This\n is useful in cases where we are replicating the same recording in multiple stages.\n\n @param replicationSessionId the session-id to be set for the received recording.\n @return this for fluent API"]
                    #[link_name = "\u{1}_ZN5aeron7archive6client17ReplicationParams20replicationSessionIdEi"]
                    pub fn ReplicationParams_replicationSessionId(
                        this: *mut root::aeron::archive::client::ReplicationParams,
                        replicationSessionId: ::std::os::raw::c_int,
                    ) -> *mut root::aeron::archive::client::ReplicationParams;
                }
                extern "C" {
                    #[doc = " The session-id to be used for the replicated recording.\n\n @return session-id to be useful for the replicated recording."]
                    #[link_name = "\u{1}_ZNK5aeron7archive6client17ReplicationParams20replicationSessionIdEv"]
                    pub fn ReplicationParams_replicationSessionId1(
                        this: *const root::aeron::archive::client::ReplicationParams,
                    ) -> ::std::os::raw::c_int;
                }
                extern "C" {
                    #[doc = " Sets the encoded credentials that will be passed to the source archive for authentication. Currently only simple\n authentication (i.e. not challenge/response) is supported for replication.\n\n @param encodedCredentials credentials to be passed to the source archive.\n @return this for a fluent API."]
                    #[link_name = "\u{1}_ZN5aeron7archive6client17ReplicationParams18encodedCredentialsESt4pairIPKcjE"]
                    pub fn ReplicationParams_encodedCredentials(
                        this: *mut root::aeron::archive::client::ReplicationParams,
                        encodedCredentials: [u64; 2usize],
                    ) -> *mut root::aeron::archive::client::ReplicationParams;
                }
                extern "C" {
                    #[doc = " Gets the encoded credentials that will be used to authenticate against the source archive.\n\n @return encoded credentials used for authentication."]
                    #[link_name = "\u{1}_ZNK5aeron7archive6client17ReplicationParams18encodedCredentialsEv"]
                    pub fn ReplicationParams_encodedCredentials1(
                        this: *const root::aeron::archive::client::ReplicationParams,
                    ) -> [u64; 2usize];
                }
                extern "C" {
                    #[link_name = "\u{1}_ZN5aeron7archive6client17ReplicationParamsC1Ev"]
                    pub fn ReplicationParams_ReplicationParams(
                        this: *mut root::aeron::archive::client::ReplicationParams,
                    );
                }
                impl ReplicationParams {
                    #[inline]
                    pub unsafe fn stopPosition(&self) -> ::std::os::raw::c_long {
                        ReplicationParams_stopPosition(self)
                    }
                    #[inline]
                    pub unsafe fn stopPosition1(
                        &mut self,
                        stopPosition: ::std::os::raw::c_long,
                    ) -> *mut root::aeron::archive::client::ReplicationParams {
                        ReplicationParams_stopPosition1(self, stopPosition)
                    }
                    #[inline]
                    pub unsafe fn dstRecordingId(&self) -> i64 {
                        ReplicationParams_dstRecordingId(self)
                    }
                    #[inline]
                    pub unsafe fn dstRecordingId1(
                        &mut self,
                        dstRecordingId: i64,
                    ) -> *mut root::aeron::archive::client::ReplicationParams {
                        ReplicationParams_dstRecordingId1(self, dstRecordingId)
                    }
                    #[inline]
                    pub unsafe fn liveDestination(&self) -> *const root::std::string {
                        ReplicationParams_liveDestination(self)
                    }
                    #[inline]
                    pub unsafe fn liveDestination1(
                        &mut self,
                        liveDestination: *const root::std::string,
                    ) -> *mut root::aeron::archive::client::ReplicationParams {
                        ReplicationParams_liveDestination1(self, liveDestination)
                    }
                    #[inline]
                    pub unsafe fn replicationChannel(&self) -> *const root::std::string {
                        ReplicationParams_replicationChannel(self)
                    }
                    #[inline]
                    pub unsafe fn replicationChannel1(
                        &mut self,
                        replicationChannel: *const root::std::string,
                    ) -> *mut root::aeron::archive::client::ReplicationParams {
                        ReplicationParams_replicationChannel1(self, replicationChannel)
                    }
                    #[inline]
                    pub unsafe fn channelTagId(&self) -> i64 {
                        ReplicationParams_channelTagId(self)
                    }
                    #[inline]
                    pub unsafe fn channelTagId1(
                        &mut self,
                        channelTagId: i64,
                    ) -> *mut root::aeron::archive::client::ReplicationParams {
                        ReplicationParams_channelTagId1(self, channelTagId)
                    }
                    #[inline]
                    pub unsafe fn subscriptionTagId(&self) -> i64 {
                        ReplicationParams_subscriptionTagId(self)
                    }
                    #[inline]
                    pub unsafe fn subscriptionTagId1(
                        &mut self,
                        subscriptionTagId: i64,
                    ) -> *mut root::aeron::archive::client::ReplicationParams {
                        ReplicationParams_subscriptionTagId1(self, subscriptionTagId)
                    }
                    #[inline]
                    pub unsafe fn fileIoMaxLength(&self) -> i32 {
                        ReplicationParams_fileIoMaxLength(self)
                    }
                    #[inline]
                    pub unsafe fn fileIoMaxLength1(
                        &mut self,
                        fileIoMaxLength: i32,
                    ) -> *mut root::aeron::archive::client::ReplicationParams {
                        ReplicationParams_fileIoMaxLength1(self, fileIoMaxLength)
                    }
                    #[inline]
                    pub unsafe fn replicationSessionId(
                        &mut self,
                        replicationSessionId: ::std::os::raw::c_int,
                    ) -> *mut root::aeron::archive::client::ReplicationParams {
                        ReplicationParams_replicationSessionId(self, replicationSessionId)
                    }
                    #[inline]
                    pub unsafe fn replicationSessionId1(&self) -> ::std::os::raw::c_int {
                        ReplicationParams_replicationSessionId1(self)
                    }
                    #[inline]
                    pub unsafe fn encodedCredentials(
                        &mut self,
                        encodedCredentials: [u64; 2usize],
                    ) -> *mut root::aeron::archive::client::ReplicationParams {
                        ReplicationParams_encodedCredentials(self, encodedCredentials)
                    }
                    #[inline]
                    pub unsafe fn encodedCredentials1(&self) -> [u64; 2usize] {
                        ReplicationParams_encodedCredentials1(self)
                    }
                    #[inline]
                    pub unsafe fn new() -> Self {
                        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                        ReplicationParams_ReplicationParams(__bindgen_tmp.as_mut_ptr());
                        __bindgen_tmp.assume_init()
                    }
                }
                #[doc = " Fluent API for setting optional replay parameters. Allows the user to configure starting position,\n replay length, bounding counter (for a bounded replay) and the max length for file I/O operations."]
                #[repr(C)]
                #[derive(Copy, Clone)]
                pub struct ReplayParams {
                    pub m_boundingLimitCounterId: ::std::os::raw::c_int,
                    pub m_fileIoMaxLength: ::std::os::raw::c_int,
                    pub m_position: ::std::os::raw::c_long,
                    pub m_length: ::std::os::raw::c_long,
                }
                #[test]
                fn bindgen_test_layout_ReplayParams() {
                    const UNINIT: ::std::mem::MaybeUninit<ReplayParams> =
                        ::std::mem::MaybeUninit::uninit();
                    let ptr = UNINIT.as_ptr();
                    assert_eq!(
                        ::std::mem::size_of::<ReplayParams>(),
                        24usize,
                        concat!("Size of: ", stringify!(ReplayParams))
                    );
                    assert_eq!(
                        ::std::mem::align_of::<ReplayParams>(),
                        8usize,
                        concat!("Alignment of ", stringify!(ReplayParams))
                    );
                    assert_eq!(
                        unsafe {
                            ::std::ptr::addr_of!((*ptr).m_boundingLimitCounterId) as usize
                                - ptr as usize
                        },
                        0usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(ReplayParams),
                            "::",
                            stringify!(m_boundingLimitCounterId)
                        )
                    );
                    assert_eq!(
                        unsafe {
                            ::std::ptr::addr_of!((*ptr).m_fileIoMaxLength) as usize - ptr as usize
                        },
                        4usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(ReplayParams),
                            "::",
                            stringify!(m_fileIoMaxLength)
                        )
                    );
                    assert_eq!(
                        unsafe { ::std::ptr::addr_of!((*ptr).m_position) as usize - ptr as usize },
                        8usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(ReplayParams),
                            "::",
                            stringify!(m_position)
                        )
                    );
                    assert_eq!(
                        unsafe { ::std::ptr::addr_of!((*ptr).m_length) as usize - ptr as usize },
                        16usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(ReplayParams),
                            "::",
                            stringify!(m_length)
                        )
                    );
                }
                extern "C" {
                    #[doc = " Gets the counterId specified for the bounding the replay. Returns aeron::NULL_VALUE if unspecified.\n\n @return the counter id to bound the replay."]
                    #[link_name = "\u{1}_ZNK5aeron7archive6client12ReplayParams22boundingLimitCounterIdEv"]
                    pub fn ReplayParams_boundingLimitCounterId(
                        this: *const root::aeron::archive::client::ReplayParams,
                    ) -> i32;
                }
                extern "C" {
                    #[doc = " Sets the counter id to be used for bounding the replay. Setting this value will trigger the sending of a\n bounded replay request instead of a normal replay. Default is aeron::NULL_VALUE, which will mean that a\n bound will not be applied.\n\n @param boundingLimitCounterId counter to use to bound the replay\n @return this for a fluent API"]
                    #[link_name = "\u{1}_ZN5aeron7archive6client12ReplayParams22boundingLimitCounterIdEi"]
                    pub fn ReplayParams_boundingLimitCounterId1(
                        this: *mut root::aeron::archive::client::ReplayParams,
                        mBoundingLimitCounterId: i32,
                    ) -> *mut root::aeron::archive::client::ReplayParams;
                }
                extern "C" {
                    #[doc = " Gets the maximum length for file IO operations in the replay. Defaults to aeron::NULL_VALUE if not\n set, which will trigger the use of the Archive.Context default.\n\n @return maximum file length for IO operations during replay."]
                    #[link_name = "\u{1}_ZNK5aeron7archive6client12ReplayParams15fileIoMaxLengthEv"]
                    pub fn ReplayParams_fileIoMaxLength(
                        this: *const root::aeron::archive::client::ReplayParams,
                    ) -> i32;
                }
                extern "C" {
                    #[doc = " The maximum size of a file operation when reading from the archive to execute the replay. Will use the value\n defined in the context otherwise. This can be used reduce the size of file IO operations to lower the\n priority of some replays. Setting it to a value larger than the context value will have no affect.\n\n @param fileIoMaxLength maximum length of a replay file operation\n @return this for a fluent API"]
                    #[link_name = "\u{1}_ZN5aeron7archive6client12ReplayParams15fileIoMaxLengthEi"]
                    pub fn ReplayParams_fileIoMaxLength1(
                        this: *mut root::aeron::archive::client::ReplayParams,
                        mFileIoMaxLength: i32,
                    ) -> *mut root::aeron::archive::client::ReplayParams;
                }
                extern "C" {
                    #[doc = " Position to start the replay at.\n\n @return position for the start of the replay."]
                    #[link_name = "\u{1}_ZNK5aeron7archive6client12ReplayParams8positionEv"]
                    pub fn ReplayParams_position(
                        this: *const root::aeron::archive::client::ReplayParams,
                    ) -> i64;
                }
                extern "C" {
                    #[doc = " Set the position to start the replay. If set to aeron::NULL_POSITION (which is the default) then\n the stream will be replayed from the start.\n\n @param position to start the replay from.\n @return this for a fluent API."]
                    #[link_name = "\u{1}_ZN5aeron7archive6client12ReplayParams8positionEl"]
                    pub fn ReplayParams_position1(
                        this: *mut root::aeron::archive::client::ReplayParams,
                        mPosition: i64,
                    ) -> *mut root::aeron::archive::client::ReplayParams;
                }
                extern "C" {
                    #[doc = " Length of the recording to replay.\n\n @return length of the recording to replay."]
                    #[link_name = "\u{1}_ZNK5aeron7archive6client12ReplayParams6lengthEv"]
                    pub fn ReplayParams_length(
                        this: *const root::aeron::archive::client::ReplayParams,
                    ) -> i64;
                }
                extern "C" {
                    #[doc = " The length of the recorded stream to replay. If set to aeron::NULL_POSITION (the default) will\n replay a whole stream of unknown length. If set to INT64_MAX it will follow a live recording.\n\n @param length of the recording to be replayed.\n @return this for a fluent API."]
                    #[link_name = "\u{1}_ZN5aeron7archive6client12ReplayParams6lengthEl"]
                    pub fn ReplayParams_length1(
                        this: *mut root::aeron::archive::client::ReplayParams,
                        mLength: i64,
                    ) -> *mut root::aeron::archive::client::ReplayParams;
                }
                extern "C" {
                    #[doc = " Determines if the parameter setup has requested a bounded replay.\n\n @return true if the replay should be bounded, false otherwise."]
                    #[link_name = "\u{1}_ZNK5aeron7archive6client12ReplayParams9isBoundedEv"]
                    pub fn ReplayParams_isBounded(
                        this: *const root::aeron::archive::client::ReplayParams,
                    ) -> bool;
                }
                extern "C" {
                    #[link_name = "\u{1}_ZN5aeron7archive6client12ReplayParamsC1Ev"]
                    pub fn ReplayParams_ReplayParams(
                        this: *mut root::aeron::archive::client::ReplayParams,
                    );
                }
                impl ReplayParams {
                    #[inline]
                    pub unsafe fn boundingLimitCounterId(&self) -> i32 {
                        ReplayParams_boundingLimitCounterId(self)
                    }
                    #[inline]
                    pub unsafe fn boundingLimitCounterId1(
                        &mut self,
                        mBoundingLimitCounterId: i32,
                    ) -> *mut root::aeron::archive::client::ReplayParams {
                        ReplayParams_boundingLimitCounterId1(self, mBoundingLimitCounterId)
                    }
                    #[inline]
                    pub unsafe fn fileIoMaxLength(&self) -> i32 {
                        ReplayParams_fileIoMaxLength(self)
                    }
                    #[inline]
                    pub unsafe fn fileIoMaxLength1(
                        &mut self,
                        mFileIoMaxLength: i32,
                    ) -> *mut root::aeron::archive::client::ReplayParams {
                        ReplayParams_fileIoMaxLength1(self, mFileIoMaxLength)
                    }
                    #[inline]
                    pub unsafe fn position(&self) -> i64 {
                        ReplayParams_position(self)
                    }
                    #[inline]
                    pub unsafe fn position1(
                        &mut self,
                        mPosition: i64,
                    ) -> *mut root::aeron::archive::client::ReplayParams {
                        ReplayParams_position1(self, mPosition)
                    }
                    #[inline]
                    pub unsafe fn length(&self) -> i64 {
                        ReplayParams_length(self)
                    }
                    #[inline]
                    pub unsafe fn length1(
                        &mut self,
                        mLength: i64,
                    ) -> *mut root::aeron::archive::client::ReplayParams {
                        ReplayParams_length1(self, mLength)
                    }
                    #[inline]
                    pub unsafe fn isBounded(&self) -> bool {
                        ReplayParams_isBounded(self)
                    }
                    #[inline]
                    pub unsafe fn new() -> Self {
                        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                        ReplayParams_ReplayParams(__bindgen_tmp.as_mut_ptr());
                        __bindgen_tmp.assume_init()
                    }
                }
                #[doc = " Proxy class for encapsulating encoding and sending of control protocol messages to an archive."]
                #[repr(C)]
                pub struct ArchiveProxy {
                    pub m_array: [u8; 8192usize],
                    pub m_buffer: root::aeron::concurrent::AtomicBuffer,
                    pub m_publication: [u64; 2usize],
                    pub m_retryAttempts: ::std::os::raw::c_int,
                }
                #[test]
                fn bindgen_test_layout_ArchiveProxy() {
                    const UNINIT: ::std::mem::MaybeUninit<ArchiveProxy> =
                        ::std::mem::MaybeUninit::uninit();
                    let ptr = UNINIT.as_ptr();
                    assert_eq!(
                        ::std::mem::size_of::<ArchiveProxy>(),
                        8232usize,
                        concat!("Size of: ", stringify!(ArchiveProxy))
                    );
                    assert_eq!(
                        ::std::mem::align_of::<ArchiveProxy>(),
                        8usize,
                        concat!("Alignment of ", stringify!(ArchiveProxy))
                    );
                    assert_eq!(
                        unsafe { ::std::ptr::addr_of!((*ptr).m_array) as usize - ptr as usize },
                        0usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(ArchiveProxy),
                            "::",
                            stringify!(m_array)
                        )
                    );
                    assert_eq!(
                        unsafe { ::std::ptr::addr_of!((*ptr).m_buffer) as usize - ptr as usize },
                        8192usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(ArchiveProxy),
                            "::",
                            stringify!(m_buffer)
                        )
                    );
                    assert_eq!(
                        unsafe {
                            ::std::ptr::addr_of!((*ptr).m_publication) as usize - ptr as usize
                        },
                        8208usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(ArchiveProxy),
                            "::",
                            stringify!(m_publication)
                        )
                    );
                    assert_eq!(
                        unsafe {
                            ::std::ptr::addr_of!((*ptr).m_retryAttempts) as usize - ptr as usize
                        },
                        8224usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(ArchiveProxy),
                            "::",
                            stringify!(m_retryAttempts)
                        )
                    );
                }
                extern "C" {
                    #[doc = " Get the Publication used for sending control messages.\n\n @return the Publication used for sending control messages."]
                    #[link_name = "\u{1}_ZN5aeron7archive6client12ArchiveProxy11publicationEv"]
                    pub fn ArchiveProxy_publication(
                        this: *mut root::aeron::archive::client::ArchiveProxy,
                    ) -> [u64; 2usize];
                }
                extern "C" {
                    #[doc = " Try Connect to an archive on its control interface providing the response stream details. Only one attempt will\n be made to offer the request.\n\n @param responseChannel  for the control message responses.\n @param responseStreamId for the control message responses.\n @param encodedCredentials for the connect request.\n @param correlationId    for this request.\n @return true if successfully offered otherwise false."]
                    #[link_name = "\u{1}_ZN5aeron7archive6client12ArchiveProxy10tryConnectERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEiSt4pairIPKcjEl"]
                    pub fn ArchiveProxy_tryConnect(
                        this: *mut root::aeron::archive::client::ArchiveProxy,
                        responseChannel: *const root::std::string,
                        responseStreamId: ::std::os::raw::c_int,
                        encodedCredentials: [u64; 2usize],
                        correlationId: ::std::os::raw::c_long,
                    ) -> bool;
                }
                extern "C" {
                    #[doc = " Try send a challenge response to an archive on its control interface providing the response details.\n Only one attempt will be made to offer the response.\n\n @param encodedCredentials for the response.\n @param correlationId      for this response.\n @param controlSessionId   for this response.\n @return true if successfully offered otherwise false."]
                    #[link_name = "\u{1}_ZN5aeron7archive6client12ArchiveProxy20tryChallengeResponseESt4pairIPKcjEll"]
                    pub fn ArchiveProxy_tryChallengeResponse(
                        this: *mut root::aeron::archive::client::ArchiveProxy,
                        encodedCredentials: [u64; 2usize],
                        correlationId: ::std::os::raw::c_long,
                        controlSessionId: ::std::os::raw::c_long,
                    ) -> bool;
                }
                extern "C" {
                    #[link_name = "\u{1}_ZN5aeron7archive6client12ArchiveProxyC1ESt10shared_ptrINS_20ExclusivePublicationEEi"]
                    pub fn ArchiveProxy_ArchiveProxy(
                        this: *mut root::aeron::archive::client::ArchiveProxy,
                        publication: [u64; 2usize],
                        retryAttempts: ::std::os::raw::c_int,
                    );
                }
                impl ArchiveProxy {
                    #[inline]
                    pub unsafe fn publication(&mut self) -> [u64; 2usize] {
                        ArchiveProxy_publication(self)
                    }
                    #[inline]
                    pub unsafe fn tryConnect(
                        &mut self,
                        responseChannel: *const root::std::string,
                        responseStreamId: ::std::os::raw::c_int,
                        encodedCredentials: [u64; 2usize],
                        correlationId: ::std::os::raw::c_long,
                    ) -> bool {
                        ArchiveProxy_tryConnect(
                            self,
                            responseChannel,
                            responseStreamId,
                            encodedCredentials,
                            correlationId,
                        )
                    }
                    #[inline]
                    pub unsafe fn tryChallengeResponse(
                        &mut self,
                        encodedCredentials: [u64; 2usize],
                        correlationId: ::std::os::raw::c_long,
                        controlSessionId: ::std::os::raw::c_long,
                    ) -> bool {
                        ArchiveProxy_tryChallengeResponse(
                            self,
                            encodedCredentials,
                            correlationId,
                            controlSessionId,
                        )
                    }
                    #[inline]
                    pub unsafe fn new(
                        publication: [u64; 2usize],
                        retryAttempts: ::std::os::raw::c_int,
                    ) -> Self {
                        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                        ArchiveProxy_ArchiveProxy(
                            __bindgen_tmp.as_mut_ptr(),
                            publication,
                            retryAttempts,
                        );
                        __bindgen_tmp.assume_init()
                    }
                }
                #[doc = " Encapsulate the polling and decoding of archive control protocol response messages."]
                #[repr(C)]
                pub struct ControlResponsePoller {
                    pub m_fragmentAssembler: root::aeron::ControlledFragmentAssembler,
                    pub m_fragmentHandler: root::aeron::controlled_poll_fragment_handler_t,
                    pub m_subscription: [u64; 2usize],
                    pub m_fragmentLimit: ::std::os::raw::c_int,
                    pub m_controlSessionId: ::std::os::raw::c_long,
                    pub m_correlationId: ::std::os::raw::c_long,
                    pub m_relevantId: ::std::os::raw::c_long,
                    pub m_recordingId: ::std::os::raw::c_long,
                    pub m_subscriptionId: ::std::os::raw::c_long,
                    pub m_position: ::std::os::raw::c_long,
                    pub m_recordingSignalCode: ::std::os::raw::c_int,
                    pub m_version: ::std::os::raw::c_int,
                    pub m_codeValue: ::std::os::raw::c_int,
                    pub m_errorMessage: root::std::string,
                    pub m_isPollComplete: bool,
                    pub m_isCodeOk: bool,
                    pub m_isCodeError: bool,
                    pub m_isControlResponse: bool,
                    pub m_wasChallenged: bool,
                    pub m_isRecordingSignal: bool,
                    pub m_encodedChallenge: [u64; 2usize],
                }
                #[test]
                fn bindgen_test_layout_ControlResponsePoller() {
                    const UNINIT: ::std::mem::MaybeUninit<ControlResponsePoller> =
                        ::std::mem::MaybeUninit::uninit();
                    let ptr = UNINIT.as_ptr();
                    assert_eq!(
                        ::std::mem::size_of::<ControlResponsePoller>(),
                        272usize,
                        concat!("Size of: ", stringify!(ControlResponsePoller))
                    );
                    assert_eq!(
                        ::std::mem::align_of::<ControlResponsePoller>(),
                        8usize,
                        concat!("Alignment of ", stringify!(ControlResponsePoller))
                    );
                    assert_eq!(
                        unsafe {
                            ::std::ptr::addr_of!((*ptr).m_fragmentAssembler) as usize - ptr as usize
                        },
                        0usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(ControlResponsePoller),
                            "::",
                            stringify!(m_fragmentAssembler)
                        )
                    );
                    assert_eq!(
                        unsafe {
                            ::std::ptr::addr_of!((*ptr).m_fragmentHandler) as usize - ptr as usize
                        },
                        96usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(ControlResponsePoller),
                            "::",
                            stringify!(m_fragmentHandler)
                        )
                    );
                    assert_eq!(
                        unsafe {
                            ::std::ptr::addr_of!((*ptr).m_subscription) as usize - ptr as usize
                        },
                        128usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(ControlResponsePoller),
                            "::",
                            stringify!(m_subscription)
                        )
                    );
                    assert_eq!(
                        unsafe {
                            ::std::ptr::addr_of!((*ptr).m_fragmentLimit) as usize - ptr as usize
                        },
                        144usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(ControlResponsePoller),
                            "::",
                            stringify!(m_fragmentLimit)
                        )
                    );
                    assert_eq!(
                        unsafe {
                            ::std::ptr::addr_of!((*ptr).m_controlSessionId) as usize - ptr as usize
                        },
                        152usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(ControlResponsePoller),
                            "::",
                            stringify!(m_controlSessionId)
                        )
                    );
                    assert_eq!(
                        unsafe {
                            ::std::ptr::addr_of!((*ptr).m_correlationId) as usize - ptr as usize
                        },
                        160usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(ControlResponsePoller),
                            "::",
                            stringify!(m_correlationId)
                        )
                    );
                    assert_eq!(
                        unsafe {
                            ::std::ptr::addr_of!((*ptr).m_relevantId) as usize - ptr as usize
                        },
                        168usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(ControlResponsePoller),
                            "::",
                            stringify!(m_relevantId)
                        )
                    );
                    assert_eq!(
                        unsafe {
                            ::std::ptr::addr_of!((*ptr).m_recordingId) as usize - ptr as usize
                        },
                        176usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(ControlResponsePoller),
                            "::",
                            stringify!(m_recordingId)
                        )
                    );
                    assert_eq!(
                        unsafe {
                            ::std::ptr::addr_of!((*ptr).m_subscriptionId) as usize - ptr as usize
                        },
                        184usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(ControlResponsePoller),
                            "::",
                            stringify!(m_subscriptionId)
                        )
                    );
                    assert_eq!(
                        unsafe { ::std::ptr::addr_of!((*ptr).m_position) as usize - ptr as usize },
                        192usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(ControlResponsePoller),
                            "::",
                            stringify!(m_position)
                        )
                    );
                    assert_eq!(
                        unsafe {
                            ::std::ptr::addr_of!((*ptr).m_recordingSignalCode) as usize
                                - ptr as usize
                        },
                        200usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(ControlResponsePoller),
                            "::",
                            stringify!(m_recordingSignalCode)
                        )
                    );
                    assert_eq!(
                        unsafe { ::std::ptr::addr_of!((*ptr).m_version) as usize - ptr as usize },
                        204usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(ControlResponsePoller),
                            "::",
                            stringify!(m_version)
                        )
                    );
                    assert_eq!(
                        unsafe { ::std::ptr::addr_of!((*ptr).m_codeValue) as usize - ptr as usize },
                        208usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(ControlResponsePoller),
                            "::",
                            stringify!(m_codeValue)
                        )
                    );
                    assert_eq!(
                        unsafe {
                            ::std::ptr::addr_of!((*ptr).m_errorMessage) as usize - ptr as usize
                        },
                        216usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(ControlResponsePoller),
                            "::",
                            stringify!(m_errorMessage)
                        )
                    );
                    assert_eq!(
                        unsafe {
                            ::std::ptr::addr_of!((*ptr).m_isPollComplete) as usize - ptr as usize
                        },
                        248usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(ControlResponsePoller),
                            "::",
                            stringify!(m_isPollComplete)
                        )
                    );
                    assert_eq!(
                        unsafe { ::std::ptr::addr_of!((*ptr).m_isCodeOk) as usize - ptr as usize },
                        249usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(ControlResponsePoller),
                            "::",
                            stringify!(m_isCodeOk)
                        )
                    );
                    assert_eq!(
                        unsafe {
                            ::std::ptr::addr_of!((*ptr).m_isCodeError) as usize - ptr as usize
                        },
                        250usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(ControlResponsePoller),
                            "::",
                            stringify!(m_isCodeError)
                        )
                    );
                    assert_eq!(
                        unsafe {
                            ::std::ptr::addr_of!((*ptr).m_isControlResponse) as usize - ptr as usize
                        },
                        251usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(ControlResponsePoller),
                            "::",
                            stringify!(m_isControlResponse)
                        )
                    );
                    assert_eq!(
                        unsafe {
                            ::std::ptr::addr_of!((*ptr).m_wasChallenged) as usize - ptr as usize
                        },
                        252usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(ControlResponsePoller),
                            "::",
                            stringify!(m_wasChallenged)
                        )
                    );
                    assert_eq!(
                        unsafe {
                            ::std::ptr::addr_of!((*ptr).m_isRecordingSignal) as usize - ptr as usize
                        },
                        253usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(ControlResponsePoller),
                            "::",
                            stringify!(m_isRecordingSignal)
                        )
                    );
                    assert_eq!(
                        unsafe {
                            ::std::ptr::addr_of!((*ptr).m_encodedChallenge) as usize - ptr as usize
                        },
                        256usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(ControlResponsePoller),
                            "::",
                            stringify!(m_encodedChallenge)
                        )
                    );
                }
                extern "C" {
                    #[doc = " Get the Subscription used for polling responses.\n\n @return the Subscription used for polling responses."]
                    #[link_name = "\u{1}_ZN5aeron7archive6client21ControlResponsePoller12subscriptionEv"]
                    pub fn ControlResponsePoller_subscription(
                        this: *mut root::aeron::archive::client::ControlResponsePoller,
                    ) -> [u64; 2usize];
                }
                extern "C" {
                    #[doc = " Poll for control response events.\n\n @return the number of fragments read during the operation. Zero if no events are available."]
                    #[link_name = "\u{1}_ZN5aeron7archive6client21ControlResponsePoller4pollEv"]
                    pub fn ControlResponsePoller_poll(
                        this: *mut root::aeron::archive::client::ControlResponsePoller,
                    ) -> ::std::os::raw::c_int;
                }
                extern "C" {
                    #[doc = " Control session id of the last polled message or Aeron#NULL_VALUE if poll returned nothing.\n\n @return control session id of the last polled message or Aeron#NULL_VALUE if poll returned nothing."]
                    #[link_name = "\u{1}_ZNK5aeron7archive6client21ControlResponsePoller16controlSessionIdEv"]
                    pub fn ControlResponsePoller_controlSessionId(
                        this: *const root::aeron::archive::client::ControlResponsePoller,
                    ) -> ::std::os::raw::c_long;
                }
                extern "C" {
                    #[doc = " Correlation id of the last polled message or Aeron#NULL_VALUE if poll returned nothing.\n\n @return correlation id of the last polled message or Aeron#NULL_VALUE if poll returned nothing."]
                    #[link_name = "\u{1}_ZNK5aeron7archive6client21ControlResponsePoller13correlationIdEv"]
                    pub fn ControlResponsePoller_correlationId(
                        this: *const root::aeron::archive::client::ControlResponsePoller,
                    ) -> ::std::os::raw::c_long;
                }
                extern "C" {
                    #[doc = " Get the relevant id returned with the response, e.g. replay session id.\n\n @return the relevant id returned with the response."]
                    #[link_name = "\u{1}_ZNK5aeron7archive6client21ControlResponsePoller10relevantIdEv"]
                    pub fn ControlResponsePoller_relevantId(
                        this: *const root::aeron::archive::client::ControlResponsePoller,
                    ) -> ::std::os::raw::c_long;
                }
                extern "C" {
                    #[doc = " Recording id of polled RecordingSignal or Aeron#NULL_VALUE if poll returned nothing.\n\n @return recording id of polled RecordingSignal or Aeron#NULL_VALUE if poll returned nothing."]
                    #[link_name = "\u{1}_ZNK5aeron7archive6client21ControlResponsePoller11recordingIdEv"]
                    pub fn ControlResponsePoller_recordingId(
                        this: *const root::aeron::archive::client::ControlResponsePoller,
                    ) -> ::std::os::raw::c_long;
                }
                extern "C" {
                    #[doc = " Subscription id of polled RecordingSignal or Aeron#NULL_VALUE if poll returned nothing.\n\n @return subscription id of polled RecordingSignal or Aeron#NULL_VALUE if poll returned nothing."]
                    #[link_name = "\u{1}_ZNK5aeron7archive6client21ControlResponsePoller14subscriptionIdEv"]
                    pub fn ControlResponsePoller_subscriptionId(
                        this: *const root::aeron::archive::client::ControlResponsePoller,
                    ) -> ::std::os::raw::c_long;
                }
                extern "C" {
                    #[doc = " Position of polled RecordingSignal or Aeron#NULL_VALUE if poll returned nothing.\n\n @return position id of polled RecordingSignal or Aeron#NULL_VALUE if poll returned nothing."]
                    #[link_name = "\u{1}_ZNK5aeron7archive6client21ControlResponsePoller8positionEv"]
                    pub fn ControlResponsePoller_position(
                        this: *const root::aeron::archive::client::ControlResponsePoller,
                    ) -> ::std::os::raw::c_long;
                }
                extern "C" {
                    #[doc = " Code of polled RecordingSignal or INT32_MIN if poll returned nothing.\n\n @return code of polled RecordingSignal or INT32_MIN if poll returned nothing."]
                    #[link_name = "\u{1}_ZNK5aeron7archive6client21ControlResponsePoller19recordingSignalCodeEv"]
                    pub fn ControlResponsePoller_recordingSignalCode(
                        this: *const root::aeron::archive::client::ControlResponsePoller,
                    ) -> ::std::os::raw::c_int;
                }
                extern "C" {
                    #[doc = " Version response from the server in semantic version form.\n\n @return response from the server in semantic version form."]
                    #[link_name = "\u{1}_ZNK5aeron7archive6client21ControlResponsePoller7versionEv"]
                    pub fn ControlResponsePoller_version(
                        this: *const root::aeron::archive::client::ControlResponsePoller,
                    ) -> ::std::os::raw::c_int;
                }
                extern "C" {
                    #[doc = " Was last received message a Control Response?\n\n @return whether the last received message was a Control Response."]
                    #[link_name = "\u{1}_ZNK5aeron7archive6client21ControlResponsePoller17isControlResponseEv"]
                    pub fn ControlResponsePoller_isControlResponse(
                        this: *const root::aeron::archive::client::ControlResponsePoller,
                    ) -> bool;
                }
                extern "C" {
                    #[doc = " Was last received message a RecordingSignal?\n\n @return whether the last received message was a RecordingSignal."]
                    #[link_name = "\u{1}_ZNK5aeron7archive6client21ControlResponsePoller17isRecordingSignalEv"]
                    pub fn ControlResponsePoller_isRecordingSignal(
                        this: *const root::aeron::archive::client::ControlResponsePoller,
                    ) -> bool;
                }
                extern "C" {
                    #[doc = " Was the last polling action received a complete message?\n\n @return true if the last polling action received a complete message?"]
                    #[link_name = "\u{1}_ZNK5aeron7archive6client21ControlResponsePoller14isPollCompleteEv"]
                    pub fn ControlResponsePoller_isPollComplete(
                        this: *const root::aeron::archive::client::ControlResponsePoller,
                    ) -> bool;
                }
                extern "C" {
                    #[doc = " Get the error message of the last response.\n\n @return the error message of the last response."]
                    #[link_name = "\u{1}_ZN5aeron7archive6client21ControlResponsePoller12errorMessageB5cxx11Ev"]
                    pub fn ControlResponsePoller_errorMessage(
                        this: *mut root::aeron::archive::client::ControlResponsePoller,
                    ) -> root::std::string;
                }
                extern "C" {
                    #[doc = " Did the last received control response have a response code of OK?\n\n @return whether the last received control response had a response code of OK?"]
                    #[link_name = "\u{1}_ZNK5aeron7archive6client21ControlResponsePoller8isCodeOkEv"]
                    pub fn ControlResponsePoller_isCodeOk(
                        this: *const root::aeron::archive::client::ControlResponsePoller,
                    ) -> bool;
                }
                extern "C" {
                    #[doc = " Did the last received control response have a response code of ERROR?\n\n @return whether the last received control response had a response code of ERROR?"]
                    #[link_name = "\u{1}_ZNK5aeron7archive6client21ControlResponsePoller11isCodeErrorEv"]
                    pub fn ControlResponsePoller_isCodeError(
                        this: *const root::aeron::archive::client::ControlResponsePoller,
                    ) -> bool;
                }
                extern "C" {
                    #[doc = " Get the response code value of the last response.\n\n @return the response code value of the last response."]
                    #[link_name = "\u{1}_ZNK5aeron7archive6client21ControlResponsePoller9codeValueEv"]
                    pub fn ControlResponsePoller_codeValue(
                        this: *const root::aeron::archive::client::ControlResponsePoller,
                    ) -> ::std::os::raw::c_int;
                }
                extern "C" {
                    #[doc = " Was the last polling action received a challenge message?\n\n @return true if the last polling action received was a challenge message, false if not."]
                    #[link_name = "\u{1}_ZNK5aeron7archive6client21ControlResponsePoller13wasChallengedEv"]
                    pub fn ControlResponsePoller_wasChallenged(
                        this: *const root::aeron::archive::client::ControlResponsePoller,
                    ) -> bool;
                }
                extern "C" {
                    #[doc = " Get the encoded challenge of the last challenge.\n\n @return the encoded challenge of the last challenge."]
                    #[link_name = "\u{1}_ZN5aeron7archive6client21ControlResponsePoller16encodedChallengeEv"]
                    pub fn ControlResponsePoller_encodedChallenge(
                        this: *mut root::aeron::archive::client::ControlResponsePoller,
                    ) -> [u64; 2usize];
                }
                extern "C" {
                    #[link_name = "\u{1}_ZN5aeron7archive6client21ControlResponsePoller10onFragmentERNS_10concurrent12AtomicBufferEiiRNS3_9logbuffer6HeaderE"]
                    pub fn ControlResponsePoller_onFragment(
                        this: *mut root::aeron::archive::client::ControlResponsePoller,
                        buffer: *mut root::aeron::concurrent::AtomicBuffer,
                        offset: root::aeron::util::index_t,
                        length: root::aeron::util::index_t,
                        header: *mut root::aeron::concurrent::logbuffer::Header,
                    ) -> root::aeron::ControlledPollAction;
                }
                extern "C" {
                    #[link_name = "\u{1}_ZN5aeron7archive6client21ControlResponsePollerC1ESt10shared_ptrINS_12SubscriptionEEi"]
                    pub fn ControlResponsePoller_ControlResponsePoller(
                        this: *mut root::aeron::archive::client::ControlResponsePoller,
                        subscription: [u64; 2usize],
                        fragmentLimit: ::std::os::raw::c_int,
                    );
                }
                impl ControlResponsePoller {
                    #[inline]
                    pub unsafe fn subscription(&mut self) -> [u64; 2usize] {
                        ControlResponsePoller_subscription(self)
                    }
                    #[inline]
                    pub unsafe fn poll(&mut self) -> ::std::os::raw::c_int {
                        ControlResponsePoller_poll(self)
                    }
                    #[inline]
                    pub unsafe fn controlSessionId(&self) -> ::std::os::raw::c_long {
                        ControlResponsePoller_controlSessionId(self)
                    }
                    #[inline]
                    pub unsafe fn correlationId(&self) -> ::std::os::raw::c_long {
                        ControlResponsePoller_correlationId(self)
                    }
                    #[inline]
                    pub unsafe fn relevantId(&self) -> ::std::os::raw::c_long {
                        ControlResponsePoller_relevantId(self)
                    }
                    #[inline]
                    pub unsafe fn recordingId(&self) -> ::std::os::raw::c_long {
                        ControlResponsePoller_recordingId(self)
                    }
                    #[inline]
                    pub unsafe fn subscriptionId(&self) -> ::std::os::raw::c_long {
                        ControlResponsePoller_subscriptionId(self)
                    }
                    #[inline]
                    pub unsafe fn position(&self) -> ::std::os::raw::c_long {
                        ControlResponsePoller_position(self)
                    }
                    #[inline]
                    pub unsafe fn recordingSignalCode(&self) -> ::std::os::raw::c_int {
                        ControlResponsePoller_recordingSignalCode(self)
                    }
                    #[inline]
                    pub unsafe fn version(&self) -> ::std::os::raw::c_int {
                        ControlResponsePoller_version(self)
                    }
                    #[inline]
                    pub unsafe fn isControlResponse(&self) -> bool {
                        ControlResponsePoller_isControlResponse(self)
                    }
                    #[inline]
                    pub unsafe fn isRecordingSignal(&self) -> bool {
                        ControlResponsePoller_isRecordingSignal(self)
                    }
                    #[inline]
                    pub unsafe fn isPollComplete(&self) -> bool {
                        ControlResponsePoller_isPollComplete(self)
                    }
                    #[inline]
                    pub unsafe fn errorMessage(&mut self) -> root::std::string {
                        ControlResponsePoller_errorMessage(self)
                    }
                    #[inline]
                    pub unsafe fn isCodeOk(&self) -> bool {
                        ControlResponsePoller_isCodeOk(self)
                    }
                    #[inline]
                    pub unsafe fn isCodeError(&self) -> bool {
                        ControlResponsePoller_isCodeError(self)
                    }
                    #[inline]
                    pub unsafe fn codeValue(&self) -> ::std::os::raw::c_int {
                        ControlResponsePoller_codeValue(self)
                    }
                    #[inline]
                    pub unsafe fn wasChallenged(&self) -> bool {
                        ControlResponsePoller_wasChallenged(self)
                    }
                    #[inline]
                    pub unsafe fn encodedChallenge(&mut self) -> [u64; 2usize] {
                        ControlResponsePoller_encodedChallenge(self)
                    }
                    #[inline]
                    pub unsafe fn onFragment(
                        &mut self,
                        buffer: *mut root::aeron::concurrent::AtomicBuffer,
                        offset: root::aeron::util::index_t,
                        length: root::aeron::util::index_t,
                        header: *mut root::aeron::concurrent::logbuffer::Header,
                    ) -> root::aeron::ControlledPollAction {
                        ControlResponsePoller_onFragment(self, buffer, offset, length, header)
                    }
                    #[inline]
                    pub unsafe fn new(
                        subscription: [u64; 2usize],
                        fragmentLimit: ::std::os::raw::c_int,
                    ) -> Self {
                        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                        ControlResponsePoller_ControlResponsePoller(
                            __bindgen_tmp.as_mut_ptr(),
                            subscription,
                            fragmentLimit,
                        );
                        __bindgen_tmp.assume_init()
                    }
                }
                #[doc = " A recording descriptor returned as a result of requesting a listing of recordings.\n\n @param controlSessionId  of the originating session requesting to list recordings.\n @param correlationId     of the associated request to list recordings.\n @param recordingId       of this recording descriptor.\n @param startTimestamp    for the recording.\n @param stopTimestamp     for the recording.\n @param startPosition     for the recording against the recorded publication.\n @param stopPosition      reached for the recording.\n @param initialTermId     for the recorded publication.\n @param segmentFileLength for the recording which is a multiple of termBufferLength.\n @param termBufferLength  for the recorded publication.\n @param mtuLength         for the recorded publication.\n @param sessionId         for the recorded publication.\n @param streamId          for the recorded publication.\n @param strippedChannel   for the recorded publication.\n @param originalChannel   for the recorded publication.\n @param sourceIdentity    for the recorded publication."]
                pub type recording_descriptor_consumer_t = [u64; 4usize];
                #[repr(C)]
                pub struct RecordingDescriptorPoller {
                    pub m_fragmentAssembler: root::aeron::ControlledFragmentAssembler,
                    pub m_fragmentHandler: root::aeron::controlled_poll_fragment_handler_t,
                    pub m_errorHandler: root::aeron::util::exception_handler_t,
                    pub m_onRecordingSignal: root::aeron::archive::client::on_recording_signal_t,
                    pub m_consumer: root::aeron::archive::client::recording_descriptor_consumer_t,
                    pub m_subscription: [u64; 2usize],
                    pub m_controlSessionId: ::std::os::raw::c_long,
                    pub m_fragmentLimit: ::std::os::raw::c_int,
                    pub m_correlationId: ::std::os::raw::c_long,
                    pub m_remainingRecordCount: ::std::os::raw::c_int,
                    pub m_isDispatchComplete: bool,
                }
                #[test]
                fn bindgen_test_layout_RecordingDescriptorPoller() {
                    const UNINIT: ::std::mem::MaybeUninit<RecordingDescriptorPoller> =
                        ::std::mem::MaybeUninit::uninit();
                    let ptr = UNINIT.as_ptr();
                    assert_eq!(
                        ::std::mem::size_of::<RecordingDescriptorPoller>(),
                        272usize,
                        concat!("Size of: ", stringify!(RecordingDescriptorPoller))
                    );
                    assert_eq!(
                        ::std::mem::align_of::<RecordingDescriptorPoller>(),
                        8usize,
                        concat!("Alignment of ", stringify!(RecordingDescriptorPoller))
                    );
                    assert_eq!(
                        unsafe {
                            ::std::ptr::addr_of!((*ptr).m_fragmentAssembler) as usize - ptr as usize
                        },
                        0usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(RecordingDescriptorPoller),
                            "::",
                            stringify!(m_fragmentAssembler)
                        )
                    );
                    assert_eq!(
                        unsafe {
                            ::std::ptr::addr_of!((*ptr).m_fragmentHandler) as usize - ptr as usize
                        },
                        96usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(RecordingDescriptorPoller),
                            "::",
                            stringify!(m_fragmentHandler)
                        )
                    );
                    assert_eq!(
                        unsafe {
                            ::std::ptr::addr_of!((*ptr).m_errorHandler) as usize - ptr as usize
                        },
                        128usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(RecordingDescriptorPoller),
                            "::",
                            stringify!(m_errorHandler)
                        )
                    );
                    assert_eq!(
                        unsafe {
                            ::std::ptr::addr_of!((*ptr).m_onRecordingSignal) as usize - ptr as usize
                        },
                        160usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(RecordingDescriptorPoller),
                            "::",
                            stringify!(m_onRecordingSignal)
                        )
                    );
                    assert_eq!(
                        unsafe { ::std::ptr::addr_of!((*ptr).m_consumer) as usize - ptr as usize },
                        192usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(RecordingDescriptorPoller),
                            "::",
                            stringify!(m_consumer)
                        )
                    );
                    assert_eq!(
                        unsafe {
                            ::std::ptr::addr_of!((*ptr).m_subscription) as usize - ptr as usize
                        },
                        224usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(RecordingDescriptorPoller),
                            "::",
                            stringify!(m_subscription)
                        )
                    );
                    assert_eq!(
                        unsafe {
                            ::std::ptr::addr_of!((*ptr).m_controlSessionId) as usize - ptr as usize
                        },
                        240usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(RecordingDescriptorPoller),
                            "::",
                            stringify!(m_controlSessionId)
                        )
                    );
                    assert_eq!(
                        unsafe {
                            ::std::ptr::addr_of!((*ptr).m_fragmentLimit) as usize - ptr as usize
                        },
                        248usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(RecordingDescriptorPoller),
                            "::",
                            stringify!(m_fragmentLimit)
                        )
                    );
                    assert_eq!(
                        unsafe {
                            ::std::ptr::addr_of!((*ptr).m_correlationId) as usize - ptr as usize
                        },
                        256usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(RecordingDescriptorPoller),
                            "::",
                            stringify!(m_correlationId)
                        )
                    );
                    assert_eq!(
                        unsafe {
                            ::std::ptr::addr_of!((*ptr).m_remainingRecordCount) as usize
                                - ptr as usize
                        },
                        264usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(RecordingDescriptorPoller),
                            "::",
                            stringify!(m_remainingRecordCount)
                        )
                    );
                    assert_eq!(
                        unsafe {
                            ::std::ptr::addr_of!((*ptr).m_isDispatchComplete) as usize
                                - ptr as usize
                        },
                        268usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(RecordingDescriptorPoller),
                            "::",
                            stringify!(m_isDispatchComplete)
                        )
                    );
                }
                extern "C" {
                    #[doc = " Poll for recording events.\n\n @return the number of fragments read during the operation. Zero if no events are available."]
                    #[link_name = "\u{1}_ZN5aeron7archive6client25RecordingDescriptorPoller4pollEv"]
                    pub fn RecordingDescriptorPoller_poll(
                        this: *mut root::aeron::archive::client::RecordingDescriptorPoller,
                    ) -> ::std::os::raw::c_int;
                }
                extern "C" {
                    #[doc = " Get the Subscription used for polling responses.\n\n @return the Subscription used for polling responses."]
                    #[link_name = "\u{1}_ZN5aeron7archive6client25RecordingDescriptorPoller12subscriptionEv"]
                    pub fn RecordingDescriptorPoller_subscription(
                        this: *mut root::aeron::archive::client::RecordingDescriptorPoller,
                    ) -> [u64; 2usize];
                }
                extern "C" {
                    #[doc = " Control session id for filtering responses.\n\n @return control session id for filtering responses."]
                    #[link_name = "\u{1}_ZNK5aeron7archive6client25RecordingDescriptorPoller16controlSessionIdEv"]
                    pub fn RecordingDescriptorPoller_controlSessionId(
                        this: *const root::aeron::archive::client::RecordingDescriptorPoller,
                    ) -> ::std::os::raw::c_long;
                }
                extern "C" {
                    #[doc = " Is the dispatch of descriptors complete?\n\n @return true if the dispatch of descriptors complete?"]
                    #[link_name = "\u{1}_ZNK5aeron7archive6client25RecordingDescriptorPoller18isDispatchCompleteEv"]
                    pub fn RecordingDescriptorPoller_isDispatchComplete(
                        this: *const root::aeron::archive::client::RecordingDescriptorPoller,
                    ) -> bool;
                }
                extern "C" {
                    #[doc = " Get the number of remaining records expected.\n\n @return the number of remaining records expected."]
                    #[link_name = "\u{1}_ZNK5aeron7archive6client25RecordingDescriptorPoller20remainingRecordCountEv"]
                    pub fn RecordingDescriptorPoller_remainingRecordCount(
                        this: *const root::aeron::archive::client::RecordingDescriptorPoller,
                    ) -> ::std::os::raw::c_int;
                }
                extern "C" {
                    #[doc = " Reset the poller to dispatch the descriptors returned from a query.\n\n @param correlationId for the response.\n @param recordCount   of descriptors to expect.\n @param consumer      to which the recording descriptors are to be dispatched."]
                    #[link_name = "\u{1}_ZN5aeron7archive6client25RecordingDescriptorPoller5resetEliRKSt8functionIFvllllllliiiiiiRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESB_SB_EE"]
                    pub fn RecordingDescriptorPoller_reset(
                        this: *mut root::aeron::archive::client::RecordingDescriptorPoller,
                        correlationId: ::std::os::raw::c_long,
                        recordCount: ::std::os::raw::c_int,
                        consumer : * const root :: aeron :: archive :: client :: recording_descriptor_consumer_t,
                    );
                }
                extern "C" {
                    #[link_name = "\u{1}_ZN5aeron7archive6client25RecordingDescriptorPoller10onFragmentERNS_10concurrent12AtomicBufferEiiRNS3_9logbuffer6HeaderE"]
                    pub fn RecordingDescriptorPoller_onFragment(
                        this: *mut root::aeron::archive::client::RecordingDescriptorPoller,
                        buffer: *mut root::aeron::concurrent::AtomicBuffer,
                        offset: root::aeron::util::index_t,
                        length: root::aeron::util::index_t,
                        header: *mut root::aeron::concurrent::logbuffer::Header,
                    ) -> root::aeron::ControlledPollAction;
                }
                extern "C" {
                    #[link_name = "\u{1}_ZN5aeron7archive6client25RecordingDescriptorPollerC1ESt10shared_ptrINS_12SubscriptionEERKSt8functionIFvRKSt9exceptionEEli"]
                    pub fn RecordingDescriptorPoller_RecordingDescriptorPoller(
                        this: *mut root::aeron::archive::client::RecordingDescriptorPoller,
                        subscription: [u64; 2usize],
                        errorHandler: *const root::aeron::util::exception_handler_t,
                        controlSessionId: ::std::os::raw::c_long,
                        fragmentLimit: ::std::os::raw::c_int,
                    );
                }
                extern "C" {
                    #[link_name = "\u{1}_ZN5aeron7archive6client25RecordingDescriptorPollerC1ESt10shared_ptrINS_12SubscriptionEERKSt8functionIFvRKSt9exceptionEERKS6_IFvlllliEEli"]
                    pub fn RecordingDescriptorPoller_RecordingDescriptorPoller1(
                        this: *mut root::aeron::archive::client::RecordingDescriptorPoller,
                        subscription: [u64; 2usize],
                        errorHandler: *const root::aeron::util::exception_handler_t,
                        recordingSignalConsumer : * const root :: aeron :: archive :: client :: on_recording_signal_t,
                        controlSessionId: ::std::os::raw::c_long,
                        fragmentLimit: ::std::os::raw::c_int,
                    );
                }
                impl RecordingDescriptorPoller {
                    #[inline]
                    pub unsafe fn poll(&mut self) -> ::std::os::raw::c_int {
                        RecordingDescriptorPoller_poll(self)
                    }
                    #[inline]
                    pub unsafe fn subscription(&mut self) -> [u64; 2usize] {
                        RecordingDescriptorPoller_subscription(self)
                    }
                    #[inline]
                    pub unsafe fn controlSessionId(&self) -> ::std::os::raw::c_long {
                        RecordingDescriptorPoller_controlSessionId(self)
                    }
                    #[inline]
                    pub unsafe fn isDispatchComplete(&self) -> bool {
                        RecordingDescriptorPoller_isDispatchComplete(self)
                    }
                    #[inline]
                    pub unsafe fn remainingRecordCount(&self) -> ::std::os::raw::c_int {
                        RecordingDescriptorPoller_remainingRecordCount(self)
                    }
                    #[inline]
                    pub unsafe fn reset(
                        &mut self,
                        correlationId: ::std::os::raw::c_long,
                        recordCount: ::std::os::raw::c_int,
                        consumer : * const root :: aeron :: archive :: client :: recording_descriptor_consumer_t,
                    ) {
                        RecordingDescriptorPoller_reset(self, correlationId, recordCount, consumer)
                    }
                    #[inline]
                    pub unsafe fn onFragment(
                        &mut self,
                        buffer: *mut root::aeron::concurrent::AtomicBuffer,
                        offset: root::aeron::util::index_t,
                        length: root::aeron::util::index_t,
                        header: *mut root::aeron::concurrent::logbuffer::Header,
                    ) -> root::aeron::ControlledPollAction {
                        RecordingDescriptorPoller_onFragment(self, buffer, offset, length, header)
                    }
                    #[inline]
                    pub unsafe fn new(
                        subscription: [u64; 2usize],
                        errorHandler: *const root::aeron::util::exception_handler_t,
                        controlSessionId: ::std::os::raw::c_long,
                        fragmentLimit: ::std::os::raw::c_int,
                    ) -> Self {
                        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                        RecordingDescriptorPoller_RecordingDescriptorPoller(
                            __bindgen_tmp.as_mut_ptr(),
                            subscription,
                            errorHandler,
                            controlSessionId,
                            fragmentLimit,
                        );
                        __bindgen_tmp.assume_init()
                    }
                    #[inline]
                    pub unsafe fn new1(
                        subscription: [u64; 2usize],
                        errorHandler: *const root::aeron::util::exception_handler_t,
                        recordingSignalConsumer : * const root :: aeron :: archive :: client :: on_recording_signal_t,
                        controlSessionId: ::std::os::raw::c_long,
                        fragmentLimit: ::std::os::raw::c_int,
                    ) -> Self {
                        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                        RecordingDescriptorPoller_RecordingDescriptorPoller1(
                            __bindgen_tmp.as_mut_ptr(),
                            subscription,
                            errorHandler,
                            recordingSignalConsumer,
                            controlSessionId,
                            fragmentLimit,
                        );
                        __bindgen_tmp.assume_init()
                    }
                }
                #[doc = " Descriptor for an active recording subscription on the archive.\n\n @param controlSessionId for the request.\n @param correlationId    for the request.\n @param subscriptionId   that can be used to stop the recording subscription.\n @param streamId         the subscription was registered with.\n @param strippedChannel  the subscription was registered with."]
                pub type recording_subscription_descriptor_consumer_t = [u64; 4usize];
                #[doc = " Encapsulate the polling, decoding, dispatching of recording descriptors from an archive."]
                #[repr(C)]
                pub struct RecordingSubscriptionDescriptorPoller {
                    pub m_fragmentAssembler: root::aeron::ControlledFragmentAssembler,
                    pub m_fragmentHandler: root::aeron::controlled_poll_fragment_handler_t,
                    pub m_errorHandler: root::aeron::util::exception_handler_t,
                    pub m_onRecordingSignal: root::aeron::archive::client::on_recording_signal_t,
                    pub m_consumer:
                        root::aeron::archive::client::recording_subscription_descriptor_consumer_t,
                    pub m_subscription: [u64; 2usize],
                    pub m_controlSessionId: ::std::os::raw::c_long,
                    pub m_fragmentLimit: ::std::os::raw::c_int,
                    pub m_correlationId: ::std::os::raw::c_long,
                    pub m_remainingSubscriptionCount: ::std::os::raw::c_int,
                    pub m_isDispatchComplete: bool,
                }
                #[test]
                fn bindgen_test_layout_RecordingSubscriptionDescriptorPoller() {
                    const UNINIT: ::std::mem::MaybeUninit<RecordingSubscriptionDescriptorPoller> =
                        ::std::mem::MaybeUninit::uninit();
                    let ptr = UNINIT.as_ptr();
                    assert_eq!(
                        ::std::mem::size_of::<RecordingSubscriptionDescriptorPoller>(),
                        272usize,
                        concat!(
                            "Size of: ",
                            stringify!(RecordingSubscriptionDescriptorPoller)
                        )
                    );
                    assert_eq!(
                        ::std::mem::align_of::<RecordingSubscriptionDescriptorPoller>(),
                        8usize,
                        concat!(
                            "Alignment of ",
                            stringify!(RecordingSubscriptionDescriptorPoller)
                        )
                    );
                    assert_eq!(
                        unsafe {
                            ::std::ptr::addr_of!((*ptr).m_fragmentAssembler) as usize - ptr as usize
                        },
                        0usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(RecordingSubscriptionDescriptorPoller),
                            "::",
                            stringify!(m_fragmentAssembler)
                        )
                    );
                    assert_eq!(
                        unsafe {
                            ::std::ptr::addr_of!((*ptr).m_fragmentHandler) as usize - ptr as usize
                        },
                        96usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(RecordingSubscriptionDescriptorPoller),
                            "::",
                            stringify!(m_fragmentHandler)
                        )
                    );
                    assert_eq!(
                        unsafe {
                            ::std::ptr::addr_of!((*ptr).m_errorHandler) as usize - ptr as usize
                        },
                        128usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(RecordingSubscriptionDescriptorPoller),
                            "::",
                            stringify!(m_errorHandler)
                        )
                    );
                    assert_eq!(
                        unsafe {
                            ::std::ptr::addr_of!((*ptr).m_onRecordingSignal) as usize - ptr as usize
                        },
                        160usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(RecordingSubscriptionDescriptorPoller),
                            "::",
                            stringify!(m_onRecordingSignal)
                        )
                    );
                    assert_eq!(
                        unsafe { ::std::ptr::addr_of!((*ptr).m_consumer) as usize - ptr as usize },
                        192usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(RecordingSubscriptionDescriptorPoller),
                            "::",
                            stringify!(m_consumer)
                        )
                    );
                    assert_eq!(
                        unsafe {
                            ::std::ptr::addr_of!((*ptr).m_subscription) as usize - ptr as usize
                        },
                        224usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(RecordingSubscriptionDescriptorPoller),
                            "::",
                            stringify!(m_subscription)
                        )
                    );
                    assert_eq!(
                        unsafe {
                            ::std::ptr::addr_of!((*ptr).m_controlSessionId) as usize - ptr as usize
                        },
                        240usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(RecordingSubscriptionDescriptorPoller),
                            "::",
                            stringify!(m_controlSessionId)
                        )
                    );
                    assert_eq!(
                        unsafe {
                            ::std::ptr::addr_of!((*ptr).m_fragmentLimit) as usize - ptr as usize
                        },
                        248usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(RecordingSubscriptionDescriptorPoller),
                            "::",
                            stringify!(m_fragmentLimit)
                        )
                    );
                    assert_eq!(
                        unsafe {
                            ::std::ptr::addr_of!((*ptr).m_correlationId) as usize - ptr as usize
                        },
                        256usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(RecordingSubscriptionDescriptorPoller),
                            "::",
                            stringify!(m_correlationId)
                        )
                    );
                    assert_eq!(
                        unsafe {
                            ::std::ptr::addr_of!((*ptr).m_remainingSubscriptionCount) as usize
                                - ptr as usize
                        },
                        264usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(RecordingSubscriptionDescriptorPoller),
                            "::",
                            stringify!(m_remainingSubscriptionCount)
                        )
                    );
                    assert_eq!(
                        unsafe {
                            ::std::ptr::addr_of!((*ptr).m_isDispatchComplete) as usize
                                - ptr as usize
                        },
                        268usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(RecordingSubscriptionDescriptorPoller),
                            "::",
                            stringify!(m_isDispatchComplete)
                        )
                    );
                }
                extern "C" {
                    #[doc = " Poll for recording subscriptions.\n\n @return the number of fragments read during the operation. Zero if no events are available."]
                    #[link_name = "\u{1}_ZN5aeron7archive6client37RecordingSubscriptionDescriptorPoller4pollEv"]
                    pub fn RecordingSubscriptionDescriptorPoller_poll(
                        this : * mut root :: aeron :: archive :: client :: RecordingSubscriptionDescriptorPoller,
                    ) -> ::std::os::raw::c_int;
                }
                extern "C" {
                    #[doc = " Get the Subscription used for polling responses.\n\n @return the Subscription used for polling responses."]
                    #[link_name = "\u{1}_ZN5aeron7archive6client37RecordingSubscriptionDescriptorPoller12subscriptionEv"]
                    pub fn RecordingSubscriptionDescriptorPoller_subscription(
                        this : * mut root :: aeron :: archive :: client :: RecordingSubscriptionDescriptorPoller,
                    ) -> [u64; 2usize];
                }
                extern "C" {
                    #[doc = " Control session id for filtering responses.\n\n @return control session id for filtering responses."]
                    #[link_name = "\u{1}_ZNK5aeron7archive6client37RecordingSubscriptionDescriptorPoller16controlSessionIdEv"]
                    pub fn RecordingSubscriptionDescriptorPoller_controlSessionId(
                        this : * const root :: aeron :: archive :: client :: RecordingSubscriptionDescriptorPoller,
                    ) -> ::std::os::raw::c_long;
                }
                extern "C" {
                    #[doc = " Is the dispatch of descriptors complete?\n\n @return true if the dispatch of descriptors complete?"]
                    #[link_name = "\u{1}_ZNK5aeron7archive6client37RecordingSubscriptionDescriptorPoller18isDispatchCompleteEv"]
                    pub fn RecordingSubscriptionDescriptorPoller_isDispatchComplete(
                        this : * const root :: aeron :: archive :: client :: RecordingSubscriptionDescriptorPoller,
                    ) -> bool;
                }
                extern "C" {
                    #[doc = " Get the number of remaining subscriptions expected.\n\n @return the number of remaining subscriptions expected."]
                    #[link_name = "\u{1}_ZNK5aeron7archive6client37RecordingSubscriptionDescriptorPoller26remainingSubscriptionCountEv"]
                    pub fn RecordingSubscriptionDescriptorPoller_remainingSubscriptionCount(
                        this : * const root :: aeron :: archive :: client :: RecordingSubscriptionDescriptorPoller,
                    ) -> ::std::os::raw::c_int;
                }
                extern "C" {
                    #[doc = " Reset the poller to dispatch the descriptors returned from a query.\n\n @param correlationId     for the response.\n @param subscriptionCount of descriptors to expect.\n @param consumer          to which the recording subscription descriptors are to be dispatched."]
                    #[link_name = "\u{1}_ZN5aeron7archive6client37RecordingSubscriptionDescriptorPoller5resetEliRKSt8functionIFvllliRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEEE"]
                    pub fn RecordingSubscriptionDescriptorPoller_reset(
                        this : * mut root :: aeron :: archive :: client :: RecordingSubscriptionDescriptorPoller,
                        correlationId: ::std::os::raw::c_long,
                        subscriptionCount: ::std::os::raw::c_int,
                        consumer : * const root :: aeron :: archive :: client :: recording_subscription_descriptor_consumer_t,
                    );
                }
                extern "C" {
                    #[link_name = "\u{1}_ZN5aeron7archive6client37RecordingSubscriptionDescriptorPoller10onFragmentERNS_10concurrent12AtomicBufferEiiRNS3_9logbuffer6HeaderE"]
                    pub fn RecordingSubscriptionDescriptorPoller_onFragment(
                        this : * mut root :: aeron :: archive :: client :: RecordingSubscriptionDescriptorPoller,
                        buffer: *mut root::aeron::concurrent::AtomicBuffer,
                        offset: root::aeron::util::index_t,
                        length: root::aeron::util::index_t,
                        header: *mut root::aeron::concurrent::logbuffer::Header,
                    ) -> root::aeron::ControlledPollAction;
                }
                extern "C" {
                    #[link_name = "\u{1}_ZN5aeron7archive6client37RecordingSubscriptionDescriptorPollerC1ESt10shared_ptrINS_12SubscriptionEERKSt8functionIFvRKSt9exceptionEEli"]
                    pub fn RecordingSubscriptionDescriptorPoller_RecordingSubscriptionDescriptorPoller(
                        this : * mut root :: aeron :: archive :: client :: RecordingSubscriptionDescriptorPoller,
                        subscription: [u64; 2usize],
                        errorHandler: *const root::aeron::util::exception_handler_t,
                        controlSessionId: ::std::os::raw::c_long,
                        fragmentLimit: ::std::os::raw::c_int,
                    );
                }
                extern "C" {
                    #[link_name = "\u{1}_ZN5aeron7archive6client37RecordingSubscriptionDescriptorPollerC1ESt10shared_ptrINS_12SubscriptionEERKSt8functionIFvRKSt9exceptionEERKS6_IFvlllliEEli"]
                    pub fn RecordingSubscriptionDescriptorPoller_RecordingSubscriptionDescriptorPoller1(
                        this : * mut root :: aeron :: archive :: client :: RecordingSubscriptionDescriptorPoller,
                        subscription: [u64; 2usize],
                        errorHandler: *const root::aeron::util::exception_handler_t,
                        recordingSignalConsumer : * const root :: aeron :: archive :: client :: on_recording_signal_t,
                        controlSessionId: ::std::os::raw::c_long,
                        fragmentLimit: ::std::os::raw::c_int,
                    );
                }
                impl RecordingSubscriptionDescriptorPoller {
                    #[inline]
                    pub unsafe fn poll(&mut self) -> ::std::os::raw::c_int {
                        RecordingSubscriptionDescriptorPoller_poll(self)
                    }
                    #[inline]
                    pub unsafe fn subscription(&mut self) -> [u64; 2usize] {
                        RecordingSubscriptionDescriptorPoller_subscription(self)
                    }
                    #[inline]
                    pub unsafe fn controlSessionId(&self) -> ::std::os::raw::c_long {
                        RecordingSubscriptionDescriptorPoller_controlSessionId(self)
                    }
                    #[inline]
                    pub unsafe fn isDispatchComplete(&self) -> bool {
                        RecordingSubscriptionDescriptorPoller_isDispatchComplete(self)
                    }
                    #[inline]
                    pub unsafe fn remainingSubscriptionCount(&self) -> ::std::os::raw::c_int {
                        RecordingSubscriptionDescriptorPoller_remainingSubscriptionCount(self)
                    }
                    #[inline]
                    pub unsafe fn reset(
                        &mut self,
                        correlationId: ::std::os::raw::c_long,
                        subscriptionCount: ::std::os::raw::c_int,
                        consumer : * const root :: aeron :: archive :: client :: recording_subscription_descriptor_consumer_t,
                    ) {
                        RecordingSubscriptionDescriptorPoller_reset(
                            self,
                            correlationId,
                            subscriptionCount,
                            consumer,
                        )
                    }
                    #[inline]
                    pub unsafe fn onFragment(
                        &mut self,
                        buffer: *mut root::aeron::concurrent::AtomicBuffer,
                        offset: root::aeron::util::index_t,
                        length: root::aeron::util::index_t,
                        header: *mut root::aeron::concurrent::logbuffer::Header,
                    ) -> root::aeron::ControlledPollAction {
                        RecordingSubscriptionDescriptorPoller_onFragment(
                            self, buffer, offset, length, header,
                        )
                    }
                    #[inline]
                    pub unsafe fn new(
                        subscription: [u64; 2usize],
                        errorHandler: *const root::aeron::util::exception_handler_t,
                        controlSessionId: ::std::os::raw::c_long,
                        fragmentLimit: ::std::os::raw::c_int,
                    ) -> Self {
                        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                        RecordingSubscriptionDescriptorPoller_RecordingSubscriptionDescriptorPoller(
                            __bindgen_tmp.as_mut_ptr(),
                            subscription,
                            errorHandler,
                            controlSessionId,
                            fragmentLimit,
                        );
                        __bindgen_tmp.assume_init()
                    }
                    #[inline]
                    pub unsafe fn new1(
                        subscription: [u64; 2usize],
                        errorHandler: *const root::aeron::util::exception_handler_t,
                        recordingSignalConsumer : * const root :: aeron :: archive :: client :: on_recording_signal_t,
                        controlSessionId: ::std::os::raw::c_long,
                        fragmentLimit: ::std::os::raw::c_int,
                    ) -> Self {
                        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                        RecordingSubscriptionDescriptorPoller_RecordingSubscriptionDescriptorPoller1 (__bindgen_tmp . as_mut_ptr () , subscription , errorHandler , recordingSignalConsumer , controlSessionId , fragmentLimit) ;
                        __bindgen_tmp.assume_init()
                    }
                }
                #[doc = " Client for interacting with a local or remote Aeron Archive for requesting the recording and replay message streams.\n <p>\n This client provides a simple interaction model which is mostly synchronous and may not be optimal.\n The underlying components such as the ArchiveProxy and the ControlResponsePoller or\n RecordingDescriptorPoller may be used directly if a more asynchronous interaction is required.\n <p>\n Note: This class is threadsafe."]
                #[repr(C)]
                pub struct AeronArchive {
                    pub m_ctx: u64,
                    pub m_archiveProxy: u64,
                    pub m_controlResponsePoller: u64,
                    pub m_recordingDescriptorPoller: u64,
                    pub m_recordingSubscriptionDescriptorPoller: u64,
                    pub m_aeron: [u64; 2usize],
                    pub m_lock: root::std::recursive_mutex,
                    pub m_nanoClock: root::aeron::nano_clock_t,
                    pub m_controlSessionId: ::std::os::raw::c_long,
                    pub m_lastCorrelationId: ::std::os::raw::c_long,
                    pub m_messageTimeoutNs: ::std::os::raw::c_longlong,
                    pub m_isClosed: bool,
                    pub m_isInCallback: bool,
                }
                #[doc = " Specialised configuration options for communicating with an Aeron Archive.\n <p>\n The context will be copied after a successful\n AeronArchive#connect(Context) or AeronArchive::asyncConnect(Context)."]
                pub type AeronArchive_Context_t = root::aeron::archive::client::Context;
                #[doc = " Source is local to the archive and will be recorded using a spy Subscription."]
                pub const AeronArchive_SourceLocation_LOCAL:
                    root::aeron::archive::client::AeronArchive_SourceLocation = 0;
                #[doc = " Source is remote to the archive and will be recorded using a network Subscription."]
                pub const AeronArchive_SourceLocation_REMOTE:
                    root::aeron::archive::client::AeronArchive_SourceLocation = 1;
                #[doc = " Location of the source with respect to the archive."]
                pub type AeronArchive_SourceLocation = ::std::os::raw::c_int;
                #[doc = " Allows for the async establishment of a archive session."]
                #[repr(C)]
                pub struct AeronArchive_AsyncConnect {
                    pub m_nanoClock: root::aeron::nano_clock_t,
                    pub m_ctx: u64,
                    pub m_archiveProxy: u64,
                    pub m_controlResponsePoller: u64,
                    pub m_aeron: [u64; 2usize],
                    pub m_subscription: [u64; 2usize],
                    pub m_publication: [u64; 2usize],
                    pub m_subscriptionId: ::std::os::raw::c_long,
                    pub m_publicationId: ::std::os::raw::c_long,
                    pub m_deadlineNs: ::std::os::raw::c_longlong,
                    pub m_correlationId: ::std::os::raw::c_long,
                    pub m_challengeControlSessionId: ::std::os::raw::c_long,
                    pub m_step: ::std::os::raw::c_uchar,
                    pub m_encodedCredentialsFromChallenge: [u64; 2usize],
                }
                #[test]
                fn bindgen_test_layout_AeronArchive_AsyncConnect() {
                    const UNINIT: ::std::mem::MaybeUninit<AeronArchive_AsyncConnect> =
                        ::std::mem::MaybeUninit::uninit();
                    let ptr = UNINIT.as_ptr();
                    assert_eq!(
                        ::std::mem::size_of::<AeronArchive_AsyncConnect>(),
                        168usize,
                        concat!("Size of: ", stringify!(AeronArchive_AsyncConnect))
                    );
                    assert_eq!(
                        ::std::mem::align_of::<AeronArchive_AsyncConnect>(),
                        8usize,
                        concat!("Alignment of ", stringify!(AeronArchive_AsyncConnect))
                    );
                    assert_eq!(
                        unsafe { ::std::ptr::addr_of!((*ptr).m_nanoClock) as usize - ptr as usize },
                        0usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(AeronArchive_AsyncConnect),
                            "::",
                            stringify!(m_nanoClock)
                        )
                    );
                    assert_eq!(
                        unsafe { ::std::ptr::addr_of!((*ptr).m_ctx) as usize - ptr as usize },
                        32usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(AeronArchive_AsyncConnect),
                            "::",
                            stringify!(m_ctx)
                        )
                    );
                    assert_eq!(
                        unsafe {
                            ::std::ptr::addr_of!((*ptr).m_archiveProxy) as usize - ptr as usize
                        },
                        40usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(AeronArchive_AsyncConnect),
                            "::",
                            stringify!(m_archiveProxy)
                        )
                    );
                    assert_eq!(
                        unsafe {
                            ::std::ptr::addr_of!((*ptr).m_controlResponsePoller) as usize
                                - ptr as usize
                        },
                        48usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(AeronArchive_AsyncConnect),
                            "::",
                            stringify!(m_controlResponsePoller)
                        )
                    );
                    assert_eq!(
                        unsafe { ::std::ptr::addr_of!((*ptr).m_aeron) as usize - ptr as usize },
                        56usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(AeronArchive_AsyncConnect),
                            "::",
                            stringify!(m_aeron)
                        )
                    );
                    assert_eq!(
                        unsafe {
                            ::std::ptr::addr_of!((*ptr).m_subscription) as usize - ptr as usize
                        },
                        72usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(AeronArchive_AsyncConnect),
                            "::",
                            stringify!(m_subscription)
                        )
                    );
                    assert_eq!(
                        unsafe {
                            ::std::ptr::addr_of!((*ptr).m_publication) as usize - ptr as usize
                        },
                        88usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(AeronArchive_AsyncConnect),
                            "::",
                            stringify!(m_publication)
                        )
                    );
                    assert_eq!(
                        unsafe {
                            ::std::ptr::addr_of!((*ptr).m_subscriptionId) as usize - ptr as usize
                        },
                        104usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(AeronArchive_AsyncConnect),
                            "::",
                            stringify!(m_subscriptionId)
                        )
                    );
                    assert_eq!(
                        unsafe {
                            ::std::ptr::addr_of!((*ptr).m_publicationId) as usize - ptr as usize
                        },
                        112usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(AeronArchive_AsyncConnect),
                            "::",
                            stringify!(m_publicationId)
                        )
                    );
                    assert_eq!(
                        unsafe {
                            ::std::ptr::addr_of!((*ptr).m_deadlineNs) as usize - ptr as usize
                        },
                        120usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(AeronArchive_AsyncConnect),
                            "::",
                            stringify!(m_deadlineNs)
                        )
                    );
                    assert_eq!(
                        unsafe {
                            ::std::ptr::addr_of!((*ptr).m_correlationId) as usize - ptr as usize
                        },
                        128usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(AeronArchive_AsyncConnect),
                            "::",
                            stringify!(m_correlationId)
                        )
                    );
                    assert_eq!(
                        unsafe {
                            ::std::ptr::addr_of!((*ptr).m_challengeControlSessionId) as usize
                                - ptr as usize
                        },
                        136usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(AeronArchive_AsyncConnect),
                            "::",
                            stringify!(m_challengeControlSessionId)
                        )
                    );
                    assert_eq!(
                        unsafe { ::std::ptr::addr_of!((*ptr).m_step) as usize - ptr as usize },
                        144usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(AeronArchive_AsyncConnect),
                            "::",
                            stringify!(m_step)
                        )
                    );
                    assert_eq!(
                        unsafe {
                            ::std::ptr::addr_of!((*ptr).m_encodedCredentialsFromChallenge) as usize
                                - ptr as usize
                        },
                        152usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(AeronArchive_AsyncConnect),
                            "::",
                            stringify!(m_encodedCredentialsFromChallenge)
                        )
                    );
                }
                extern "C" {
                    #[doc = " Poll for a complete connection.\n\n @return a new AeronArchive if successfully connected otherwise null."]
                    #[link_name = "\u{1}_ZN5aeron7archive6client12AeronArchive12AsyncConnect4pollEv"]
                    pub fn AeronArchive_AsyncConnect_poll(
                        this: *mut root::aeron::archive::client::AeronArchive_AsyncConnect,
                    ) -> [u64; 2usize];
                }
                extern "C" {
                    #[doc = " The step in the connect process this connect attempt has reached.\n\n @return the step in the connect process this connect attempt has reached."]
                    #[link_name = "\u{1}_ZNK5aeron7archive6client12AeronArchive12AsyncConnect4stepEv"]
                    pub fn AeronArchive_AsyncConnect_step(
                        this: *const root::aeron::archive::client::AeronArchive_AsyncConnect,
                    ) -> ::std::os::raw::c_uchar;
                }
                extern "C" {
                    #[link_name = "\u{1}_ZN5aeron7archive6client12AeronArchive12AsyncConnectC1ERNS1_7ContextESt10shared_ptrINS_5AeronEEllx"]
                    pub fn AeronArchive_AsyncConnect_AsyncConnect(
                        this: *mut root::aeron::archive::client::AeronArchive_AsyncConnect,
                        context: *mut root::aeron::archive::client::AeronArchive_Context_t,
                        aeron: [u64; 2usize],
                        subscriptionId: ::std::os::raw::c_long,
                        publicationId: ::std::os::raw::c_long,
                        deadlineNs: ::std::os::raw::c_longlong,
                    );
                }
                impl AeronArchive_AsyncConnect {
                    #[inline]
                    pub unsafe fn poll(&mut self) -> [u64; 2usize] {
                        AeronArchive_AsyncConnect_poll(self)
                    }
                    #[inline]
                    pub unsafe fn step(&self) -> ::std::os::raw::c_uchar {
                        AeronArchive_AsyncConnect_step(self)
                    }
                    #[inline]
                    pub unsafe fn new(
                        context: *mut root::aeron::archive::client::AeronArchive_Context_t,
                        aeron: [u64; 2usize],
                        subscriptionId: ::std::os::raw::c_long,
                        publicationId: ::std::os::raw::c_long,
                        deadlineNs: ::std::os::raw::c_longlong,
                    ) -> Self {
                        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                        AeronArchive_AsyncConnect_AsyncConnect(
                            __bindgen_tmp.as_mut_ptr(),
                            context,
                            aeron,
                            subscriptionId,
                            publicationId,
                            deadlineNs,
                        );
                        __bindgen_tmp.assume_init()
                    }
                }
                #[test]
                fn bindgen_test_layout_AeronArchive() {
                    const UNINIT: ::std::mem::MaybeUninit<AeronArchive> =
                        ::std::mem::MaybeUninit::uninit();
                    let ptr = UNINIT.as_ptr();
                    assert_eq!(
                        ::std::mem::size_of::<AeronArchive>(),
                        160usize,
                        concat!("Size of: ", stringify!(AeronArchive))
                    );
                    assert_eq!(
                        ::std::mem::align_of::<AeronArchive>(),
                        8usize,
                        concat!("Alignment of ", stringify!(AeronArchive))
                    );
                    assert_eq!(
                        unsafe { ::std::ptr::addr_of!((*ptr).m_ctx) as usize - ptr as usize },
                        0usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(AeronArchive),
                            "::",
                            stringify!(m_ctx)
                        )
                    );
                    assert_eq!(
                        unsafe {
                            ::std::ptr::addr_of!((*ptr).m_archiveProxy) as usize - ptr as usize
                        },
                        8usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(AeronArchive),
                            "::",
                            stringify!(m_archiveProxy)
                        )
                    );
                    assert_eq!(
                        unsafe {
                            ::std::ptr::addr_of!((*ptr).m_controlResponsePoller) as usize
                                - ptr as usize
                        },
                        16usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(AeronArchive),
                            "::",
                            stringify!(m_controlResponsePoller)
                        )
                    );
                    assert_eq!(
                        unsafe {
                            ::std::ptr::addr_of!((*ptr).m_recordingDescriptorPoller) as usize
                                - ptr as usize
                        },
                        24usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(AeronArchive),
                            "::",
                            stringify!(m_recordingDescriptorPoller)
                        )
                    );
                    assert_eq!(
                        unsafe {
                            ::std::ptr::addr_of!((*ptr).m_recordingSubscriptionDescriptorPoller)
                                as usize
                                - ptr as usize
                        },
                        32usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(AeronArchive),
                            "::",
                            stringify!(m_recordingSubscriptionDescriptorPoller)
                        )
                    );
                    assert_eq!(
                        unsafe { ::std::ptr::addr_of!((*ptr).m_aeron) as usize - ptr as usize },
                        40usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(AeronArchive),
                            "::",
                            stringify!(m_aeron)
                        )
                    );
                    assert_eq!(
                        unsafe { ::std::ptr::addr_of!((*ptr).m_lock) as usize - ptr as usize },
                        56usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(AeronArchive),
                            "::",
                            stringify!(m_lock)
                        )
                    );
                    assert_eq!(
                        unsafe { ::std::ptr::addr_of!((*ptr).m_nanoClock) as usize - ptr as usize },
                        96usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(AeronArchive),
                            "::",
                            stringify!(m_nanoClock)
                        )
                    );
                    assert_eq!(
                        unsafe {
                            ::std::ptr::addr_of!((*ptr).m_controlSessionId) as usize - ptr as usize
                        },
                        128usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(AeronArchive),
                            "::",
                            stringify!(m_controlSessionId)
                        )
                    );
                    assert_eq!(
                        unsafe {
                            ::std::ptr::addr_of!((*ptr).m_lastCorrelationId) as usize - ptr as usize
                        },
                        136usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(AeronArchive),
                            "::",
                            stringify!(m_lastCorrelationId)
                        )
                    );
                    assert_eq!(
                        unsafe {
                            ::std::ptr::addr_of!((*ptr).m_messageTimeoutNs) as usize - ptr as usize
                        },
                        144usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(AeronArchive),
                            "::",
                            stringify!(m_messageTimeoutNs)
                        )
                    );
                    assert_eq!(
                        unsafe { ::std::ptr::addr_of!((*ptr).m_isClosed) as usize - ptr as usize },
                        152usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(AeronArchive),
                            "::",
                            stringify!(m_isClosed)
                        )
                    );
                    assert_eq!(
                        unsafe {
                            ::std::ptr::addr_of!((*ptr).m_isInCallback) as usize - ptr as usize
                        },
                        153usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(AeronArchive),
                            "::",
                            stringify!(m_isInCallback)
                        )
                    );
                }
                extern "C" {
                    #[doc = " Begin an attempt at creating a connection which can be completed by calling AsyncConnect#poll.\n\n @param ctx for the archive connection.\n @return the AsyncConnect that can be polled for completion."]
                    #[link_name = "\u{1}_ZN5aeron7archive6client12AeronArchive12asyncConnectERNS1_7ContextE"]
                    pub fn AeronArchive_asyncConnect(
                        ctx: *mut root::aeron::archive::client::AeronArchive_Context_t,
                    ) -> [u64; 2usize];
                }
                extern "C" {
                    #[doc = " Begin an attempt at creating a connection which can be completed by calling AsyncConnect#poll.\n\n @return the AsyncConnect that can be polled for completion."]
                    #[link_name = "\u{1}_ZN5aeron7archive6client12AeronArchive12asyncConnectEv"]
                    pub fn AeronArchive_asyncConnect1() -> [u64; 2usize];
                }
                extern "C" {
                    #[doc = " Connect to an Aeron archive using a default Context. This will create a control session.\n\n @return the newly created AeronArchive client."]
                    #[link_name = "\u{1}_ZN5aeron7archive6client12AeronArchive7connectEv"]
                    pub fn AeronArchive_connect() -> [u64; 2usize];
                }
                extern "C" {
                    #[doc = " Get the Context used to connect this archive client.\n\n @return the Context used to connect this archive client."]
                    #[link_name = "\u{1}_ZN5aeron7archive6client12AeronArchive7contextEv"]
                    pub fn AeronArchive_context(
                        this: *mut root::aeron::archive::client::AeronArchive,
                    ) -> *mut root::aeron::archive::client::AeronArchive_Context_t;
                }
                extern "C" {
                    #[doc = " The control session id allocated for this control session to the archive.\n\n @return control session id allocated for this control session to the archive."]
                    #[link_name = "\u{1}_ZNK5aeron7archive6client12AeronArchive16controlSessionIdEv"]
                    pub fn AeronArchive_controlSessionId(
                        this: *const root::aeron::archive::client::AeronArchive,
                    ) -> ::std::os::raw::c_long;
                }
                extern "C" {
                    #[doc = " The last used correlation id for this control session to the archive.\n\n @return last used correlation id for this connection to the archive."]
                    #[link_name = "\u{1}_ZNK5aeron7archive6client12AeronArchive17lastCorrelationIdEv"]
                    pub fn AeronArchive_lastCorrelationId(
                        this: *const root::aeron::archive::client::AeronArchive,
                    ) -> ::std::os::raw::c_long;
                }
                extern "C" {
                    #[doc = " The ArchiveProxy for send asynchronous messages to the connected archive.\n\n @return the ArchiveProxy for send asynchronous messages to the connected archive."]
                    #[link_name = "\u{1}_ZNK5aeron7archive6client12AeronArchive12archiveProxyEv"]
                    pub fn AeronArchive_archiveProxy(
                        this: *const root::aeron::archive::client::AeronArchive,
                    ) -> *mut root::aeron::archive::client::ArchiveProxy;
                }
                extern "C" {
                    #[doc = " Get the ControlResponsePoller for polling additional events on the control channel.\n\n @return the ControlResponsePoller for polling additional events on the control channel."]
                    #[link_name = "\u{1}_ZNK5aeron7archive6client12AeronArchive21controlResponsePollerEv"]
                    pub fn AeronArchive_controlResponsePoller(
                        this: *const root::aeron::archive::client::AeronArchive,
                    ) -> *mut root::aeron::archive::client::ControlResponsePoller;
                }
                extern "C" {
                    #[doc = " Get the RecordingDescriptorPoller for polling recording descriptors on the control channel.\n\n @return the RecordingDescriptorPoller for polling recording descriptors on the control channel."]
                    #[link_name = "\u{1}_ZNK5aeron7archive6client12AeronArchive25recordingDescriptorPollerEv"]
                    pub fn AeronArchive_recordingDescriptorPoller(
                        this: *const root::aeron::archive::client::AeronArchive,
                    ) -> *mut root::aeron::archive::client::RecordingDescriptorPoller;
                }
                extern "C" {
                    #[doc = " The RecordingSubscriptionDescriptorPoller for polling subscription descriptors on the control channel.\n\n @return the RecordingSubscriptionDescriptorPoller for polling subscription descriptors on the control\n channel."]
                    #[link_name = "\u{1}_ZNK5aeron7archive6client12AeronArchive37recordingSubscriptionDescriptorPollerEv"]
                    pub fn AeronArchive_recordingSubscriptionDescriptorPoller(
                        this: *const root::aeron::archive::client::AeronArchive,
                    ) -> *mut root::aeron::archive::client::RecordingSubscriptionDescriptorPoller;
                }
                extern "C" {
                    #[doc = " Poll the response stream once for an error. If another message is present then it will be skipped over\n so only call when not expecting another response. If not connected then it will return NOT_CONNECTED.\n\n @return the error String otherwise an empty string is returned if no error is found."]
                    #[link_name = "\u{1}_ZN5aeron7archive6client12AeronArchive20pollForErrorResponseB5cxx11Ev"]
                    pub fn AeronArchive_pollForErrorResponse(
                        this: *mut root::aeron::archive::client::AeronArchive,
                    ) -> root::std::string;
                }
                extern "C" {
                    #[doc = " Check if an error has been returned for the control session, or if it is no longer connected, and throw\n an ArchiveException if Context#errorHandler is not set.\n <p>\n To check for an error response without raising an exception then try #pollForErrorResponse.\n\n @see #pollForErrorResponse"]
                    #[link_name = "\u{1}_ZN5aeron7archive6client12AeronArchive21checkForErrorResponseEv"]
                    pub fn AeronArchive_checkForErrorResponse(
                        this: *mut root::aeron::archive::client::AeronArchive,
                    );
                }
                extern "C" {
                    #[doc = " Poll for RecordingSignals and dispatch them to Context#recordingSignalConsumer.\n\n @return the number of RecordingSignals dispatched."]
                    #[link_name = "\u{1}_ZN5aeron7archive6client12AeronArchive23pollForRecordingSignalsEv"]
                    pub fn AeronArchive_pollForRecordingSignals(
                        this: *mut root::aeron::archive::client::AeronArchive,
                    ) -> ::std::os::raw::c_int;
                }
                extern "C" {
                    #[doc = " Return the static version string for the binary library.\n\n @return static version and build string"]
                    #[link_name = "\u{1}_ZN5aeron7archive6client12AeronArchive7versionB5cxx11Ev"]
                    pub fn AeronArchive_version() -> root::std::string;
                }
                extern "C" {
                    #[link_name = "\u{1}_ZN5aeron7archive6client12AeronArchiveC1ESt10unique_ptrINS1_7ContextESt14default_deleteIS4_EES3_INS1_12ArchiveProxyES5_IS8_EES3_INS1_21ControlResponsePollerES5_ISB_EES3_INS1_25RecordingDescriptorPollerES5_ISE_EES3_INS1_37RecordingSubscriptionDescriptorPollerES5_ISH_EESt10shared_ptrINS_5AeronEEl"]
                    pub fn AeronArchive_AeronArchive(
                        this: *mut root::aeron::archive::client::AeronArchive,
                        ctx: u64,
                        archiveProxy: u64,
                        controlResponsePoller: u64,
                        recordingDescriptorPoller: u64,
                        recordingSubscriptionDescriptorPoller: u64,
                        aeron: [u64; 2usize],
                        controlSessionId: ::std::os::raw::c_long,
                    );
                }
                extern "C" {
                    #[link_name = "\u{1}_ZN5aeron7archive6client12AeronArchiveD1Ev"]
                    pub fn AeronArchive_AeronArchive_destructor(
                        this: *mut root::aeron::archive::client::AeronArchive,
                    );
                }
                impl AeronArchive {
                    #[inline]
                    pub unsafe fn asyncConnect(
                        ctx: *mut root::aeron::archive::client::AeronArchive_Context_t,
                    ) -> [u64; 2usize] {
                        AeronArchive_asyncConnect(ctx)
                    }
                    #[inline]
                    pub unsafe fn asyncConnect1() -> [u64; 2usize] {
                        AeronArchive_asyncConnect1()
                    }
                    #[inline]
                    pub unsafe fn connect() -> [u64; 2usize] {
                        AeronArchive_connect()
                    }
                    #[inline]
                    pub unsafe fn context(
                        &mut self,
                    ) -> *mut root::aeron::archive::client::AeronArchive_Context_t
                    {
                        AeronArchive_context(self)
                    }
                    #[inline]
                    pub unsafe fn controlSessionId(&self) -> ::std::os::raw::c_long {
                        AeronArchive_controlSessionId(self)
                    }
                    #[inline]
                    pub unsafe fn lastCorrelationId(&self) -> ::std::os::raw::c_long {
                        AeronArchive_lastCorrelationId(self)
                    }
                    #[inline]
                    pub unsafe fn archiveProxy(
                        &self,
                    ) -> *mut root::aeron::archive::client::ArchiveProxy {
                        AeronArchive_archiveProxy(self)
                    }
                    #[inline]
                    pub unsafe fn controlResponsePoller(
                        &self,
                    ) -> *mut root::aeron::archive::client::ControlResponsePoller
                    {
                        AeronArchive_controlResponsePoller(self)
                    }
                    #[inline]
                    pub unsafe fn recordingDescriptorPoller(
                        &self,
                    ) -> *mut root::aeron::archive::client::RecordingDescriptorPoller
                    {
                        AeronArchive_recordingDescriptorPoller(self)
                    }
                    #[inline]
                    pub unsafe fn recordingSubscriptionDescriptorPoller(
                        &self,
                    ) -> *mut root::aeron::archive::client::RecordingSubscriptionDescriptorPoller
                    {
                        AeronArchive_recordingSubscriptionDescriptorPoller(self)
                    }
                    #[inline]
                    pub unsafe fn pollForErrorResponse(&mut self) -> root::std::string {
                        AeronArchive_pollForErrorResponse(self)
                    }
                    #[inline]
                    pub unsafe fn checkForErrorResponse(&mut self) {
                        AeronArchive_checkForErrorResponse(self)
                    }
                    #[inline]
                    pub unsafe fn pollForRecordingSignals(&mut self) -> ::std::os::raw::c_int {
                        AeronArchive_pollForRecordingSignals(self)
                    }
                    #[inline]
                    pub unsafe fn version() -> root::std::string {
                        AeronArchive_version()
                    }
                    #[inline]
                    pub unsafe fn new(
                        ctx: u64,
                        archiveProxy: u64,
                        controlResponsePoller: u64,
                        recordingDescriptorPoller: u64,
                        recordingSubscriptionDescriptorPoller: u64,
                        aeron: [u64; 2usize],
                        controlSessionId: ::std::os::raw::c_long,
                    ) -> Self {
                        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                        AeronArchive_AeronArchive(
                            __bindgen_tmp.as_mut_ptr(),
                            ctx,
                            archiveProxy,
                            controlResponsePoller,
                            recordingDescriptorPoller,
                            recordingSubscriptionDescriptorPoller,
                            aeron,
                            controlSessionId,
                        );
                        __bindgen_tmp.assume_init()
                    }
                    #[inline]
                    pub unsafe fn destruct(&mut self) {
                        AeronArchive_AeronArchive_destructor(self)
                    }
                }
            }
        }
        #[repr(C)]
        #[derive(Copy, Clone)]
        pub struct BufferBuilder {
            pub m_capacity: ::std::os::raw::c_uint,
            pub m_limit: ::std::os::raw::c_uint,
            pub m_nextTermOffset: root::aeron::util::index_t,
            pub m_buffer: u64,
        }
        #[test]
        fn bindgen_test_layout_BufferBuilder() {
            const UNINIT: ::std::mem::MaybeUninit<BufferBuilder> =
                ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<BufferBuilder>(),
                24usize,
                concat!("Size of: ", stringify!(BufferBuilder))
            );
            assert_eq!(
                ::std::mem::align_of::<BufferBuilder>(),
                8usize,
                concat!("Alignment of ", stringify!(BufferBuilder))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_capacity) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(BufferBuilder),
                    "::",
                    stringify!(m_capacity)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_limit) as usize - ptr as usize },
                4usize,
                concat!(
                    "Offset of field: ",
                    stringify!(BufferBuilder),
                    "::",
                    stringify!(m_limit)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_nextTermOffset) as usize - ptr as usize },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(BufferBuilder),
                    "::",
                    stringify!(m_nextTermOffset)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_buffer) as usize - ptr as usize },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(BufferBuilder),
                    "::",
                    stringify!(m_buffer)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZNK5aeron13BufferBuilder6bufferEv"]
            pub fn BufferBuilder_buffer(
                this: *const root::aeron::BufferBuilder,
            ) -> *mut ::std::os::raw::c_uchar;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNK5aeron13BufferBuilder5limitEv"]
            pub fn BufferBuilder_limit(
                this: *const root::aeron::BufferBuilder,
            ) -> ::std::os::raw::c_uint;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5aeron13BufferBuilder5limitEj"]
            pub fn BufferBuilder_limit1(
                this: *mut root::aeron::BufferBuilder,
                limit: ::std::os::raw::c_uint,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZNK5aeron13BufferBuilder14nextTermOffsetEv"]
            pub fn BufferBuilder_nextTermOffset(
                this: *const root::aeron::BufferBuilder,
            ) -> root::aeron::util::index_t;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5aeron13BufferBuilder14nextTermOffsetEi"]
            pub fn BufferBuilder_nextTermOffset1(
                this: *mut root::aeron::BufferBuilder,
                offset: root::aeron::util::index_t,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5aeron13BufferBuilder5resetEv"]
            pub fn BufferBuilder_reset(this: *mut root::aeron::BufferBuilder) -> *mut root::aeron::BufferBuilder;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5aeron13BufferBuilder6appendERNS_10concurrent12AtomicBufferEiiRNS1_9logbuffer6HeaderE"]
            pub fn BufferBuilder_append(
                this: *mut root::aeron::BufferBuilder,
                buffer: *mut root::aeron::concurrent::AtomicBuffer,
                offset: root::aeron::util::index_t,
                length: root::aeron::util::index_t,
                arg1: *mut root::aeron::concurrent::logbuffer::Header,
            ) -> *mut root::aeron::BufferBuilder;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5aeron13BufferBuilderC1Ej"]
            pub fn BufferBuilder_BufferBuilder(
                this: *mut root::aeron::BufferBuilder,
                initialLength: ::std::os::raw::c_uint,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5aeron13BufferBuilderC1EOS0_"]
            pub fn BufferBuilder_BufferBuilder1(
                this: *mut root::aeron::BufferBuilder,
                builder: *mut root::aeron::BufferBuilder,
            );
        }
        impl BufferBuilder {
            #[inline]
            pub unsafe fn buffer(&self) -> *mut ::std::os::raw::c_uchar {
                BufferBuilder_buffer(self)
            }
            #[inline]
            pub unsafe fn limit(&self) -> ::std::os::raw::c_uint {
                BufferBuilder_limit(self)
            }
            #[inline]
            pub unsafe fn limit1(&mut self, limit: ::std::os::raw::c_uint) {
                BufferBuilder_limit1(self, limit)
            }
            #[inline]
            pub unsafe fn nextTermOffset(&self) -> root::aeron::util::index_t {
                BufferBuilder_nextTermOffset(self)
            }
            #[inline]
            pub unsafe fn nextTermOffset1(&mut self, offset: root::aeron::util::index_t) {
                BufferBuilder_nextTermOffset1(self, offset)
            }
            #[inline]
            pub unsafe fn reset(&mut self) -> *mut root::aeron::BufferBuilder {
                BufferBuilder_reset(self)
            }
            #[inline]
            pub unsafe fn append(
                &mut self,
                buffer: *mut root::aeron::concurrent::AtomicBuffer,
                offset: root::aeron::util::index_t,
                length: root::aeron::util::index_t,
                arg1: *mut root::aeron::concurrent::logbuffer::Header,
            ) -> *mut root::aeron::BufferBuilder {
                BufferBuilder_append(self, buffer, offset, length, arg1)
            }
            #[inline]
            pub unsafe fn new(initialLength: ::std::os::raw::c_uint) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                BufferBuilder_BufferBuilder(__bindgen_tmp.as_mut_ptr(), initialLength);
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn new1(builder: *mut root::aeron::BufferBuilder) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                BufferBuilder_BufferBuilder1(__bindgen_tmp.as_mut_ptr(), builder);
                __bindgen_tmp.assume_init()
            }
        }
        #[repr(C)]
        pub struct ControlledFragmentAssembler {
            pub m_initialBufferLength: usize,
            pub m_delegate: root::aeron::controlled_poll_fragment_handler_t,
            pub m_builderBySessionIdMap: [u64; 7usize],
        }
        #[test]
        fn bindgen_test_layout_ControlledFragmentAssembler() {
            const UNINIT: ::std::mem::MaybeUninit<ControlledFragmentAssembler> =
                ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<ControlledFragmentAssembler>(),
                96usize,
                concat!("Size of: ", stringify!(ControlledFragmentAssembler))
            );
            assert_eq!(
                ::std::mem::align_of::<ControlledFragmentAssembler>(),
                8usize,
                concat!("Alignment of ", stringify!(ControlledFragmentAssembler))
            );
            assert_eq!(
                unsafe {
                    ::std::ptr::addr_of!((*ptr).m_initialBufferLength) as usize - ptr as usize
                },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ControlledFragmentAssembler),
                    "::",
                    stringify!(m_initialBufferLength)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_delegate) as usize - ptr as usize },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ControlledFragmentAssembler),
                    "::",
                    stringify!(m_delegate)
                )
            );
            assert_eq!(
                unsafe {
                    ::std::ptr::addr_of!((*ptr).m_builderBySessionIdMap) as usize - ptr as usize
                },
                40usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ControlledFragmentAssembler),
                    "::",
                    stringify!(m_builderBySessionIdMap)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5aeron27ControlledFragmentAssembler7handlerEv"]
            pub fn ControlledFragmentAssembler_handler(
                this: *mut root::aeron::ControlledFragmentAssembler,
            ) -> root::aeron::controlled_poll_fragment_handler_t;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5aeron27ControlledFragmentAssembler19deleteSessionBufferEi"]
            pub fn ControlledFragmentAssembler_deleteSessionBuffer(
                this: *mut root::aeron::ControlledFragmentAssembler,
                sessionId: ::std::os::raw::c_int,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5aeron27ControlledFragmentAssemblerC1ERKSt8functionIFNS_20ControlledPollActionERNS_10concurrent12AtomicBufferEiiRNS3_9logbuffer6HeaderEEEm"]
            pub fn ControlledFragmentAssembler_ControlledFragmentAssembler(
                this: *mut root::aeron::ControlledFragmentAssembler,
                delegate: *const root::aeron::controlled_poll_fragment_handler_t,
                initialBufferLength: usize,
            );
        }
        impl ControlledFragmentAssembler {
            #[inline]
            pub unsafe fn handler(&mut self) -> root::aeron::controlled_poll_fragment_handler_t {
                ControlledFragmentAssembler_handler(self)
            }
            #[inline]
            pub unsafe fn deleteSessionBuffer(&mut self, sessionId: ::std::os::raw::c_int) {
                ControlledFragmentAssembler_deleteSessionBuffer(self, sessionId)
            }
            #[inline]
            pub unsafe fn new(
                delegate: *const root::aeron::controlled_poll_fragment_handler_t,
                initialBufferLength: usize,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                ControlledFragmentAssembler_ControlledFragmentAssembler(
                    __bindgen_tmp.as_mut_ptr(),
                    delegate,
                    initialBufferLength,
                );
                __bindgen_tmp.assume_init()
            }
        }
    }

    #[test]
    fn __bindgen_test_layout_ReadablePosition_open0_UnsafeBufferPosition_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<
                root::aeron::concurrent::status::ReadablePosition<
                    root::aeron::concurrent::status::UnsafeBufferPosition,
                >,
            >(),
            24usize,
            concat!(
                "Size of template specialization: ",
                stringify!(
                    root::aeron::concurrent::status::ReadablePosition<
                        root::aeron::concurrent::status::UnsafeBufferPosition,
                    >
                )
            )
        );
        assert_eq!(
            ::std::mem::align_of::<
                root::aeron::concurrent::status::ReadablePosition<
                    root::aeron::concurrent::status::UnsafeBufferPosition,
                >,
            >(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(
                    root::aeron::concurrent::status::ReadablePosition<
                        root::aeron::concurrent::status::UnsafeBufferPosition,
                    >
                )
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_ReadablePosition_open0_UnsafeBufferPosition_close0_instantiation_1() {
        assert_eq!(
            ::std::mem::size_of::<
                root::aeron::concurrent::status::ReadablePosition<
                    root::aeron::concurrent::status::UnsafeBufferPosition,
                >,
            >(),
            24usize,
            concat!(
                "Size of template specialization: ",
                stringify!(
                    root::aeron::concurrent::status::ReadablePosition<
                        root::aeron::concurrent::status::UnsafeBufferPosition,
                    >
                )
            )
        );
        assert_eq!(
            ::std::mem::align_of::<
                root::aeron::concurrent::status::ReadablePosition<
                    root::aeron::concurrent::status::UnsafeBufferPosition,
                >,
            >(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(
                    root::aeron::concurrent::status::ReadablePosition<
                        root::aeron::concurrent::status::UnsafeBufferPosition,
                    >
                )
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Position_open0_UnsafeBufferPosition_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<
                root::aeron::concurrent::status::Position<
                    root::aeron::concurrent::status::UnsafeBufferPosition,
                >,
            >(),
            24usize,
            concat!(
                "Size of template specialization: ",
                stringify!(
                    root::aeron::concurrent::status::Position<
                        root::aeron::concurrent::status::UnsafeBufferPosition,
                    >
                )
            )
        );
        assert_eq!(
            ::std::mem::align_of::<
                root::aeron::concurrent::status::Position<
                    root::aeron::concurrent::status::UnsafeBufferPosition,
                >,
            >(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(
                    root::aeron::concurrent::status::Position<
                        root::aeron::concurrent::status::UnsafeBufferPosition,
                    >
                )
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_AtomicArrayUpdater_open0_shared_ptr_open1_Image_close1_close0_instantiation(
    ) {
        assert_eq!(
            ::std::mem::size_of::<[u64; 4usize]>(),
            32usize,
            concat!(
                "Size of template specialization: ",
                stringify!([u64; 4usize])
            )
        );
        assert_eq!(
            ::std::mem::align_of::<[u64; 4usize]>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!([u64; 4usize])
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Flyweight_open0_CorrelatedMessageDefn_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<
                root::aeron::command::Flyweight<root::aeron::command::CorrelatedMessageDefn>,
            >(),
            32usize,
            concat!(
                "Size of template specialization: ",
                stringify!(
                    root::aeron::command::Flyweight<root::aeron::command::CorrelatedMessageDefn>
                )
            )
        );
        assert_eq!(
            ::std::mem::align_of::<
                root::aeron::command::Flyweight<root::aeron::command::CorrelatedMessageDefn>,
            >(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(
                    root::aeron::command::Flyweight<root::aeron::command::CorrelatedMessageDefn>
                )
            )
        );
    }

    #[test]
    fn __bindgen_test_layout_Flyweight_open0_PublicationBuffersReadyDefn_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<
                root::aeron::command::Flyweight<root::aeron::command::PublicationBuffersReadyDefn>,
            >(),
            32usize,
            concat!(
                "Size of template specialization: ",
                stringify!(
                    root::aeron::command::Flyweight<
                        root::aeron::command::PublicationBuffersReadyDefn,
                    >
                )
            )
        );
        assert_eq!(
            ::std::mem::align_of::<
                root::aeron::command::Flyweight<root::aeron::command::PublicationBuffersReadyDefn>,
            >(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(
                    root::aeron::command::Flyweight<
                        root::aeron::command::PublicationBuffersReadyDefn,
                    >
                )
            )
        );
    }
    
    #[test]
    fn __bindgen_test_layout_Flyweight_open0_ImageBuffersReadyDefn_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<
                root::aeron::command::Flyweight<root::aeron::command::ImageBuffersReadyDefn>,
            >(),
            32usize,
            concat!(
                "Size of template specialization: ",
                stringify!(
                    root::aeron::command::Flyweight<root::aeron::command::ImageBuffersReadyDefn>
                )
            )
        );
        assert_eq!(
            ::std::mem::align_of::<
                root::aeron::command::Flyweight<root::aeron::command::ImageBuffersReadyDefn>,
            >(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(
                    root::aeron::command::Flyweight<root::aeron::command::ImageBuffersReadyDefn>
                )
            )
        );
    }

    #[test]
    fn __bindgen_test_layout_Flyweight_open0_ImageMessageDefn_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<
                root::aeron::command::Flyweight<root::aeron::command::ImageMessageDefn>,
            >(),
            32usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::aeron::command::Flyweight<root::aeron::command::ImageMessageDefn>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<
                root::aeron::command::Flyweight<root::aeron::command::ImageMessageDefn>,
            >(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::aeron::command::Flyweight<root::aeron::command::ImageMessageDefn>)
            )
        );
    }

    #[test]
    fn __bindgen_test_layout_Flyweight_open0_ErrorResponseDefn_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<
                root::aeron::command::Flyweight<root::aeron::command::ErrorResponseDefn>,
            >(),
            32usize,
            concat!(
                "Size of template specialization: ",
                stringify!(
                    root::aeron::command::Flyweight<root::aeron::command::ErrorResponseDefn>
                )
            )
        );
        assert_eq!(
            ::std::mem::align_of::<
                root::aeron::command::Flyweight<root::aeron::command::ErrorResponseDefn>,
            >(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(
                    root::aeron::command::Flyweight<root::aeron::command::ErrorResponseDefn>
                )
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Flyweight_open0_OperationSucceededDefn_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<
                root::aeron::command::Flyweight<root::aeron::command::OperationSucceededDefn>,
            >(),
            32usize,
            concat!(
                "Size of template specialization: ",
                stringify!(
                    root::aeron::command::Flyweight<root::aeron::command::OperationSucceededDefn>
                )
            )
        );
        assert_eq!(
            ::std::mem::align_of::<
                root::aeron::command::Flyweight<root::aeron::command::OperationSucceededDefn>,
            >(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(
                    root::aeron::command::Flyweight<root::aeron::command::OperationSucceededDefn>
                )
            )
        );
    }
    
    #[test]
    fn __bindgen_test_layout_Flyweight_open0_SubscriptionReadyDefn_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<
                root::aeron::command::Flyweight<root::aeron::command::SubscriptionReadyDefn>,
            >(),
            32usize,
            concat!(
                "Size of template specialization: ",
                stringify!(
                    root::aeron::command::Flyweight<root::aeron::command::SubscriptionReadyDefn>
                )
            )
        );
        assert_eq!(
            ::std::mem::align_of::<
                root::aeron::command::Flyweight<root::aeron::command::SubscriptionReadyDefn>,
            >(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(
                    root::aeron::command::Flyweight<root::aeron::command::SubscriptionReadyDefn>
                )
            )
        );
    }
    
    #[test]
    fn __bindgen_test_layout_Flyweight_open0_CounterUpdateDefn_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<
                root::aeron::command::Flyweight<root::aeron::command::CounterUpdateDefn>,
            >(),
            32usize,
            concat!(
                "Size of template specialization: ",
                stringify!(
                    root::aeron::command::Flyweight<root::aeron::command::CounterUpdateDefn>
                )
            )
        );
        assert_eq!(
            ::std::mem::align_of::<
                root::aeron::command::Flyweight<root::aeron::command::CounterUpdateDefn>,
            >(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(
                    root::aeron::command::Flyweight<root::aeron::command::CounterUpdateDefn>
                )
            )
        );
    }
    
    #[test]
    fn __bindgen_test_layout_Flyweight_open0_ClientTimeoutDefn_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<
                root::aeron::command::Flyweight<root::aeron::command::ClientTimeoutDefn>,
            >(),
            32usize,
            concat!(
                "Size of template specialization: ",
                stringify!(
                    root::aeron::command::Flyweight<root::aeron::command::ClientTimeoutDefn>
                )
            )
        );
        assert_eq!(
            ::std::mem::align_of::<
                root::aeron::command::Flyweight<root::aeron::command::ClientTimeoutDefn>,
            >(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(
                    root::aeron::command::Flyweight<root::aeron::command::ClientTimeoutDefn>
                )
            )
        );
    }
    
    #[test]
    fn __bindgen_test_layout_DriverListenerAdapter_open0_ClientConductor_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<root::aeron::DriverListenerAdapter<root::aeron::ClientConductor>>(
            ),
            16usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::aeron::DriverListenerAdapter<root::aeron::ClientConductor>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::aeron::DriverListenerAdapter<root::aeron::ClientConductor>>(
            ),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::aeron::DriverListenerAdapter<root::aeron::ClientConductor>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_AgentInvoker_open0_ClientConductor_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<
                root::aeron::concurrent::AgentInvoker<root::aeron::ClientConductor>,
            >(),
            24usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::aeron::concurrent::AgentInvoker<root::aeron::ClientConductor>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<
                root::aeron::concurrent::AgentInvoker<root::aeron::ClientConductor>,
            >(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::aeron::concurrent::AgentInvoker<root::aeron::ClientConductor>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_AgentRunner_open0_ClientConductor_SleepingIdleStrategy_close0_instantiation(
    ) {
        assert_eq!(
            ::std::mem::size_of::<
                root::aeron::concurrent::AgentRunner<
                    root::aeron::ClientConductor,
                    root::aeron::concurrent::SleepingIdleStrategy,
                >,
            >(),
            72usize,
            concat!(
                "Size of template specialization: ",
                stringify ! (root :: aeron :: concurrent :: AgentRunner < root :: aeron :: ClientConductor , root :: aeron :: concurrent :: SleepingIdleStrategy >)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<
                root::aeron::concurrent::AgentRunner<
                    root::aeron::ClientConductor,
                    root::aeron::concurrent::SleepingIdleStrategy,
                >,
            >(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify ! (root :: aeron :: concurrent :: AgentRunner < root :: aeron :: ClientConductor , root :: aeron :: concurrent :: SleepingIdleStrategy >)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_AgentInvoker_open0_ClientConductor_close0_instantiation_1() {
        assert_eq!(
            ::std::mem::size_of::<
                root::aeron::concurrent::AgentInvoker<root::aeron::ClientConductor>,
            >(),
            24usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::aeron::concurrent::AgentInvoker<root::aeron::ClientConductor>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<
                root::aeron::concurrent::AgentInvoker<root::aeron::ClientConductor>,
            >(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::aeron::concurrent::AgentInvoker<root::aeron::ClientConductor>)
            )
        );
    }

}
