/* automatically generated by rust-bindgen 0.66.1 */

#[allow(non_snake_case, non_camel_case_types, non_upper_case_globals)]
pub mod root {
    #[allow(unused_imports)]
    use self::super::root;
    pub const AERON_NULL_VALUE: i32 = -1;
    pub const AERON_CLIENT_ERROR_DRIVER_TIMEOUT: i32 = -1000;
    pub const AERON_CLIENT_ERROR_CLIENT_TIMEOUT: i32 = -1001;
    pub const AERON_CLIENT_ERROR_CONDUCTOR_SERVICE_TIMEOUT: i32 = -1002;
    pub const AERON_CLIENT_ERROR_BUFFER_FULL: i32 = -1003;
    pub const AERON_CLIENT_MAX_LOCAL_ADDRESS_STR_LEN: u32 = 64;
    pub const AERON_DIR_ENV_VAR: &[u8; 10] = b"AERON_DIR\0";
    pub const AERON_DRIVER_TIMEOUT_ENV_VAR: &[u8; 21] = b"AERON_DRIVER_TIMEOUT\0";
    pub const AERON_CLIENT_RESOURCE_LINGER_DURATION_ENV_VAR: &[u8; 38] =
        b"AERON_CLIENT_RESOURCE_LINGER_DURATION\0";
    pub const AERON_CLIENT_PRE_TOUCH_MAPPED_MEMORY_ENV_VAR: &[u8; 37] =
        b"AERON_CLIENT_PRE_TOUCH_MAPPED_MEMORY\0";
    pub const AERON_AGENT_ON_START_FUNCTION_ENV_VAR: &[u8; 30] = b"AERON_AGENT_ON_START_FUNCTION\0";
    pub const AERON_COUNTER_CACHE_LINE_LENGTH: u32 = 64;
    pub const AERON_COUNTER_RECORD_UNUSED: u32 = 0;
    pub const AERON_COUNTER_RECORD_ALLOCATED: u32 = 1;
    pub const AERON_COUNTER_RECORD_RECLAIMED: i32 = -1;
    pub const AERON_NULL_COUNTER_ID: i32 = -1;
    pub const AERON_PUBLICATION_NOT_CONNECTED: i32 = -1;
    pub const AERON_PUBLICATION_BACK_PRESSURED: i32 = -2;
    pub const AERON_PUBLICATION_ADMIN_ACTION: i32 = -3;
    pub const AERON_PUBLICATION_CLOSED: i32 = -4;
    pub const AERON_PUBLICATION_MAX_POSITION_EXCEEDED: i32 = -5;
    pub const AERON_PUBLICATION_ERROR: i32 = -6;
    pub const AERON_FILE_SEP: u8 = 47u8;
    pub const AERON_COMPILER_GCC: u32 = 1;
    pub const AERON_COMPILER_LLVM: u32 = 1;
    pub const AERON_CPU_X64: u32 = 1;
    pub const AERON_MAX_PATH: u32 = 384;
    pub mod std {
        #[allow(unused_imports)]
        use self::super::super::root;
        #[repr(C)]
        #[derive(Copy, Clone)]
        pub struct basic_string {
            pub _address: u8,
        }
        pub type basic_string__Char_alloc_type = u8;
        pub type basic_string__Alloc_traits = u8;
        pub type basic_string_traits_type = u8;
        pub type basic_string_value_type = u8;
        pub type basic_string_allocator_type = u8;
        pub type basic_string_size_type = u8;
        pub type basic_string_difference_type = u8;
        pub type basic_string_reference = u8;
        pub type basic_string_const_reference = u8;
        pub type basic_string_pointer = u8;
        pub type basic_string_const_pointer = u8;
        pub type basic_string_iterator = u8;
        pub type basic_string_const_iterator = u8;
        pub type basic_string_const_reverse_iterator = u8;
        pub type basic_string_reverse_iterator = u8;
        pub type basic_string___const_iterator = u8;
        #[repr(C)]
        #[derive(Copy, Clone)]
        pub struct basic_string__Alloc_hider {
            pub _address: u8,
        }
        pub const basic_string__S_local_capacity: root::std::basic_string__bindgen_ty_1 = 0;
        pub type basic_string__bindgen_ty_1 = i32;
        #[repr(C)]
        #[repr(align(8))]
        #[derive(Copy, Clone)]
        pub union basic_string__bindgen_ty_2 {
            pub _bindgen_opaque_blob: u64,
        }
        #[repr(C)]
        #[derive(Copy, Clone)]
        pub struct pair {
            pub _address: u8,
        }
        pub type pair_first_type = u8;
        pub type pair_second_type = u8;
        pub type pair__PCCP = u8;
        pub type pair__PCCFP = u8;
        #[repr(C)]
        #[derive(Copy, Clone)]
        pub struct pair___zero_as_null_pointer_constant {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Copy, Clone)]
        pub struct hash {
            pub _address: u8,
        }
        #[repr(C)]
        #[repr(align(8))]
        #[derive(Copy, Clone)]
        pub struct exception {
            pub _bindgen_opaque_blob: u64,
        }
        #[test]
        fn bindgen_test_layout_exception() {
            assert_eq!(
                ::std::mem::size_of::<exception>(),
                8usize,
                concat!("Size of: ", stringify!(exception))
            );
            assert_eq!(
                ::std::mem::align_of::<exception>(),
                8usize,
                concat!("Alignment of ", stringify!(exception))
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZNSt9exceptionD1Ev"]
            pub fn exception_exception_destructor(this: *mut root::std::exception);
        }
        extern "C" {
            #[link_name = "\u{1}_ZNKSt9exception4whatEv"]
            pub fn exception_what(
                this: *mut ::std::os::raw::c_void,
            ) -> *const ::std::os::raw::c_char;
        }
        #[repr(C)]
        #[derive(Copy, Clone)]
        pub struct allocator {
            pub _address: u8,
        }
        pub type allocator_value_type = u8;
        pub type allocator_size_type = u64;
        pub type allocator_difference_type = u64;
        pub type allocator_pointer = u8;
        pub type allocator_const_pointer = u8;
        pub type allocator_reference = u8;
        pub type allocator_const_reference = u8;
        #[repr(C)]
        #[derive(Copy, Clone)]
        pub struct allocator_rebind {
            pub _address: u8,
        }
        pub type allocator_rebind_other = u8;
        pub type allocator_propagate_on_container_move_assignment = u8;
        pub type allocator_is_always_equal = u8;
        #[repr(C)]
        #[derive(Copy, Clone)]
        pub struct equal_to {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Copy, Clone)]
        pub struct unordered_map {
            pub _address: u8,
        }
        pub type unordered_map__Hashtable = u8;
        pub type unordered_map_key_type = u8;
        pub type unordered_map_value_type = u8;
        pub type unordered_map_mapped_type = u8;
        pub type unordered_map_hasher = u8;
        pub type unordered_map_key_equal = u8;
        pub type unordered_map_allocator_type = u8;
        pub type unordered_map_pointer = u8;
        pub type unordered_map_const_pointer = u8;
        pub type unordered_map_reference = u8;
        pub type unordered_map_const_reference = u8;
        pub type unordered_map_iterator = u8;
        pub type unordered_map_const_iterator = u8;
        pub type unordered_map_local_iterator = u8;
        pub type unordered_map_const_local_iterator = u8;
        pub type unordered_map_size_type = u8;
        pub type unordered_map_difference_type = u8;
        pub mod chrono {
            #[allow(unused_imports)]
            use self::super::super::super::root;
        }
        #[repr(C)]
        #[repr(align(8))]
        #[derive(Copy, Clone)]
        pub struct recursive_mutex {
            pub _bindgen_opaque_blob: [u64; 5usize],
        }
        pub type recursive_mutex_native_handle_type = u64;
        #[test]
        fn bindgen_test_layout_recursive_mutex() {
            assert_eq!(
                ::std::mem::size_of::<recursive_mutex>(),
                40usize,
                concat!("Size of: ", stringify!(recursive_mutex))
            );
            assert_eq!(
                ::std::mem::align_of::<recursive_mutex>(),
                8usize,
                concat!("Alignment of ", stringify!(recursive_mutex))
            );
        }
        pub type string = [u64; 4usize];
        #[repr(C)]
        #[derive(Copy, Clone)]
        pub struct char_traits {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Copy, Clone)]
        pub struct function {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Copy, Clone)]
        pub struct default_delete {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Copy, Clone)]
        pub struct unique_ptr {
            pub _address: u8,
        }
        pub type unique_ptr__DeleterConstraint = u8;
        pub type unique_ptr_pointer = u8;
        pub type unique_ptr_element_type = u8;
        pub type unique_ptr_deleter_type = u8;
        pub type unique_ptr___safe_conversion_up = u8;
        #[repr(C)]
        #[repr(align(8))]
        #[derive(Copy, Clone)]
        pub struct thread {
            pub _bindgen_opaque_blob: u64,
        }
        pub type thread_native_handle_type = u64;
        #[repr(C)]
        #[repr(align(8))]
        #[derive(Copy, Clone)]
        pub struct thread_id {
            pub _bindgen_opaque_blob: u64,
        }
        #[test]
        fn bindgen_test_layout_thread_id() {
            assert_eq!(
                ::std::mem::size_of::<thread_id>(),
                8usize,
                concat!("Size of: ", stringify!(thread_id))
            );
            assert_eq!(
                ::std::mem::align_of::<thread_id>(),
                8usize,
                concat!("Alignment of ", stringify!(thread_id))
            );
        }
        pub type thread___not_same = u8;
        #[repr(C)]
        #[repr(align(8))]
        #[derive(Copy, Clone)]
        pub struct thread__State {
            pub _bindgen_opaque_blob: u64,
        }
        #[test]
        fn bindgen_test_layout_thread__State() {
            assert_eq!(
                ::std::mem::size_of::<thread__State>(),
                8usize,
                concat!("Size of: ", stringify!(thread__State))
            );
            assert_eq!(
                ::std::mem::align_of::<thread__State>(),
                8usize,
                concat!("Alignment of ", stringify!(thread__State))
            );
        }
        pub type thread__State_ptr = u64;
        #[repr(C)]
        #[derive(Copy, Clone)]
        pub struct thread__State_impl {}
        #[repr(C)]
        #[derive(Copy, Clone)]
        pub struct thread__Invoker {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Copy, Clone)]
        pub struct thread__Invoker___result {
            pub _address: u8,
        }
        pub type thread__Call_wrapper = u8;
        #[test]
        fn bindgen_test_layout_thread() {
            assert_eq!(
                ::std::mem::size_of::<thread>(),
                8usize,
                concat!("Size of: ", stringify!(thread))
            );
            assert_eq!(
                ::std::mem::align_of::<thread>(),
                8usize,
                concat!("Alignment of ", stringify!(thread))
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZNSt6thread4joinEv"]
            pub fn thread_join(this: *mut root::std::thread);
        }
        extern "C" {
            #[link_name = "\u{1}_ZNSt6thread6detachEv"]
            pub fn thread_detach(this: *mut root::std::thread);
        }
        extern "C" {
            #[link_name = "\u{1}_ZNSt6thread20hardware_concurrencyEv"]
            pub fn thread_hardware_concurrency() -> ::std::os::raw::c_uint;
        }
        impl thread {
            #[inline]
            pub unsafe fn join(&mut self) {
                thread_join(self)
            }
            #[inline]
            pub unsafe fn detach(&mut self) {
                thread_detach(self)
            }
            #[inline]
            pub unsafe fn hardware_concurrency() -> ::std::os::raw::c_uint {
                thread_hardware_concurrency()
            }
        }
        extern "C" {
            #[link_name = "\u{1}_ZNSt6thread6_StateD1Ev"]
            pub fn thread__State__State_destructor(this: *mut root::std::thread__State);
        }
        #[repr(C)]
        #[derive(Copy, Clone)]
        pub struct atomic {
            pub _address: u8,
        }
        pub type atomic_value_type = u8;
        #[repr(C)]
        #[derive(Copy, Clone)]
        pub struct shared_ptr {
            pub _address: u8,
        }
        pub type shared_ptr__Constructible = u8;
        pub type shared_ptr__Assignable = u8;
        pub type shared_ptr_element_type = u8;
        pub type array_value_type = u8;
        pub type array_pointer = u8;
        pub type array_const_pointer = u8;
        pub type array_reference = u8;
        pub type array_const_reference = u8;
        pub type array_iterator = u8;
        pub type array_const_iterator = u8;
        pub type array_size_type = u64;
        pub type array_difference_type = u64;
        pub type array_reverse_iterator = u8;
        pub type array_const_reverse_iterator = u8;
        #[repr(C)]
        #[derive(Copy, Clone)]
        pub struct vector {
            pub _address: u8,
        }
        pub type vector__Base = u8;
        pub type vector__Tp_alloc_type = u8;
        pub type vector__Alloc_traits = u8;
        pub type vector_value_type = u8;
        pub type vector_pointer = u8;
        pub type vector_const_pointer = u8;
        pub type vector_reference = u8;
        pub type vector_const_reference = u8;
        pub type vector_iterator = u8;
        pub type vector_const_iterator = u8;
        pub type vector_const_reverse_iterator = u8;
        pub type vector_reverse_iterator = u8;
        pub type vector_size_type = u64;
        pub type vector_difference_type = u64;
        pub type vector_allocator_type = u8;
        #[repr(C)]
        #[derive(Copy, Clone)]
        pub struct vector__Temporary_value {
            pub _address: u8,
        }
        #[repr(C)]
        #[repr(align(1))]
        #[derive(Copy, Clone)]
        pub union vector__Temporary_value__Storage {
            pub _bindgen_opaque_blob: u8,
        }
    }
    pub mod __gnu_cxx {
        #[allow(unused_imports)]
        use self::super::super::root;
    }
    pub mod aeron {
        #[allow(unused_imports)]
        use self::super::super::root;
        pub mod util {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            #[doc = " Callback to indicate an exception has occurred.\n\n This handler may be called in a context of noexcept so the handler can not safely throw.\n\n @param exception that has occurred."]
            pub type exception_handler_t = [u64; 4usize];
            pub const ExceptionCategory_EXCEPTION_CATEGORY_FATAL:
                root::aeron::util::ExceptionCategory = 0;
            pub const ExceptionCategory_EXCEPTION_CATEGORY_ERROR:
                root::aeron::util::ExceptionCategory = 1;
            pub const ExceptionCategory_EXCEPTION_CATEGORY_WARN:
                root::aeron::util::ExceptionCategory = 2;
            pub type ExceptionCategory = ::std::os::raw::c_long;
            #[repr(C)]
            pub struct SourcedException {
                pub _base: root::std::exception,
                pub m_where: root::std::string,
                pub m_what: root::std::string,
                pub m_category: root::aeron::util::ExceptionCategory,
            }
            #[test]
            fn bindgen_test_layout_SourcedException() {
                const UNINIT: ::std::mem::MaybeUninit<SourcedException> =
                    ::std::mem::MaybeUninit::uninit();
                let ptr = UNINIT.as_ptr();
                assert_eq!(
                    ::std::mem::size_of::<SourcedException>(),
                    80usize,
                    concat!("Size of: ", stringify!(SourcedException))
                );
                assert_eq!(
                    ::std::mem::align_of::<SourcedException>(),
                    8usize,
                    concat!("Alignment of ", stringify!(SourcedException))
                );
                assert_eq!(
                    unsafe { ::std::ptr::addr_of!((*ptr).m_where) as usize - ptr as usize },
                    8usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(SourcedException),
                        "::",
                        stringify!(m_where)
                    )
                );
                assert_eq!(
                    unsafe { ::std::ptr::addr_of!((*ptr).m_what) as usize - ptr as usize },
                    40usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(SourcedException),
                        "::",
                        stringify!(m_what)
                    )
                );
                assert_eq!(
                    unsafe { ::std::ptr::addr_of!((*ptr).m_category) as usize - ptr as usize },
                    72usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(SourcedException),
                        "::",
                        stringify!(m_category)
                    )
                );
            }
            #[repr(C)]
            pub struct IOException {
                pub _base: root::aeron::util::SourcedException,
            }
            #[test]
            fn bindgen_test_layout_IOException() {
                assert_eq!(
                    ::std::mem::size_of::<IOException>(),
                    80usize,
                    concat!("Size of: ", stringify!(IOException))
                );
                assert_eq!(
                    ::std::mem::align_of::<IOException>(),
                    8usize,
                    concat!("Alignment of ", stringify!(IOException))
                );
            }
            #[repr(C)]
            pub struct FormatException {
                pub _base: root::aeron::util::SourcedException,
            }
            #[test]
            fn bindgen_test_layout_FormatException() {
                assert_eq!(
                    ::std::mem::size_of::<FormatException>(),
                    80usize,
                    concat!("Size of: ", stringify!(FormatException))
                );
                assert_eq!(
                    ::std::mem::align_of::<FormatException>(),
                    8usize,
                    concat!("Alignment of ", stringify!(FormatException))
                );
            }
            #[repr(C)]
            pub struct OutOfBoundsException {
                pub _base: root::aeron::util::SourcedException,
            }
            #[test]
            fn bindgen_test_layout_OutOfBoundsException() {
                assert_eq!(
                    ::std::mem::size_of::<OutOfBoundsException>(),
                    80usize,
                    concat!("Size of: ", stringify!(OutOfBoundsException))
                );
                assert_eq!(
                    ::std::mem::align_of::<OutOfBoundsException>(),
                    8usize,
                    concat!("Alignment of ", stringify!(OutOfBoundsException))
                );
            }
            #[repr(C)]
            pub struct ParseException {
                pub _base: root::aeron::util::SourcedException,
            }
            #[test]
            fn bindgen_test_layout_ParseException() {
                assert_eq!(
                    ::std::mem::size_of::<ParseException>(),
                    80usize,
                    concat!("Size of: ", stringify!(ParseException))
                );
                assert_eq!(
                    ::std::mem::align_of::<ParseException>(),
                    8usize,
                    concat!("Alignment of ", stringify!(ParseException))
                );
            }
            #[repr(C)]
            pub struct ElementNotFound {
                pub _base: root::aeron::util::SourcedException,
            }
            #[test]
            fn bindgen_test_layout_ElementNotFound() {
                assert_eq!(
                    ::std::mem::size_of::<ElementNotFound>(),
                    80usize,
                    concat!("Size of: ", stringify!(ElementNotFound))
                );
                assert_eq!(
                    ::std::mem::align_of::<ElementNotFound>(),
                    8usize,
                    concat!("Alignment of ", stringify!(ElementNotFound))
                );
            }
            #[repr(C)]
            pub struct IllegalArgumentException {
                pub _base: root::aeron::util::SourcedException,
            }
            #[test]
            fn bindgen_test_layout_IllegalArgumentException() {
                assert_eq!(
                    ::std::mem::size_of::<IllegalArgumentException>(),
                    80usize,
                    concat!("Size of: ", stringify!(IllegalArgumentException))
                );
                assert_eq!(
                    ::std::mem::align_of::<IllegalArgumentException>(),
                    8usize,
                    concat!("Alignment of ", stringify!(IllegalArgumentException))
                );
            }
            #[repr(C)]
            pub struct IllegalStateException {
                pub _base: root::aeron::util::SourcedException,
            }
            #[test]
            fn bindgen_test_layout_IllegalStateException() {
                assert_eq!(
                    ::std::mem::size_of::<IllegalStateException>(),
                    80usize,
                    concat!("Size of: ", stringify!(IllegalStateException))
                );
                assert_eq!(
                    ::std::mem::align_of::<IllegalStateException>(),
                    8usize,
                    concat!("Alignment of ", stringify!(IllegalStateException))
                );
            }
            #[repr(C)]
            pub struct DriverTimeoutException {
                pub _base: root::aeron::util::SourcedException,
            }
            #[test]
            fn bindgen_test_layout_DriverTimeoutException() {
                assert_eq!(
                    ::std::mem::size_of::<DriverTimeoutException>(),
                    80usize,
                    concat!("Size of: ", stringify!(DriverTimeoutException))
                );
                assert_eq!(
                    ::std::mem::align_of::<DriverTimeoutException>(),
                    8usize,
                    concat!("Alignment of ", stringify!(DriverTimeoutException))
                );
            }
            #[repr(C)]
            pub struct ConductorServiceTimeoutException {
                pub _base: root::aeron::util::SourcedException,
            }
            #[test]
            fn bindgen_test_layout_ConductorServiceTimeoutException() {
                assert_eq!(
                    ::std::mem::size_of::<ConductorServiceTimeoutException>(),
                    80usize,
                    concat!("Size of: ", stringify!(ConductorServiceTimeoutException))
                );
                assert_eq!(
                    ::std::mem::align_of::<ConductorServiceTimeoutException>(),
                    8usize,
                    concat!(
                        "Alignment of ",
                        stringify!(ConductorServiceTimeoutException)
                    )
                );
            }
            #[repr(C)]
            pub struct ClientTimeoutException {
                pub _base: root::aeron::util::SourcedException,
            }
            #[test]
            fn bindgen_test_layout_ClientTimeoutException() {
                assert_eq!(
                    ::std::mem::size_of::<ClientTimeoutException>(),
                    80usize,
                    concat!("Size of: ", stringify!(ClientTimeoutException))
                );
                assert_eq!(
                    ::std::mem::align_of::<ClientTimeoutException>(),
                    8usize,
                    concat!("Alignment of ", stringify!(ClientTimeoutException))
                );
            }
            #[repr(C)]
            pub struct AeronException {
                pub _base: root::aeron::util::SourcedException,
            }
            #[test]
            fn bindgen_test_layout_AeronException() {
                assert_eq!(
                    ::std::mem::size_of::<AeronException>(),
                    80usize,
                    concat!("Size of: ", stringify!(AeronException))
                );
                assert_eq!(
                    ::std::mem::align_of::<AeronException>(),
                    8usize,
                    concat!("Alignment of ", stringify!(AeronException))
                );
            }
            #[repr(C)]
            pub struct UnknownSubscriptionException {
                pub _base: root::aeron::util::SourcedException,
            }
            #[test]
            fn bindgen_test_layout_UnknownSubscriptionException() {
                assert_eq!(
                    ::std::mem::size_of::<UnknownSubscriptionException>(),
                    80usize,
                    concat!("Size of: ", stringify!(UnknownSubscriptionException))
                );
                assert_eq!(
                    ::std::mem::align_of::<UnknownSubscriptionException>(),
                    8usize,
                    concat!("Alignment of ", stringify!(UnknownSubscriptionException))
                );
            }
            #[repr(C)]
            pub struct ReentrantException {
                pub _base: root::aeron::util::SourcedException,
            }
            #[test]
            fn bindgen_test_layout_ReentrantException() {
                assert_eq!(
                    ::std::mem::size_of::<ReentrantException>(),
                    80usize,
                    concat!("Size of: ", stringify!(ReentrantException))
                );
                assert_eq!(
                    ::std::mem::align_of::<ReentrantException>(),
                    8usize,
                    concat!("Alignment of ", stringify!(ReentrantException))
                );
            }
            #[repr(C)]
            pub struct UnsupportedOperationException {
                pub _base: root::aeron::util::SourcedException,
            }
            #[test]
            fn bindgen_test_layout_UnsupportedOperationException() {
                assert_eq!(
                    ::std::mem::size_of::<UnsupportedOperationException>(),
                    80usize,
                    concat!("Size of: ", stringify!(UnsupportedOperationException))
                );
                assert_eq!(
                    ::std::mem::align_of::<UnsupportedOperationException>(),
                    8usize,
                    concat!("Alignment of ", stringify!(UnsupportedOperationException))
                );
            }
            #[repr(C)]
            pub struct RegistrationException {
                pub _base: root::aeron::util::SourcedException,
                pub m_errorCode: ::std::os::raw::c_int,
            }
            #[test]
            fn bindgen_test_layout_RegistrationException() {
                const UNINIT: ::std::mem::MaybeUninit<RegistrationException> =
                    ::std::mem::MaybeUninit::uninit();
                let ptr = UNINIT.as_ptr();
                assert_eq!(
                    ::std::mem::size_of::<RegistrationException>(),
                    88usize,
                    concat!("Size of: ", stringify!(RegistrationException))
                );
                assert_eq!(
                    ::std::mem::align_of::<RegistrationException>(),
                    8usize,
                    concat!("Alignment of ", stringify!(RegistrationException))
                );
                assert_eq!(
                    unsafe { ::std::ptr::addr_of!((*ptr).m_errorCode) as usize - ptr as usize },
                    80usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(RegistrationException),
                        "::",
                        stringify!(m_errorCode)
                    )
                );
            }
            #[repr(C)]
            pub struct TimeoutException {
                pub _base: root::aeron::util::AeronException,
            }
            #[test]
            fn bindgen_test_layout_TimeoutException() {
                assert_eq!(
                    ::std::mem::size_of::<TimeoutException>(),
                    80usize,
                    concat!("Size of: ", stringify!(TimeoutException))
                );
                assert_eq!(
                    ::std::mem::align_of::<TimeoutException>(),
                    8usize,
                    concat!("Alignment of ", stringify!(TimeoutException))
                );
            }
            #[repr(C)]
            pub struct ChannelEndpointException {
                pub _base: root::aeron::util::AeronException,
                pub m_statusIndicatorCounterId: ::std::os::raw::c_int,
            }
            #[test]
            fn bindgen_test_layout_ChannelEndpointException() {
                const UNINIT: ::std::mem::MaybeUninit<ChannelEndpointException> =
                    ::std::mem::MaybeUninit::uninit();
                let ptr = UNINIT.as_ptr();
                assert_eq!(
                    ::std::mem::size_of::<ChannelEndpointException>(),
                    88usize,
                    concat!("Size of: ", stringify!(ChannelEndpointException))
                );
                assert_eq!(
                    ::std::mem::align_of::<ChannelEndpointException>(),
                    8usize,
                    concat!("Alignment of ", stringify!(ChannelEndpointException))
                );
                assert_eq!(
                    unsafe {
                        ::std::ptr::addr_of!((*ptr).m_statusIndicatorCounterId) as usize
                            - ptr as usize
                    },
                    80usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(ChannelEndpointException),
                        "::",
                        stringify!(m_statusIndicatorCounterId)
                    )
                );
            }
            #[repr(C)]
            pub struct OnScopeExit {
                pub m_holder: u64,
            }
            #[repr(C)]
            pub struct OnScopeExit_FuncHolderBase__bindgen_vtable(::std::os::raw::c_void);
            #[repr(C)]
            pub struct OnScopeExit_FuncHolderBase {
                pub vtable_: *const OnScopeExit_FuncHolderBase__bindgen_vtable,
            }
            #[test]
            fn bindgen_test_layout_OnScopeExit_FuncHolderBase() {
                assert_eq!(
                    ::std::mem::size_of::<OnScopeExit_FuncHolderBase>(),
                    8usize,
                    concat!("Size of: ", stringify!(OnScopeExit_FuncHolderBase))
                );
                assert_eq!(
                    ::std::mem::align_of::<OnScopeExit_FuncHolderBase>(),
                    8usize,
                    concat!("Alignment of ", stringify!(OnScopeExit_FuncHolderBase))
                );
            }
            #[repr(C)]
            pub struct OnScopeExit_FuncHolder<func_t> {
                pub _base: root::aeron::util::OnScopeExit_FuncHolderBase,
                pub f: func_t,
                pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<func_t>>,
            }
            #[test]
            fn bindgen_test_layout_OnScopeExit() {
                const UNINIT: ::std::mem::MaybeUninit<OnScopeExit> =
                    ::std::mem::MaybeUninit::uninit();
                let ptr = UNINIT.as_ptr();
                assert_eq!(
                    ::std::mem::size_of::<OnScopeExit>(),
                    8usize,
                    concat!("Size of: ", stringify!(OnScopeExit))
                );
                assert_eq!(
                    ::std::mem::align_of::<OnScopeExit>(),
                    8usize,
                    concat!("Alignment of ", stringify!(OnScopeExit))
                );
                assert_eq!(
                    unsafe { ::std::ptr::addr_of!((*ptr).m_holder) as usize - ptr as usize },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(OnScopeExit),
                        "::",
                        stringify!(m_holder)
                    )
                );
            }
            #[repr(C)]
            pub struct CallbackGuard {
                pub m_isInCallback: *mut bool,
            }
            #[test]
            fn bindgen_test_layout_CallbackGuard() {
                const UNINIT: ::std::mem::MaybeUninit<CallbackGuard> =
                    ::std::mem::MaybeUninit::uninit();
                let ptr = UNINIT.as_ptr();
                assert_eq!(
                    ::std::mem::size_of::<CallbackGuard>(),
                    8usize,
                    concat!("Size of: ", stringify!(CallbackGuard))
                );
                assert_eq!(
                    ::std::mem::align_of::<CallbackGuard>(),
                    8usize,
                    concat!("Alignment of ", stringify!(CallbackGuard))
                );
                assert_eq!(
                    unsafe { ::std::ptr::addr_of!((*ptr).m_isInCallback) as usize - ptr as usize },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(CallbackGuard),
                        "::",
                        stringify!(m_isInCallback)
                    )
                );
            }
            #[doc = " a 32-bit signed int that is used for lengths and offsets to be compatible with Java's 32-bit int."]
            pub type index_t = ::std::os::raw::c_int;
        }
        pub mod concurrent {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            pub mod atomic {
                #[allow(unused_imports)]
                use self::super::super::super::super::root;
            }
            #[doc = " Wraps, but does not own, a buffer of memory for providing atomic operations. This is for providing a view."]
            #[repr(C)]
            #[derive(Copy, Clone)]
            pub struct AtomicBuffer {
                pub m_buffer: *mut ::std::os::raw::c_uchar,
                pub m_length: root::aeron::concurrent::AtomicBuffer_length_t,
            }
            pub type AtomicBuffer_length_t = ::std::os::raw::c_uint;
            #[test]
            fn bindgen_test_layout_AtomicBuffer() {
                const UNINIT: ::std::mem::MaybeUninit<AtomicBuffer> =
                    ::std::mem::MaybeUninit::uninit();
                let ptr = UNINIT.as_ptr();
                assert_eq!(
                    ::std::mem::size_of::<AtomicBuffer>(),
                    16usize,
                    concat!("Size of: ", stringify!(AtomicBuffer))
                );
                assert_eq!(
                    ::std::mem::align_of::<AtomicBuffer>(),
                    8usize,
                    concat!("Alignment of ", stringify!(AtomicBuffer))
                );
                assert_eq!(
                    unsafe { ::std::ptr::addr_of!((*ptr).m_buffer) as usize - ptr as usize },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(AtomicBuffer),
                        "::",
                        stringify!(m_buffer)
                    )
                );
                assert_eq!(
                    unsafe { ::std::ptr::addr_of!((*ptr).m_length) as usize - ptr as usize },
                    8usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(AtomicBuffer),
                        "::",
                        stringify!(m_length)
                    )
                );
            }
            pub mod logbuffer {
                #[allow(unused_imports)]
                use self::super::super::super::super::root;
                pub mod DataFrameHeader {
                    #[allow(unused_imports)]
                    use self::super::super::super::super::super::root;
                }
                #[doc = " Represents the header of the data frame for accessing meta data fields."]
                #[repr(C)]
                #[derive(Copy, Clone)]
                pub struct Header {
                    pub m_header: *mut root::aeron_header_t,
                    pub m_headerValues: root::aeron_header_values_t,
                    pub m_context: *mut ::std::os::raw::c_void,
                }
                #[test]
                fn bindgen_test_layout_Header() {
                    const UNINIT: ::std::mem::MaybeUninit<Header> =
                        ::std::mem::MaybeUninit::uninit();
                    let ptr = UNINIT.as_ptr();
                    assert_eq!(
                        ::std::mem::size_of::<Header>(),
                        64usize,
                        concat!("Size of: ", stringify!(Header))
                    );
                    assert_eq!(
                        ::std::mem::align_of::<Header>(),
                        8usize,
                        concat!("Alignment of ", stringify!(Header))
                    );
                    assert_eq!(
                        unsafe { ::std::ptr::addr_of!((*ptr).m_header) as usize - ptr as usize },
                        0usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(Header),
                            "::",
                            stringify!(m_header)
                        )
                    );
                    assert_eq!(
                        unsafe {
                            ::std::ptr::addr_of!((*ptr).m_headerValues) as usize - ptr as usize
                        },
                        8usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(Header),
                            "::",
                            stringify!(m_headerValues)
                        )
                    );
                    assert_eq!(
                        unsafe { ::std::ptr::addr_of!((*ptr).m_context) as usize - ptr as usize },
                        56usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(Header),
                            "::",
                            stringify!(m_context)
                        )
                    );
                }
                #[doc = " Callback for handling fragments of data being read from a log.\n\n Handler for reading data that is coming from a log buffer. The frame will either contain a whole message\n or a fragment of a message to be reassembled. Messages are fragmented if greater than the frame for MTU in length.\n\n @param buffer containing the data.\n @param offset at which the data begins.\n @param length of the data in bytes.\n @param header representing the meta data for the data."]
                pub type fragment_handler_t = u8;
                #[doc = " Represents a claimed range in a buffer to be used for recording a message without copy semantics for later commit.\n <p>\n The claimed space is in {@link #buffer()} between {@link #offset()} and {@link #offset()} + {@link #length()}.\n When the buffer is filled with message data, use {@link #commit()} to make it available to subscribers."]
                #[repr(C)]
                #[derive(Copy, Clone)]
                pub struct BufferClaim {
                    pub m_buffer: root::aeron::concurrent::AtomicBuffer,
                }
                #[test]
                fn bindgen_test_layout_BufferClaim() {
                    const UNINIT: ::std::mem::MaybeUninit<BufferClaim> =
                        ::std::mem::MaybeUninit::uninit();
                    let ptr = UNINIT.as_ptr();
                    assert_eq!(
                        ::std::mem::size_of::<BufferClaim>(),
                        16usize,
                        concat!("Size of: ", stringify!(BufferClaim))
                    );
                    assert_eq!(
                        ::std::mem::align_of::<BufferClaim>(),
                        8usize,
                        concat!("Alignment of ", stringify!(BufferClaim))
                    );
                    assert_eq!(
                        unsafe { ::std::ptr::addr_of!((*ptr).m_buffer) as usize - ptr as usize },
                        0usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(BufferClaim),
                            "::",
                            stringify!(m_buffer)
                        )
                    );
                }
            }
            #[repr(C)]
            pub struct AgentRunner<Agent, IdleStrategy> {
                pub m_agent: *mut Agent,
                pub m_idleStrategy: *mut IdleStrategy,
                pub m_exceptionHandler: *mut root::aeron::util::exception_handler_t,
                pub m_isStarted: u8,
                pub m_isRunning: u8,
                pub m_isClosed: u8,
                pub m_thread: root::std::thread,
                pub m_name: root::std::string,
                pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<Agent>>,
                pub _phantom_1: ::std::marker::PhantomData<::std::cell::UnsafeCell<IdleStrategy>>,
            }
            #[repr(C)]
            #[derive(Copy, Clone)]
            pub struct AgentInvoker<Agent> {
                pub m_agent: *mut Agent,
                pub m_exceptionHandler: *mut root::aeron::util::exception_handler_t,
                pub m_isStarted: bool,
                pub m_isRunning: bool,
                pub m_isClosed: bool,
                pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<Agent>>,
            }
            #[doc = " Reads the counters metadata and values buffers.\n\n This class is threadsafe.\n\n <b>Values Buffer</b>\n <pre>\n   0                   1                   2                   3\n   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n  |                        Counter Value                          |\n  |                                                               |\n  +---------------------------------------------------------------+\n  |                       Registration Id                         |\n  |                                                               |\n  +---------------------------------------------------------------+\n  |                          Owner Id                             |\n  |                                                               |\n  +---------------------------------------------------------------+\n  |                     104 bytes of padding                     ...\n ...                                                              |\n  +---------------------------------------------------------------+\n  |                   Repeats to end of buffer                   ...\n  |                                                               |\n ...                                                              |\n  +---------------------------------------------------------------+\n </pre>\n\n <b>Meta Data Buffer</b>\n <pre>\n   0                   1                   2                   3\n   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n  |                        Record State                           |\n  +---------------------------------------------------------------+\n  |                          Type Id                              |\n  +---------------------------------------------------------------+\n  |                  Free-for-reuse Deadline (ms)                 |\n  |                                                               |\n  +---------------------------------------------------------------+\n  |                      112 bytes for key                       ...\n ...                                                              |\n  +-+-------------------------------------------------------------+\n  |R|                      Label Length                           |\n  +-+-------------------------------------------------------------+\n  |                  380 bytes of Label in ASCII                 ...\n ...                                                              |\n  +---------------------------------------------------------------+\n  |                   Repeats to end of buffer                   ...\n  |                                                               |\n ...                                                              |\n  +---------------------------------------------------------------+\n </pre>"]
            pub type on_counters_metadata_t = u8;
            #[repr(C)]
            #[derive(Copy, Clone)]
            pub struct CountersReader {
                pub m_countersReader: *mut root::aeron_counters_reader_t,
                pub m_buffers: root::aeron_counters_reader_buffers_t,
            }
            pub const CountersReader_NULL_COUNTER_ID: ::std::os::raw::c_int = -1;
            pub const CountersReader_RECORD_UNUSED: ::std::os::raw::c_int = 0;
            pub const CountersReader_RECORD_ALLOCATED: ::std::os::raw::c_int = 1;
            pub const CountersReader_RECORD_RECLAIMED: ::std::os::raw::c_int = -1;
            pub const CountersReader_DEFAULT_REGISTRATION_ID: ::std::os::raw::c_long = 0;
            pub const CountersReader_NOT_FREE_TO_REUSE: ::std::os::raw::c_long =
                9223372036854775807;
            extern "C" {
                #[link_name = "\u{1}_ZN5aeron10concurrent14CountersReader14COUNTER_LENGTHE"]
                pub static CountersReader_COUNTER_LENGTH: root::aeron::util::index_t;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN5aeron10concurrent14CountersReader22REGISTRATION_ID_OFFSETE"]
                pub static CountersReader_REGISTRATION_ID_OFFSET: root::aeron::util::index_t;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN5aeron10concurrent14CountersReader15METADATA_LENGTHE"]
                pub static CountersReader_METADATA_LENGTH: root::aeron::util::index_t;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN5aeron10concurrent14CountersReader14TYPE_ID_OFFSETE"]
                pub static CountersReader_TYPE_ID_OFFSET: root::aeron::util::index_t;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN5aeron10concurrent14CountersReader30FREE_FOR_REUSE_DEADLINE_OFFSETE"]
                pub static CountersReader_FREE_FOR_REUSE_DEADLINE_OFFSET:
                    root::aeron::util::index_t;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN5aeron10concurrent14CountersReader10KEY_OFFSETE"]
                pub static CountersReader_KEY_OFFSET: root::aeron::util::index_t;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN5aeron10concurrent14CountersReader19LABEL_LENGTH_OFFSETE"]
                pub static CountersReader_LABEL_LENGTH_OFFSET: root::aeron::util::index_t;
            }
            pub const CountersReader_MAX_LABEL_LENGTH: ::std::os::raw::c_int = 380;
            pub const CountersReader_MAX_KEY_LENGTH: ::std::os::raw::c_int = 112;
            #[test]
            fn bindgen_test_layout_CountersReader() {
                const UNINIT: ::std::mem::MaybeUninit<CountersReader> =
                    ::std::mem::MaybeUninit::uninit();
                let ptr = UNINIT.as_ptr();
                assert_eq!(
                    ::std::mem::size_of::<CountersReader>(),
                    40usize,
                    concat!("Size of: ", stringify!(CountersReader))
                );
                assert_eq!(
                    ::std::mem::align_of::<CountersReader>(),
                    8usize,
                    concat!("Alignment of ", stringify!(CountersReader))
                );
                assert_eq!(
                    unsafe {
                        ::std::ptr::addr_of!((*ptr).m_countersReader) as usize - ptr as usize
                    },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(CountersReader),
                        "::",
                        stringify!(m_countersReader)
                    )
                );
                assert_eq!(
                    unsafe { ::std::ptr::addr_of!((*ptr).m_buffers) as usize - ptr as usize },
                    8usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(CountersReader),
                        "::",
                        stringify!(m_buffers)
                    )
                );
            }
            pub mod status {
                #[allow(unused_imports)]
                use self::super::super::super::super::root;
                #[repr(C)]
                #[derive(Copy, Clone)]
                pub struct ReadablePosition<X> {
                    pub m_impl: X,
                    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<X>>,
                }
                #[repr(C)]
                #[derive(Copy, Clone)]
                pub struct Position<X> {
                    pub _base: root::aeron::concurrent::status::ReadablePosition<X>,
                    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<X>>,
                }
                #[repr(C)]
                #[derive(Copy, Clone)]
                pub struct UnsafeBufferPosition {
                    pub m_buffer: root::aeron::concurrent::AtomicBuffer,
                    pub m_id: ::std::os::raw::c_int,
                    pub m_offset: ::std::os::raw::c_int,
                }
                #[test]
                fn bindgen_test_layout_UnsafeBufferPosition() {
                    const UNINIT: ::std::mem::MaybeUninit<UnsafeBufferPosition> =
                        ::std::mem::MaybeUninit::uninit();
                    let ptr = UNINIT.as_ptr();
                    assert_eq!(
                        ::std::mem::size_of::<UnsafeBufferPosition>(),
                        24usize,
                        concat!("Size of: ", stringify!(UnsafeBufferPosition))
                    );
                    assert_eq!(
                        ::std::mem::align_of::<UnsafeBufferPosition>(),
                        8usize,
                        concat!("Alignment of ", stringify!(UnsafeBufferPosition))
                    );
                    assert_eq!(
                        unsafe { ::std::ptr::addr_of!((*ptr).m_buffer) as usize - ptr as usize },
                        0usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(UnsafeBufferPosition),
                            "::",
                            stringify!(m_buffer)
                        )
                    );
                    assert_eq!(
                        unsafe { ::std::ptr::addr_of!((*ptr).m_id) as usize - ptr as usize },
                        16usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(UnsafeBufferPosition),
                            "::",
                            stringify!(m_id)
                        )
                    );
                    assert_eq!(
                        unsafe { ::std::ptr::addr_of!((*ptr).m_offset) as usize - ptr as usize },
                        20usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(UnsafeBufferPosition),
                            "::",
                            stringify!(m_offset)
                        )
                    );
                }
                #[repr(C)]
                #[derive(Copy, Clone)]
                pub struct StatusIndicatorReader {
                    pub m_staticBuffer: [u8; 8usize],
                    pub m_buffer: root::aeron::concurrent::AtomicBuffer,
                    pub m_id: ::std::os::raw::c_int,
                    pub m_offset: ::std::os::raw::c_int,
                }
                #[test]
                fn bindgen_test_layout_StatusIndicatorReader() {
                    const UNINIT: ::std::mem::MaybeUninit<StatusIndicatorReader> =
                        ::std::mem::MaybeUninit::uninit();
                    let ptr = UNINIT.as_ptr();
                    assert_eq!(
                        ::std::mem::size_of::<StatusIndicatorReader>(),
                        32usize,
                        concat!("Size of: ", stringify!(StatusIndicatorReader))
                    );
                    assert_eq!(
                        ::std::mem::align_of::<StatusIndicatorReader>(),
                        8usize,
                        concat!("Alignment of ", stringify!(StatusIndicatorReader))
                    );
                    assert_eq!(
                        unsafe {
                            ::std::ptr::addr_of!((*ptr).m_staticBuffer) as usize - ptr as usize
                        },
                        0usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(StatusIndicatorReader),
                            "::",
                            stringify!(m_staticBuffer)
                        )
                    );
                    assert_eq!(
                        unsafe { ::std::ptr::addr_of!((*ptr).m_buffer) as usize - ptr as usize },
                        8usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(StatusIndicatorReader),
                            "::",
                            stringify!(m_buffer)
                        )
                    );
                    assert_eq!(
                        unsafe { ::std::ptr::addr_of!((*ptr).m_id) as usize - ptr as usize },
                        24usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(StatusIndicatorReader),
                            "::",
                            stringify!(m_id)
                        )
                    );
                    assert_eq!(
                        unsafe { ::std::ptr::addr_of!((*ptr).m_offset) as usize - ptr as usize },
                        28usize,
                        concat!(
                            "Offset of field: ",
                            stringify!(StatusIndicatorReader),
                            "::",
                            stringify!(m_offset)
                        )
                    );
                }
            }
            #[repr(C)]
            pub struct AtomicCounter {
                pub m_counter: *mut root::aeron_counter_t,
                pub m_ptr: *mut ::std::os::raw::c_long,
                pub m_constants: root::aeron_counter_constants_t,
            }
            #[test]
            fn bindgen_test_layout_AtomicCounter() {
                const UNINIT: ::std::mem::MaybeUninit<AtomicCounter> =
                    ::std::mem::MaybeUninit::uninit();
                let ptr = UNINIT.as_ptr();
                assert_eq!(
                    ::std::mem::size_of::<AtomicCounter>(),
                    32usize,
                    concat!("Size of: ", stringify!(AtomicCounter))
                );
                assert_eq!(
                    ::std::mem::align_of::<AtomicCounter>(),
                    8usize,
                    concat!("Alignment of ", stringify!(AtomicCounter))
                );
                assert_eq!(
                    unsafe { ::std::ptr::addr_of!((*ptr).m_counter) as usize - ptr as usize },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(AtomicCounter),
                        "::",
                        stringify!(m_counter)
                    )
                );
                assert_eq!(
                    unsafe { ::std::ptr::addr_of!((*ptr).m_ptr) as usize - ptr as usize },
                    8usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(AtomicCounter),
                        "::",
                        stringify!(m_ptr)
                    )
                );
                assert_eq!(
                    unsafe { ::std::ptr::addr_of!((*ptr).m_constants) as usize - ptr as usize },
                    16usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(AtomicCounter),
                        "::",
                        stringify!(m_constants)
                    )
                );
            }
        }
        #[doc = " Supplies the reserved value field for a data frame header. The returned value will be set in the header as\n Little Endian format.\n\n This will be called as the last action of encoding a data frame right before the length is set. All other fields\n in the header plus the body of the frame will have been written at the point of supply.\n\n @param termBuffer for the message\n @param termOffset of the start of the message\n @param length of the message in bytes"]
        pub type on_reserved_value_supplier_t = [u64; 4usize];
        pub type AsyncDestination = root::aeron_async_destination_t;
        #[doc = " @example BasicPublisher.cpp\n/\n/**\n Aeron Publisher API for sending messages to subscribers of a given channel and streamId pair. Publishers\n are created via an {@link Aeron} object, and messages are sent via an offer method or a claim and commit\n method combination.\n <p>\n The APIs for tryClaim and offer are non-blocking and threadsafe.\n <p>\n Note: Publication instances are threadsafe and can be shared between publisher threads.\n @see Aeron#addPublication\n @see Aeron#findPublication"]
        #[repr(C)]
        pub struct Publication {
            pub m_aeron: *mut root::aeron_t,
            pub m_publication: *mut root::aeron_publication_t,
            pub m_constants: root::aeron_publication_constants_t,
            pub m_channel: root::std::string,
            pub m_pendingDestinations: [u64; 7usize],
            pub m_adminLock: root::std::recursive_mutex,
        }
        #[test]
        fn bindgen_test_layout_Publication() {
            const UNINIT: ::std::mem::MaybeUninit<Publication> = ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<Publication>(),
                232usize,
                concat!("Size of: ", stringify!(Publication))
            );
            assert_eq!(
                ::std::mem::align_of::<Publication>(),
                8usize,
                concat!("Alignment of ", stringify!(Publication))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_aeron) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Publication),
                    "::",
                    stringify!(m_aeron)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_publication) as usize - ptr as usize },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Publication),
                    "::",
                    stringify!(m_publication)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_constants) as usize - ptr as usize },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Publication),
                    "::",
                    stringify!(m_constants)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_channel) as usize - ptr as usize },
                104usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Publication),
                    "::",
                    stringify!(m_channel)
                )
            );
            assert_eq!(
                unsafe {
                    ::std::ptr::addr_of!((*ptr).m_pendingDestinations) as usize - ptr as usize
                },
                136usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Publication),
                    "::",
                    stringify!(m_pendingDestinations)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_adminLock) as usize - ptr as usize },
                192usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Publication),
                    "::",
                    stringify!(m_adminLock)
                )
            );
        }
        #[doc = " Aeron Publisher API for sending messages to subscribers of a given channel and streamId pair. ExclusivePublications\n each get their own session id so multiple can be concurrently active on the same media driver as independent streams.\n\n {@link ExclusivePublication}s are created via the {@link Aeron#addExclusivePublication(String, int)} method,\n and messages are sent via one of the {@link #offer(DirectBuffer)} methods, or a\n {@link #tryClaim(int, ExclusiveBufferClaim)} and {@link ExclusiveBufferClaim#commit()} method combination.\n\n {@link ExclusivePublication}s have the potential to provide greater throughput than {@link Publication}s.\n\n The APIs tryClaim and offer are non-blocking.\n\n <b>Note:</b> ExclusivePublication instances are NOT threadsafe for offer and try claim methods but are for others.\n\n @see Aeron#addExclusivePublication(String, int)\n @see BufferClaim"]
        #[repr(C)]
        pub struct ExclusivePublication {
            #[doc = " @endcond"]
            pub m_aeron: *mut root::aeron_t,
            pub m_publication: *mut root::aeron_exclusive_publication_t,
            pub m_constants: root::aeron_publication_constants_t,
            pub m_channel: root::std::string,
            pub m_pendingDestinations: [u64; 7usize],
            pub m_adminLock: root::std::recursive_mutex,
        }
        #[test]
        fn bindgen_test_layout_ExclusivePublication() {
            const UNINIT: ::std::mem::MaybeUninit<ExclusivePublication> =
                ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<ExclusivePublication>(),
                232usize,
                concat!("Size of: ", stringify!(ExclusivePublication))
            );
            assert_eq!(
                ::std::mem::align_of::<ExclusivePublication>(),
                8usize,
                concat!("Alignment of ", stringify!(ExclusivePublication))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_aeron) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ExclusivePublication),
                    "::",
                    stringify!(m_aeron)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_publication) as usize - ptr as usize },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ExclusivePublication),
                    "::",
                    stringify!(m_publication)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_constants) as usize - ptr as usize },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ExclusivePublication),
                    "::",
                    stringify!(m_constants)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_channel) as usize - ptr as usize },
                104usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ExclusivePublication),
                    "::",
                    stringify!(m_channel)
                )
            );
            assert_eq!(
                unsafe {
                    ::std::ptr::addr_of!((*ptr).m_pendingDestinations) as usize - ptr as usize
                },
                136usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ExclusivePublication),
                    "::",
                    stringify!(m_pendingDestinations)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_adminLock) as usize - ptr as usize },
                192usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ExclusivePublication),
                    "::",
                    stringify!(m_adminLock)
                )
            );
        }
        extern "C" {
            #[doc = " Get the status for the channel of this {@link Publication}\n\n @return status code for this channel"]
            #[link_name = "\u{1}_ZNK5aeron20ExclusivePublication13channelStatusEv"]
            pub fn ExclusivePublication_channelStatus(
                this: *const root::aeron::ExclusivePublication,
            ) -> ::std::os::raw::c_long;
        }
        impl ExclusivePublication {
            #[inline]
            pub unsafe fn channelStatus(&self) -> ::std::os::raw::c_long {
                ExclusivePublication_channelStatus(self)
            }
        }
        #[doc = " Abort the current polling operation and do not advance the position for this fragment."]
        pub const ControlledPollAction_ABORT: root::aeron::ControlledPollAction = 1;
        #[doc = " Break from the current polling operation and commit the position as of the end of the current fragment\n being handled."]
        pub const ControlledPollAction_BREAK: root::aeron::ControlledPollAction = 2;
        #[doc = " Continue processing but commit the position as of the end of the current fragment so that\n flow control is applied to this point."]
        pub const ControlledPollAction_COMMIT: root::aeron::ControlledPollAction = 3;
        #[doc = " Continue processing taking the same approach as the in fragment_handler_t."]
        pub const ControlledPollAction_CONTINUE: root::aeron::ControlledPollAction = 4;
        pub type ControlledPollAction = ::std::os::raw::c_int;
        #[doc = " Callback for handling fragments of data being read from a log.\n\n @param buffer containing the data.\n @param offset at which the data begins.\n @param length of the data in bytes.\n @param header representing the meta data for the data.\n @return The action to be taken with regard to the stream position after the callback."]
        pub type controlled_poll_fragment_handler_t = u8;
        #[doc = " Represents a replicated publication {@link Image} from a publisher to a {@link Subscription}.\n Each {@link Image} identifies a source publisher by session id.\n\n Is an overlay on the LogBuffers and Position. So, can be effectively copied and moved."]
        #[repr(C)]
        pub struct Image {
            pub m_subscription: *mut root::aeron_subscription_t,
            pub m_image: *mut root::aeron_image_t,
            pub m_constants: root::aeron_image_constants_t,
            pub m_sourceIdentity: root::std::string,
        }
        pub type Image_list_t = [u64; 3usize];
        pub type Image_array_t = *mut [u64; 2usize];
        #[test]
        fn bindgen_test_layout_Image() {
            const UNINIT: ::std::mem::MaybeUninit<Image> = ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<Image>(),
                120usize,
                concat!("Size of: ", stringify!(Image))
            );
            assert_eq!(
                ::std::mem::align_of::<Image>(),
                8usize,
                concat!("Alignment of ", stringify!(Image))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_subscription) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Image),
                    "::",
                    stringify!(m_subscription)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_image) as usize - ptr as usize },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Image),
                    "::",
                    stringify!(m_image)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_constants) as usize - ptr as usize },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Image),
                    "::",
                    stringify!(m_constants)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_sourceIdentity) as usize - ptr as usize },
                88usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Image),
                    "::",
                    stringify!(m_sourceIdentity)
                )
            );
        }
        #[doc = " Function called by Aeron to deliver notification of an available image.\n\n The Image passed may not be the image used internally, but may be copied or moved freely.\n\n Implementations should do the minimum work for passing off state to another thread for later processing\n and should not make a reentrant call back into the Aeron instance.\n\n @param image that has become available."]
        pub type on_available_image_t = [u64; 4usize];
        #[doc = " Function called by Aeron to deliver notification that an Image has become unavailable for polling.\n\n The Image passed is not guaranteed to be valid after the callback.\n\n Implementations should do the minimum work for passing off state to another thread for later processing\n and should not make a reentrant call back into the Aeron instance.\n\n @param image that has become unavailable"]
        pub type on_unavailable_image_t = [u64; 4usize];
        #[doc = " Function called by Aeron to deliver notification that the media driver has added a Publication successfully.\n\n Implementations should do the minimum work for passing off state to another thread for later processing\n and should not make a reentrant call back into the Aeron instance.\n\n @param channel of the Publication\n @param streamId within the channel of the Publication\n @param sessionId of the Publication\n @param correlationId used by the Publication for adding. Aka the registrationId returned by Aeron::addPublication"]
        pub type on_new_publication_t = [u64; 4usize];
        #[doc = " Function called by Aeron to deliver notification that the media driver has added a Subscription successfully.\n\n Implementations should do the minimum work for passing off state to another thread for later processing\n and should not make a reentrant call back into the Aeron instance.\n\n @param channel of the Subscription\n @param streamId within the channel of the Subscription\n @param correlationId used by the Subscription for adding. Aka the registrationId returned by Aeron::addSubscription"]
        pub type on_new_subscription_t = [u64; 4usize];
        #[doc = " Function called by Aeron to deliver notification of a Counter being available.\n\n Implementations should do the minimum work for passing off state to another thread for later processing\n and should not make a reentrant call back into the Aeron instance.\n\n @param countersReader for more detail on the counter.\n @param registrationId for the counter.\n @param counterId      that is available."]
        pub type on_available_counter_t = [u64; 4usize];
        #[doc = " Function called by Aeron to deliver notification of counter being removed.\n\n Implementations should do the minimum work for passing off state to another thread for later processing\n and should not make a reentrant call back into the Aeron instance.\n\n @param countersReader for more counter details.\n @param registrationId for the counter.\n @param counterId      that is unavailable."]
        pub type on_unavailable_counter_t = [u64; 4usize];
        #[doc = " Function called when the Aeron client is closed to notify that the client or any of it associated resources\n should not be used after this event."]
        pub type on_close_client_t = [u64; 4usize];
        #[doc = " This class provides configuration for the {@link Aeron} class via the {@link Aeron::Aeron} or {@link Aeron::connect}\n methods and its overloads. It gives applications some control over the interactions with the Aeron Media Driver.\n It can also set up error handling as well as application callbacks for connection information from the\n Media Driver."]
        #[repr(C)]
        #[derive(Copy, Clone)]
        pub struct Context {
            pub m_context: *mut root::aeron_context_t,
            pub m_onAvailableImageHandler: root::aeron::on_available_image_t,
            pub m_onUnavailableImageHandler: root::aeron::on_unavailable_image_t,
            pub m_exceptionHandler: root::aeron::util::exception_handler_t,
            pub m_onNewPublicationHandler: root::aeron::on_new_publication_t,
            pub m_isOnNewExclusivePublicationHandlerSet: bool,
            pub m_onNewExclusivePublicationHandler: root::aeron::on_new_publication_t,
            pub m_onNewSubscriptionHandler: root::aeron::on_new_subscription_t,
            pub m_onAvailableCounterHandler: root::aeron::on_available_counter_t,
            pub m_onUnavailableCounterHandler: root::aeron::on_unavailable_counter_t,
            pub m_onCloseClientHandler: root::aeron::on_close_client_t,
        }
        #[test]
        fn bindgen_test_layout_Context() {
            const UNINIT: ::std::mem::MaybeUninit<Context> = ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<Context>(),
                304usize,
                concat!("Size of: ", stringify!(Context))
            );
            assert_eq!(
                ::std::mem::align_of::<Context>(),
                8usize,
                concat!("Alignment of ", stringify!(Context))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_context) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Context),
                    "::",
                    stringify!(m_context)
                )
            );
            assert_eq!(
                unsafe {
                    ::std::ptr::addr_of!((*ptr).m_onAvailableImageHandler) as usize - ptr as usize
                },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Context),
                    "::",
                    stringify!(m_onAvailableImageHandler)
                )
            );
            assert_eq!(
                unsafe {
                    ::std::ptr::addr_of!((*ptr).m_onUnavailableImageHandler) as usize - ptr as usize
                },
                40usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Context),
                    "::",
                    stringify!(m_onUnavailableImageHandler)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_exceptionHandler) as usize - ptr as usize },
                72usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Context),
                    "::",
                    stringify!(m_exceptionHandler)
                )
            );
            assert_eq!(
                unsafe {
                    ::std::ptr::addr_of!((*ptr).m_onNewPublicationHandler) as usize - ptr as usize
                },
                104usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Context),
                    "::",
                    stringify!(m_onNewPublicationHandler)
                )
            );
            assert_eq!(
                unsafe {
                    ::std::ptr::addr_of!((*ptr).m_isOnNewExclusivePublicationHandlerSet) as usize
                        - ptr as usize
                },
                136usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Context),
                    "::",
                    stringify!(m_isOnNewExclusivePublicationHandlerSet)
                )
            );
            assert_eq!(
                unsafe {
                    ::std::ptr::addr_of!((*ptr).m_onNewExclusivePublicationHandler) as usize
                        - ptr as usize
                },
                144usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Context),
                    "::",
                    stringify!(m_onNewExclusivePublicationHandler)
                )
            );
            assert_eq!(
                unsafe {
                    ::std::ptr::addr_of!((*ptr).m_onNewSubscriptionHandler) as usize - ptr as usize
                },
                176usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Context),
                    "::",
                    stringify!(m_onNewSubscriptionHandler)
                )
            );
            assert_eq!(
                unsafe {
                    ::std::ptr::addr_of!((*ptr).m_onAvailableCounterHandler) as usize - ptr as usize
                },
                208usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Context),
                    "::",
                    stringify!(m_onAvailableCounterHandler)
                )
            );
            assert_eq!(
                unsafe {
                    ::std::ptr::addr_of!((*ptr).m_onUnavailableCounterHandler) as usize
                        - ptr as usize
                },
                240usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Context),
                    "::",
                    stringify!(m_onUnavailableCounterHandler)
                )
            );
            assert_eq!(
                unsafe {
                    ::std::ptr::addr_of!((*ptr).m_onCloseClientHandler) as usize - ptr as usize
                },
                272usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Context),
                    "::",
                    stringify!(m_onCloseClientHandler)
                )
            );
        }
        #[repr(C)]
        pub struct ChannelUri {
            pub m_prefix: root::std::string,
            pub m_media: root::std::string,
            pub m_params: u64,
        }
        pub const ChannelUri_State_MEDIA: root::aeron::ChannelUri_State = 0;
        pub const ChannelUri_State_PARAMS_KEY: root::aeron::ChannelUri_State = 1;
        pub const ChannelUri_State_PARAMS_VALUE: root::aeron::ChannelUri_State = 2;
        pub type ChannelUri_State = ::std::os::raw::c_int;
        #[test]
        fn bindgen_test_layout_ChannelUri() {
            const UNINIT: ::std::mem::MaybeUninit<ChannelUri> = ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<ChannelUri>(),
                72usize,
                concat!("Size of: ", stringify!(ChannelUri))
            );
            assert_eq!(
                ::std::mem::align_of::<ChannelUri>(),
                8usize,
                concat!("Alignment of ", stringify!(ChannelUri))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_prefix) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ChannelUri),
                    "::",
                    stringify!(m_prefix)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_media) as usize - ptr as usize },
                32usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ChannelUri),
                    "::",
                    stringify!(m_media)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_params) as usize - ptr as usize },
                64usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ChannelUri),
                    "::",
                    stringify!(m_params)
                )
            );
        }
        #[repr(C)]
        #[derive(Copy, Clone)]
        pub struct AsyncAddSubscription {
            pub m_async: *mut root::aeron_async_add_subscription_t,
            pub m_onAvailableImage: root::aeron::on_available_image_t,
            pub m_onUnavailableImage: root::aeron::on_unavailable_image_t,
        }
        #[test]
        fn bindgen_test_layout_AsyncAddSubscription() {
            const UNINIT: ::std::mem::MaybeUninit<AsyncAddSubscription> =
                ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<AsyncAddSubscription>(),
                72usize,
                concat!("Size of: ", stringify!(AsyncAddSubscription))
            );
            assert_eq!(
                ::std::mem::align_of::<AsyncAddSubscription>(),
                8usize,
                concat!("Alignment of ", stringify!(AsyncAddSubscription))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_async) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(AsyncAddSubscription),
                    "::",
                    stringify!(m_async)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_onAvailableImage) as usize - ptr as usize },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(AsyncAddSubscription),
                    "::",
                    stringify!(m_onAvailableImage)
                )
            );
            assert_eq!(
                unsafe {
                    ::std::ptr::addr_of!((*ptr).m_onUnavailableImage) as usize - ptr as usize
                },
                40usize,
                concat!(
                    "Offset of field: ",
                    stringify!(AsyncAddSubscription),
                    "::",
                    stringify!(m_onUnavailableImage)
                )
            );
        }
        #[doc = " Aeron Subscriber API for receiving messages from publishers on a given channel and streamId pair.\n Subscribers are created via an {@link Aeron} object, and received messages are delivered\n to the {@link fragment_handler_t}.\n <p>\n By default fragmented messages are not reassembled before delivery. If an application must\n receive whole messages, whether or not they were fragmented, then the Subscriber\n should be created with a {@link FragmentAssembler} or a custom implementation.\n <p>\n It is an applications responsibility to {@link #poll} the Subscriber for new messages.\n <p>\n Subscriptions are not threadsafe and should not be shared between subscribers.\n\n @see FragmentAssembler"]
        #[repr(C)]
        pub struct Subscription {
            #[doc = " @endcond"]
            pub m_aeron: *mut root::aeron_t,
            pub m_subscription: *mut root::aeron_subscription_t,
            pub m_addSubscription: *mut root::aeron::AsyncAddSubscription,
            pub m_constants: root::aeron_subscription_constants_t,
            pub m_channel: root::std::string,
            pub m_pendingDestinations: [u64; 7usize],
            pub m_adminLock: root::std::recursive_mutex,
        }
        #[test]
        fn bindgen_test_layout_Subscription() {
            const UNINIT: ::std::mem::MaybeUninit<Subscription> = ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<Subscription>(),
                192usize,
                concat!("Size of: ", stringify!(Subscription))
            );
            assert_eq!(
                ::std::mem::align_of::<Subscription>(),
                8usize,
                concat!("Alignment of ", stringify!(Subscription))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_aeron) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Subscription),
                    "::",
                    stringify!(m_aeron)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_subscription) as usize - ptr as usize },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Subscription),
                    "::",
                    stringify!(m_subscription)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_addSubscription) as usize - ptr as usize },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Subscription),
                    "::",
                    stringify!(m_addSubscription)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_constants) as usize - ptr as usize },
                24usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Subscription),
                    "::",
                    stringify!(m_constants)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_channel) as usize - ptr as usize },
                64usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Subscription),
                    "::",
                    stringify!(m_channel)
                )
            );
            assert_eq!(
                unsafe {
                    ::std::ptr::addr_of!((*ptr).m_pendingDestinations) as usize - ptr as usize
                },
                96usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Subscription),
                    "::",
                    stringify!(m_pendingDestinations)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_adminLock) as usize - ptr as usize },
                152usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Subscription),
                    "::",
                    stringify!(m_adminLock)
                )
            );
        }
        #[repr(C)]
        pub struct Counter {
            pub _base: root::aeron::concurrent::AtomicCounter,
            pub m_reader: *mut root::aeron::concurrent::CountersReader,
            pub m_registrationId: ::std::os::raw::c_long,
        }
        #[test]
        fn bindgen_test_layout_Counter() {
            const UNINIT: ::std::mem::MaybeUninit<Counter> = ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<Counter>(),
                48usize,
                concat!("Size of: ", stringify!(Counter))
            );
            assert_eq!(
                ::std::mem::align_of::<Counter>(),
                8usize,
                concat!("Alignment of ", stringify!(Counter))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_reader) as usize - ptr as usize },
                32usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Counter),
                    "::",
                    stringify!(m_reader)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_registrationId) as usize - ptr as usize },
                40usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Counter),
                    "::",
                    stringify!(m_registrationId)
                )
            );
        }
        pub type epoch_clock_t = u8;
        pub type nano_clock_t = u8;
        #[repr(C)]
        #[derive(Copy, Clone)]
        pub struct ClientConductor {
            pub m_aeron: *mut root::aeron_t,
        }
        #[test]
        fn bindgen_test_layout_ClientConductor() {
            const UNINIT: ::std::mem::MaybeUninit<ClientConductor> =
                ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<ClientConductor>(),
                8usize,
                concat!("Size of: ", stringify!(ClientConductor))
            );
            assert_eq!(
                ::std::mem::align_of::<ClientConductor>(),
                8usize,
                concat!("Alignment of ", stringify!(ClientConductor))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_aeron) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ClientConductor),
                    "::",
                    stringify!(m_aeron)
                )
            );
        }
        pub type AsyncAddPublication = root::aeron_async_add_publication_t;
        pub type AsyncAddExclusivePublication = root::aeron_async_add_exclusive_publication_t;
        pub type AsyncAddCounter = root::aeron_async_add_counter_t;
        #[doc = " Aeron entry point for communicating to the Media Driver for creating {@link Publication}s and {@link Subscription}s.\n Use a {@link Context} to configure the Aeron object.\n <p>\n A client application requires only one Aeron object per Media Driver."]
        #[repr(C)]
        pub struct Aeron {
            pub m_context: root::aeron::Context,
            pub m_aeron: *mut root::aeron_t,
            pub m_countersReader: root::aeron::concurrent::CountersReader,
            pub m_pendingPublications: [u64; 7usize],
            pub m_pendingExclusivePublications: [u64; 7usize],
            pub m_pendingSubscriptions: [u64; 7usize],
            pub m_pendingCounters: [u64; 7usize],
            pub m_availableCounterHandlers: [u64; 3usize],
            pub m_unavailableCounterHandlers: [u64; 3usize],
            pub m_closeClientHandlers: [u64; 3usize],
            pub m_adminLock: root::std::recursive_mutex,
            pub m_clientConductor: root::aeron::ClientConductor,
            pub m_conductorInvoker:
                root::aeron::concurrent::AgentInvoker<root::aeron::ClientConductor>,
        }
        #[test]
        fn bindgen_test_layout_Aeron() {
            const UNINIT: ::std::mem::MaybeUninit<Aeron> = ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<Aeron>(),
                720usize,
                concat!("Size of: ", stringify!(Aeron))
            );
            assert_eq!(
                ::std::mem::align_of::<Aeron>(),
                8usize,
                concat!("Alignment of ", stringify!(Aeron))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_context) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Aeron),
                    "::",
                    stringify!(m_context)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_aeron) as usize - ptr as usize },
                304usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Aeron),
                    "::",
                    stringify!(m_aeron)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_countersReader) as usize - ptr as usize },
                312usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Aeron),
                    "::",
                    stringify!(m_countersReader)
                )
            );
            assert_eq!(
                unsafe {
                    ::std::ptr::addr_of!((*ptr).m_pendingPublications) as usize - ptr as usize
                },
                352usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Aeron),
                    "::",
                    stringify!(m_pendingPublications)
                )
            );
            assert_eq!(
                unsafe {
                    ::std::ptr::addr_of!((*ptr).m_pendingExclusivePublications) as usize
                        - ptr as usize
                },
                408usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Aeron),
                    "::",
                    stringify!(m_pendingExclusivePublications)
                )
            );
            assert_eq!(
                unsafe {
                    ::std::ptr::addr_of!((*ptr).m_pendingSubscriptions) as usize - ptr as usize
                },
                464usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Aeron),
                    "::",
                    stringify!(m_pendingSubscriptions)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_pendingCounters) as usize - ptr as usize },
                520usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Aeron),
                    "::",
                    stringify!(m_pendingCounters)
                )
            );
            assert_eq!(
                unsafe {
                    ::std::ptr::addr_of!((*ptr).m_availableCounterHandlers) as usize - ptr as usize
                },
                576usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Aeron),
                    "::",
                    stringify!(m_availableCounterHandlers)
                )
            );
            assert_eq!(
                unsafe {
                    ::std::ptr::addr_of!((*ptr).m_unavailableCounterHandlers) as usize
                        - ptr as usize
                },
                600usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Aeron),
                    "::",
                    stringify!(m_unavailableCounterHandlers)
                )
            );
            assert_eq!(
                unsafe {
                    ::std::ptr::addr_of!((*ptr).m_closeClientHandlers) as usize - ptr as usize
                },
                624usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Aeron),
                    "::",
                    stringify!(m_closeClientHandlers)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_adminLock) as usize - ptr as usize },
                648usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Aeron),
                    "::",
                    stringify!(m_adminLock)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_clientConductor) as usize - ptr as usize },
                688usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Aeron),
                    "::",
                    stringify!(m_clientConductor)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_conductorInvoker) as usize - ptr as usize },
                696usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Aeron),
                    "::",
                    stringify!(m_conductorInvoker)
                )
            );
        }
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct aeron_context_stct {
        _unused: [u8; 0],
    }
    pub type aeron_context_t = root::aeron_context_stct;
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct aeron_stct {
        _unused: [u8; 0],
    }
    pub type aeron_t = root::aeron_stct;
    #[doc = " Structure used to hold information for a try_claim function call."]
    pub type aeron_buffer_claim_t = root::aeron_buffer_claim_stct;
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct aeron_publication_stct {
        _unused: [u8; 0],
    }
    pub type aeron_publication_t = root::aeron_publication_stct;
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct aeron_exclusive_publication_stct {
        _unused: [u8; 0],
    }
    pub type aeron_exclusive_publication_t = root::aeron_exclusive_publication_stct;
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct aeron_header_stct {
        _unused: [u8; 0],
    }
    pub type aeron_header_t = root::aeron_header_stct;
    #[repr(C, packed(4))]
    #[derive(Copy, Clone)]
    pub struct aeron_header_values_frame_stct {
        pub frame_length: i32,
        pub version: i8,
        pub flags: u8,
        pub type_: i16,
        pub term_offset: i32,
        pub session_id: i32,
        pub stream_id: i32,
        pub term_id: i32,
        pub reserved_value: i64,
    }
    #[test]
    fn bindgen_test_layout_aeron_header_values_frame_stct() {
        const UNINIT: ::std::mem::MaybeUninit<aeron_header_values_frame_stct> =
            ::std::mem::MaybeUninit::uninit();
        let ptr = UNINIT.as_ptr();
        assert_eq!(
            ::std::mem::size_of::<aeron_header_values_frame_stct>(),
            32usize,
            concat!("Size of: ", stringify!(aeron_header_values_frame_stct))
        );
        assert_eq!(
            ::std::mem::align_of::<aeron_header_values_frame_stct>(),
            4usize,
            concat!("Alignment of ", stringify!(aeron_header_values_frame_stct))
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).frame_length) as usize - ptr as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(aeron_header_values_frame_stct),
                "::",
                stringify!(frame_length)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(aeron_header_values_frame_stct),
                "::",
                stringify!(version)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
            5usize,
            concat!(
                "Offset of field: ",
                stringify!(aeron_header_values_frame_stct),
                "::",
                stringify!(flags)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
            6usize,
            concat!(
                "Offset of field: ",
                stringify!(aeron_header_values_frame_stct),
                "::",
                stringify!(type_)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).term_offset) as usize - ptr as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(aeron_header_values_frame_stct),
                "::",
                stringify!(term_offset)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).session_id) as usize - ptr as usize },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(aeron_header_values_frame_stct),
                "::",
                stringify!(session_id)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).stream_id) as usize - ptr as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(aeron_header_values_frame_stct),
                "::",
                stringify!(stream_id)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).term_id) as usize - ptr as usize },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(aeron_header_values_frame_stct),
                "::",
                stringify!(term_id)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).reserved_value) as usize - ptr as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(aeron_header_values_frame_stct),
                "::",
                stringify!(reserved_value)
            )
        );
    }
    pub type aeron_header_values_frame_t = root::aeron_header_values_frame_stct;
    #[repr(C, packed(4))]
    #[derive(Copy, Clone)]
    pub struct aeron_header_values_stct {
        pub frame: root::aeron_header_values_frame_t,
        pub initial_term_id: i32,
        pub position_bits_to_shift: usize,
    }
    #[test]
    fn bindgen_test_layout_aeron_header_values_stct() {
        const UNINIT: ::std::mem::MaybeUninit<aeron_header_values_stct> =
            ::std::mem::MaybeUninit::uninit();
        let ptr = UNINIT.as_ptr();
        assert_eq!(
            ::std::mem::size_of::<aeron_header_values_stct>(),
            44usize,
            concat!("Size of: ", stringify!(aeron_header_values_stct))
        );
        assert_eq!(
            ::std::mem::align_of::<aeron_header_values_stct>(),
            4usize,
            concat!("Alignment of ", stringify!(aeron_header_values_stct))
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).frame) as usize - ptr as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(aeron_header_values_stct),
                "::",
                stringify!(frame)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).initial_term_id) as usize - ptr as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(aeron_header_values_stct),
                "::",
                stringify!(initial_term_id)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).position_bits_to_shift) as usize - ptr as usize },
            36usize,
            concat!(
                "Offset of field: ",
                stringify!(aeron_header_values_stct),
                "::",
                stringify!(position_bits_to_shift)
            )
        );
    }
    pub type aeron_header_values_t = root::aeron_header_values_stct;
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct aeron_subscription_stct {
        _unused: [u8; 0],
    }
    pub type aeron_subscription_t = root::aeron_subscription_stct;
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct aeron_image_stct {
        _unused: [u8; 0],
    }
    pub type aeron_image_t = root::aeron_image_stct;
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct aeron_counter_stct {
        _unused: [u8; 0],
    }
    pub type aeron_counter_t = root::aeron_counter_stct;
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct aeron_log_buffer_stct {
        _unused: [u8; 0],
    }
    pub type aeron_log_buffer_t = root::aeron_log_buffer_stct;
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct aeron_counters_reader_stct {
        _unused: [u8; 0],
    }
    pub type aeron_counters_reader_t = root::aeron_counters_reader_stct;
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct aeron_client_registering_resource_stct {
        _unused: [u8; 0],
    }
    pub type aeron_async_add_publication_t = root::aeron_client_registering_resource_stct;
    pub type aeron_async_add_exclusive_publication_t = root::aeron_client_registering_resource_stct;
    pub type aeron_async_add_subscription_t = root::aeron_client_registering_resource_stct;
    pub type aeron_async_add_counter_t = root::aeron_client_registering_resource_stct;
    pub type aeron_async_destination_t = root::aeron_client_registering_resource_stct;
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct aeron_image_fragment_assembler_stct {
        _unused: [u8; 0],
    }
    pub type aeron_image_fragment_assembler_t = root::aeron_image_fragment_assembler_stct;
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct aeron_image_controlled_fragment_assembler_stct {
        _unused: [u8; 0],
    }
    pub type aeron_image_controlled_fragment_assembler_t =
        root::aeron_image_controlled_fragment_assembler_stct;
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct aeron_fragment_assembler_stct {
        _unused: [u8; 0],
    }
    pub type aeron_fragment_assembler_t = root::aeron_fragment_assembler_stct;
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct aeron_controlled_fragment_assembler_stct {
        _unused: [u8; 0],
    }
    pub type aeron_controlled_fragment_assembler_t = root::aeron_controlled_fragment_assembler_stct;
    extern "C" {
        pub fn aeron_context_set_dir(
            context: *mut root::aeron_context_t,
            value: *const ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn aeron_context_get_dir(
            context: *mut root::aeron_context_t,
        ) -> *const ::std::os::raw::c_char;
    }
    extern "C" {
        pub fn aeron_context_set_driver_timeout_ms(
            context: *mut root::aeron_context_t,
            value: u64,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn aeron_context_get_driver_timeout_ms(context: *mut root::aeron_context_t) -> u64;
    }
    extern "C" {
        pub fn aeron_context_set_keepalive_interval_ns(
            context: *mut root::aeron_context_t,
            value: u64,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn aeron_context_get_keepalive_interval_ns(context: *mut root::aeron_context_t) -> u64;
    }
    extern "C" {
        pub fn aeron_context_set_resource_linger_duration_ns(
            context: *mut root::aeron_context_t,
            value: u64,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn aeron_context_get_resource_linger_duration_ns(
            context: *mut root::aeron_context_t,
        ) -> u64;
    }
    extern "C" {
        pub fn aeron_context_set_pre_touch_mapped_memory(
            context: *mut root::aeron_context_t,
            value: bool,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn aeron_context_get_pre_touch_mapped_memory(
            context: *mut root::aeron_context_t,
        ) -> bool;
    }
    #[doc = " The error handler to be called when an error occurs."]
    pub type aeron_error_handler_t = ::std::option::Option<
        unsafe extern "C" fn(
            clientd: *mut ::std::os::raw::c_void,
            errcode: ::std::os::raw::c_int,
            message: *const ::std::os::raw::c_char,
        ),
    >;
    #[doc = " Generalised notification callback."]
    pub type aeron_notification_t =
        ::std::option::Option<unsafe extern "C" fn(clientd: *mut ::std::os::raw::c_void)>;
    extern "C" {
        pub fn aeron_context_set_error_handler(
            context: *mut root::aeron_context_t,
            handler: root::aeron_error_handler_t,
            clientd: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn aeron_context_get_error_handler(
            context: *mut root::aeron_context_t,
        ) -> root::aeron_error_handler_t;
    }
    extern "C" {
        pub fn aeron_context_get_error_handler_clientd(
            context: *mut root::aeron_context_t,
        ) -> *mut ::std::os::raw::c_void;
    }
    #[doc = " Function called by aeron_client_t to deliver notification that the media driver has added an aeron_publication_t\n or aeron_exclusive_publication_t successfully.\n\n Implementations should do the minimum work for passing off state to another thread for later processing.\n\n @param clientd to be returned in the call\n @param async associated with the original add publication call\n @param channel of the publication\n @param stream_id within the channel of the publication\n @param session_id of the publication\n @param correlation_id used by the publication"]
    pub type aeron_on_new_publication_t = ::std::option::Option<
        unsafe extern "C" fn(
            clientd: *mut ::std::os::raw::c_void,
            async_: *mut root::aeron_async_add_publication_t,
            channel: *const ::std::os::raw::c_char,
            stream_id: i32,
            session_id: i32,
            correlation_id: i64,
        ),
    >;
    extern "C" {
        pub fn aeron_context_set_on_new_publication(
            context: *mut root::aeron_context_t,
            handler: root::aeron_on_new_publication_t,
            clientd: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn aeron_context_get_on_new_publication(
            context: *mut root::aeron_context_t,
        ) -> root::aeron_on_new_publication_t;
    }
    extern "C" {
        pub fn aeron_context_get_on_new_publication_clientd(
            context: *mut root::aeron_context_t,
        ) -> *mut ::std::os::raw::c_void;
    }
    extern "C" {
        pub fn aeron_context_set_on_new_exclusive_publication(
            context: *mut root::aeron_context_t,
            handler: root::aeron_on_new_publication_t,
            clientd: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn aeron_context_get_on_new_exclusive_publication(
            context: *mut root::aeron_context_t,
        ) -> root::aeron_on_new_publication_t;
    }
    extern "C" {
        pub fn aeron_context_get_on_new_exclusive_publication_clientd(
            context: *mut root::aeron_context_t,
        ) -> *mut ::std::os::raw::c_void;
    }
    #[doc = " Function called by aeron_client_t to deliver notification that the media driver has added an aeron_subscription_t\n successfully.\n\n Implementations should do the minimum work for handing off state to another thread for later processing.\n\n @param clientd to be returned in the call\n @param async associated with the original aeron_add_async_subscription call\n @param channel of the subscription\n @param stream_id within the channel of the subscription\n @param session_id of the subscription\n @param correlation_id used by the subscription"]
    pub type aeron_on_new_subscription_t = ::std::option::Option<
        unsafe extern "C" fn(
            clientd: *mut ::std::os::raw::c_void,
            async_: *mut root::aeron_async_add_subscription_t,
            channel: *const ::std::os::raw::c_char,
            stream_id: i32,
            correlation_id: i64,
        ),
    >;
    extern "C" {
        pub fn aeron_context_set_on_new_subscription(
            context: *mut root::aeron_context_t,
            handler: root::aeron_on_new_subscription_t,
            clientd: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn aeron_context_get_on_new_subscription(
            context: *mut root::aeron_context_t,
        ) -> root::aeron_on_new_subscription_t;
    }
    extern "C" {
        pub fn aeron_context_get_on_new_subscription_clientd(
            context: *mut root::aeron_context_t,
        ) -> *mut ::std::os::raw::c_void;
    }
    #[doc = " Function called by aeron_client_t to deliver notifications that an aeron_image_t was added.\n\n @param clientd to be returned in the call.\n @param subscription that image is part of.\n @param image that has become available."]
    pub type aeron_on_available_image_t = ::std::option::Option<
        unsafe extern "C" fn(
            clientd: *mut ::std::os::raw::c_void,
            subscription: *mut root::aeron_subscription_t,
            image: *mut root::aeron_image_t,
        ),
    >;
    #[doc = " Function called by aeron_client_t to deliver notifications that an aeron_image_t has been removed from use and\n should not be used any longer.\n\n @param clientd to be returned in the call.\n @param subscription that image is part of.\n @param image that has become unavailable."]
    pub type aeron_on_unavailable_image_t = ::std::option::Option<
        unsafe extern "C" fn(
            clientd: *mut ::std::os::raw::c_void,
            subscription: *mut root::aeron_subscription_t,
            image: *mut root::aeron_image_t,
        ),
    >;
    #[doc = " Function called by aeron_client_t to deliver notifications that a counter has been added to the driver.\n\n @param clientd to be returned in the call.\n @param counters_reader that holds the counter.\n @param registration_id of the counter.\n @param counter_id of the counter."]
    pub type aeron_on_available_counter_t = ::std::option::Option<
        unsafe extern "C" fn(
            clientd: *mut ::std::os::raw::c_void,
            counters_reader: *mut root::aeron_counters_reader_t,
            registration_id: i64,
            counter_id: i32,
        ),
    >;
    extern "C" {
        pub fn aeron_context_set_on_available_counter(
            context: *mut root::aeron_context_t,
            handler: root::aeron_on_available_counter_t,
            clientd: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn aeron_context_get_on_available_counter(
            context: *mut root::aeron_context_t,
        ) -> root::aeron_on_available_counter_t;
    }
    extern "C" {
        pub fn aeron_context_get_on_available_counter_clientd(
            context: *mut root::aeron_context_t,
        ) -> *mut ::std::os::raw::c_void;
    }
    #[doc = " Function called by aeron_client_t to deliver notifications that a counter has been removed from the driver.\n\n @param clientd to be returned in the call.\n @param counters_reader that holds the counter.\n @param registration_id of the counter.\n @param counter_id of the counter."]
    pub type aeron_on_unavailable_counter_t = ::std::option::Option<
        unsafe extern "C" fn(
            clientd: *mut ::std::os::raw::c_void,
            counters_reader: *mut root::aeron_counters_reader_t,
            registration_id: i64,
            counter_id: i32,
        ),
    >;
    extern "C" {
        pub fn aeron_context_set_on_unavailable_counter(
            context: *mut root::aeron_context_t,
            handler: root::aeron_on_unavailable_counter_t,
            clientd: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn aeron_context_get_on_unavailable_counter(
            context: *mut root::aeron_context_t,
        ) -> root::aeron_on_unavailable_counter_t;
    }
    extern "C" {
        pub fn aeron_context_get_on_unavailable_counter_clientd(
            context: *mut root::aeron_context_t,
        ) -> *mut ::std::os::raw::c_void;
    }
    #[doc = " Function called by aeron_client_t to deliver notifications that the client is closing.\n\n @param clientd to be returned in the call."]
    pub type aeron_on_close_client_t =
        ::std::option::Option<unsafe extern "C" fn(clientd: *mut ::std::os::raw::c_void)>;
    extern "C" {
        pub fn aeron_context_set_on_close_client(
            context: *mut root::aeron_context_t,
            handler: root::aeron_on_close_client_t,
            clientd: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn aeron_context_get_on_close_client(
            context: *mut root::aeron_context_t,
        ) -> root::aeron_on_close_client_t;
    }
    extern "C" {
        pub fn aeron_context_get_on_close_client_clientd(
            context: *mut root::aeron_context_t,
        ) -> *mut ::std::os::raw::c_void;
    }
    extern "C" {
        #[doc = " Whether to use an invoker to control the conductor agent or spawn a thread."]
        pub fn aeron_context_set_use_conductor_agent_invoker(
            context: *mut root::aeron_context_t,
            value: bool,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn aeron_context_get_use_conductor_agent_invoker(
            context: *mut root::aeron_context_t,
        ) -> bool;
    }
    pub type aeron_agent_on_start_func_t = ::std::option::Option<
        unsafe extern "C" fn(
            state: *mut ::std::os::raw::c_void,
            role_name: *const ::std::os::raw::c_char,
        ),
    >;
    extern "C" {
        pub fn aeron_context_set_agent_on_start_function(
            context: *mut root::aeron_context_t,
            value: root::aeron_agent_on_start_func_t,
            state: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn aeron_context_get_agent_on_start_function(
            context: *mut root::aeron_context_t,
        ) -> root::aeron_agent_on_start_func_t;
    }
    extern "C" {
        pub fn aeron_context_get_agent_on_start_state(
            context: *mut root::aeron_context_t,
        ) -> *mut ::std::os::raw::c_void;
    }
    extern "C" {
        #[doc = " Create a aeron_context_t struct and initialize with default values.\n\n @param context to create and initialize\n @return 0 for success and -1 for error."]
        pub fn aeron_context_init(
            context: *mut *mut root::aeron_context_t,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Close and delete aeron_context_t struct.\n\n @param context to close and delete\n @return 0 for success and -1 for error."]
        pub fn aeron_context_close(context: *mut root::aeron_context_t) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Create a aeron_t client struct and initialize from the aeron_context_t struct.\n\n The given aeron_context_t struct will be used exclusively by the client. Do not reuse between clients.\n\n @param aeron  client to create and initialize.\n @param context to use for initialization.\n @return 0 for success and -1 for error."]
        pub fn aeron_init(
            client: *mut *mut root::aeron_t,
            context: *mut root::aeron_context_t,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Start an aeron_t. This may spawn a thread for the Client Conductor.\n\n @param client to start.\n @return 0 for success and -1 for error."]
        pub fn aeron_start(client: *mut root::aeron_t) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Call the Conductor main do_work duty cycle once.\n\n Client must have been created with use conductor invoker set to true.\n\n @param client to call do_work duty cycle on.\n @return 0 for success and -1 for error."]
        pub fn aeron_main_do_work(client: *mut root::aeron_t) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Call the Conductor Idle Strategy.\n\n @param client to idle.\n @param work_count to pass to idle strategy."]
        pub fn aeron_main_idle_strategy(
            client: *mut root::aeron_t,
            work_count: ::std::os::raw::c_int,
        );
    }
    extern "C" {
        #[doc = " Close and delete aeron_t struct.\n\n @param client to close and delete\n @return 0 for success and -1 for error."]
        pub fn aeron_close(client: *mut root::aeron_t) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Determines if the client has been closed, e.g. via a driver timeout. Don't call this method after calling\n aeron_close as that will have already freed the associated memory.\n\n @param client to check if closed.\n @return true if it has been closed, false otherwise."]
        pub fn aeron_is_closed(client: *mut root::aeron_t) -> bool;
    }
    extern "C" {
        #[doc = " Call stream_out to print the counter labels and values.\n\n @param client to get the counters from.\n @param stream_out to call for each label and value."]
        pub fn aeron_print_counters(
            client: *mut root::aeron_t,
            stream_out: ::std::option::Option<
                unsafe extern "C" fn(arg1: *const ::std::os::raw::c_char),
            >,
        );
    }
    extern "C" {
        #[doc = " Return the aeron_context_t that is in use by the given client.\n\n @param client to return the aeron_context_t for.\n @return the aeron_context_t for the given client or NULL for an error."]
        pub fn aeron_context(client: *mut root::aeron_t) -> *mut root::aeron_context_t;
    }
    extern "C" {
        #[doc = " Return the client id in use by the client.\n\n @param client to return the client id for.\n @return id value or -1 for an error."]
        pub fn aeron_client_id(client: *mut root::aeron_t) -> i64;
    }
    extern "C" {
        #[doc = " Return a unique correlation id from the driver.\n\n @param client to use to get the id.\n @return unique correlation id or -1 for an error."]
        pub fn aeron_next_correlation_id(client: *mut root::aeron_t) -> i64;
    }
    extern "C" {
        #[doc = " Asynchronously add a publication using the given client and return an object to use to determine when the\n publication is available.\n\n @param async object to use for polling completion.\n @param client to add the publication to.\n @param uri for the channel of the publication.\n @param stream_id for the publication.\n @return 0 for success or -1 for an error."]
        pub fn aeron_async_add_publication(
            async_: *mut *mut root::aeron_async_add_publication_t,
            client: *mut root::aeron_t,
            uri: *const ::std::os::raw::c_char,
            stream_id: i32,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Poll the completion of the aeron_async_add_publication call.\n\n @param publication to set if completed successfully.\n @param async to check for completion.\n @return 0 for not complete (try again), 1 for completed successfully, or -1 for an error."]
        pub fn aeron_async_add_publication_poll(
            publication: *mut *mut root::aeron_publication_t,
            async_: *mut root::aeron_async_add_publication_t,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Asynchronously add an exclusive publication using the given client and return an object to use to determine when the\n publication is available.\n\n @param async object to use for polling completion.\n @param client to add the publication to.\n @param uri for the channel of the publication.\n @param stream_id for the publication.\n @return 0 for success or -1 for an error."]
        pub fn aeron_async_add_exclusive_publication(
            async_: *mut *mut root::aeron_async_add_exclusive_publication_t,
            client: *mut root::aeron_t,
            uri: *const ::std::os::raw::c_char,
            stream_id: i32,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Poll the completion of the aeron_async_add_exclusive_publication call.\n\n @param publication to set if completed successfully.\n @param async to check for completion.\n @return 0 for not complete (try again), 1 for completed successfully, or -1 for an error."]
        pub fn aeron_async_add_exclusive_publication_poll(
            publication: *mut *mut root::aeron_exclusive_publication_t,
            async_: *mut root::aeron_async_add_exclusive_publication_t,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Asynchronously add a subscription using the given client and return an object to use to determine when the\n subscription is available.\n\n @param async object to use for polling completion.\n @param client to add the subscription to.\n @param uri for the channel of the subscription.\n @param stream_id for the subscription.\n @param on_available_image_handler to be called when images become available on the subscription.\n @param on_available_image_clientd to be passed when images become available on the subscription.\n @param on_unavailable_image_handler to be called when images go unavailable on the subscription.\n @param on_available_image_clientd to be called when images go unavailable on the subscription.\n @return 0 for success or -1 for an error."]
        pub fn aeron_async_add_subscription(
            async_: *mut *mut root::aeron_async_add_subscription_t,
            client: *mut root::aeron_t,
            uri: *const ::std::os::raw::c_char,
            stream_id: i32,
            on_available_image_handler: root::aeron_on_available_image_t,
            on_available_image_clientd: *mut ::std::os::raw::c_void,
            on_unavailable_image_handler: root::aeron_on_unavailable_image_t,
            on_unavailable_image_clientd: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Poll the completion of the aeron_async_add_subscription call.\n\n @param subscription to set if completed successfully.\n @param async to check for completion.\n @return 0 for not complete (try again), 1 for completed successfully, or -1 for an error."]
        pub fn aeron_async_add_subscription_poll(
            subscription: *mut *mut root::aeron_subscription_t,
            async_: *mut root::aeron_async_add_subscription_t,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Return a reference to the counters reader of the given client.\n\n The aeron_counters_reader_t is maintained by the client. And should not be freed.\n\n @param client that contains the counters reader.\n @return aeron_counters_reader_t or NULL for error."]
        pub fn aeron_counters_reader(
            client: *mut root::aeron_t,
        ) -> *mut root::aeron_counters_reader_t;
    }
    extern "C" {
        #[doc = " Asynchronously add a counter using the given client and return an object to use to determine when the\n counter is available.\n\n @param async object to use for polling completion.\n @param client to add the counter to.\n @param type_id for the counter.\n @param key_buffer for the counter.\n @param key_buffer_length for the counter.\n @param label_buffer for the counter.\n @param label_buffer_length for the counter.\n @return 0 for success or -1 for an error."]
        pub fn aeron_async_add_counter(
            async_: *mut *mut root::aeron_async_add_counter_t,
            client: *mut root::aeron_t,
            type_id: i32,
            key_buffer: *const u8,
            key_buffer_length: usize,
            label_buffer: *const ::std::os::raw::c_char,
            label_buffer_length: usize,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Poll the completion of the aeron_async_add_counter call.\n\n @param counter to set if completed successfully.\n @param async to check for completion.\n @return 0 for not complete (try again), 1 for completed successfully, or -1 for an error."]
        pub fn aeron_async_add_counter_poll(
            counter: *mut *mut root::aeron_counter_t,
            async_: *mut root::aeron_async_add_counter_t,
        ) -> ::std::os::raw::c_int;
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct aeron_on_available_counter_pair_stct {
        pub handler: root::aeron_on_available_counter_t,
        pub clientd: *mut ::std::os::raw::c_void,
    }
    #[test]
    fn bindgen_test_layout_aeron_on_available_counter_pair_stct() {
        const UNINIT: ::std::mem::MaybeUninit<aeron_on_available_counter_pair_stct> =
            ::std::mem::MaybeUninit::uninit();
        let ptr = UNINIT.as_ptr();
        assert_eq!(
            ::std::mem::size_of::<aeron_on_available_counter_pair_stct>(),
            16usize,
            concat!(
                "Size of: ",
                stringify!(aeron_on_available_counter_pair_stct)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<aeron_on_available_counter_pair_stct>(),
            8usize,
            concat!(
                "Alignment of ",
                stringify!(aeron_on_available_counter_pair_stct)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).handler) as usize - ptr as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(aeron_on_available_counter_pair_stct),
                "::",
                stringify!(handler)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).clientd) as usize - ptr as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(aeron_on_available_counter_pair_stct),
                "::",
                stringify!(clientd)
            )
        );
    }
    pub type aeron_on_available_counter_pair_t = root::aeron_on_available_counter_pair_stct;
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct aeron_on_unavailable_counter_pair_stct {
        pub handler: root::aeron_on_unavailable_counter_t,
        pub clientd: *mut ::std::os::raw::c_void,
    }
    #[test]
    fn bindgen_test_layout_aeron_on_unavailable_counter_pair_stct() {
        const UNINIT: ::std::mem::MaybeUninit<aeron_on_unavailable_counter_pair_stct> =
            ::std::mem::MaybeUninit::uninit();
        let ptr = UNINIT.as_ptr();
        assert_eq!(
            ::std::mem::size_of::<aeron_on_unavailable_counter_pair_stct>(),
            16usize,
            concat!(
                "Size of: ",
                stringify!(aeron_on_unavailable_counter_pair_stct)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<aeron_on_unavailable_counter_pair_stct>(),
            8usize,
            concat!(
                "Alignment of ",
                stringify!(aeron_on_unavailable_counter_pair_stct)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).handler) as usize - ptr as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(aeron_on_unavailable_counter_pair_stct),
                "::",
                stringify!(handler)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).clientd) as usize - ptr as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(aeron_on_unavailable_counter_pair_stct),
                "::",
                stringify!(clientd)
            )
        );
    }
    pub type aeron_on_unavailable_counter_pair_t = root::aeron_on_unavailable_counter_pair_stct;
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct aeron_on_close_client_pair_stct {
        pub handler: root::aeron_on_close_client_t,
        pub clientd: *mut ::std::os::raw::c_void,
    }
    #[test]
    fn bindgen_test_layout_aeron_on_close_client_pair_stct() {
        const UNINIT: ::std::mem::MaybeUninit<aeron_on_close_client_pair_stct> =
            ::std::mem::MaybeUninit::uninit();
        let ptr = UNINIT.as_ptr();
        assert_eq!(
            ::std::mem::size_of::<aeron_on_close_client_pair_stct>(),
            16usize,
            concat!("Size of: ", stringify!(aeron_on_close_client_pair_stct))
        );
        assert_eq!(
            ::std::mem::align_of::<aeron_on_close_client_pair_stct>(),
            8usize,
            concat!("Alignment of ", stringify!(aeron_on_close_client_pair_stct))
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).handler) as usize - ptr as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(aeron_on_close_client_pair_stct),
                "::",
                stringify!(handler)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).clientd) as usize - ptr as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(aeron_on_close_client_pair_stct),
                "::",
                stringify!(clientd)
            )
        );
    }
    pub type aeron_on_close_client_pair_t = root::aeron_on_close_client_pair_stct;
    extern "C" {
        #[doc = " Add a handler to be called when a new counter becomes available.\n\n NOTE: This function blocks until the handler is added by the client conductor thread.\n\n @param client for the counter\n @param pair holding the handler to call and a clientd to pass when called.\n @return 0 for success and -1 for error"]
        pub fn aeron_add_available_counter_handler(
            client: *mut root::aeron_t,
            pair: *mut root::aeron_on_available_counter_pair_t,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Remove a previously added handler to be called when a new counter becomes available.\n\n NOTE: This function blocks until the handler is removed by the client conductor thread.\n\n @param client for the counter\n @param pair holding the handler to call and a clientd to pass when called.\n @return 0 for success and -1 for error"]
        pub fn aeron_remove_available_counter_handler(
            client: *mut root::aeron_t,
            pair: *mut root::aeron_on_available_counter_pair_t,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Add a handler to be called when a new counter becomes unavailable or goes away.\n\n NOTE: This function blocks until the handler is added by the client conductor thread.\n\n @param client for the counter\n @param pair holding the handler to call and a clientd to pass when called.\n @return 0 for success and -1 for error"]
        pub fn aeron_add_unavailable_counter_handler(
            client: *mut root::aeron_t,
            pair: *mut root::aeron_on_unavailable_counter_pair_t,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Remove a previously added handler to be called when a new counter becomes unavailable or goes away.\n\n NOTE: This function blocks until the handler is removed by the client conductor thread.\n\n @param client for the counter\n @param pair holding the handler to call and a clientd to pass when called.\n @return 0 for success and -1 for error"]
        pub fn aeron_remove_unavailable_counter_handler(
            client: *mut root::aeron_t,
            pair: *mut root::aeron_on_unavailable_counter_pair_t,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Add a handler to be called when client is closed.\n\n NOTE: This function blocks until the handler is added by the client conductor thread.\n\n @param client for the counter\n @param pair holding the handler to call and a clientd to pass when called.\n @return 0 for success and -1 for error"]
        pub fn aeron_add_close_handler(
            client: *mut root::aeron_t,
            pair: *mut root::aeron_on_close_client_pair_t,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Remove a previously added handler to be called when client is closed.\n\n NOTE: This function blocks until the handler is removed by the client conductor thread.\n\n @param client for the counter\n @param pair holding the handler to call and a clientd to pass when called.\n @return 0 for success and -1 for error"]
        pub fn aeron_remove_close_handler(
            client: *mut root::aeron_t,
            pair: *mut root::aeron_on_close_client_pair_t,
        ) -> ::std::os::raw::c_int;
    }
    #[repr(C, packed(4))]
    #[derive(Copy, Clone)]
    pub struct aeron_counter_value_descriptor_stct {
        pub counter_value: i64,
        pub registration_id: i64,
        pub owner_id: i64,
        pub pad1: [u8; 104usize],
    }
    #[test]
    fn bindgen_test_layout_aeron_counter_value_descriptor_stct() {
        const UNINIT: ::std::mem::MaybeUninit<aeron_counter_value_descriptor_stct> =
            ::std::mem::MaybeUninit::uninit();
        let ptr = UNINIT.as_ptr();
        assert_eq!(
            ::std::mem::size_of::<aeron_counter_value_descriptor_stct>(),
            128usize,
            concat!("Size of: ", stringify!(aeron_counter_value_descriptor_stct))
        );
        assert_eq!(
            ::std::mem::align_of::<aeron_counter_value_descriptor_stct>(),
            4usize,
            concat!(
                "Alignment of ",
                stringify!(aeron_counter_value_descriptor_stct)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).counter_value) as usize - ptr as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(aeron_counter_value_descriptor_stct),
                "::",
                stringify!(counter_value)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).registration_id) as usize - ptr as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(aeron_counter_value_descriptor_stct),
                "::",
                stringify!(registration_id)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).owner_id) as usize - ptr as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(aeron_counter_value_descriptor_stct),
                "::",
                stringify!(owner_id)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).pad1) as usize - ptr as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(aeron_counter_value_descriptor_stct),
                "::",
                stringify!(pad1)
            )
        );
    }
    pub type aeron_counter_value_descriptor_t = root::aeron_counter_value_descriptor_stct;
    #[repr(C, packed(4))]
    #[derive(Copy, Clone)]
    pub struct aeron_counter_metadata_descriptor_stct {
        pub state: i32,
        pub type_id: i32,
        pub free_for_reuse_deadline_ms: i64,
        pub key: [u8; 112usize],
        pub label_length: i32,
        pub label: [u8; 380usize],
    }
    #[test]
    fn bindgen_test_layout_aeron_counter_metadata_descriptor_stct() {
        const UNINIT: ::std::mem::MaybeUninit<aeron_counter_metadata_descriptor_stct> =
            ::std::mem::MaybeUninit::uninit();
        let ptr = UNINIT.as_ptr();
        assert_eq!(
            ::std::mem::size_of::<aeron_counter_metadata_descriptor_stct>(),
            512usize,
            concat!(
                "Size of: ",
                stringify!(aeron_counter_metadata_descriptor_stct)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<aeron_counter_metadata_descriptor_stct>(),
            4usize,
            concat!(
                "Alignment of ",
                stringify!(aeron_counter_metadata_descriptor_stct)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(aeron_counter_metadata_descriptor_stct),
                "::",
                stringify!(state)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).type_id) as usize - ptr as usize },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(aeron_counter_metadata_descriptor_stct),
                "::",
                stringify!(type_id)
            )
        );
        assert_eq!(
            unsafe {
                ::std::ptr::addr_of!((*ptr).free_for_reuse_deadline_ms) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(aeron_counter_metadata_descriptor_stct),
                "::",
                stringify!(free_for_reuse_deadline_ms)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).key) as usize - ptr as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(aeron_counter_metadata_descriptor_stct),
                "::",
                stringify!(key)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).label_length) as usize - ptr as usize },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(aeron_counter_metadata_descriptor_stct),
                "::",
                stringify!(label_length)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).label) as usize - ptr as usize },
            132usize,
            concat!(
                "Offset of field: ",
                stringify!(aeron_counter_metadata_descriptor_stct),
                "::",
                stringify!(label)
            )
        );
    }
    pub type aeron_counter_metadata_descriptor_t = root::aeron_counter_metadata_descriptor_stct;
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct aeron_counters_reader_buffers_stct {
        pub values: *mut u8,
        pub metadata: *mut u8,
        pub values_length: usize,
        pub metadata_length: usize,
    }
    #[test]
    fn bindgen_test_layout_aeron_counters_reader_buffers_stct() {
        const UNINIT: ::std::mem::MaybeUninit<aeron_counters_reader_buffers_stct> =
            ::std::mem::MaybeUninit::uninit();
        let ptr = UNINIT.as_ptr();
        assert_eq!(
            ::std::mem::size_of::<aeron_counters_reader_buffers_stct>(),
            32usize,
            concat!("Size of: ", stringify!(aeron_counters_reader_buffers_stct))
        );
        assert_eq!(
            ::std::mem::align_of::<aeron_counters_reader_buffers_stct>(),
            8usize,
            concat!(
                "Alignment of ",
                stringify!(aeron_counters_reader_buffers_stct)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).values) as usize - ptr as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(aeron_counters_reader_buffers_stct),
                "::",
                stringify!(values)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).metadata) as usize - ptr as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(aeron_counters_reader_buffers_stct),
                "::",
                stringify!(metadata)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).values_length) as usize - ptr as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(aeron_counters_reader_buffers_stct),
                "::",
                stringify!(values_length)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).metadata_length) as usize - ptr as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(aeron_counters_reader_buffers_stct),
                "::",
                stringify!(metadata_length)
            )
        );
    }
    pub type aeron_counters_reader_buffers_t = root::aeron_counters_reader_buffers_stct;
    extern "C" {
        #[doc = " Get buffer pointers and lengths for the counters reader.\n\n @param reader reader containing the buffers.\n @param buffers output structure to return the buffers.\n @return -1 on failure, 0 on success."]
        pub fn aeron_counters_reader_get_buffers(
            reader: *mut root::aeron_counters_reader_t,
            buffers: *mut root::aeron_counters_reader_buffers_t,
        ) -> ::std::os::raw::c_int;
    }
    #[doc = " Function called by aeron_counters_reader_foreach_counter for each counter in the aeron_counters_reader_t.\n\n @param value of the counter.\n @param id of the counter.\n @param label for the counter.\n @param label_length for the counter.\n @param clientd to be returned in the call"]
    pub type aeron_counters_reader_foreach_counter_func_t = ::std::option::Option<
        unsafe extern "C" fn(
            value: i64,
            id: i32,
            type_id: i32,
            key: *const u8,
            key_length: usize,
            label: *const ::std::os::raw::c_char,
            label_length: usize,
            clientd: *mut ::std::os::raw::c_void,
        ),
    >;
    extern "C" {
        #[doc = " Iterate over the counters in the counters_reader and call the given function for each counter.\n\n @param counters_reader to iterate over.\n @param func to call for each counter.\n @param clientd to pass for each call to func."]
        pub fn aeron_counters_reader_foreach_counter(
            counters_reader: *mut root::aeron_counters_reader_t,
            func: root::aeron_counters_reader_foreach_counter_func_t,
            clientd: *mut ::std::os::raw::c_void,
        );
    }
    extern "C" {
        #[doc = " Get the current max counter id.\n\n @param reader to query\n @return -1 on failure, max counter id on success."]
        pub fn aeron_counters_reader_max_counter_id(
            reader: *mut root::aeron_counters_reader_t,
        ) -> i32;
    }
    extern "C" {
        #[doc = " Get the address for a counter.\n\n @param counters_reader that contains the counter\n @param counter_id to find\n @return address of the counter value"]
        pub fn aeron_counters_reader_addr(
            counters_reader: *mut root::aeron_counters_reader_t,
            counter_id: i32,
        ) -> *mut i64;
    }
    extern "C" {
        #[doc = " Get the registration id assigned to a counter.\n\n @param counters_reader representing the this pointer.\n @param counter_id      for which the registration id requested.\n @param registration_id pointer for value to be set on success.\n @return -1 on failure, 0 on success."]
        pub fn aeron_counters_reader_counter_registration_id(
            counters_reader: *mut root::aeron_counters_reader_t,
            counter_id: i32,
            registration_id: *mut i64,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Get the owner id assigned to a counter which will typically be the client id.\n\n @param counters_reader representing the this pointer.\n @param counter_id      for which the registration id requested.\n @param owner_id        pointer for value to be set on success.\n @return -1 on failure, 0 on success."]
        pub fn aeron_counters_reader_counter_owner_id(
            counters_reader: *mut root::aeron_counters_reader_t,
            counter_id: i32,
            owner_id: *mut i64,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Get the state for a counter.\n\n @param counters_reader that contains the counter\n @param counter_id to find\n @param state out pointer for the current state to be stored in.\n @return -1 on failure, 0 on success."]
        pub fn aeron_counters_reader_counter_state(
            counters_reader: *mut root::aeron_counters_reader_t,
            counter_id: i32,
            state: *mut i32,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Get the type id for a counter.\n\n @param counters_reader that contains the counter\n @param counter_id to find\n @param type id out pointer for the current state to be stored in.\n @return -1 on failure, 0 on success."]
        pub fn aeron_counters_reader_counter_type_id(
            counters_reader: *mut root::aeron_counters_reader_t,
            counter_id: i32,
            type_id: *mut i32,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Get the label for a counter.\n\n @param counters_reader that contains the counter\n @param counter_id to find\n @param buffer to store the counter in.\n @param buffer_length length of the output buffer\n @return -1 on failure, number of characters copied to buffer on success."]
        pub fn aeron_counters_reader_counter_label(
            counters_reader: *mut root::aeron_counters_reader_t,
            counter_id: i32,
            buffer: *mut ::std::os::raw::c_char,
            buffer_length: usize,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Get the free for reuse deadline (ms) for a counter.\n\n @param counters_reader that contains the counter.\n @param counter_id to find.\n @param deadline_ms output value to store the deadline.\n @return -1 on failure, 0 on success."]
        pub fn aeron_counters_reader_free_for_reuse_deadline_ms(
            counters_reader: *mut root::aeron_counters_reader_t,
            counter_id: i32,
            deadline_ms: *mut i64,
        ) -> ::std::os::raw::c_int;
    }
    #[doc = " Function called when filling in the reserved value field of a message.\n\n @param clientd passed to the offer function.\n @param buffer of the entire frame, including Aeron data header.\n @param frame_length of the entire frame."]
    pub type aeron_reserved_value_supplier_t = ::std::option::Option<
        unsafe extern "C" fn(
            clientd: *mut ::std::os::raw::c_void,
            buffer: *mut u8,
            frame_length: usize,
        ) -> i64,
    >;
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct aeron_iovec_stct {
        pub iov_base: *mut u8,
        pub iov_len: usize,
    }
    #[test]
    fn bindgen_test_layout_aeron_iovec_stct() {
        const UNINIT: ::std::mem::MaybeUninit<aeron_iovec_stct> = ::std::mem::MaybeUninit::uninit();
        let ptr = UNINIT.as_ptr();
        assert_eq!(
            ::std::mem::size_of::<aeron_iovec_stct>(),
            16usize,
            concat!("Size of: ", stringify!(aeron_iovec_stct))
        );
        assert_eq!(
            ::std::mem::align_of::<aeron_iovec_stct>(),
            8usize,
            concat!("Alignment of ", stringify!(aeron_iovec_stct))
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).iov_base) as usize - ptr as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(aeron_iovec_stct),
                "::",
                stringify!(iov_base)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).iov_len) as usize - ptr as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(aeron_iovec_stct),
                "::",
                stringify!(iov_len)
            )
        );
    }
    pub type aeron_iovec_t = root::aeron_iovec_stct;
    #[doc = " Structure used to hold information for a try_claim function call."]
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct aeron_buffer_claim_stct {
        pub frame_header: *mut u8,
        pub data: *mut u8,
        pub length: usize,
    }
    #[test]
    fn bindgen_test_layout_aeron_buffer_claim_stct() {
        const UNINIT: ::std::mem::MaybeUninit<aeron_buffer_claim_stct> =
            ::std::mem::MaybeUninit::uninit();
        let ptr = UNINIT.as_ptr();
        assert_eq!(
            ::std::mem::size_of::<aeron_buffer_claim_stct>(),
            24usize,
            concat!("Size of: ", stringify!(aeron_buffer_claim_stct))
        );
        assert_eq!(
            ::std::mem::align_of::<aeron_buffer_claim_stct>(),
            8usize,
            concat!("Alignment of ", stringify!(aeron_buffer_claim_stct))
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).frame_header) as usize - ptr as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(aeron_buffer_claim_stct),
                "::",
                stringify!(frame_header)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(aeron_buffer_claim_stct),
                "::",
                stringify!(data)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(aeron_buffer_claim_stct),
                "::",
                stringify!(length)
            )
        );
    }
    extern "C" {
        #[doc = " Commit the given buffer_claim as a complete message available for consumption.\n\n @param buffer_claim to commit.\n @return 0 for success or -1 for error."]
        pub fn aeron_buffer_claim_commit(
            buffer_claim: *mut root::aeron_buffer_claim_t,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Abort the given buffer_claim and assign its position as padding.\n\n @param buffer_claim to abort.\n @return 0 for success or -1 for error."]
        pub fn aeron_buffer_claim_abort(
            buffer_claim: *mut root::aeron_buffer_claim_t,
        ) -> ::std::os::raw::c_int;
    }
    #[doc = " Configuration for a publication that does not change during it's lifetime."]
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct aeron_publication_constants_stct {
        #[doc = " Media address for delivery to the channel.\n\n This returns a pointer only valid for the lifetime of the publication."]
        pub channel: *const ::std::os::raw::c_char,
        #[doc = " The registration used to register this Publication with the media driver by the first publisher."]
        pub original_registration_id: i64,
        #[doc = " Get the registration id used to register this Publication with the media driver.\n\n If this value is different from the original_registration_id then a previous active registration exists."]
        pub registration_id: i64,
        #[doc = " The maximum possible position this stream can reach due to its term buffer length.\n\n Maximum possible position is term-length times 2^31 in bytes."]
        pub max_possible_position: i64,
        #[doc = " Number of bits to right shift a position to get a term count for how far the stream has progressed."]
        pub position_bits_to_shift: usize,
        #[doc = " Get the length in bytes for each term partition in the log buffer."]
        pub term_buffer_length: usize,
        #[doc = " Maximum message length supported in bytes. Messages may be made of multiple fragments if greater than\n MTU length."]
        pub max_message_length: usize,
        #[doc = " Maximum length of a message payload that fits within a message fragment.\n\n This is he MTU length minus the message fragment header length."]
        pub max_payload_length: usize,
        #[doc = " Stream id of the publication."]
        pub stream_id: i32,
        #[doc = " Session id of the publication."]
        pub session_id: i32,
        #[doc = " The initial term id assigned when this publication was created. This can be used to determine how many\n terms have passed since creation."]
        pub initial_term_id: i32,
        #[doc = " Counter id for the publication limit."]
        pub publication_limit_counter_id: i32,
        #[doc = " Counter id for the channel status indicator"]
        pub channel_status_indicator_id: i32,
    }
    #[test]
    fn bindgen_test_layout_aeron_publication_constants_stct() {
        const UNINIT: ::std::mem::MaybeUninit<aeron_publication_constants_stct> =
            ::std::mem::MaybeUninit::uninit();
        let ptr = UNINIT.as_ptr();
        assert_eq!(
            ::std::mem::size_of::<aeron_publication_constants_stct>(),
            88usize,
            concat!("Size of: ", stringify!(aeron_publication_constants_stct))
        );
        assert_eq!(
            ::std::mem::align_of::<aeron_publication_constants_stct>(),
            8usize,
            concat!(
                "Alignment of ",
                stringify!(aeron_publication_constants_stct)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).channel) as usize - ptr as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(aeron_publication_constants_stct),
                "::",
                stringify!(channel)
            )
        );
        assert_eq!(
            unsafe {
                ::std::ptr::addr_of!((*ptr).original_registration_id) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(aeron_publication_constants_stct),
                "::",
                stringify!(original_registration_id)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).registration_id) as usize - ptr as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(aeron_publication_constants_stct),
                "::",
                stringify!(registration_id)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).max_possible_position) as usize - ptr as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(aeron_publication_constants_stct),
                "::",
                stringify!(max_possible_position)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).position_bits_to_shift) as usize - ptr as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(aeron_publication_constants_stct),
                "::",
                stringify!(position_bits_to_shift)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).term_buffer_length) as usize - ptr as usize },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(aeron_publication_constants_stct),
                "::",
                stringify!(term_buffer_length)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).max_message_length) as usize - ptr as usize },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(aeron_publication_constants_stct),
                "::",
                stringify!(max_message_length)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).max_payload_length) as usize - ptr as usize },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(aeron_publication_constants_stct),
                "::",
                stringify!(max_payload_length)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).stream_id) as usize - ptr as usize },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(aeron_publication_constants_stct),
                "::",
                stringify!(stream_id)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).session_id) as usize - ptr as usize },
            68usize,
            concat!(
                "Offset of field: ",
                stringify!(aeron_publication_constants_stct),
                "::",
                stringify!(session_id)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).initial_term_id) as usize - ptr as usize },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(aeron_publication_constants_stct),
                "::",
                stringify!(initial_term_id)
            )
        );
        assert_eq!(
            unsafe {
                ::std::ptr::addr_of!((*ptr).publication_limit_counter_id) as usize - ptr as usize
            },
            76usize,
            concat!(
                "Offset of field: ",
                stringify!(aeron_publication_constants_stct),
                "::",
                stringify!(publication_limit_counter_id)
            )
        );
        assert_eq!(
            unsafe {
                ::std::ptr::addr_of!((*ptr).channel_status_indicator_id) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(aeron_publication_constants_stct),
                "::",
                stringify!(channel_status_indicator_id)
            )
        );
    }
    #[doc = " Configuration for a publication that does not change during it's lifetime."]
    pub type aeron_publication_constants_t = root::aeron_publication_constants_stct;
    extern "C" {
        #[doc = " Non-blocking publish of a buffer containing a message.\n\n @param publication to publish on.\n @param buffer to publish.\n @param length of the buffer.\n @param reserved_value_supplier to use for setting the reserved value field or NULL.\n @param clientd to pass to the reserved_value_supplier.\n @return the new stream position otherwise a negative error value."]
        pub fn aeron_publication_offer(
            publication: *mut root::aeron_publication_t,
            buffer: *const u8,
            length: usize,
            reserved_value_supplier: root::aeron_reserved_value_supplier_t,
            clientd: *mut ::std::os::raw::c_void,
        ) -> i64;
    }
    extern "C" {
        #[doc = " Non-blocking publish by gathering buffer vectors into a message.\n\n @param publication to publish on.\n @param iov array for the vectors\n @param iovcnt of the number of vectors\n @param reserved_value_supplier to use for setting the reserved value field or NULL.\n @param clientd to pass to the reserved_value_supplier.\n @return the new stream position otherwise a negative error value."]
        pub fn aeron_publication_offerv(
            publication: *mut root::aeron_publication_t,
            iov: *mut root::aeron_iovec_t,
            iovcnt: usize,
            reserved_value_supplier: root::aeron_reserved_value_supplier_t,
            clientd: *mut ::std::os::raw::c_void,
        ) -> i64;
    }
    extern "C" {
        #[doc = " Try to claim a range in the publication log into which a message can be written with zero copy semantics.\n Once the message has been written then aeron_buffer_claim_commit should be called thus making it available.\n A claim length cannot be greater than max payload length.\n <p>\n <b>Note:</b> This method can only be used for message lengths less than MTU length minus header.\n If the claim is held for more than the aeron.publication.unblock.timeout system property then the driver will\n assume the publication thread is dead and will unblock the claim thus allowing other threads to make progress\n and other claims to be sent to reach end-of-stream (EOS).\n\n @code\n aeron_buffer_claim_t buffer_claim;\n\n if (aeron_publication_try_claim(publication, length, &buffer_claim) > 0L)\n {\n     // work with buffer_claim->data directly.\n     aeron_buffer_claim_commit(&buffer_claim);\n }\n @endcode\n\n @param publication to publish to.\n @param length of the message.\n @param buffer_claim to be populated if the claim succeeds.\n @return the new stream position otherwise a negative error value."]
        pub fn aeron_publication_try_claim(
            publication: *mut root::aeron_publication_t,
            length: usize,
            buffer_claim: *mut root::aeron_buffer_claim_t,
        ) -> i64;
    }
    extern "C" {
        #[doc = " Get the status of the media channel for this publication.\n <p>\n The status will be ERRORED (-1) if a socket exception occurs on setup and ACTIVE (1) if all is well.\n\n @param publication to check status of.\n @return 1 for ACTIVE, -1 for ERRORED"]
        pub fn aeron_publication_channel_status(publication: *mut root::aeron_publication_t)
            -> i64;
    }
    extern "C" {
        #[doc = " Has the publication closed?\n\n @param publication to check\n @return true if this publication is closed."]
        pub fn aeron_publication_is_closed(publication: *mut root::aeron_publication_t) -> bool;
    }
    extern "C" {
        #[doc = " Has the publication seen an active Subscriber recently?\n\n @param publication to check.\n @return true if this publication has recently seen an active subscriber otherwise false."]
        pub fn aeron_publication_is_connected(publication: *mut root::aeron_publication_t) -> bool;
    }
    extern "C" {
        #[doc = " Fill in a structure with the constants in use by a publication.\n\n @param publication to get the constants for.\n @param constants structure to fill in with the constants\n @return 0 for success and -1 for error."]
        pub fn aeron_publication_constants(
            publication: *mut root::aeron_publication_t,
            constants: *mut root::aeron_publication_constants_t,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Get the current position to which the publication has advanced for this stream.\n\n @param publication to query.\n @return the current position to which the publication has advanced for this stream or a negative error value."]
        pub fn aeron_publication_position(publication: *mut root::aeron_publication_t) -> i64;
    }
    extern "C" {
        #[doc = " Get the position limit beyond which this publication will be back pressured.\n\n This should only be used as a guide to determine when back pressure is likely to be applied.\n\n @param publication to query.\n @return the position limit beyond which this publication will be back pressured or a negative error value."]
        pub fn aeron_publication_position_limit(publication: *mut root::aeron_publication_t)
            -> i64;
    }
    extern "C" {
        #[doc = " Add a destination manually to a multi-destination-cast publication.\n\n @param async object to use for polling completion.\n @param publication to add destination to.\n @param uri for the destination to add.\n @return 0 for success and -1 for error."]
        pub fn aeron_publication_async_add_destination(
            async_: *mut *mut root::aeron_async_destination_t,
            client: *mut root::aeron_t,
            publication: *mut root::aeron_publication_t,
            uri: *const ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Remove a destination manually from a multi-destination-cast publication.\n\n @param async object to use for polling completion.\n @param publication to remove destination from.\n @param uri for the destination to remove.\n @return 0 for success and -1 for error."]
        pub fn aeron_publication_async_remove_destination(
            async_: *mut *mut root::aeron_async_destination_t,
            client: *mut root::aeron_t,
            publication: *mut root::aeron_publication_t,
            uri: *const ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Poll the completion of the add/remove of a destination to/from a publication.\n\n @param async to check for completion.\n @return 0 for not complete (try again), 1 for completed successfully, or -1 for an error."]
        pub fn aeron_publication_async_destination_poll(
            async_: *mut root::aeron_async_destination_t,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Add a destination manually to a multi-destination-cast exclusive publication.\n\n @param async object to use for polling completion.\n @param publication to add destination to.\n @param uri for the destination to add.\n @return 0 for success and -1 for error."]
        pub fn aeron_exclusive_publication_async_add_destination(
            async_: *mut *mut root::aeron_async_destination_t,
            client: *mut root::aeron_t,
            publication: *mut root::aeron_exclusive_publication_t,
            uri: *const ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Remove a destination manually from a multi-destination-cast exclusive publication.\n\n @param async object to use for polling completion.\n @param publication to remove destination from.\n @param uri for the destination to remove.\n @return 0 for success and -1 for error."]
        pub fn aeron_exclusive_publication_async_remove_destination(
            async_: *mut *mut root::aeron_async_destination_t,
            client: *mut root::aeron_t,
            publication: *mut root::aeron_exclusive_publication_t,
            uri: *const ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Poll the completion of the add/remove of a destination to/from an exclusive publication.\n\n @param async to check for completion.\n @return 0 for not complete (try again), 1 for completed successfully, or -1 for an error."]
        pub fn aeron_exclusive_publication_async_destination_poll(
            async_: *mut root::aeron_async_destination_t,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Asynchronously close the publication. Will callback on the on_complete notification when the subscription is closed.\n The callback is optional, use NULL for the on_complete callback if not required.\n\n @param publication to close\n @param on_close_complete optional callback to execute once the subscription has been closed and freed. This may\n happen on a separate thread, so the caller should ensure that clientd has the appropriate lifetime.\n @param on_close_complete_clientd parameter to pass to the on_complete callback.\n @return 0 for success or -1 for error."]
        pub fn aeron_publication_close(
            publication: *mut root::aeron_publication_t,
            on_close_complete: root::aeron_notification_t,
            on_close_complete_clientd: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Get the publication's channel\n\n @param publication this\n @return channel uri string"]
        pub fn aeron_publication_channel(
            publication: *mut root::aeron_publication_t,
        ) -> *const ::std::os::raw::c_char;
    }
    extern "C" {
        #[doc = " Get the publication's stream id\n\n @param publication this\n @return stream id"]
        pub fn aeron_publication_stream_id(publication: *mut root::aeron_publication_t) -> i32;
    }
    extern "C" {
        #[doc = " Get the publication's session id\n @param publication this\n @return session id"]
        pub fn aeron_publication_session_id(publication: *mut root::aeron_publication_t) -> i32;
    }
    extern "C" {
        #[doc = " Get all of the local socket addresses for this publication. Typically only one representing the control address.\n\n @param subscription to query\n @param address_vec to hold the received addresses\n @param address_vec_len available length of the vector to hold the addresses\n @return number of addresses found or -1 if there is an error.\n @see aeron_subscription_local_sockaddrs"]
        pub fn aeron_publication_local_sockaddrs(
            publication: *mut root::aeron_publication_t,
            address_vec: *mut root::aeron_iovec_t,
            address_vec_len: usize,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Non-blocking publish of a buffer containing a message.\n\n @param publication to publish on.\n @param buffer to publish.\n @param length of the buffer.\n @param reserved_value_supplier to use for setting the reserved value field or NULL.\n @param clientd to pass to the reserved_value_supplier.\n @return the new stream position otherwise a negative error value."]
        pub fn aeron_exclusive_publication_offer(
            publication: *mut root::aeron_exclusive_publication_t,
            buffer: *const u8,
            length: usize,
            reserved_value_supplier: root::aeron_reserved_value_supplier_t,
            clientd: *mut ::std::os::raw::c_void,
        ) -> i64;
    }
    extern "C" {
        #[doc = " Non-blocking publish by gathering buffer vectors into a message.\n\n @param publication to publish on.\n @param iov array for the vectors\n @param iovcnt of the number of vectors\n @param reserved_value_supplier to use for setting the reserved value field or NULL.\n @param clientd to pass to the reserved_value_supplier.\n @return the new stream position otherwise a negative error value."]
        pub fn aeron_exclusive_publication_offerv(
            publication: *mut root::aeron_exclusive_publication_t,
            iov: *mut root::aeron_iovec_t,
            iovcnt: usize,
            reserved_value_supplier: root::aeron_reserved_value_supplier_t,
            clientd: *mut ::std::os::raw::c_void,
        ) -> i64;
    }
    extern "C" {
        #[doc = " Try to claim a range in the publication log into which a message can be written with zero copy semantics.\n Once the message has been written then aeron_buffer_claim_commit should be called thus making it available.\n A claim length cannot be greater than max payload length.\n <p>\n <b>Note:</b> This method can only be used for message lengths less than MTU length minus header.\n\n @code\n aeron_buffer_claim_t buffer_claim;\n\n if (aeron_exclusive_publication_try_claim(publication, length, &buffer_claim) > 0L)\n {\n     // work with buffer_claim->data directly.\n     aeron_buffer_claim_commit(&buffer_claim);\n }\n @endcode\n\n @param publication to publish to.\n @param length of the message.\n @param buffer_claim to be populated if the claim succeeds.\n @return the new stream position otherwise a negative error value."]
        pub fn aeron_exclusive_publication_try_claim(
            publication: *mut root::aeron_exclusive_publication_t,
            length: usize,
            buffer_claim: *mut root::aeron_buffer_claim_t,
        ) -> i64;
    }
    extern "C" {
        #[doc = " Append a padding record log of a given length to make up the log to a position.\n\n @param length of the range to claim, in bytes.\n @return the new stream position otherwise a negative error value."]
        pub fn aeron_exclusive_publication_append_padding(
            publication: *mut root::aeron_exclusive_publication_t,
            length: usize,
        ) -> i64;
    }
    extern "C" {
        #[doc = " Offer a block of pre-formatted message fragments directly into the current term.\n\n @param buffer containing the pre-formatted block of message fragments.\n @param offset offset in the buffer at which the first fragment begins.\n @param length in bytes of the encoded block.\n @return the new stream position otherwise a negative error value."]
        pub fn aeron_exclusive_publication_offer_block(
            publication: *mut root::aeron_exclusive_publication_t,
            buffer: *const u8,
            length: usize,
        ) -> i64;
    }
    extern "C" {
        #[doc = " Get the status of the media channel for this publication.\n <p>\n The status will be ERRORED (-1) if a socket exception occurs on setup and ACTIVE (1) if all is well.\n\n @param publication to check status of.\n @return 1 for ACTIVE, -1 for ERRORED"]
        pub fn aeron_exclusive_publication_channel_status(
            publication: *mut root::aeron_exclusive_publication_t,
        ) -> i64;
    }
    extern "C" {
        #[doc = " Fill in a structure with the constants in use by a publication.\n\n @param publication to get the constants for.\n @param constants structure to fill in with the constants\n @return 0 for success and -1 for error."]
        pub fn aeron_exclusive_publication_constants(
            publication: *mut root::aeron_exclusive_publication_t,
            constants: *mut root::aeron_publication_constants_t,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Get the current position to which the publication has advanced for this stream.\n\n @param publication to query.\n @return the current position to which the publication has advanced for this stream or a negative error value."]
        pub fn aeron_exclusive_publication_position(
            publication: *mut root::aeron_exclusive_publication_t,
        ) -> i64;
    }
    extern "C" {
        #[doc = " Get the position limit beyond which this publication will be back pressured.\n\n This should only be used as a guide to determine when back pressure is likely to be applied.\n\n @param publication to query.\n @return the position limit beyond which this publication will be back pressured or a negative error value."]
        pub fn aeron_exclusive_publication_position_limit(
            publication: *mut root::aeron_exclusive_publication_t,
        ) -> i64;
    }
    extern "C" {
        #[doc = " Asynchronously close the publication.\n\n @param publication to close\n @return 0 for success or -1 for error."]
        pub fn aeron_exclusive_publication_close(
            publication: *mut root::aeron_exclusive_publication_t,
            on_close_complete: root::aeron_notification_t,
            on_close_complete_clientd: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Has the exclusive publication closed?\n\n @param publication to check\n @return true if this publication is closed."]
        pub fn aeron_exclusive_publication_is_closed(
            publication: *mut root::aeron_exclusive_publication_t,
        ) -> bool;
    }
    extern "C" {
        #[doc = " Has the exclusive publication seen an active Subscriber recently?\n\n @param publication to check.\n @return true if this publication has recently seen an active subscriber otherwise false."]
        pub fn aeron_exclusive_publication_is_connected(
            publication: *mut root::aeron_exclusive_publication_t,
        ) -> bool;
    }
    extern "C" {
        #[doc = " Get all of the local socket addresses for this exclusive publication. Typically only one representing the control\n address.\n\n @see aeron_subscription_local_sockaddrs\n @param subscription to query\n @param address_vec to hold the received addresses\n @param address_vec_len available length of the vector to hold the addresses\n @return number of addresses found or -1 if there is an error."]
        pub fn aeron_exclusive_publication_local_sockaddrs(
            publication: *mut root::aeron_exclusive_publication_t,
            address_vec: *mut root::aeron_iovec_t,
            address_vec_len: usize,
        ) -> ::std::os::raw::c_int;
    }
    #[doc = " Callback for handling fragments of data being read from a log.\n\n The frame will either contain a whole message or a fragment of a message to be reassembled. Messages are fragmented\n if greater than the frame for MTU in length.\n\n @param clientd passed to the poll function.\n @param buffer containing the data.\n @param length of the data in bytes.\n @param header representing the meta data for the data."]
    pub type aeron_fragment_handler_t = ::std::option::Option<
        unsafe extern "C" fn(
            clientd: *mut ::std::os::raw::c_void,
            buffer: *const u8,
            length: usize,
            header: *mut root::aeron_header_t,
        ),
    >;
    #[doc = " Abort the current polling operation and do not advance the position for this fragment."]
    pub const aeron_controlled_fragment_handler_action_en_AERON_ACTION_ABORT:
        root::aeron_controlled_fragment_handler_action_en = 1;
    #[doc = " Break from the current polling operation and commit the position as of the end of the current fragment\n being handled."]
    pub const aeron_controlled_fragment_handler_action_en_AERON_ACTION_BREAK:
        root::aeron_controlled_fragment_handler_action_en = 2;
    #[doc = " Continue processing but commit the position as of the end of the current fragment so that\n flow control is applied to this point."]
    pub const aeron_controlled_fragment_handler_action_en_AERON_ACTION_COMMIT:
        root::aeron_controlled_fragment_handler_action_en = 3;
    #[doc = " Continue processing until fragment limit or no fragments with position commit at end of poll as in\n aeron_fragment_handler_t."]
    pub const aeron_controlled_fragment_handler_action_en_AERON_ACTION_CONTINUE:
        root::aeron_controlled_fragment_handler_action_en = 4;
    pub type aeron_controlled_fragment_handler_action_en = ::std::os::raw::c_uint;
    pub use self::super::root::aeron_controlled_fragment_handler_action_en as aeron_controlled_fragment_handler_action_t;
    #[doc = " Callback for handling fragments of data being read from a log.\n\n Handler for reading data that is coming from a log buffer. The frame will either contain a whole message\n or a fragment of a message to be reassembled. Messages are fragmented if greater than the frame for MTU in length.\n\n @param clientd passed to the controlled poll function.\n @param buffer containing the data.\n @param length of the data in bytes.\n @param header representing the meta data for the data.\n @return The action to be taken with regard to the stream position after the callback."]
    pub type aeron_controlled_fragment_handler_t = ::std::option::Option<
        unsafe extern "C" fn(
            clientd: *mut ::std::os::raw::c_void,
            buffer: *const u8,
            length: usize,
            header: *mut root::aeron_header_t,
        ) -> root::aeron_controlled_fragment_handler_action_t,
    >;
    #[doc = " Callback for handling a block of messages being read from a log.\n\n @param clientd passed to the block poll function.\n @param buffer containing the block of message fragments.\n @param offset at which the block begins, including any frame headers.\n @param length of the block in bytes, including any frame headers that is aligned.\n @param session_id of the stream containing this block of message fragments.\n @param term_id of the stream containing this block of message fragments."]
    pub type aeron_block_handler_t = ::std::option::Option<
        unsafe extern "C" fn(
            clientd: *mut ::std::os::raw::c_void,
            buffer: *const u8,
            length: usize,
            session_id: i32,
            term_id: i32,
        ),
    >;
    extern "C" {
        #[doc = " Get all of the field values from the header. This will do a memcpy into the supplied header_values_t pointer.\n\n @param header to read values from.\n @param values to copy values to, must not be null.\n @return 0 on success, -1 on failure."]
        pub fn aeron_header_values(
            header: *mut root::aeron_header_t,
            values: *mut root::aeron_header_values_t,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Get the current position to which the Image has advanced on reading this message.\n\n @param header the current header message\n @return the current position to which the Image has advanced on reading this message."]
        pub fn aeron_header_position(header: *mut root::aeron_header_t) -> i64;
    }
    extern "C" {
        #[doc = " Get the number of times to left shift the term count to multiply by term length.\n\n @return number of times to left shift the term count to multiply by term length."]
        pub fn aeron_header_position_bits_to_shift(header: *mut root::aeron_header_t) -> usize;
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct aeron_subscription_constants_stct {
        #[doc = " Media address for delivery to the channel.\n\n This returns a pointer only valid for the lifetime of the subscription."]
        pub channel: *const ::std::os::raw::c_char,
        #[doc = " Callback used to indicate when an Image becomes available under this Subscription."]
        pub on_available_image: root::aeron_on_available_image_t,
        #[doc = " Callback used to indicate when an Image goes unavailable under this Subscription."]
        pub on_unavailable_image: root::aeron_on_unavailable_image_t,
        #[doc = " Return the registration id used to register this Subscription with the media driver."]
        pub registration_id: i64,
        #[doc = " Stream identity for scoping within the channel media address."]
        pub stream_id: i32,
        #[doc = " Counter id for the channel status indicator"]
        pub channel_status_indicator_id: i32,
    }
    #[test]
    fn bindgen_test_layout_aeron_subscription_constants_stct() {
        const UNINIT: ::std::mem::MaybeUninit<aeron_subscription_constants_stct> =
            ::std::mem::MaybeUninit::uninit();
        let ptr = UNINIT.as_ptr();
        assert_eq!(
            ::std::mem::size_of::<aeron_subscription_constants_stct>(),
            40usize,
            concat!("Size of: ", stringify!(aeron_subscription_constants_stct))
        );
        assert_eq!(
            ::std::mem::align_of::<aeron_subscription_constants_stct>(),
            8usize,
            concat!(
                "Alignment of ",
                stringify!(aeron_subscription_constants_stct)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).channel) as usize - ptr as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(aeron_subscription_constants_stct),
                "::",
                stringify!(channel)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).on_available_image) as usize - ptr as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(aeron_subscription_constants_stct),
                "::",
                stringify!(on_available_image)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).on_unavailable_image) as usize - ptr as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(aeron_subscription_constants_stct),
                "::",
                stringify!(on_unavailable_image)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).registration_id) as usize - ptr as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(aeron_subscription_constants_stct),
                "::",
                stringify!(registration_id)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).stream_id) as usize - ptr as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(aeron_subscription_constants_stct),
                "::",
                stringify!(stream_id)
            )
        );
        assert_eq!(
            unsafe {
                ::std::ptr::addr_of!((*ptr).channel_status_indicator_id) as usize - ptr as usize
            },
            36usize,
            concat!(
                "Offset of field: ",
                stringify!(aeron_subscription_constants_stct),
                "::",
                stringify!(channel_status_indicator_id)
            )
        );
    }
    pub type aeron_subscription_constants_t = root::aeron_subscription_constants_stct;
    extern "C" {
        #[doc = " Poll the images under the subscription for available message fragments.\n <p>\n Each fragment read will be a whole message if it is under MTU length. If larger than MTU then it will come\n as a series of fragments ordered within a session.\n <p>\n To assemble messages that span multiple fragments then use aeron_fragment_assembler_t.\n\n @param subscription to poll.\n @param handler for handling each message fragment as it is read.\n @param fragment_limit number of message fragments to limit when polling across multiple images.\n @return the number of fragments received or -1 for error."]
        pub fn aeron_subscription_poll(
            subscription: *mut root::aeron_subscription_t,
            handler: root::aeron_fragment_handler_t,
            clientd: *mut ::std::os::raw::c_void,
            fragment_limit: usize,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Poll in a controlled manner the images under the subscription for available message fragments.\n Control is applied to fragments in the stream. If more fragments can be read on another stream\n they will even if BREAK or ABORT is returned from the fragment handler.\n <p>\n Each fragment read will be a whole message if it is under MTU length. If larger than MTU then it will come\n as a series of fragments ordered within a session.\n <p>\n To assemble messages that span multiple fragments then use aeron_controlled_fragment_assembler_t.\n\n @param subscription to poll.\n @param handler for handling each message fragment as it is read.\n @param fragment_limit number of message fragments to limit when polling across multiple images.\n @return the number of fragments received or -1 for error."]
        pub fn aeron_subscription_controlled_poll(
            subscription: *mut root::aeron_subscription_t,
            handler: root::aeron_controlled_fragment_handler_t,
            clientd: *mut ::std::os::raw::c_void,
            fragment_limit: usize,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Poll the images under the subscription for available message fragments in blocks.\n <p>\n This method is useful for operations like bulk archiving and messaging indexing.\n\n @param subscription to poll.\n @param handler to receive a block of fragments from each image.\n @param block_length_limit for each image polled.\n @return the number of bytes consumed or -1 for error."]
        pub fn aeron_subscription_block_poll(
            subscription: *mut root::aeron_subscription_t,
            handler: root::aeron_block_handler_t,
            clientd: *mut ::std::os::raw::c_void,
            block_length_limit: usize,
        ) -> ::std::os::raw::c_long;
    }
    extern "C" {
        #[doc = " Is this subscription connected by having at least one open publication image.\n\n @param subscription to check.\n @return true if this subscription connected by having at least one open publication image."]
        pub fn aeron_subscription_is_connected(
            subscription: *mut root::aeron_subscription_t,
        ) -> bool;
    }
    extern "C" {
        #[doc = " Fill in a structure with the constants in use by a subscription.\n\n @param subscription to get the constants for.\n @param constants structure to fill in with the constants\n @return 0 for success and -1 for error."]
        pub fn aeron_subscription_constants(
            subscription: *mut root::aeron_subscription_t,
            constants: *mut root::aeron_subscription_constants_t,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Count of images associated to this subscription.\n\n @param subscription to count images for.\n @return count of count associated to this subscription or -1 for error."]
        pub fn aeron_subscription_image_count(
            subscription: *mut root::aeron_subscription_t,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Return the image associated with the given session_id under the given subscription.\n\n Note: the returned image is considered retained by the application and thus must be released via\n aeron_image_release when finished or if the image becomes unavailable.\n\n @param subscription to search.\n @param session_id associated with the image.\n @return image associated with the given session_id or NULL if no image exists."]
        pub fn aeron_subscription_image_by_session_id(
            subscription: *mut root::aeron_subscription_t,
            session_id: i32,
        ) -> *mut root::aeron_image_t;
    }
    extern "C" {
        #[doc = " Return the image at the given index.\n\n Note: the returned image is considered retained by the application and thus must be released via\n aeron_image_release when finished or if the image becomes unavailable.\n\n @param subscription to search.\n @param index for the image.\n @return image at the given index or NULL if no image exists."]
        pub fn aeron_subscription_image_at_index(
            subscription: *mut root::aeron_subscription_t,
            index: usize,
        ) -> *mut root::aeron_image_t;
    }
    extern "C" {
        #[doc = " Iterate over the images for this subscription calling the given function.\n\n @param subscription to iterate over.\n @param handler to be called for each image."]
        pub fn aeron_subscription_for_each_image(
            subscription: *mut root::aeron_subscription_t,
            handler: ::std::option::Option<
                unsafe extern "C" fn(
                    image: *mut root::aeron_image_t,
                    clientd: *mut ::std::os::raw::c_void,
                ),
            >,
            clientd: *mut ::std::os::raw::c_void,
        );
    }
    extern "C" {
        #[doc = " Retain the given image for access in the application.\n\n Note: A retain call must have a corresponding release call.\n Note: Subscriptions are not threadsafe and should not be shared between subscribers.\n\n @param subscription that image is part of.\n @param image to retain\n @return 0 for success and -1 for error."]
        pub fn aeron_subscription_image_retain(
            subscription: *mut root::aeron_subscription_t,
            image: *mut root::aeron_image_t,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Release the given image and relinquish desire to use the image directly.\n\n Note: Subscriptions are not threadsafe and should not be shared between subscribers.\n\n @param subscription that image is part of.\n @param image to release\n @return 0 for success and -1 for error."]
        pub fn aeron_subscription_image_release(
            subscription: *mut root::aeron_subscription_t,
            image: *mut root::aeron_image_t,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Is the subscription closed.\n\n @param subscription to be checked.\n @return true if it has been closed otherwise false."]
        pub fn aeron_subscription_is_closed(subscription: *mut root::aeron_subscription_t) -> bool;
    }
    extern "C" {
        #[doc = " Get the status of the media channel for this subscription.\n <p>\n The status will be ERRORED (-1) if a socket exception occurs on setup and ACTIVE (1) if all is well.\n\n @param subscription to check status of.\n @return 1 for ACTIVE, -1 for ERRORED"]
        pub fn aeron_subscription_channel_status(
            subscription: *mut root::aeron_subscription_t,
        ) -> i64;
    }
    extern "C" {
        #[doc = " Add a destination manually to a multi-destination-subscription.\n\n @param async object to use for polling completion.\n @param subscription to add destination to.\n @param uri for the destination to add.\n @return 0 for success and -1 for error."]
        pub fn aeron_subscription_async_add_destination(
            async_: *mut *mut root::aeron_async_destination_t,
            client: *mut root::aeron_t,
            subscription: *mut root::aeron_subscription_t,
            uri: *const ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Remove a destination manually from a multi-destination-subscription.\n\n @param async object to use for polling completion.\n @param subscription to remove destination from.\n @param uri for the destination to remove.\n @return 0 for success and -1 for error."]
        pub fn aeron_subscription_async_remove_destination(
            async_: *mut *mut root::aeron_async_destination_t,
            client: *mut root::aeron_t,
            subscription: *mut root::aeron_subscription_t,
            uri: *const ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Poll the completion of add/remove of a destination to/from a subscription.\n\n @param async to check for completion.\n @return 0 for not complete (try again), 1 for completed successfully, or -1 for an error."]
        pub fn aeron_subscription_async_destination_poll(
            async_: *mut root::aeron_async_destination_t,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Asynchronously close the subscription. Will callback on the on_complete notification when the subscription is\n closed. The callback is optional, use NULL for the on_complete callback if not required.\n\n @param subscription to close\n @param on_close_complete optional callback to execute once the subscription has been closed and freed. This may\n happen on a separate thread, so the caller should ensure that clientd has the appropriate lifetime.\n @param on_close_complete_clientd parameter to pass to the on_complete callback.\n @return 0 for success or -1 for error."]
        pub fn aeron_subscription_close(
            subscription: *mut root::aeron_subscription_t,
            on_close_complete: root::aeron_notification_t,
            on_close_complete_clientd: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Get all of the local socket addresses for this subscription. Multiple addresses can occur if this is a\n multi-destination subscription. Addresses will a string representation in numeric form. IPv6 addresses will be\n surrounded by '[' and ']' so that the ':' that separate the parts are distinguishable from the port delimiter.\n E.g. [fe80::7552:c06e:6bf4:4160]:12345. As of writing the maximum length for a formatted address is 54 bytes\n including the NULL terminator. AERON_CLIENT_MAX_LOCAL_ADDRESS_STR_LEN is defined to provide enough space to fit the\n returned string. Returned strings will be NULL terminated. If the buffer to hold the address can not hold enough\n of the message it will be truncated and the last character will be null.\n\n If the address_vec_len is less the total number of addresses available then the first addresses found up to that\n length will be placed into the address_vec. However the function will return the total number of addresses available\n so if if that is larger than the input array then the client code may wish to re-query with a larger array to get\n them all.\n\n @param subscription to query\n @param address_vec to hold the received addresses\n @param address_vec_len available length of the vector to hold the addresses\n @return number of addresses found or -1 if there is an error."]
        pub fn aeron_subscription_local_sockaddrs(
            subscription: *mut root::aeron_subscription_t,
            address_vec: *mut root::aeron_iovec_t,
            address_vec_len: usize,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Retrieves the first local socket address for this subscription. If this is not MDS then it will be the one\n representing endpoint for this subscription.\n\n @see aeron_subscription_local_sockaddrs\n @param subscription to query\n @param address for the received address\n @param address_len available length for the copied address.\n @return -1 on error, 0 if address not found, 1 if address is found."]
        pub fn aeron_subscription_resolved_endpoint(
            subscription: *mut root::aeron_subscription_t,
            address: *const ::std::os::raw::c_char,
            address_len: usize,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Retrieves the channel URI for this subscription with any wildcard ports filled in. If the channel is not UDP or\n does not have a wildcard port (`0`), then it will return the original URI.\n\n @param subscription to query\n @param uri buffer to hold the resolved uri\n @param uri_len length of the buffer\n @return -1 on failure or the number of bytes written to the buffer (excluding the NULL terminator). Writing is done\n on a per key basis, so if the buffer was truncated before writing completed, it will only include the byte count up\n to the key that overflowed. However, the invariant that if the number returned >= uri_len, then output will have been\n truncated."]
        pub fn aeron_subscription_try_resolve_channel_endpoint_port(
            subscription: *mut root::aeron_subscription_t,
            uri: *mut ::std::os::raw::c_char,
            uri_len: usize,
        ) -> ::std::os::raw::c_int;
    }
    #[doc = " Configuration for an image that does not change during it's lifetime."]
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct aeron_image_constants_stct {
        #[doc = " The subscription to which this image belongs."]
        pub subscription: *mut root::aeron_subscription_t,
        #[doc = " The source identity of the sending publisher as an abstract concept appropriate for the media."]
        pub source_identity: *const ::std::os::raw::c_char,
        #[doc = " The correlationId for identification of the image with the media driver."]
        pub correlation_id: i64,
        #[doc = " Get the position the subscriber joined this stream at."]
        pub join_position: i64,
        #[doc = " Number of bits to right shift a position to get a term count for how far the stream has progressed."]
        pub position_bits_to_shift: usize,
        #[doc = " Get the length in bytes for each term partition in the log buffer."]
        pub term_buffer_length: usize,
        #[doc = " The length in bytes of the MTU (Maximum Transmission Unit) the Sender used for the datagram."]
        pub mtu_length: usize,
        #[doc = " The sessionId for the steam of messages. Sessions are unique within a subscription and unique across\n all publications from a source identity."]
        pub session_id: i32,
        #[doc = " The initial term at which the stream started for this session."]
        pub initial_term_id: i32,
        #[doc = " Counter id that refers to the subscriber position for this image."]
        pub subscriber_position_id: i32,
    }
    #[test]
    fn bindgen_test_layout_aeron_image_constants_stct() {
        const UNINIT: ::std::mem::MaybeUninit<aeron_image_constants_stct> =
            ::std::mem::MaybeUninit::uninit();
        let ptr = UNINIT.as_ptr();
        assert_eq!(
            ::std::mem::size_of::<aeron_image_constants_stct>(),
            72usize,
            concat!("Size of: ", stringify!(aeron_image_constants_stct))
        );
        assert_eq!(
            ::std::mem::align_of::<aeron_image_constants_stct>(),
            8usize,
            concat!("Alignment of ", stringify!(aeron_image_constants_stct))
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).subscription) as usize - ptr as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(aeron_image_constants_stct),
                "::",
                stringify!(subscription)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).source_identity) as usize - ptr as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(aeron_image_constants_stct),
                "::",
                stringify!(source_identity)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).correlation_id) as usize - ptr as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(aeron_image_constants_stct),
                "::",
                stringify!(correlation_id)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).join_position) as usize - ptr as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(aeron_image_constants_stct),
                "::",
                stringify!(join_position)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).position_bits_to_shift) as usize - ptr as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(aeron_image_constants_stct),
                "::",
                stringify!(position_bits_to_shift)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).term_buffer_length) as usize - ptr as usize },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(aeron_image_constants_stct),
                "::",
                stringify!(term_buffer_length)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).mtu_length) as usize - ptr as usize },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(aeron_image_constants_stct),
                "::",
                stringify!(mtu_length)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).session_id) as usize - ptr as usize },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(aeron_image_constants_stct),
                "::",
                stringify!(session_id)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).initial_term_id) as usize - ptr as usize },
            60usize,
            concat!(
                "Offset of field: ",
                stringify!(aeron_image_constants_stct),
                "::",
                stringify!(initial_term_id)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).subscriber_position_id) as usize - ptr as usize },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(aeron_image_constants_stct),
                "::",
                stringify!(subscriber_position_id)
            )
        );
    }
    #[doc = " Configuration for an image that does not change during it's lifetime."]
    pub type aeron_image_constants_t = root::aeron_image_constants_stct;
    extern "C" {
        #[doc = " Fill in a structure with the constants in use by a image.\n\n @param image to get the constants for.\n @param constants structure to fill in with the constants\n @return 0 for success and -1 for error."]
        pub fn aeron_image_constants(
            image: *mut root::aeron_image_t,
            constants: *mut root::aeron_image_constants_t,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " The position this image has been consumed to by the subscriber.\n\n @param image to query position of.\n @return the position this image has been consumed to by the subscriber."]
        pub fn aeron_image_position(image: *mut root::aeron_image_t) -> i64;
    }
    extern "C" {
        #[doc = " Set the subscriber position for this image to indicate where it has been consumed to.\n\n @param image to set the position of.\n @param new_position for the consumption point."]
        pub fn aeron_image_set_position(
            image: *mut root::aeron_image_t,
            position: i64,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Is the current consumed position at the end of the stream?\n\n @param image to check.\n @return true if at the end of the stream or false if not."]
        pub fn aeron_image_is_end_of_stream(image: *mut root::aeron_image_t) -> bool;
    }
    extern "C" {
        #[doc = " Count of observed active transports within the image liveness timeout.\n\n If the image is closed, then this is 0. This may also be 0 if no actual datagrams have arrived. IPC\n Images also will be 0.\n\n @param image to check.\n @return count of active transports - 0 if Image is closed, no datagrams yet, or IPC. Or -1 for error."]
        pub fn aeron_image_active_transport_count(
            image: *mut root::aeron_image_t,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Poll for new messages in a stream. If new messages are found beyond the last consumed position then they\n will be delivered to the handler up to a limited number of fragments as specified.\n <p>\n Use a fragment assembler to assemble messages which span multiple fragments.\n\n @param image to poll.\n @param handler to which message fragments are delivered.\n @param clientd to pass to the handler.\n @param fragment_limit for the number of fragments to be consumed during one polling operation.\n @return the number of fragments that have been consumed or -1 for error."]
        pub fn aeron_image_poll(
            image: *mut root::aeron_image_t,
            handler: root::aeron_fragment_handler_t,
            clientd: *mut ::std::os::raw::c_void,
            fragment_limit: usize,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Poll for new messages in a stream. If new messages are found beyond the last consumed position then they\n will be delivered to the handler up to a limited number of fragments as specified.\n <p>\n Use a controlled fragment assembler to assemble messages which span multiple fragments.\n\n @param image to poll.\n @param handler to which message fragments are delivered.\n @param clientd to pass to the handler.\n @param fragment_limit for the number of fragments to be consumed during one polling operation.\n @return the number of fragments that have been consumed or -1 for error."]
        pub fn aeron_image_controlled_poll(
            image: *mut root::aeron_image_t,
            handler: root::aeron_controlled_fragment_handler_t,
            clientd: *mut ::std::os::raw::c_void,
            fragment_limit: usize,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Poll for new messages in a stream. If new messages are found beyond the last consumed position then they\n will be delivered to the handler up to a limited number of fragments as specified or the maximum position specified.\n <p>\n Use a fragment assembler to assemble messages which span multiple fragments.\n\n @param image to poll.\n @param handler to which message fragments are delivered.\n @param clientd to pass to the handler.\n @param limit_position to consume messages up to.\n @param fragment_limit for the number of fragments to be consumed during one polling operation.\n @return the number of fragments that have been consumed or -1 for error."]
        pub fn aeron_image_bounded_poll(
            image: *mut root::aeron_image_t,
            handler: root::aeron_fragment_handler_t,
            clientd: *mut ::std::os::raw::c_void,
            limit_position: i64,
            fragment_limit: usize,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Poll for new messages in a stream. If new messages are found beyond the last consumed position then they\n will be delivered to the handler up to a limited number of fragments as specified or the maximum position specified.\n <p>\n Use a controlled fragment assembler to assemble messages which span multiple fragments.\n\n @param image to poll.\n @param handler to which message fragments are delivered.\n @param clientd to pass to the handler.\n @param limit_position to consume messages up to.\n @param fragment_limit for the number of fragments to be consumed during one polling operation.\n @return the number of fragments that have been consumed or -1 for error."]
        pub fn aeron_image_bounded_controlled_poll(
            image: *mut root::aeron_image_t,
            handler: root::aeron_controlled_fragment_handler_t,
            clientd: *mut ::std::os::raw::c_void,
            limit_position: i64,
            fragment_limit: usize,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Peek for new messages in a stream by scanning forward from an initial position. If new messages are found then\n they will be delivered to the handler up to a limited position.\n <p>\n Use a controlled fragment assembler to assemble messages which span multiple fragments. Scans must also\n start at the beginning of a message so that the assembler is reset.\n\n @param image to peek.\n @param initial_position from which to peek forward.\n @param handler to which message fragments are delivered.\n @param clientd to pass to the handler.\n @param limit_position up to which can be scanned.\n @return the resulting position after the scan terminates which is a complete message or -1 for error."]
        pub fn aeron_image_controlled_peek(
            image: *mut root::aeron_image_t,
            initial_position: i64,
            handler: root::aeron_controlled_fragment_handler_t,
            clientd: *mut ::std::os::raw::c_void,
            limit_position: i64,
        ) -> i64;
    }
    extern "C" {
        #[doc = " Poll for new messages in a stream. If new messages are found beyond the last consumed position then they\n will be delivered to the handler up to a limited number of bytes.\n <p>\n A scan will terminate if a padding frame is encountered. If first frame in a scan is padding then a block\n for the padding is notified. If the padding comes after the first frame in a scan then the scan terminates\n at the offset the padding frame begins. Padding frames are delivered singularly in a block.\n <p>\n Padding frames may be for a greater range than the limit offset but only the header needs to be valid so\n relevant length of the frame is data header length.\n\n @param image to poll.\n @param handler to which block is delivered.\n @param clientd to pass to the handler.\n @param block_length_limit up to which a block may be in length.\n @return the number of bytes that have been consumed or -1 for error."]
        pub fn aeron_image_block_poll(
            image: *mut root::aeron_image_t,
            handler: root::aeron_block_handler_t,
            clientd: *mut ::std::os::raw::c_void,
            block_length_limit: usize,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn aeron_image_is_closed(image: *mut root::aeron_image_t) -> bool;
    }
    extern "C" {
        #[doc = " Create an image fragment assembler for use with a single image.\n\n @param assembler to be set when created successfully.\n @param delegate to call on completed.\n @param delegate_clientd to pass to delegate handler.\n @return 0 for success and -1 for error."]
        pub fn aeron_image_fragment_assembler_create(
            assembler: *mut *mut root::aeron_image_fragment_assembler_t,
            delegate: root::aeron_fragment_handler_t,
            delegate_clientd: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Delete an image fragment assembler.\n\n @param assembler to delete.\n @return 0 for success or -1 for error."]
        pub fn aeron_image_fragment_assembler_delete(
            assembler: *mut root::aeron_image_fragment_assembler_t,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Handler function to be passed for handling fragment assembly.\n\n @param clientd passed in the poll call (must be a aeron_image_fragment_assembler_t)\n @param buffer containing the data.\n @param length of the data in bytes.\n @param header representing the meta data for the data."]
        pub fn aeron_image_fragment_assembler_handler(
            clientd: *mut ::std::os::raw::c_void,
            buffer: *const u8,
            length: usize,
            header: *mut root::aeron_header_t,
        );
    }
    extern "C" {
        #[doc = " Create an image controlled fragment assembler for use with a single image.\n\n @param assembler to be set when created successfully.\n @param delegate to call on completed\n @param delegate_clientd to pass to delegate handler.\n @return 0 for success and -1 for error."]
        pub fn aeron_image_controlled_fragment_assembler_create(
            assembler: *mut *mut root::aeron_image_controlled_fragment_assembler_t,
            delegate: root::aeron_controlled_fragment_handler_t,
            delegate_clientd: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Delete an image controlled fragment assembler.\n\n @param assembler to delete.\n @return 0 for success or -1 for error."]
        pub fn aeron_image_controlled_fragment_assembler_delete(
            assembler: *mut root::aeron_image_controlled_fragment_assembler_t,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Handler function to be passed for handling fragment assembly.\n\n @param clientd passed in the poll call (must be a aeron_image_controlled_fragment_assembler_t)\n @param buffer containing the data.\n @param length of the data in bytes.\n @param header representing the meta data for the data.\n @return The action to be taken with regard to the stream position after the callback."]
        pub fn aeron_controlled_image_fragment_assembler_handler(
            clientd: *mut ::std::os::raw::c_void,
            buffer: *const u8,
            length: usize,
            header: *mut root::aeron_header_t,
        ) -> root::aeron_controlled_fragment_handler_action_t;
    }
    extern "C" {
        #[doc = " Create a fragment assembler for use with a subscription.\n\n @param assembler to be set when created successfully.\n @param delegate to call on completed\n @param delegate_clientd to pass to delegate handler.\n @return 0 for success and -1 for error."]
        pub fn aeron_fragment_assembler_create(
            assembler: *mut *mut root::aeron_fragment_assembler_t,
            delegate: root::aeron_fragment_handler_t,
            delegate_clientd: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Delete a fragment assembler.\n\n @param assembler to delete.\n @return 0 for success or -1 for error."]
        pub fn aeron_fragment_assembler_delete(
            assembler: *mut root::aeron_fragment_assembler_t,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Handler function to be passed for handling fragment assembly.\n\n @param clientd passed in the poll call (must be a aeron_fragment_assembler_t)\n @param buffer containing the data.\n @param length of the data in bytes.\n @param header representing the meta data for the data."]
        pub fn aeron_fragment_assembler_handler(
            clientd: *mut ::std::os::raw::c_void,
            buffer: *const u8,
            length: usize,
            header: *mut root::aeron_header_t,
        );
    }
    extern "C" {
        #[doc = " Create a controlled fragment assembler for use with a subscription.\n\n @param assembler to be set when created successfully.\n @param delegate to call on completed\n @param delegate_clientd to pass to delegate handler.\n @return 0 for success and -1 for error."]
        pub fn aeron_controlled_fragment_assembler_create(
            assembler: *mut *mut root::aeron_controlled_fragment_assembler_t,
            delegate: root::aeron_controlled_fragment_handler_t,
            delegate_clientd: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Delete a controlled fragment assembler.\n\n @param assembler to delete.\n @return 0 for success or -1 for error."]
        pub fn aeron_controlled_fragment_assembler_delete(
            assembler: *mut root::aeron_controlled_fragment_assembler_t,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Handler function to be passed for handling fragment assembly.\n\n @param clientd passed in the poll call (must be a aeron_controlled_fragment_assembler_t)\n @param buffer containing the data.\n @param length of the data in bytes.\n @param header representing the meta data for the data.\n @return The action to be taken with regard to the stream position after the callback."]
        pub fn aeron_controlled_fragment_assembler_handler(
            clientd: *mut ::std::os::raw::c_void,
            buffer: *const u8,
            length: usize,
            header: *mut root::aeron_header_t,
        ) -> root::aeron_controlled_fragment_handler_action_t;
    }
    extern "C" {
        #[doc = " Return a pointer to the counter value.\n\n @param counter to pointer to.\n @return pointer to the counter value."]
        pub fn aeron_counter_addr(counter: *mut root::aeron_counter_t) -> *mut i64;
    }
    #[doc = " Configuration for a counter that does not change during it's lifetime."]
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct aeron_counter_constants_stct {
        #[doc = " Return the registration id used to register this counter with the media driver."]
        pub registration_id: i64,
        #[doc = " Identity for the counter within the counters reader and counters manager."]
        pub counter_id: i32,
    }
    #[test]
    fn bindgen_test_layout_aeron_counter_constants_stct() {
        const UNINIT: ::std::mem::MaybeUninit<aeron_counter_constants_stct> =
            ::std::mem::MaybeUninit::uninit();
        let ptr = UNINIT.as_ptr();
        assert_eq!(
            ::std::mem::size_of::<aeron_counter_constants_stct>(),
            16usize,
            concat!("Size of: ", stringify!(aeron_counter_constants_stct))
        );
        assert_eq!(
            ::std::mem::align_of::<aeron_counter_constants_stct>(),
            8usize,
            concat!("Alignment of ", stringify!(aeron_counter_constants_stct))
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).registration_id) as usize - ptr as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(aeron_counter_constants_stct),
                "::",
                stringify!(registration_id)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).counter_id) as usize - ptr as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(aeron_counter_constants_stct),
                "::",
                stringify!(counter_id)
            )
        );
    }
    #[doc = " Configuration for a counter that does not change during it's lifetime."]
    pub type aeron_counter_constants_t = root::aeron_counter_constants_stct;
    extern "C" {
        #[doc = " Fill in a structure with the constants in use by a counter.\n\n @param counter to get the constants for.\n @param constants structure to fill in with the constants.\n @return 0 for success and -1 for error."]
        pub fn aeron_counter_constants(
            counter: *mut root::aeron_counter_t,
            constants: *mut root::aeron_counter_constants_t,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Asynchronously close the counter.\n\n @param counter to close.\n @return 0 for success or -1 for error."]
        pub fn aeron_counter_close(
            counter: *mut root::aeron_counter_t,
            on_close_complete: root::aeron_notification_t,
            on_close_complete_clientd: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Check if the counter is closed\n @param counter to check\n @return true if closed, false otherwise."]
        pub fn aeron_counter_is_closed(counter: *mut root::aeron_counter_t) -> bool;
    }
    extern "C" {
        #[doc = " Return full version and build string.\n\n @return full version and build string."]
        pub fn aeron_version_full() -> *const ::std::os::raw::c_char;
    }
    extern "C" {
        #[doc = " Return major version number.\n\n @return major version number."]
        pub fn aeron_version_major() -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Return minor version number.\n\n @return minor version number."]
        pub fn aeron_version_minor() -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Return patch version number.\n\n @return patch version number."]
        pub fn aeron_version_patch() -> ::std::os::raw::c_int;
    }
    #[doc = " Clock function used by aeron."]
    pub type aeron_clock_func_t = ::std::option::Option<unsafe extern "C" fn() -> i64>;
    extern "C" {
        #[doc = " Return time in nanoseconds for machine. Is not wall clock time.\n\n @return nanoseconds since epoch for machine."]
        pub fn aeron_nano_clock() -> i64;
    }
    extern "C" {
        #[doc = " Return time in milliseconds since epoch. Is wall clock time.\n\n @return milliseconds since epoch."]
        pub fn aeron_epoch_clock() -> i64;
    }
    #[doc = " Function to return logging information."]
    pub type aeron_log_func_t =
        ::std::option::Option<unsafe extern "C" fn(arg1: *const ::std::os::raw::c_char)>;
    extern "C" {
        #[doc = " Determine if an aeron driver is using a given aeron directory.\n\n @param dirname  for aeron directory\n @param timeout_ms  to use to determine activity for aeron directory\n @param log_func to call during activity check to log diagnostic information.\n @return true for active driver or false for no active driver."]
        pub fn aeron_is_driver_active(
            dirname: *const ::std::os::raw::c_char,
            timeout_ms: i64,
            log_func: root::aeron_log_func_t,
        ) -> bool;
    }
    extern "C" {
        #[doc = " Load properties from a string containing name=value pairs and set appropriate environment variables for the\n process so that subsequent calls to aeron_driver_context_init will use those values.\n\n @param buffer containing properties and values.\n @return 0 for success and -1 for error."]
        pub fn aeron_properties_buffer_load(
            buffer: *const ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Load properties file and set appropriate environment variables for the process so that subsequent\n calls to aeron_driver_context_init will use those values.\n\n @param filename to load.\n @return 0 for success and -1 for error."]
        pub fn aeron_properties_file_load(
            filename: *const ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Load properties from HTTP URL and set environment variables for the process so that subsequent\n calls to aeron_driver_context_init will use those values.\n\n @param url to attempt to retrieve and load.\n @return 0 for success and -1 for error."]
        pub fn aeron_properties_http_load(
            url: *const ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Load properties based on URL or filename. If string contains file or http URL, it will attempt\n to load properties from a file or http as indicated. If not a URL, then it will try to load the string\n as a filename.\n\n @param url_or_filename to load properties from.\n @return 0 for success and -1 for error."]
        pub fn aeron_properties_load(
            url_or_filename: *const ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Return current aeron error code (errno) for calling thread.\n\n @return aeron error code for calling thread."]
        pub fn aeron_errcode() -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Return the current aeron error message for calling thread.\n\n @return aeron error message for calling thread."]
        pub fn aeron_errmsg() -> *const ::std::os::raw::c_char;
    }
    extern "C" {
        #[doc = " Get the default path used by the Aeron media driver.\n\n @param path buffer to store the path.\n @param path_length space available in the buffer\n @return -1 if there is an issue or the number of bytes written to path excluding the terminator `\\0`. If this\n is equal to or greater than the path_length then the path has been truncated."]
        pub fn aeron_default_path(
            path: *mut ::std::os::raw::c_char,
            path_length: usize,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Gets the registration id for addition of the counter. Note that using this after a call to poll the succeeds or\n errors is undefined behaviour. As the async_add_counter_t may have been freed.\n\n @param add_counter used to check for completion.\n @return registration id for the counter."]
        pub fn aeron_async_add_counter_get_registration_id(
            add_counter: *mut root::aeron_async_add_counter_t,
        ) -> i64;
    }
    extern "C" {
        #[doc = " Gets the registration id for addition of the publication. Note that using this after a call to poll the succeeds or\n errors is undefined behaviour. As the async_add_publication_t may have been freed.\n\n @param add_publication used to check for completion.\n @return registration id for the publication."]
        pub fn aeron_async_add_publication_get_registration_id(
            add_publication: *mut root::aeron_async_add_publication_t,
        ) -> i64;
    }
    extern "C" {
        #[doc = " Gets the registration id for addition of the exclusive_publication. Note that using this after a call to poll the\n succeeds or errors is undefined behaviour. As the async_add_exclusive_publication_t may have been freed.\n\n @param add_exclusive_publication used to check for completion.\n @return registration id for the exclusive_publication."]
        pub fn aeron_async_add_exclusive_exclusive_publication_get_registration_id(
            add_exclusive_publication: *mut root::aeron_async_add_exclusive_publication_t,
        ) -> i64;
    }
    extern "C" {
        #[doc = " Gets the registration id for addition of the subscription. Note that using this after a call to poll the succeeds or\n errors is undefined behaviour. As the async_add_subscription_t may have been freed.\n\n @param add_subscription used to check for completion.\n @return registration id for the subscription."]
        pub fn aeron_async_add_subscription_get_registration_id(
            add_subscription: *mut root::aeron_async_add_subscription_t,
        ) -> i64;
    }
    extern "C" {
        #[doc = " Gets the registration_id for the destination command supplied. Note that this is the correlation_id used for\n the specified destination command, not the registration_id for the original parent resource (publication,\n subscription).\n\n @param async_destination tracking the current destination command.\n @return correlation_id sent to driver."]
        pub fn aeron_async_destination_get_registration_id(
            async_destination: *mut root::aeron_async_destination_t,
        ) -> i64;
    }
    extern "C" {
        #[doc = " Request the media driver terminates operation and closes all resources.\n\n @param directory    in which the media driver is running.\n @param token_buffer containing the authentication token confirming the client is allowed to terminate the driver.\n @param token_length of the token in the buffer.\n @return"]
        pub fn aeron_context_request_driver_termination(
            directory: *const ::std::os::raw::c_char,
            token_buffer: *const u8,
            token_length: usize,
        ) -> ::std::os::raw::c_int;
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct aeron_cnc_stct {
        _unused: [u8; 0],
    }
    pub type aeron_cnc_t = root::aeron_cnc_stct;
    #[repr(C, packed(4))]
    #[derive(Copy, Clone)]
    pub struct aeron_cnc_constants_stct {
        pub cnc_version: i32,
        pub to_driver_buffer_length: i32,
        pub to_clients_buffer_length: i32,
        pub counter_metadata_buffer_length: i32,
        pub counter_values_buffer_length: i32,
        pub error_log_buffer_length: i32,
        pub client_liveness_timeout: i64,
        pub start_timestamp: i64,
        pub pid: i64,
    }
    #[test]
    fn bindgen_test_layout_aeron_cnc_constants_stct() {
        const UNINIT: ::std::mem::MaybeUninit<aeron_cnc_constants_stct> =
            ::std::mem::MaybeUninit::uninit();
        let ptr = UNINIT.as_ptr();
        assert_eq!(
            ::std::mem::size_of::<aeron_cnc_constants_stct>(),
            48usize,
            concat!("Size of: ", stringify!(aeron_cnc_constants_stct))
        );
        assert_eq!(
            ::std::mem::align_of::<aeron_cnc_constants_stct>(),
            4usize,
            concat!("Alignment of ", stringify!(aeron_cnc_constants_stct))
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).cnc_version) as usize - ptr as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(aeron_cnc_constants_stct),
                "::",
                stringify!(cnc_version)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).to_driver_buffer_length) as usize - ptr as usize },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(aeron_cnc_constants_stct),
                "::",
                stringify!(to_driver_buffer_length)
            )
        );
        assert_eq!(
            unsafe {
                ::std::ptr::addr_of!((*ptr).to_clients_buffer_length) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(aeron_cnc_constants_stct),
                "::",
                stringify!(to_clients_buffer_length)
            )
        );
        assert_eq!(
            unsafe {
                ::std::ptr::addr_of!((*ptr).counter_metadata_buffer_length) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(aeron_cnc_constants_stct),
                "::",
                stringify!(counter_metadata_buffer_length)
            )
        );
        assert_eq!(
            unsafe {
                ::std::ptr::addr_of!((*ptr).counter_values_buffer_length) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(aeron_cnc_constants_stct),
                "::",
                stringify!(counter_values_buffer_length)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).error_log_buffer_length) as usize - ptr as usize },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(aeron_cnc_constants_stct),
                "::",
                stringify!(error_log_buffer_length)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).client_liveness_timeout) as usize - ptr as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(aeron_cnc_constants_stct),
                "::",
                stringify!(client_liveness_timeout)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).start_timestamp) as usize - ptr as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(aeron_cnc_constants_stct),
                "::",
                stringify!(start_timestamp)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).pid) as usize - ptr as usize },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(aeron_cnc_constants_stct),
                "::",
                stringify!(pid)
            )
        );
    }
    pub type aeron_cnc_constants_t = root::aeron_cnc_constants_stct;
    extern "C" {
        #[doc = " Initialise an aeron_cnc, which gives user level access to the command and control file used to communicate\n with the media driver. Will wait until the media driver has loaded and the cnc file is created, up to timeout_ms.\n Use a value of 0 for a non-blocking initialisation.\n\n @param aeron_cnc to hold the loaded aeron_cnc\n @param base_path media driver's base path\n @param timeout_ms Number of milliseconds to wait before timing out.\n @return 0 on success, -1 on failure."]
        pub fn aeron_cnc_init(
            aeron_cnc: *mut *mut root::aeron_cnc_t,
            base_path: *const ::std::os::raw::c_char,
            timeout_ms: i64,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Fetch the sets of constant values associated with this command and control file.\n\n @param aeron_cnc to query\n @param constants user supplied structure to hold return values.\n @return 0 on success, -1 on failure."]
        pub fn aeron_cnc_constants(
            aeron_cnc: *mut root::aeron_cnc_t,
            constants: *mut root::aeron_cnc_constants_t,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Get the current file name of the cnc file.\n\n @param aeron_cnc to query\n @return name of the cnc file"]
        pub fn aeron_cnc_filename(
            aeron_cnc: *mut root::aeron_cnc_t,
        ) -> *const ::std::os::raw::c_char;
    }
    extern "C" {
        #[doc = " Gets the timestamp of the last heartbeat sent to the media driver from any client.\n\n @param aeron_cnc to query\n @return last heartbeat timestamp in ms."]
        pub fn aeron_cnc_to_driver_heartbeat(aeron_cnc: *mut root::aeron_cnc_t) -> i64;
    }
    pub type aeron_error_log_reader_func_t = ::std::option::Option<
        unsafe extern "C" fn(
            observation_count: i32,
            first_observation_timestamp: i64,
            last_observation_timestamp: i64,
            error: *const ::std::os::raw::c_char,
            error_length: usize,
            clientd: *mut ::std::os::raw::c_void,
        ),
    >;
    extern "C" {
        #[doc = " Reads the current error log for this driver.\n\n @param aeron_cnc to query\n @param callback called for every distinct error observation\n @param clientd client data to be passed to the callback\n @param since_timestamp only return errors after this timestamp (0 returns all)\n @return the number of distinct errors seen"]
        pub fn aeron_cnc_error_log_read(
            aeron_cnc: *mut root::aeron_cnc_t,
            callback: root::aeron_error_log_reader_func_t,
            clientd: *mut ::std::os::raw::c_void,
            since_timestamp: i64,
        ) -> usize;
    }
    extern "C" {
        #[doc = " Gets a counters reader for this command and control file. This does not need to be closed manually, resources\n are tied to the instance of aeron_cnc.\n\n @param aeron_cnc to query\n @return pointer to a counters reader."]
        pub fn aeron_cnc_counters_reader(
            aeron_cnc: *mut root::aeron_cnc_t,
        ) -> *mut root::aeron_counters_reader_t;
    }
    pub type aeron_loss_reporter_read_entry_func_t = ::std::option::Option<
        unsafe extern "C" fn(
            clientd: *mut ::std::os::raw::c_void,
            observation_count: i64,
            total_bytes_lost: i64,
            first_observation_timestamp: i64,
            last_observation_timestamp: i64,
            session_id: i32,
            stream_id: i32,
            channel: *const ::std::os::raw::c_char,
            channel_length: i32,
            source: *const ::std::os::raw::c_char,
            source_length: i32,
        ),
    >;
    extern "C" {
        #[doc = " Read all of the data loss observations from the report in the same media driver instances as the cnc file.\n\n @param aeron_cnc to query\n @param entry_func callback for each observation found\n @param clientd client data to be passed to the callback.\n @return -1 on failure, number of observations on success (could be 0)."]
        pub fn aeron_cnc_loss_reporter_read(
            aeron_cnc: *mut root::aeron_cnc_t,
            entry_func: root::aeron_loss_reporter_read_entry_func_t,
            clientd: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[doc = " Closes the instance of the aeron cnc and frees its resources.\n\n @param aeron_cnc to close"]
        pub fn aeron_cnc_close(aeron_cnc: *mut root::aeron_cnc_t);
    }
    pub type aeron_idle_strategy_func_t = ::std::option::Option<
        unsafe extern "C" fn(state: *mut ::std::os::raw::c_void, work_count: ::std::os::raw::c_int),
    >;
    pub type aeron_idle_strategy_init_func_t = ::std::option::Option<
        unsafe extern "C" fn(
            state: *mut *mut ::std::os::raw::c_void,
            env_var: *const ::std::os::raw::c_char,
            init_args: *const ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int,
    >;
    extern "C" {
        pub fn aeron_semantic_version_compose(major: u8, minor: u8, patch: u8) -> i32;
    }
    extern "C" {
        pub fn aeron_semantic_version_major(version: i32) -> u8;
    }
    extern "C" {
        pub fn aeron_semantic_version_minor(version: i32) -> u8;
    }
    extern "C" {
        pub fn aeron_semantic_version_patch(version: i32) -> u8;
    }
    pub type aeron_fptr_t = ::std::option::Option<unsafe extern "C" fn()>;
    #[doc = " Set the value of the header flags field.\n\n @param flags value to be set in the header.\n @return this for a fluent API."]
    
    #[doc = " @cond HIDDEN_SYMBOLS"]
    
    
    #[test]
    fn __bindgen_test_layout_AgentInvoker_open0_ClientConductor_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<
                root::aeron::concurrent::AgentInvoker<root::aeron::ClientConductor>,
            >(),
            24usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::aeron::concurrent::AgentInvoker<root::aeron::ClientConductor>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<
                root::aeron::concurrent::AgentInvoker<root::aeron::ClientConductor>,
            >(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::aeron::concurrent::AgentInvoker<root::aeron::ClientConductor>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_AgentInvoker_open0_ClientConductor_close0_instantiation_1() {
        assert_eq!(
            ::std::mem::size_of::<
                root::aeron::concurrent::AgentInvoker<root::aeron::ClientConductor>,
            >(),
            24usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::aeron::concurrent::AgentInvoker<root::aeron::ClientConductor>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<
                root::aeron::concurrent::AgentInvoker<root::aeron::ClientConductor>,
            >(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::aeron::concurrent::AgentInvoker<root::aeron::ClientConductor>)
            )
        );
    }
}
